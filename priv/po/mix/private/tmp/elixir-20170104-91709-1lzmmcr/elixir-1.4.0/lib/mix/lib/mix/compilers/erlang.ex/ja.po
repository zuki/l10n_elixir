msgid ""
msgstr ""
"Project-Id-Version: elixir 1.4.0\n"
"PO-Revision-Date: 2017-01-23 11:05+0900\n"
"Last-Translator: Keiji Suzuki <EMAIL@ADDRESS>\n"
"Language-Team: Japanese\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#. TRANSLATORS: def Mix.Compilers.Erlang.compile(manifest, mappings, src_ext, dest_ext, force, callback)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/mix/lib/mix/compilers/erlang.ex:4
msgid ""
"Compiles the files in `mappings` with given extensions into\n"
"the destination, automatically invoking the callback for each\n"
"stale input and output pair (or for all if `force` is `true`) and\n"
"removing files that no longer have a source, while keeping the\n"
"`manifest` up to date.\n"
"\n"
"`mappings` should be a list of tuples in the form of `{src, dest}` paths.\n"
"\n"
"## Examples\n"
"\n"
"For example, a simple compiler for Lisp Flavored Erlang\n"
"would be implemented like:\n"
"\n"
"    manifest = Path.join Mix.Project.manifest_path, \".compile.lfe\"\n"
"    dest = Mix.Project.compile_path\n"
"\n"
"    compile manifest, [{\"src\", dest}], :lfe, :beam, opts, fn\n"
"      input, output ->\n"
"        :lfe_comp.file(to_erl_file(input),\n"
"                       [output_dir: Path.dirname(output)])\n"
"    end\n"
"\n"
"The command above will:\n"
"\n"
"  1. look for files ending with the `lfe` extension in `src` path\n"
"     and their `beam` counterpart in `ebin` path\n"
"\n"
"  2. for each stale file (or for all if `force` is `true`),\n"
"     invoke the callback passing the calculated input\n"
"     and output\n"
"\n"
"  3. update the manifest with the newly compiled outputs\n"
"\n"
"  4. remove any output in the manifest that does not\n"
"     have an equivalent source\n"
"\n"
"The callback must return `{:ok, mod}` or `:error` in case\n"
"of error. An error is raised at the end if any of the\n"
"files failed to compile.\n"
msgstr ""

#. TRANSLATORS: def Mix.Compilers.Erlang.compile(manifest, mappings, opts \\ [], callback)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/mix/lib/mix/compilers/erlang.ex:58
msgid ""
"Compiles the given `mappings`.\n"
"\n"
"`mappings` should be a list of tuples in the form of `{src, dest}`.\n"
"\n"
"A `manifest` file and a `callback` to be invoked for each src/dest pair\n"
"must be given. A src/dest pair where destination is `nil` is considered\n"
"to be up to date and won't be (re-)compiled.\n"
msgstr ""

#. TRANSLATORS: def Mix.Compilers.Erlang.clean(manifest)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/mix/lib/mix/compilers/erlang.ex:139
msgid "Removes compiled files for the given `manifest`.\n"
msgstr ""

#. TRANSLATORS: def Mix.Compilers.Erlang.to_erl_file(file)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/mix/lib/mix/compilers/erlang.ex:147
msgid ""
"Converts the given `file` to a format accepted by\n"
"the Erlang compilation tools.\n"
msgstr ""

#. TRANSLATORS: def Mix.Compilers.Erlang.ensure_application!(app, input)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/mix/lib/mix/compilers/erlang.ex:124
msgid "Ensures the native Erlang application is available.\n"
msgstr ""

#. TRANSLATORS: def Mix.Compilers.Erlang.assert_valid_erlc_paths(erlc_paths)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/mix/lib/mix/compilers/erlang.ex:155
msgid ""
"Asserts that the `:erlc_paths` configuration option that many Mix tasks\n"
"rely on is valid.\n"
"\n"
"Raises a `Mix.Error` exception if the option is not valid, returns `:ok`\n"
"otherwise.\n"
msgstr ""
