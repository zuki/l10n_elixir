msgid ""
msgstr ""
"Project-Id-Version: l 10n_elixir\n"
"PO-Revision-Date: 2017-01-23 11:05+0900\n"
"Last-Translator: Keiji Suzuki <EMAIL@ADDRESS>\n"
"Language-Team: Japanese\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#. TRANSLATORS: Elixir.Mix.Tasks.Profile.Fprof Summary
#: lib/mix/tasks/profile.fprof.ex:6
msgid ""
"Profiles the given file or expression using Erlang's `fprof` tool.\n"
"\n"
"`fprof` can be useful when you want to discover the bottlenecks of a\n"
"sequential code.\n"
"\n"
"Before running the code, it invokes the `app.start` task which compiles\n"
"and loads your project. Then the target expression is profiled, together\n"
"with all processes which are spawned by it. Other processes (e.g. those\n"
"residing in the OTP application supervision tree) are not profiled.\n"
"\n"
"To profile the code, you can use syntax similar to the `mix run` task:\n"
"\n"
"    mix profile.fprof -e Hello.world\n"
"    mix profile.fprof my_script.exs arg1 arg2 arg3\n"
"\n"
"## Command line options\n"
"\n"
"  * `--callers` - prints detailed information about immediate callers and "
"called functions\n"
"  * `--details` - includes profile data for each profiled process\n"
"  * `--sort key` - sorts the output by given key: `acc` (default) or `own`\n"
"  * `--config`, `-c`  - loads the given configuration file\n"
"  * `--eval`, `-e` - evaluates the given code\n"
"  * `--require`, `-r` - requires pattern before running the command\n"
"  * `--parallel`, `-p` - makes all requires parallel\n"
"  * `--no-compile`    - does not compile even if files require compilation\n"
"  * `--no-deps-check` - does not check dependencies\n"
"  * `--no-archives-check` - does not check archives\n"
"  * `--no-start` - does not start applications after compilation\n"
"  * `--no-elixir-version-check` - does not check the Elixir version from mix."
"exs\n"
"  * `--no-warmup` - does not execute code once before profiling\n"
"\n"
"## Profile output\n"
"\n"
"Example output:\n"
"    #                                        CNT    ACC (ms)    OWN (ms)\n"
"    Total                                 200279    1972.188    1964.579\n"
"    :fprof.apply_start_stop/4                  0    1972.188       0.012\n"
"    anonymous fn/0 in :elixir_compiler_2       1    1972.167       0.001\n"
"    Test.run/0                                 1    1972.166       0.007\n"
"    Test.do_something/1                        3    1972.131       0.040\n"
"    Test.bottleneck/0                          1    1599.490       0.007\n"
"    ...\n"
"\n"
"The default output contains data gathered from all profiled processes.\n"
"All times are wall clock milliseconds. The columns have the following "
"meaning:\n"
"\n"
"  * CNT - total number of invocations of the given function\n"
"  * ACC - total time spent in the function\n"
"  * OWN - time spent in the function, excluding the time of called "
"functions\n"
"\n"
"The first row (Total) is the sum of all functions executed in all profiled\n"
"processes. For the given output, we had a total of 200279 function calls and "
"spent\n"
"about 2 seconds running the code.\n"
"\n"
"More detailed information is returned if you provide the `--callers` and\n"
"`--details` options.\n"
"\n"
"When `--callers` option is specified, you'll see expanded function entries:\n"
"\n"
"    Mod.caller1/0                             3     200.000       0.017\n"
"    Mod.caller2/0                             2     100.000       0.017\n"
"      Mod.some_function/0                     5     300.000       0.017  "
"<--\n"
"        Mod.called1/0                         4     250.000       0.010\n"
"        Mod.called2/0                         1      50.000       0.030\n"
"\n"
"Here, the arrow (`<--`) indicates the __marked__ function - the function\n"
"described by this paragraph. You also see its immediate callers (above) and\n"
"called functions (below).\n"
"\n"
"All the values of caller functions describe the marked function. For "
"example,\n"
"the first row means that `Mod.caller1/0` invoked `Mod.some_function/0` 3 "
"times.\n"
"200ms of the total time spent in `Mod.some_function/0` was spent processing\n"
"calls from this particular caller.\n"
"\n"
"In contrast, the values for the called functions describe those functions, "
"but\n"
"in the context of the marked function. For example, the last row means that\n"
"`Mod.called2/0` was called once by `Mod.some_function/0`, and in that case\n"
"the total time spent in the function was 50ms.\n"
"\n"
"For a detailed explanation it's worth reading the analysis in\n"
"[Erlang documentation for fprof](http://www.erlang.org/doc/man/fprof."
"html#analysis).\n"
"\n"
"## Caveats\n"
"\n"
"You should be aware that the code being profiled is running in an anonymous\n"
"function which is invoked by `:fprof` module. Thus, you'll see some "
"additional\n"
"entries in your profile output, such as `:fprof` calls, an anonymous\n"
"function with high ACC time, or an `:undefined` function which represents\n"
"the outer caller (non-profiled code which started the profiler).\n"
"\n"
"Also, keep in mind that profiling might significantly increase the running "
"time\n"
"of the profiled processes. This might skew your results if, for example, "
"those\n"
"processes perform some I/O operations, since running time of those "
"operations\n"
"will remain unchanged, while CPU bound operations of the profiled processes\n"
"might take significantly longer. Thus, when profiling some intensive "
"program,\n"
"try to reduce such dependencies, or be aware of the resulting bias.\n"
"\n"
"Finally, it's advised to profile your program with the `prod` environment, "
"since\n"
"this should provide more realistic insights into bottlenecks.\n"
msgstr ""
