msgid ""
msgstr ""
"Project-Id-Version: elixir 1.4.0\n"
"POT-Creation-Date: \n"
"PO-Revision-Date: 2017-01-24 17:01+0900\n"
"Last-Translator: Keiji Suzuki <EMAIL@ADDRESS>\n"
"Language-Team: Japanese\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Poedit 1.8.11\n"

#. TRANSLATORS: defmacro Mix.Config.config(app, opts)
#: lib/mix/config.ex:51
msgid ""
"Configures the given application.\n"
"\n"
"Keyword lists are always deep merged.\n"
"\n"
"## Examples\n"
"\n"
"The given `opts` are merged into the existing configuration\n"
"for the given `app`. Conflicting keys are overridden by the\n"
"ones specified in `opts`. For example, the declaration below:\n"
"\n"
"    config :lager,\n"
"      log_level: :warn,\n"
"      mode: :truncate\n"
"\n"
"    config :lager,\n"
"      log_level: :info,\n"
"      threshold: 1024\n"
"\n"
"Will have a final configuration of:\n"
"\n"
"    [log_level: :info, mode: :truncate, threshold: 1024]\n"
"\n"
"This final configuration can be retrieved at run or compile time:\n"
"\n"
"    Application.get_all_env(:lager)\n"
"\n"
msgstr ""
"指定したアプリケーションを構成します。\n"
"\n"
"キーワードリストは常にディープマージされます。\n"
"\n"
"## 例\n"
"\n"
"指定した`opts`は指定した`app`の既存の構成にマージされます。\n"
"構成キーは`opts`で指定されたもので上書きされます。\n"
"たとえば、次の定義では:\n"
"\n"
"    config :lager,\n"
"      log_level: :warn,\n"
"      mode: :truncate\n"
"\n"
"    config :lager,\n"
"      log_level: :info,\n"
"      threshold: 1024\n"
"\n"
"最終的に次の構成になります:\n"
"\n"
"    [log_level: :info, mode: :truncate, threshold: 1024]\n"
"\n"
"この最終的な構成は実行時またはコンパイル時に取り出すことができます:\n"
"\n"
"    Application.get_all_env(:lager)\n"
"\n"

#. TRANSLATORS: def Mix.Config.read!(file, loaded_paths \\ [])
#: lib/mix/config.ex:163
msgid ""
"Reads and validates a configuration file.\n"
"\n"
"`file` is the path to the configuration file to be read. If that file "
"doesn't\n"
"exist or if there's an error loading it, a `Mix.Config.LoadError` exception\n"
"will be raised.\n"
"\n"
"`loaded_paths` is a list of configuration files that have been previously\n"
"read. If `file` exists in `loaded_paths`, a `Mix.Config.LoadError` "
"exception\n"
"will be raised.\n"
msgstr ""
"構成ファイルを読み込んで検証します。\n"
"\n"
"`file`は読み込む構成ファイルのパスです。このファイルが存在しない、\n"
"または、ロード中にエラーが発生した場合は、`Mix.Config.LoadError`\n"
"例外が発生します。\n"
"\n"
"`loaded_paths`は前もって読み込まれていた構成ファイルのリストです。\n"
"`file`が`loaded_paths`に含まれている場合は、`Mix.Config.LoadError`\n"
"例外が発生します。\n"

#. TRANSLATORS: def Mix.Config.read_wildcard!(path, loaded_paths \\ [])
#: lib/mix/config.ex:201
msgid ""
"Reads many configuration files given by wildcard into a single config.\n"
"\n"
"Raises an error if `path` is a concrete filename (with no wildcards)\n"
"but the corresponding file does not exist; if `path` matches no files,\n"
"no errors are raised.\n"
"\n"
"`loaded_paths` is a list of configuration files that have been previously\n"
"read.\n"
msgstr ""
"ワイルドカードにより指定された多くの構成ファイルを一つの個性に読み込みま"
"す。\n"
"\n"
"`path`が具体的なファイル名（ワイルドカードなし）の場合はエラーが発生します"
"が、\n"
"対応するファイルが存在しない、すなわち、`path`にマッチするファイルがない場合"
"は\n"
"エラーは発生しません。\n"
"\n"
"`loaded_paths`は前もって読み込まれていた構成ファイルのリスト\n"
"です。\n"

#. TRANSLATORS: defmacro Mix.Config.config(app, key, opts)
#: lib/mix/config.ex:85
msgid ""
"Configures the given key for the given application.\n"
"\n"
"Keyword lists are always deep merged.\n"
"\n"
"## Examples\n"
"\n"
"The given `opts` are merged into the existing values for `key`\n"
"in the given `app`. Conflicting keys are overridden by the\n"
"ones specified in `opts`. For example, given the two configurations\n"
"below:\n"
"\n"
"    config :ecto, Repo,\n"
"      log_level: :warn,\n"
"      adapter: Ecto.Adapters.Postgres\n"
"\n"
"    config :ecto, Repo,\n"
"      log_level: :info,\n"
"      pool_size: 10\n"
"\n"
"the final value of the configuration for the `Ecto` key in the `:ecto`\n"
"application will be:\n"
"\n"
"    [log_level: :info, pool_size: 10, adapter: Ecto.Adapters.Postgres]\n"
"\n"
"This final value can be retrieved at runtime or compile time with:\n"
"\n"
"    Application.get_env(:ecto, Repo)\n"
"\n"
msgstr ""
"指定したアプリケーションの指定したキーを構成します。\n"
"\n"
"キーワードリストは常にディープマージされます。\n"
"\n"
"## 例\n"
"\n"
"指定した`opts`は指定した`app`の既存の値にマージされます。\n"
"衝突したキーは、`opts`で指定したキーで上書きされます。\n"
"たとえば、次のような２つの構成がある\n"
"場合:\n"
"\n"
"    config :ecto, Repo,\n"
"      log_level: :warn,\n"
"      adapter: Ecto.Adapters.Postgres\n"
"\n"
"    config :ecto, Repo,\n"
"      log_level: :info,\n"
"      pool_size: 10\n"
"\n"
"`:ecto`アプリケーションの`Ecto`キーの最終的な\n"
"構成の値は次のようになります:\n"
"\n"
"    [log_level: :info, pool_size: 10, adapter: Ecto.Adapters.Postgres]\n"
"\n"
"この最終的な値は実行時またはコンパイル時に取り出すことができます:\n"
"\n"
"    Application.get_env(:ecto, Repo)\n"
"\n"

#. TRANSLATORS: def Mix.Config.persist(config)
#: lib/mix/config.ex:220
msgid ""
"Persists the given configuration by modifying\n"
"the configured applications environment.\n"
"\n"
"`config` should be a list of `{app, app_config}` tuples or a\n"
"`%{app => app_config}` map where `app` are the applications to\n"
"be configured and `app_config` are the configuration (as key-value\n"
"pairs) for each of those applications.\n"
"\n"
"Returns the configured applications.\n"
"\n"
"## Examples\n"
"\n"
"    Mix.Config.persist(logger: [level: :error], my_app: [my_config: 1])\n"
"    #=> [:logger, :my_app]\n"
"\n"
msgstr ""
"構成されるアプリケーションの環境を変更することにより\n"
"指定した構成を永続化します。\n"
"\n"
"`config`は`{app, app_config}` タプルのリストか\n"
"`%{app => app_config}` マップでなければいけません。\n"
"ここで、`app`は構成されるアプリケーション、`app_config`は\n"
"各アプリケーションの各々に対する構成（キー・値ペア）です。\n"
"\n"
"構成されたアプリケーションを返します。\n"
"## 例\n"
"\n"
"    Mix.Config.persist(logger: [level: :error], my_app: [my_config: 1])\n"
"    #=> [:logger, :my_app]\n"
"\n"

#. TRANSLATORS: Elixir.Mix.Config Summary
#: lib/mix/config.ex:2
msgid ""
"Module for defining, reading and merging app configurations.\n"
"\n"
"Most commonly, this module is used to define your own configuration:\n"
"\n"
"    use Mix.Config\n"
"\n"
"    config :plug,\n"
"      key1: \"value1\",\n"
"      key2: \"value2\"\n"
"\n"
"    import_config \"#{Mix.env}.exs\"\n"
"\n"
"All `config/*` macros, including `import_config/1`, are used\n"
"to help define such configuration files.\n"
"\n"
"Furthermore, this module provides functions like `read!/1`,\n"
"`merge/2` and friends which help manipulate configurations\n"
"in general.\n"
"\n"
"Configuration set using `Mix.Config` will set the application env, so\n"
"that `Application.get_env/3` and other `Application` functions can be used\n"
"at run or compile time to retrieve or change the configuration.\n"
"\n"
"For example, the `:key1` value from application `:plug` (see above) can be\n"
"retrieved with:\n"
"\n"
"    \"value1\" = Application.fetch_env!(:plug, :key1)\n"
"\n"
msgstr ""
"アプリケーションの構成を定義、読み込み、マージするためのモジュールです。\n"
"\n"
"通常、このモジュールは独自の構成を定義するために使用されます。\n"
"\n"
"    use Mix.Config\n"
"\n"
"    config :plug,\n"
"      key1: \"value1\",\n"
"      key2: \"value2\"\n"
"\n"
"    import_config \"#{Mix.env}.exs\"\n"
"\n"
"`import_config/1`を含むすべての`config/*`マクロはそのような\n"
"構成ファイルを定義するのに使用されます。\n"
"\n"
"さらに、このモジュールは、一般に構成の操作を助ける\n"
"`read!/1`や`merge/2` などの関数も提供して\n"
"います。\n"
"\n"
"`Mix.Config` を使う構成セットはアプリケーションの環境を設定します。\n"
"そのため、 `Application.get_env/3`やその他の`Application`関数を\n"
"実行時やコンパイル時に使用して、構成を取り出したり変更したりすることができま"
"す。\n"
"\n"
"たとえば、アプリケーションの`:plug`から`:key1`の値（上を参照）を次の\n"
"ように取り出すことができます。\n"
"\n"
"    \"value1\" = Application.fetch_env!(:plug, :key1)\n"
"\n"

#. TRANSLATORS: def Mix.Config.merge(config1, config2)
#: lib/mix/config.ex:268
msgid ""
"Merges two configurations.\n"
"\n"
"The configuration of each application is merged together\n"
"with the values in the second one having higher preference\n"
"than the first in case of conflicts.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Mix.Config.merge([app: [k: :v1]], [app: [k: :v2]])\n"
"    [app: [k: :v2]]\n"
"\n"
"    iex> Mix.Config.merge([app1: []], [app2: []])\n"
"    [app1: [], app2: []]\n"
"\n"
msgstr ""
"２つの構成をマージします。\n"
"\n"
"各アプリケーションの構成をマージします。構成が衝突する場合は\n"
"最初の構成より２番目の値が優先されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> Mix.Config.merge([app: [k: :v1]], [app: [k: :v2]])\n"
"    [app: [k: :v2]]\n"
"\n"
"    iex> Mix.Config.merge([app1: []], [app2: []])\n"
"    [app1: [], app2: []]\n"
"\n"

#. TRANSLATORS: defmacro Mix.Config.import_config(path_or_wildcard)
#: lib/mix/config.ex:122
msgid ""
"Imports configuration from the given file or files.\n"
"\n"
"If `path_or_wildcard` is a wildcard, then all the files\n"
"matching that wildcard will be imported; if no file matches\n"
"the wildcard, no errors are raised. If `path_or_wildcard` is\n"
"not a wildcard but a path to a single file, then that file is\n"
"imported; in case the file doesn't exist, an error is raised.\n"
"This behaviour is analogous to the one for `read_wildcard!/1`.\n"
"\n"
"If path/wildcard is a relative path/wildcard, it will be expanded "
"relatively\n"
"to the directory the current configuration file is in.\n"
"\n"
"## Examples\n"
"\n"
"This is often used to emulate configuration across environments:\n"
"\n"
"    import_config \"#{Mix.env}.exs\"\n"
"\n"
"Or to import files from children in umbrella projects:\n"
"\n"
"    import_config \"../apps/*/config/config.exs\"\n"
"\n"
msgstr ""
"指定した（１つまたは複数の）ファイルから構成をインポートします。\n"
"\n"
"`path_or_wildcard`がワイルドカードの場合はワイルドカードに\n"
"マッチするすべてのファイルがインポートされます。ワイルドカードに\n"
"マッチするファイルがない場合はエラーは発生しません。`path_or_wildcard`が\n"
"ワイルドカードではなく単一ファイルのパスである場合は、そのファイルが\n"
"インポートされます。ファイルが存在しない場合はエラーが発生します。\n"
"このビヘイビアは`read_wildcard!/1`と同じです。\n"
"\n"
"パスまたはワイルドカードが相対表現の場合、現在の構成ファイルがある\n"
"ディレクトリからの相対として展開されます。\n"
"## 例\n"
"\n"
"以下は複数の環境の構成をエミュレートする際によく使われます:\n"
"\n"
"    import_config \"#{Mix.env}.exs\"\n"
"\n"
"また、アンブレラプロジェクトの子からファイルをインポートするには次のようにし"
"ます:\n"
"\n"
"    import_config \"../apps/*/config/config.exs\"\n"
"\n"

#. TRANSLATORS: def Mix.Config.validate!(config)
#: lib/mix/config.ex:246
msgid "Validates a configuration.\n"
msgstr "構成を検証します。\n"
