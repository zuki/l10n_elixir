#. TRANSLATORS: defmacro Mix.Config.config(app, opts)
#: lib/mix/config.ex:51 
msgid ""
"Configures the given application.\n"
"\n"
"Keyword lists are always deep merged.\n"
"\n"
"## Examples\n"
"\n"
"The given `opts` are merged into the existing configuration\n"
"for the given `app`. Conflicting keys are overridden by the\n"
"ones specified in `opts`. For example, the declaration below:\n"
"\n"
"    config :lager,\n"
"      log_level: :warn,\n"
"      mode: :truncate\n"
"\n"
"    config :lager,\n"
"      log_level: :info,\n"
"      threshold: 1024\n"
"\n"
"Will have a final configuration of:\n"
"\n"
"    [log_level: :info, mode: :truncate, threshold: 1024]\n"
"\n"
"This final configuration can be retrieved at run or compile time:\n"
"\n"
"    Application.get_all_env(:lager)\n"
"\n"
msgstr ""
#. TRANSLATORS: def Mix.Config.read!(file, loaded_paths \\ [])
#: lib/mix/config.ex:163 
msgid ""
"Reads and validates a configuration file.\n"
"\n"
"`file` is the path to the configuration file to be read. If that file doesn't\n"
"exist or if there's an error loading it, a `Mix.Config.LoadError` exception\n"
"will be raised.\n"
"\n"
"`loaded_paths` is a list of configuration files that have been previously\n"
"read. If `file` exists in `loaded_paths`, a `Mix.Config.LoadError` exception\n"
"will be raised.\n"
msgstr ""
#. TRANSLATORS: def Mix.Config.read_wildcard!(path, loaded_paths \\ [])
#: lib/mix/config.ex:201 
msgid ""
"Reads many configuration files given by wildcard into a single config.\n"
"\n"
"Raises an error if `path` is a concrete filename (with no wildcards)\n"
"but the corresponding file does not exist; if `path` matches no files,\n"
"no errors are raised.\n"
"\n"
"`loaded_paths` is a list of configuration files that have been previously\n"
"read.\n"
msgstr ""
#. TRANSLATORS: defmacro Mix.Config.config(app, key, opts)
#: lib/mix/config.ex:85 
msgid ""
"Configures the given key for the given application.\n"
"\n"
"Keyword lists are always deep merged.\n"
"\n"
"## Examples\n"
"\n"
"The given `opts` are merged into the existing values for `key`\n"
"in the given `app`. Conflicting keys are overridden by the\n"
"ones specified in `opts`. For example, given the two configurations\n"
"below:\n"
"\n"
"    config :ecto, Repo,\n"
"      log_level: :warn,\n"
"      adapter: Ecto.Adapters.Postgres\n"
"\n"
"    config :ecto, Repo,\n"
"      log_level: :info,\n"
"      pool_size: 10\n"
"\n"
"the final value of the configuration for the `Ecto` key in the `:ecto`\n"
"application will be:\n"
"\n"
"    [log_level: :info, pool_size: 10, adapter: Ecto.Adapters.Postgres]\n"
"\n"
"This final value can be retrieved at runtime or compile time with:\n"
"\n"
"    Application.get_env(:ecto, Repo)\n"
"\n"
msgstr ""
#. TRANSLATORS: def Mix.Config.persist(config)
#: lib/mix/config.ex:220 
msgid ""
"Persists the given configuration by modifying\n"
"the configured applications environment.\n"
"\n"
"`config` should be a list of `{app, app_config}` tuples or a\n"
"`%{app => app_config}` map where `app` are the applications to\n"
"be configured and `app_config` are the configuration (as key-value\n"
"pairs) for each of those applications.\n"
"\n"
"Returns the configured applications.\n"
"\n"
"## Examples\n"
"\n"
"    Mix.Config.persist(logger: [level: :error], my_app: [my_config: 1])\n"
"    #=> [:logger, :my_app]\n"
"\n"
msgstr ""
#. TRANSLATORS: Elixir.Mix.Config Summary
#: lib/mix/config.ex:2 
msgid ""
"Module for defining, reading and merging app configurations.\n"
"\n"
"Most commonly, this module is used to define your own configuration:\n"
"\n"
"    use Mix.Config\n"
"\n"
"    config :plug,\n"
"      key1: \"value1\",\n"
"      key2: \"value2\"\n"
"\n"
"    import_config \"#{Mix.env}.exs\"\n"
"\n"
"All `config/*` macros, including `import_config/1`, are used\n"
"to help define such configuration files.\n"
"\n"
"Furthermore, this module provides functions like `read!/1`,\n"
"`merge/2` and friends which help manipulate configurations\n"
"in general.\n"
"\n"
"Configuration set using `Mix.Config` will set the application env, so\n"
"that `Application.get_env/3` and other `Application` functions can be used\n"
"at run or compile time to retrieve or change the configuration.\n"
"\n"
"For example, the `:key1` value from application `:plug` (see above) can be\n"
"retrieved with:\n"
"\n"
"    \"value1\" = Application.fetch_env!(:plug, :key1)\n"
"\n"
msgstr ""
#. TRANSLATORS: def Mix.Config.merge(config1, config2)
#: lib/mix/config.ex:268 
msgid ""
"Merges two configurations.\n"
"\n"
"The configuration of each application is merged together\n"
"with the values in the second one having higher preference\n"
"than the first in case of conflicts.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Mix.Config.merge([app: [k: :v1]], [app: [k: :v2]])\n"
"    [app: [k: :v2]]\n"
"\n"
"    iex> Mix.Config.merge([app1: []], [app2: []])\n"
"    [app1: [], app2: []]\n"
"\n"
msgstr ""
#. TRANSLATORS: defmacro Mix.Config.import_config(path_or_wildcard)
#: lib/mix/config.ex:122 
msgid ""
"Imports configuration from the given file or files.\n"
"\n"
"If `path_or_wildcard` is a wildcard, then all the files\n"
"matching that wildcard will be imported; if no file matches\n"
"the wildcard, no errors are raised. If `path_or_wildcard` is\n"
"not a wildcard but a path to a single file, then that file is\n"
"imported; in case the file doesn't exist, an error is raised.\n"
"This behaviour is analogous to the one for `read_wildcard!/1`.\n"
"\n"
"If path/wildcard is a relative path/wildcard, it will be expanded relatively\n"
"to the directory the current configuration file is in.\n"
"\n"
"## Examples\n"
"\n"
"This is often used to emulate configuration across environments:\n"
"\n"
"    import_config \"#{Mix.env}.exs\"\n"
"\n"
"Or to import files from children in umbrella projects:\n"
"\n"
"    import_config \"../apps/*/config/config.exs\"\n"
"\n"
msgstr ""
#. TRANSLATORS: def Mix.Config.validate!(config)
#: lib/mix/config.ex:246 
msgid ""
"Validates a configuration.\n"
msgstr ""
