#. TRANSLATORS: def Mix.Shell.Process.prompt(message)
#: lib/mix/shell/process.ex:100 
msgid ""
"Forwards the message to the current process.\n"
"\n"
"It also checks the inbox for an input message matching:\n"
"\n"
"    {:mix_shell_input, :prompt, value}\n"
"\n"
"If one does not exist, it will abort since there was no shell\n"
"process inputs given. `value` must be a string.\n"
"\n"
"## Examples\n"
"\n"
"The following will answer with `\"Meg\"` to the prompt\n"
"`\"What's your name?\"`:\n"
"\n"
"    # The response is sent before calling prompt/1 so that prompt/1 can read it\n"
"    send self(), {:mix_shell_input, :prompt, \"Meg\"}\n"
"    Mix.shell.prompt(\"What's your name?\")\n"
"\n"
msgstr ""
#. TRANSLATORS: Elixir.Mix.Shell.Process Summary
#: lib/mix/shell/process.ex:2 
msgid ""
"Mix shell that uses the current process mailbox for communication.\n"
"\n"
"\n"
"This module provides a Mix shell implementation that uses\n"
"the current process mailbox for communication instead of IO.\n"
"\n"
"As an example, when `Mix.shell.info(\"hello\")` is called,\n"
"the following message will be sent to the calling process:\n"
"\n"
"    {:mix_shell, :info, [\"hello\"]}\n"
"\n"
"This is mainly useful in tests, allowing us to assert\n"
"if given messages were received or not instead of performing\n"
"checks on some captured IO. Since we need to guarantee a clean\n"
"slate between tests, there is also a `flush/1` function\n"
"responsible for flushing all `:mix_shell` related messages\n"
"from the process inbox.\n"
"\n"
"## Examples\n"
"\n"
"    Mix.shell.info \"hello\"\n"
"    receive do {:mix_shell, :info, [msg]} -> msg end\n"
"    #=> \"hello\"\n"
"\n"
"    send self(), {:mix_shell_input, :prompt, \"Pretty cool\"}\n"
"    Mix.shell.prompt?(\"How cool was that?!\")\n"
"    #=> \"Pretty cool\"\n"
"\n"
msgstr ""
#. TRANSLATORS: def Mix.Shell.Process.yes?(message)
#: lib/mix/shell/process.ex:131 
msgid ""
"Forwards the message to the current process.\n"
"\n"
"It also checks the inbox for an input message matching:\n"
"\n"
"    {:mix_shell_input, :yes?, value}\n"
"\n"
"If one does not exist, it will abort since there was no shell\n"
"process inputs given. `value` must be `true` or `false`.\n"
"\n"
"## Example\n"
"\n"
"    # Send the response to self() first so that yes?/1 will be able to read it\n"
"    send self(), {:mix_shell_input, :yes?, true}\n"
"    Mix.shell.yes?(\"Are you sure you want to continue?\")\n"
"\n"
msgstr ""
#. TRANSLATORS: def Mix.Shell.Process.info(message)
#: lib/mix/shell/process.ex:80 
msgid ""
"Forwards the message to the current process.\n"
msgstr ""
#. TRANSLATORS: def Mix.Shell.Process.error(message)
#: lib/mix/shell/process.ex:88 
msgid ""
"Forwards the error to the current process.\n"
msgstr ""
#. TRANSLATORS: def Mix.Shell.Process.cmd(command, opts \\ [])
#: lib/mix/shell/process.ex:68 
msgid ""
"Executes the given command and forwards its messages to\n"
"the current process.\n"
msgstr ""
#. TRANSLATORS: def Mix.Shell.Process.flush(callback \\ fn x -> x end)
#: lib/mix/shell/process.ex:35 
msgid ""
"Flushes all `:mix_shell` and `:mix_shell_input` messages from the current process.\n"
"\n"
"If a callback is given, it is invoked for each received message.\n"
"\n"
"## Examples\n"
"\n"
"    flush &IO.inspect(&1)\n"
"\n"
msgstr ""
