msgid ""
msgstr ""
"Project-Id-Version: elixir 1.4.0\n"
"PO-Revision-Date: 2017-01-23 11:05+0900\n"
"Last-Translator: Keiji Suzuki <EMAIL@ADDRESS>\n"
"Language-Team: Japanese\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#. TRANSLATORS: Elixir.Mix Summary
#: lib/mix.ex:2
msgid ""
"Mix is a build tool that provides tasks for creating, compiling,\n"
"and testing Elixir projects, managing its dependencies, and more.\n"
"\n"
"## Mix.Project\n"
"\n"
"The foundation of Mix is a project. A project can be defined by using\n"
"`Mix.Project` in a module, usually placed in a file named `mix.exs`:\n"
"\n"
"    defmodule MyApp.Mixfile do\n"
"      use Mix.Project\n"
"\n"
"      def project do\n"
"        [app: :my_app,\n"
"         version: \"1.0.0\"]\n"
"      end\n"
"    end\n"
"\n"
"See the `Mix.Project` module for detailed documentation on Mix projects.\n"
"\n"
"Once the project is defined, a number of default Mix tasks can be run\n"
"directly from the command line:\n"
"\n"
"  * `mix compile` - compiles the current project\n"
"  * `mix test` - runs tests for the given project\n"
"  * `mix run` - runs a particular command inside the project\n"
"\n"
"Each task has its own options and sometimes specific configuration\n"
"to be defined in the `project/0` function. You can use `mix help`\n"
"to list all available tasks and `mix help NAME` to show help for\n"
"a particular task.\n"
"\n"
"The best way to get started with your first project is by calling\n"
"`mix new my_project` from the command line.\n"
"\n"
"## Mix.Task\n"
"\n"
"Tasks are what make Mix extensible.\n"
"\n"
"Projects can extend Mix behaviour by adding their own tasks. For\n"
"example, adding the task below inside your project will\n"
"make it available to everyone that uses your project:\n"
"\n"
"    defmodule Mix.Tasks.Hello do\n"
"      use Mix.Task\n"
"\n"
"      def run(_) do\n"
"        Mix.shell.info \"hello\"\n"
"      end\n"
"    end\n"
"\n"
"The task can now be invoked with `mix hello`.\n"
"\n"
"## Dependencies\n"
"\n"
"Mix also manages your dependencies and integrates nicely with the [Hex "
"package\n"
"manager](https://hex.pm).\n"
"\n"
"In order to use dependencies, you need to add a `:deps` key\n"
"to your project configuration. We often extract the list of dependencies\n"
"into its own function:\n"
"\n"
"    defmodule MyApp.Mixfile do\n"
"      use Mix.Project\n"
"\n"
"      def project do\n"
"        [app: :my_app,\n"
"         version: \"1.0.0\",\n"
"         deps: deps()]\n"
"      end\n"
"\n"
"      defp deps do\n"
"        [{:ecto, \"~> 0.2.5\"},\n"
"         {:plug, github: \"elixir-lang/plug\"}]\n"
"      end\n"
"    end\n"
"\n"
"You can run `mix help deps` to learn more about dependencies in Mix.\n"
"\n"
"## Environments\n"
"\n"
"Mix supports different environments. Environments allow developers to "
"prepare\n"
"and organize their project specifically for different scenarios. By "
"default,\n"
"Mix provides three environments:\n"
"\n"
"  * `:dev` - the default environment\n"
"  * `:test` - the environment `mix test` runs on\n"
"  * `:prod` - the environment your dependencies run on\n"
"\n"
"The environment can be changed via the command line by setting\n"
"the `MIX_ENV` environment variable, for example:\n"
"\n"
"    $ MIX_ENV=prod mix run server.exs\n"
"\n"
"## Aliases\n"
"\n"
"Aliases are shortcuts or tasks specific to the current project.\n"
"\n"
"In the `Mix.Task` section, we have defined a task that would be\n"
"available to everyone using our project as a dependency. What if\n"
"we wanted the task to only be available for our project? Just\n"
"define an alias:\n"
"\n"
"    defmodule MyApp.Mixfile do\n"
"      use Mix.Project\n"
"\n"
"      def project do\n"
"        [app: :my_app,\n"
"         version: \"1.0.0\",\n"
"         aliases: aliases]\n"
"      end\n"
"\n"
"      defp aliases do\n"
"        [c: \"compile\",\n"
"         hello: &hello/1]\n"
"      end\n"
"\n"
"      defp hello(_) do\n"
"        Mix.shell.info \"Hello world\"\n"
"      end\n"
"    end\n"
"\n"
"In the example above, we have defined two aliases. One is `mix c`\n"
"which is a shortcut for `mix compile`. The other is named\n"
"`mix hello`, which is the equivalent to the `Mix.Tasks.Hello`\n"
"we have defined in the `Mix.Task` section.\n"
"\n"
"Aliases may also be lists, specifying multiple tasks to be run\n"
"consecutively:\n"
"\n"
"    [all: [&hello/1, \"deps.get --only #{Mix.env}\", \"compile\"]]\n"
"\n"
"In the example above, we have defined an alias named `mix all`,\n"
"that prints hello, then fetches dependencies specific to the\n"
"current environment and compiles it.\n"
"\n"
"Arguments given to the alias will be appended to the arguments\n"
"of the last task in the list, if the last task is a function\n"
"they will be given as a list of strings to the function.\n"
"\n"
"Finally, aliases can also be used to augment existing tasks.\n"
"Let's suppose you want to augment `mix clean` to clean another\n"
"directory Mix does not know about:\n"
"\n"
"    [clean: [\"clean\", &clean_extra/1]]\n"
"\n"
"Where `&clean_extra/1` would be a function in your `mix.exs`\n"
"with extra clean up logic.\n"
"\n"
"Note aliases do not show up on `mix help`.\n"
"Aliases defined in the current project do not affect its dependencies and "
"aliases defined in dependencies are not accessible from the current "
"project.\n"
"\n"
"## Environment variables\n"
"\n"
"Several environment variables can be used to modify Mix's behaviour.\n"
"\n"
"Mix responds to the following variables:\n"
"\n"
"  * `MIX_ARCHIVES` - specifies the directory into which the archives should "
"be installed\n"
"  * `MIX_DEBUG` - outputs debug information about each task before running "
"it\n"
"  * `MIX_ENV` - specifies which environment should be used. See "
"[Environments](#module-environments)\n"
"  * `MIX_EXS` - changes the full path to the `mix.exs` file\n"
"  * `MIX_HOME` - path to mix's home directory, stores configuration files "
"and scripts used by mix\n"
"  * `MIX_PATH` - appends extra code paths\n"
"  * `MIX_QUIET` - does not print information messages to the terminal\n"
"  * `MIX_REBAR` - path to rebar command that overrides the one mix installs\n"
"  * `MIX_REBAR3` - path to rebar3 command that overrides the one mix "
"installs\n"
"\n"
"Environment variables that are not meant to hold a value (and act basically "
"as\n"
"flags) should be set to either `1` or `true`, for example:\n"
"\n"
"    $ MIX_DEBUG=1 mix compile\n"
"\n"
msgstr ""
"Mixは、Elixirプロジェクトの作成、コンパイル、テスト、依存ライブラリの管理など"
"の\n"
"タスクを提供するビルドツールです。\n"
"\n"
"## Mix.Project\n"
"\n"
"Mixの基本はプロジェクトです。プロジェクトはモジュール内で`Mix.Project`を使う"
"ことで使って\n"
"定義できます。通常、`mix.exs`という名前のファイルに置かれます:\n"
"\n"
"    defmodule MyApp.Mixfile do\n"
"      use Mix.Project\n"
"\n"
"      def project do\n"
"        [app: :my_app,\n"
"         version: \"1.0.0\"]\n"
"      end\n"
"    end\n"
"\n"
"詳細なドキュメントは、Mixプロジェクトの`Mix.Project`モジュールを参照してくだ"
"さい。\n"
"\n"
"プロジェクトを定義すると、多くのデフォルトMixタスクを\n"
"コマンドラインから直接実行することができます:\n"
"\n"
"  * `mix compile` - カレントプロジェクトをコンパイルする\n"
"  * `mix test` - 指定したプロジェクトのテストを実行する\n"
"  * `mix run` - プロジェクト内の特定のコマンドを実行する\n"
"\n"
"各タスクは独自のオプションと時には`project/0`関数で定義すべき固有の\n"
"設定を持っています。すべてのタスクを一覧するには`mix help`を、\n"
"特定のタスクのヘルプを表示するには`mix help NAME` を\n"
"使ってください。\n"
"\n"
"はじめてのプロジェクトを作成する場合の最良の方法は\n"
"コマンドラインで`mix new my_project` を呼び出すことです。\n"
"\n"
"## Mix.Task\n"
"\n"
"タスクはMixを拡張可能にするものです。\n"
"\n"
"プロジェクトは独自のタスクを追加することによりMixのビヘイビアを\n"
"拡張できます。たとえば、以下のタスクをプロジェクトに追加すると\n"
"プロジェクトを使用する誰もがそれを利用できるようになります。\n"
"\n"
"    defmodule Mix.Tasks.Hello do\n"
"      use Mix.Task\n"
"\n"
"      def run(_) do\n"
"        Mix.shell.info \"hello\"\n"
"      end\n"
"    end\n"
"\n"
"これでタスクは`mix hello`で起動できるようになります。.\n"
"\n"
"## 依存関係\n"
"\n"
"Mixは依存関係を管理し、上手に[Hexパッケージマネージャ](https://hex.pm)を\n"
"統合しています。\n"
"\n"
"依存パッケージを使用するには、プロジェクトの設定に`deps`キーを\n"
"追加する必要があります。通常、依存パッケージリストの抽出は\n"
"独自の関数にします。:\n"
"\n"
"    defmodule MyApp.Mixfile do\n"
"      use Mix.Project\n"
"\n"
"      def project do\n"
"        [app: :my_app,\n"
"         version: \"1.0.0\",\n"
"         deps: deps()]\n"
"      end\n"
"\n"
"      defp deps do\n"
"        [{:ecto, \"~> 0.2.5\"},\n"
"         {:plug, github: \"elixir-lang/plug\"}]\n"
"      end\n"
"    end\n"
"\n"
"Mixにおける依存関係に関してさらに知りたい場合は`mix help deps` を実行してくだ"
"さい。.\n"
"\n"
"## 環境\n"
"\n"
"Mixは複数の環境をサポートします。環境により開発者は異なるシナリオに合わせた\n"
"プロジェクトを用意して組織化することが可能になります。デフォルトでは\n"
"Mixは３つの環境を提供しています:\n"
"\n"
"  * `:dev` - デフォルトの環境\n"
"  * `:test` - `mix test`が実行される環境\n"
"  * `:prod` - 依存関係が実行される環境\n"
"\n"
"環境は環境変数`MIX_ENV`を設定することによりコマンドラインで変更する\n"
"ことができます。たとえば、:\n"
"\n"
"    $ MIX_ENV=prod mix run server.exs\n"
"\n"
"## エイリアス\n"
"\n"
"エイリアスはカレントプロジェクト固有のショートカットまたはタスクです。\n"
"\n"
"`Mix.Task`のセクションで、依存パッケージとしてプロジェクトを使用するすべて"
"の\n"
"者が利用できるタスクを定義しました。タスクを自分のプロジェクトのみで利用可能"
"に\n"
"したい場合はどうしたら良いでしょうか。 エイリアスを\n"
"定義するだけです:\n"
"\n"
"    defmodule MyApp.Mixfile do\n"
"      use Mix.Project\n"
"\n"
"      def project do\n"
"        [app: :my_app,\n"
"         version: \"1.0.0\",\n"
"         aliases: aliases]\n"
"      end\n"
"\n"
"      defp aliases do\n"
"        [c: \"compile\",\n"
"         hello: &hello/1]\n"
"      end\n"
"\n"
"      defp hello(_) do\n"
"        Mix.shell.info \"Hello world\"\n"
"      end\n"
"    end\n"
"\n"
"この例では２つのエイリアスを定義しました。一つは`mix c`で、これは\n"
"`mix compile`のショートカットです。もう一つは`mix hello`で、これは\n"
"`Mix.Task`のセクションで定義された`Mix.Tasks.Hello`に相当します。\n"
"\n"
"エイリアスはリストでもよく、連続して実行される複数のタスクを指定します。:\n"
"\n"
"    [all: [&hello/1, \"deps.get --only #{Mix.env}\", \"compile\"]]\n"
"\n"
"この例では、エイリアスは`mix all`という名前で定義されており、\n"
"helloを出力した後、現在の環境に固有の依存関係をフェッチし、\n"
"それをコンパイルします。\n"
"\n"
"エイリアスに与えられた引数はリストの最後のタスクの引数に追加\n"
"されます。最後のタスクが関数の場合は、引数は文字列のリストとして\n"
"関数に与えられます。\n"
"\n"
"最後に、エイリアスは既存のタスクを拡張するにもしようすることが\n"
"できます。`mix clean`をMixが知らない別のディレクトリもクリーンする\n"
"ように拡張したいとします。:\n"
"\n"
"    [clean: [\"clean\", &clean_extra/1]]\n"
"\n"
"ここで `&clean_extra/1` 追加のクリーンアップロジックを持つ\n"
"`mix.exs`中の関数です。.\n"
"\n"
"エイリアスは`mix help`では表示されないことに注意してください。カレントプロ"
"ジェクトで定義されたエイリアスは\n"
"依存パッケージには影響を及ぼしません。また、依存パッケージで定義されたエイリ"
"アスはカレントプロジェクトからはアクセスできません。\n"
"\n"
"## 環境変数\n"
"\n"
"環境変数を使って、Mixのビヘイビアを変更することができます。\n"
"\n"
"Mixは次の変数に対応します。 :\n"
"\n"
"  * `MIX_ARCHIVES` - アーカイブがインストールされるディレクトリを指定します\n"
"  * `MIX_DEBUG` - 実行前に各タスクに関するデバッグ情報を出力します\n"
"  * `MIX_ENV` - 使用する環境を指定します。[環境](#module-environments)を参"
"照。\n"
"  * `MIX_EXS` - `mix.exs` ファイルのフルパスを変更しますfile\n"
"  * `MIX_HOME` - Mixのホームディレクトリのパス。mixでシヨスうる設定ファイルや"
"スクリプトを保管します。\n"
"  * `MIX_PATH` - コードパスを追加します\n"
"  * `MIX_QUIET` - 端末に情報メッセージを表示しません\n"
"  * `MIX_REBAR` - mixがインストールするrebarコマンドを上書きするパス\n"
"  * `MIX_REBAR3` - mixがインストールするrebar3コマンドを上書きするパス\n"
"\n"
"値を保持する必要のない（基本的にフラグとして働く）環境変数には`1` か `true`"
"の\n"
"いずれかを設定するべきです。たとえば、:\n"
"\n"
"    $ MIX_DEBUG=1 mix compile\n"
"\n"

#. TRANSLATORS: def Mix.env()
#: lib/mix.ex:199
msgid "Returns the Mix environment.\n"
msgstr "Mix環境を返します。\n"

#. TRANSLATORS: def Mix.raise(message)
#: lib/mix.ex:271
msgid "Raises a Mix error that is nicely formatted.\n"
msgstr "きれいにフォーマットされたMixエラーを発生させます。\n"

#. TRANSLATORS: def Mix.shell()
#: lib/mix.ex:232
msgid ""
"Returns the current shell.\n"
"\n"
"`shell/0` can be used as a wrapper for the current shell. It contains\n"
"conveniences for requesting information from the user, printing to the shell "
"and so\n"
"forth. The Mix shell is swappable (see `shell/1`), allowing developers to "
"use\n"
"a test shell that simply sends messages to the current process instead of\n"
"performing IO (see `Mix.Shell.Process`).\n"
"\n"
"By default, this returns `Mix.Shell.IO`.\n"
msgstr ""
"カレントシェルを返します。\n"
"\n"
"`shell/0` をカレントシェルのラッパーとして使用することができます。\n"
"ユーザから情報をリクエストしたり、シェルに出力するなどの便利機能を\n"
"含んでいます。\n"
"Mixシェルは取り替え可能である（`shell/1`を参照）ので、\n"
"開発者はIOを実行せずにカレントプロセスに単にメッセージを送るだけの\n"
"テストシェルを使うことができます。\n"
"（`Mix.Shell.Process`を参照）。\n"
"\n"
"デフォルトでは、`Mix.Shell.IO`を返します。\n"

#. TRANSLATORS: def Mix.env(env)
#: lib/mix.ex:207
msgid ""
"Changes the current Mix environment to `env`.\n"
"\n"
"Be careful when invoking this function as any project\n"
"configuration won't be reloaded.\n"
msgstr ""
"現在のMix環境を`env`に変更します。\n"
"\n"
"この関数の実行には注意が必要です。プロジェクトの設定は\n"
"リロードされないからです。\n"

#. TRANSLATORS: def Mix.debug(debug)
#: lib/mix.ex:264
msgid "Sets Mix debug mode.\n"
msgstr "Mixデバッグモードを設定します。\n"

#. TRANSLATORS: def Mix.debug?()
#: lib/mix.ex:257
msgid "Returns true if Mix is in debug mode.\n"
msgstr "Mixがデバッグモードの場合、trueを返します。\n"

#. TRANSLATORS: def Mix.compilers()
#: lib/mix.ex:217
msgid ""
"Returns the default compilers used by Mix.\n"
"\n"
"It can be used in your `mix.exs` to prepend or\n"
"append new compilers to Mix:\n"
"\n"
"    def project do\n"
"      [compilers: Mix.compilers ++ [:foo, :bar]]\n"
"    end\n"
"\n"
msgstr ""
"Mixが使用するデフォルトのコンパイラを返します。\n"
"\n"
"`mix.exs`の中でMixの新たなコンパイラをデフォルトコンパイラの\n"
"前または後ろに追加する際に使用することができます。:\n"
"\n"
"    def project do\n"
"      [compilers: Mix.compilers ++ [:foo, :bar]]\n"
"    end\n"
"\n"

#. TRANSLATORS: def Mix.shell(shell)
#: lib/mix.ex:247
msgid ""
"Sets the current shell.\n"
"\n"
"After calling this function, `shell` becomes the shell that is returned by\n"
"`shell/0`.\n"
msgstr ""
"カレントシェルを設定します。\n"
"\n"
"この関数の呼び出し後は、`shell`は`shell/0`により返されたnシェルになります。\n"
