#. TRANSLATORS: Elixir.Mix Summary
#: lib/mix.ex:2 
msgid ""
"Mix is a build tool that provides tasks for creating, compiling,\n"
"and testing Elixir projects, managing its dependencies, and more.\n"
"\n"
"## Mix.Project\n"
"\n"
"The foundation of Mix is a project. A project can be defined by using\n"
"`Mix.Project` in a module, usually placed in a file named `mix.exs`:\n"
"\n"
"    defmodule MyApp.Mixfile do\n"
"      use Mix.Project\n"
"\n"
"      def project do\n"
"        [app: :my_app,\n"
"         version: \"1.0.0\"]\n"
"      end\n"
"    end\n"
"\n"
"See the `Mix.Project` module for detailed documentation on Mix projects.\n"
"\n"
"Once the project is defined, a number of default Mix tasks can be run\n"
"directly from the command line:\n"
"\n"
"  * `mix compile` - compiles the current project\n"
"  * `mix test` - runs tests for the given project\n"
"  * `mix run` - runs a particular command inside the project\n"
"\n"
"Each task has its own options and sometimes specific configuration\n"
"to be defined in the `project/0` function. You can use `mix help`\n"
"to list all available tasks and `mix help NAME` to show help for\n"
"a particular task.\n"
"\n"
"The best way to get started with your first project is by calling\n"
"`mix new my_project` from the command line.\n"
"\n"
"## Mix.Task\n"
"\n"
"Tasks are what make Mix extensible.\n"
"\n"
"Projects can extend Mix behaviour by adding their own tasks. For\n"
"example, adding the task below inside your project will\n"
"make it available to everyone that uses your project:\n"
"\n"
"    defmodule Mix.Tasks.Hello do\n"
"      use Mix.Task\n"
"\n"
"      def run(_) do\n"
"        Mix.shell.info \"hello\"\n"
"      end\n"
"    end\n"
"\n"
"The task can now be invoked with `mix hello`.\n"
"\n"
"## Dependencies\n"
"\n"
"Mix also manages your dependencies and integrates nicely with the [Hex package\n"
"manager](https://hex.pm).\n"
"\n"
"In order to use dependencies, you need to add a `:deps` key\n"
"to your project configuration. We often extract the list of dependencies\n"
"into its own function:\n"
"\n"
"    defmodule MyApp.Mixfile do\n"
"      use Mix.Project\n"
"\n"
"      def project do\n"
"        [app: :my_app,\n"
"         version: \"1.0.0\",\n"
"         deps: deps()]\n"
"      end\n"
"\n"
"      defp deps do\n"
"        [{:ecto, \"~> 0.2.5\"},\n"
"         {:plug, github: \"elixir-lang/plug\"}]\n"
"      end\n"
"    end\n"
"\n"
"You can run `mix help deps` to learn more about dependencies in Mix.\n"
"\n"
"## Environments\n"
"\n"
"Mix supports different environments. Environments allow developers to prepare\n"
"and organize their project specifically for different scenarios. By default,\n"
"Mix provides three environments:\n"
"\n"
"  * `:dev` - the default environment\n"
"  * `:test` - the environment `mix test` runs on\n"
"  * `:prod` - the environment your dependencies run on\n"
"\n"
"The environment can be changed via the command line by setting\n"
"the `MIX_ENV` environment variable, for example:\n"
"\n"
"    $ MIX_ENV=prod mix run server.exs\n"
"\n"
"## Aliases\n"
"\n"
"Aliases are shortcuts or tasks specific to the current project.\n"
"\n"
"In the `Mix.Task` section, we have defined a task that would be\n"
"available to everyone using our project as a dependency. What if\n"
"we wanted the task to only be available for our project? Just\n"
"define an alias:\n"
"\n"
"    defmodule MyApp.Mixfile do\n"
"      use Mix.Project\n"
"\n"
"      def project do\n"
"        [app: :my_app,\n"
"         version: \"1.0.0\",\n"
"         aliases: aliases]\n"
"      end\n"
"\n"
"      defp aliases do\n"
"        [c: \"compile\",\n"
"         hello: &hello/1]\n"
"      end\n"
"\n"
"      defp hello(_) do\n"
"        Mix.shell.info \"Hello world\"\n"
"      end\n"
"    end\n"
"\n"
"In the example above, we have defined two aliases. One is `mix c`\n"
"which is a shortcut for `mix compile`. The other is named\n"
"`mix hello`, which is the equivalent to the `Mix.Tasks.Hello`\n"
"we have defined in the `Mix.Task` section.\n"
"\n"
"Aliases may also be lists, specifying multiple tasks to be run\n"
"consecutively:\n"
"\n"
"    [all: [&hello/1, \"deps.get --only #{Mix.env}\", \"compile\"]]\n"
"\n"
"In the example above, we have defined an alias named `mix all`,\n"
"that prints hello, then fetches dependencies specific to the\n"
"current environment and compiles it.\n"
"\n"
"Arguments given to the alias will be appended to the arguments\n"
"of the last task in the list, if the last task is a function\n"
"they will be given as a list of strings to the function.\n"
"\n"
"Finally, aliases can also be used to augment existing tasks.\n"
"Let's suppose you want to augment `mix clean` to clean another\n"
"directory Mix does not know about:\n"
"\n"
"    [clean: [\"clean\", &clean_extra/1]]\n"
"\n"
"Where `&clean_extra/1` would be a function in your `mix.exs`\n"
"with extra clean up logic.\n"
"\n"
"Note aliases do not show up on `mix help`.\n"
"Aliases defined in the current project do not affect its dependencies and aliases defined in dependencies are not accessible from the current project.\n"
"\n"
"## Environment variables\n"
"\n"
"Several environment variables can be used to modify Mix's behaviour.\n"
"\n"
"Mix responds to the following variables:\n"
"\n"
"  * `MIX_ARCHIVES` - specifies the directory into which the archives should be installed\n"
"  * `MIX_DEBUG` - outputs debug information about each task before running it\n"
"  * `MIX_ENV` - specifies which environment should be used. See [Environments](#module-environments)\n"
"  * `MIX_EXS` - changes the full path to the `mix.exs` file\n"
"  * `MIX_HOME` - path to mix's home directory, stores configuration files and scripts used by mix\n"
"  * `MIX_PATH` - appends extra code paths\n"
"  * `MIX_QUIET` - does not print information messages to the terminal\n"
"  * `MIX_REBAR` - path to rebar command that overrides the one mix installs\n"
"  * `MIX_REBAR3` - path to rebar3 command that overrides the one mix installs\n"
"\n"
"Environment variables that are not meant to hold a value (and act basically as\n"
"flags) should be set to either `1` or `true`, for example:\n"
"\n"
"    $ MIX_DEBUG=1 mix compile\n"
"\n"
msgstr ""
#. TRANSLATORS: def Mix.env()
#: lib/mix.ex:199 
msgid ""
"Returns the Mix environment.\n"
msgstr ""
#. TRANSLATORS: def Mix.raise(message)
#: lib/mix.ex:271 
msgid ""
"Raises a Mix error that is nicely formatted.\n"
msgstr ""
#. TRANSLATORS: def Mix.env(env)
#: lib/mix.ex:207 
msgid ""
"Changes the current Mix environment to `env`.\n"
"\n"
"Be careful when invoking this function as any project\n"
"configuration won't be reloaded.\n"
msgstr ""
#. TRANSLATORS: def Mix.debug(debug)
#: lib/mix.ex:264 
msgid ""
"Sets Mix debug mode.\n"
msgstr ""
#. TRANSLATORS: def Mix.shell()
#: lib/mix.ex:232 
msgid ""
"Returns the current shell.\n"
"\n"
"`shell/0` can be used as a wrapper for the current shell. It contains\n"
"conveniences for requesting information from the user, printing to the shell and so\n"
"forth. The Mix shell is swappable (see `shell/1`), allowing developers to use\n"
"a test shell that simply sends messages to the current process instead of\n"
"performing IO (see `Mix.Shell.Process`).\n"
"\n"
"By default, this returns `Mix.Shell.IO`.\n"
msgstr ""
#. TRANSLATORS: def Mix.debug?()
#: lib/mix.ex:257 
msgid ""
"Returns true if Mix is in debug mode.\n"
msgstr ""
#. TRANSLATORS: def Mix.compilers()
#: lib/mix.ex:217 
msgid ""
"Returns the default compilers used by Mix.\n"
"\n"
"It can be used in your `mix.exs` to prepend or\n"
"append new compilers to Mix:\n"
"\n"
"    def project do\n"
"      [compilers: Mix.compilers ++ [:foo, :bar]]\n"
"    end\n"
"\n"
msgstr ""
#. TRANSLATORS: def Mix.shell(shell)
#: lib/mix.ex:247 
msgid ""
"Sets the current shell.\n"
"\n"
"After calling this function, `shell` becomes the shell that is returned by\n"
"`shell/0`.\n"
msgstr ""
