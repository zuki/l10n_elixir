msgid ""
msgstr ""
"Project-Id-Version: l 10n_elixir\n"
"PO-Revision-Date: 2016-04-02 22:26+0900\n"
"Last-Translator: 小田 照敬 <EMAIL@ADDRESS>\n"
"Language-Team: Japanese\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#. TRANSLATORS: def URI.default_port(scheme, port)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/uri.ex:48
msgid ""
"Registers the default port `port` for the given `scheme`.\n"
"\n"
"After this function is called, `port` will be returned by\n"
"`default_port/1` for the given scheme `scheme`. Note that this function\n"
"changes the default port for the given `scheme` *globally*, meaning for\n"
"every application.\n"
"\n"
"It is recommended for this function to be invoked in your\n"
"application's start callback in case you want to register\n"
"new URIs.\n"
msgstr ""

#. TRANSLATORS: Elixir.URI Summary
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/uri.ex:2
msgid ""
"Utilities for working with URIs.\n"
"\n"
"This module provides functions for working with URIs (for example, parsing\n"
"URIs or encoding query strings). For reference, most of the functions in "
"this\n"
"module refer to [RFC 3986](https://tools.ietf.org/html/rfc3986).\n"
msgstr ""

#. TRANSLATORS: def URI.encode_query(enumerable)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/uri.ex:65
#, fuzzy
msgid ""
"Encodes an enumerable into a query string.\n"
"\n"
"Takes an enumerable that enumerates as a list of two-element\n"
"tuples (e.g., a map or a keyword list) and returns a string\n"
"in the form of `key1=value1&key2=value2...` where keys and\n"
"values are URL encoded as per `encode_www_form/1`.\n"
"\n"
"Keys and values can be any term that implements the `String.Chars`\n"
"protocol, except lists which are explicitly forbidden.\n"
"\n"
"## Examples\n"
"\n"
"    iex> hd = %{\"foo\" => 1, \"bar\" => 2}\n"
"    iex> URI.encode_query(hd)\n"
"    \"bar=2&foo=1\"\n"
"\n"
"    iex> query = %{\"key\" => \"value with spaces\"}\n"
"    iex> URI.encode_query(query)\n"
"    \"key=value+with+spaces\"\n"
"\n"
"    iex> URI.encode_query %{key: [:a, :list]}\n"
"    ** (ArgumentError) encode_query/1 values cannot be lists, got: [:a, :"
"list]\n"
"\n"
msgstr ""
"enumerableをquery stringにエンコードします。\n"
"\n"
"enumerable(2アイテムのタプルのシーケンスを含みます)をとり、\n"
"キーと値がそれぞれ、`encode_www_form/1`によりURLエンコードされた、\n"
"フォーム\"key1_value1&key2=value2...\"の文字列を返します。\n"
"\n"
"キーと値は、明確に禁じられているリストを除く、`String.Chars`プロトコル\n"
"を実装した任意のタームが使えます。\n"
"\n"
"## Examples\n"
"\n"
"    iex> hd = %{\"foo\" => 1, \"bar\" => 2}\n"
"    iex> URI.encode_query(hd)\n"
"    \"bar=2&foo=1\"\n"
"\n"
"    iex> query = %{\"key\" => \"value with spaces\"}\n"
"    iex> URI.encode_query(query)\n"
"    \"key=value+with+spaces\"\n"
"\n"

#. TRANSLATORS: def URI.to_string(uri)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/uri.ex:439
msgid ""
"Returns the string representation of the given `URI` struct.\n"
"\n"
"    iex> URI.to_string(URI.parse(\"http://google.com\"))\n"
"    \"http://google.com\"\n"
"\n"
"    iex> URI.to_string(%URI{scheme: \"foo\", host: \"bar.baz\"})\n"
"    \"foo://bar.baz\"\n"
"\n"
msgstr ""

#. TRANSLATORS: def URI.decode_query(query, map \\ %{})
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/uri.ex:108
#, fuzzy
msgid ""
"Decodes a query string into a map.\n"
"\n"
"Given a query string of the form of `key1=value1&key2=value2...`, this\n"
"function inserts each key-value pair in the query string as one entry in "
"the\n"
"given `map`. Keys and values in the resulting map will be binaries. Keys "
"and\n"
"values will be percent-unescaped.\n"
"\n"
"Use `query_decoder/1` if you want to iterate over each value manually.\n"
"\n"
"## Examples\n"
"\n"
"    iex> URI.decode_query(\"foo=1&bar=2\")\n"
"    %{\"bar\" => \"2\", \"foo\" => \"1\"}\n"
"\n"
"    iex> URI.decode_query(\"percent=oh+yes%21\", %{\"starting\" => \"map"
"\"})\n"
"    %{\"percent\" => \"oh yes!\", \"starting\" => \"map\"}\n"
"\n"
msgstr ""
"query stringをmapにデコードします。\n"
"\n"
"\"key1=value1&key2=value2...\"形式のquery stringがあれば、\n"
"キー-バリューペア毎に一つのエントリとなるマップを生成します。\n"
"キーと値それぞれはバイナリです。キーと値はパーセントアンエスケープされま"
"す。\n"
"\n"
"それぞれの値を手動で繰り返したいなら、`query_decoder/1`を使ってください。\n"
"\n"
"## Examples\n"
"\n"
"    iex> URI.decode_query(\"foo=1&bar=2\")\n"
"    %{\"bar\" => \"2\", \"foo\" => \"1\"}\n"
"\n"

#. TRANSLATORS: def URI.query_decoder(query)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/uri.ex:164
#, fuzzy
msgid ""
"Returns a stream of two-element tuples representing key-value pairs in the\n"
"given `query`.\n"
"\n"
"Key and value in each tuple will be binaries and will be percent-unescaped.\n"
"\n"
"## Examples\n"
"\n"
"    iex> URI.query_decoder(\"foo=1&bar=2\") |> Enum.to_list()\n"
"    [{\"foo\", \"1\"}, {\"bar\", \"2\"}]\n"
"\n"
msgstr ""
"query stringを一つずつデコードする、\n"
"イテレータ関数を返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> URI.query_decoder(\"foo=1&bar=2\") |> Enum.map &(&1)\n"
"    [{\"foo\", \"1\"}, {\"bar\", \"2\"}]\n"
"\n"

#. TRANSLATORS: def URI.default_port(scheme)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/uri.ex:27
#, fuzzy
msgid ""
"Returns the default port for a given scheme.\n"
"\n"
"If the scheme is unknown to the `URI` module, this function returns\n"
"`nil`. The default port for any scheme can be configured globally\n"
"via `default_port/2`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> URI.default_port(\"ftp\")\n"
"    21\n"
"\n"
"    iex> URI.default_port(\"ponzi\")\n"
"    nil\n"
"\n"
msgstr ""
"与えられたプロトコルスキームのデフォルトポートを返します。\n"
"\n"
"もしスキームがURIにとって知られていないなら、`nil`を返します。\n"
"任意のスキームは`default_port/2`で登録することができます。\n"
"\n"
"## 例\n"
"\n"
"    iex> URI.default_port(\"ftp\")\n"
"    21\n"
"\n"
"    iex> URI.default_port(\"ponzi\")\n"
"    nil\n"
"\n"

#. TRANSLATORS: def URI.merge(uri, rel)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/uri.ex:452
msgid ""
"Merges two URIs.\n"
"\n"
"This function merges two URIs as per\n"
"[RFC 3986, section 5.2](http://tools.ietf.org/html/rfc3986#section-5.2).\n"
"\n"
"## Examples\n"
"\n"
"    iex> URI.merge(URI.parse(\"http://google.com\"), \"/query\") |> "
"to_string\n"
"    \"http://google.com/query\"\n"
"\n"
"    iex> URI.merge(\"http://example.com\", \"http://google.com\") |> "
"to_string\n"
"    \"http://google.com\"\n"
"\n"
msgstr ""

#. TRANSLATORS: def URI.parse(uri)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/uri.ex:361
#, fuzzy
msgid ""
"Parses a well-formed URI reference into its components.\n"
"\n"
"Note this function expects a well-formed URI and does not perform\n"
"any validation. See the \"Examples\" section below for examples of how\n"
"`URI.parse/1` can be used to parse a wide range of URIs.\n"
"\n"
"This function uses the parsing regular expression as defined\n"
"in [RFC 3986, Appendix B](http://tools.ietf.org/html/rfc3986#appendix-B).\n"
"\n"
"When a URI is given without a port, the value returned by\n"
"`URI.default_port/1` for the URI's scheme is used for the `:port` field.\n"
"\n"
"If a `%URI{}` struct is given to this function, this function returns it\n"
"unmodified.\n"
"\n"
"## Examples\n"
"\n"
"    iex> URI.parse(\"http://elixir-lang.org/\")\n"
"    %URI{scheme: \"http\", path: \"/\", query: nil, fragment: nil,\n"
"         authority: \"elixir-lang.org\", userinfo: nil,\n"
"         host: \"elixir-lang.org\", port: 80}\n"
"\n"
"    iex> URI.parse(\"//elixir-lang.org/\")\n"
"    %URI{authority: \"elixir-lang.org\", fragment: nil, host: \"elixir-lang."
"org\",\n"
"         path: \"/\", port: nil, query: nil, scheme: nil, userinfo: nil}\n"
"\n"
"    iex> URI.parse(\"/foo/bar\")\n"
"    %URI{authority: nil, fragment: nil, host: nil, path: \"/foo/bar\",\n"
"         port: nil, query: nil, scheme: nil, userinfo: nil}\n"
"\n"
"    iex> URI.parse(\"foo/bar\")\n"
"    %URI{authority: nil, fragment: nil, host: nil, path: \"foo/bar\",\n"
"         port: nil, query: nil, scheme: nil, userinfo: nil}\n"
"\n"
msgstr ""
"well-formdedなURI参照を構成要素にパースします。\n"
"\n"
"この関数はwell-formedなURIを期待していて、如何なるバリデーショ\n"
"ンも実施しないことに注意してください。`URI.parse/1`がどのよう\n"
"に広範囲の相対URIをパースするのに用いられるか下の例のセクショ\n"
"ンを参照してください。\n"
"\n"
"この関数は、[RFC3986のAppendix B]\n"
"(http://tools.ietf.org/html/rfc3986#appendix-B)\n"
"で定義された正規表現を用いてパースします。\n"
"\n"
"URIにポートが与えられないとき、`URI.default_port/1`と\n"
"`URI.default_port/2`で登録された値が使われます。\n"
"\n"
"## 例\n"
"\n"
"    iex> URI.parse(\"http://elixir-lang.org/\")\n"
"    %URI{scheme: \"http\", path: \"/\", query: nil, fragment: nil,\n"
"         authority: \"elixir-lang.org\", userinfo: nil,\n"
"         host: \"elixir-lang.org\", port: 80}\n"
"\n"
"    iex> URI.parse(\"//elixir-lang.org/\")\n"
"    %URI{authority: \"elixir-lang.org\", fragment: nil, host: \"elixir-lang."
"org\",\n"
"         path: \"/\", port: nil, query: nil, scheme: nil, userinfo: nil}\n"
"\n"
"    iex> URI.parse(\"/foo/bar\")\n"
"    %URI{authority: nil, fragment: nil, host: nil, path: \"/foo/bar\",\n"
"         port: nil, query: nil, scheme: nil, userinfo: nil}\n"
"\n"
"    iex> URI.parse(\"foo/bar\")\n"
"    %URI{authority: nil, fragment: nil, host: nil, path: \"foo/bar\",\n"
"         port: nil, query: nil, scheme: nil, userinfo: nil}\n"
"\n"

#. TRANSLATORS: def URI.encode_www_form(string)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/uri.ex:278
msgid ""
"Encodes a string as \"x-www-form-urlencoded\".\n"
"\n"
"## Example\n"
"\n"
"    iex> URI.encode_www_form(\"put: it+й\")\n"
"    \"put%3A+it%2B%D0%B9\"\n"
"\n"
msgstr ""
"\"x-www-urlencoded\"として文字列をエンコードします。\n"
"\n"
"## Example\n"
"\n"
"    iex> URI.encode_www_form(\"put: it+й\")\n"
"    \"put%3A+it%2B%D0%B9\"\n"
"\n"

#. TRANSLATORS: def URI.char_reserved?(char)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/uri.ex:201
#, fuzzy
msgid ""
"Checks if the character is a \"reserved\" character in a URI.\n"
"\n"
"Reserved characters are specified in\n"
"[RFC 3986, section 2.2](http://tools.ietf.org/html/rfc3986#section-2.2).\n"
"\n"
"## Examples\n"
"\n"
"    iex> URI.char_reserved?(?+)\n"
"    true\n"
"\n"
msgstr ""
"文字が、URIの\"予約(reserved)\"文字かどうかをチェックします。\n"
"\n"
"予約(reserved)文字は、 \n"
"[RFC3986, section 2.2](http://tools.ietf.org/html/rfc3986#section-2.2)\n"
"に定められています。\n"

#. TRANSLATORS: def URI.char_unreserved?(char)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/uri.ex:218
#, fuzzy
msgid ""
"Checks if the character is a \"unreserved\" character in a URI.\n"
"\n"
"Unreserved characters are specified in\n"
"[RFC 3986, section 2.3](http://tools.ietf.org/html/rfc3986#section-2.3).\n"
"\n"
"## Examples\n"
"\n"
"    iex> URI.char_unreserved?(?_)\n"
"    true\n"
"\n"
msgstr ""
"文字が、URIの\"非予約(unreserved)\"文字かどうかをチェックします。\n"
"\n"
"非予約(unreserved)文字は、 \n"
"[RFC3986, section 2.3](http://tools.ietf.org/html/rfc3986#section-2.3)\n"
"に定められています。\n"

#. TRANSLATORS: def URI.decode(uri)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/uri.ex:308
msgid ""
"Percent-unescapes a URI.\n"
"\n"
"## Examples\n"
"\n"
"    iex> URI.decode(\"http%3A%2F%2Felixir-lang.org\")\n"
"    \"http://elixir-lang.org\"\n"
"\n"
msgstr ""
"URIをパーセントアンエスケープします。\n"
"\n"
"## 例\n"
"\n"
"    iex> URI.decode(\"http%3A%2F%2Felixir-lang.org\")\n"
"    \"http://elixir-lang.org\"\n"
"\n"

#. TRANSLATORS: def URI.char_unescaped?(char)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/uri.ex:238
#, fuzzy
msgid ""
"Checks if the character is allowed unescaped in a URI.\n"
"\n"
"This is the default used by `URI.encode/2` where both\n"
"reserved and unreserved characters are kept unescaped.\n"
"\n"
"## Examples\n"
"\n"
"    iex> URI.char_unescaped?(?{)\n"
"    false\n"
"\n"
msgstr ""
"文字がURIでアンエスケープが許されるかどうかをチェックします。\n"
"\n"
"予約、実予約文字の両方がアンエスケープでおかれるように、\n"
"これはデフォルトで`URI.encode/2`によって使われます。\n"

#. TRANSLATORS: def URI.decode_www_form(string)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/uri.ex:325
msgid ""
"Decodes a string as \"x-www-form-urlencoded\".\n"
"\n"
"## Examples\n"
"\n"
"    iex> URI.decode_www_form(\"%3Call+in%2F\")\n"
"    \"<all in/\"\n"
"\n"
msgstr ""
"\"x-www-urlencoded\"として文字列をデコードします。\n"
"\n"
"## Examples\n"
"\n"
"    iex> URI.decode_www_form(\"%3Call+in%2F\")\n"
"    \"<all in/\"\n"
"\n"

#. TRANSLATORS: def URI.encode(string, predicate \\ &char_unescaped?/1)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/uri.ex:255
#, fuzzy
msgid ""
"Percent-escapes the given string.\n"
"\n"
"This function accepts a `predicate` function as an optional argument; if\n"
"passed, this function will be called with each character (byte) in `string` "
"as\n"
"its argument and should return `true` if that character should not be "
"escaped\n"
"and left as is.\n"
"\n"
"## Examples\n"
"\n"
"    iex> URI.encode(\"ftp://s-ite.tld/?value=put it+й\")\n"
"    \"ftp://s-ite.tld/?value=put%20it+%D0%B9\"\n"
"\n"
"    iex> URI.encode(\"a string\", &(&1 != ?i))\n"
"    \"a str%69ng\"\n"
"\n"
msgstr ""
"URIをパーセントエスケープします。\n"
"文字が現状のまま残されるかどうかを決めるための1引数の`predicate`関数\n"
"を受け付けます。\n"
"\n"
"## 例\n"
"\n"
"    iex> URI.encode(\"ftp://s-ite.tld/?value=put it+й\")\n"
"    \"ftp://s-ite.tld/?value=put%20it+%D0%B9\"\n"
"\n"

#~ msgid "Utilities for working with and creating URIs.\n"
#~ msgstr "URIの作成と動作についてのユーティリティです。\n"

#~ msgid ""
#~ "Converts the URI to string.\n"
#~ "\n"
#~ "    iex> URI.to_string(URI.parse(\"http://google.com\"))\n"
#~ "    \"http://google.com\"\n"
#~ msgstr ""
#~ "URLを文字列に変換します。\n"
#~ "\n"
#~ "    iex> URI.to_string(URI.parse(\"http://google.com\"))\n"
#~ "    \"http://google.com\"\n"

#~ msgid ""
#~ "Registers a scheme with a default port.\n"
#~ "\n"
#~ "It is recommended for this function to be invoked in your\n"
#~ "application start callback in case you want to register\n"
#~ "new URIs.\n"
#~ msgstr ""
#~ "スキームのデフォルトポートを登録します。\n"
#~ "\n"
#~ "新しいURIを登録したい場合に備えて、この関数があなたの\n"
#~ "アプリケーションのstartコールバックで実行されることは\n"
#~ "推奨されます。\n"

#~ msgid "Normalizes the scheme according to the spec by downcasing it.\n"
#~ msgstr "小文字化することにより仕様に従って、schemeを正規化します。\n"
