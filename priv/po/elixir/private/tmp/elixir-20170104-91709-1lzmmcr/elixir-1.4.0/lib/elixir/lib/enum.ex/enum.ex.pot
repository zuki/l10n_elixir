#. TRANSLATORS: def Enum.chunk(enumerable, count)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/enum.ex:319 
msgid ""
"Shortcut to `chunk(enumerable, count, count)`.\n"
msgstr ""
#. TRANSLATORS: def Enum.reduce(enumerable, fun)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/enum.ex:1690 
msgid ""
"Invokes `fun` for each element in the `enumerable`, passing that\n"
"element and the accumulator as arguments. `fun`'s return value\n"
"is stored in the accumulator.\n"
"\n"
"The first element of the enumerable is used as the initial value of\n"
"the accumulator.\n"
"If you wish to use another value for the accumulator, use\n"
"`Enumerable.reduce/3`.\n"
"This function won't call the specified function for enumerables that\n"
"are one-element long.\n"
"\n"
"Returns the accumulator.\n"
"\n"
"Note that since the first element of the enumerable is used as the\n"
"initial value of the accumulator, `fun` will only be executed `n - 1`\n"
"times where `n` is the length of the enumerable.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.reduce([1, 2, 3, 4], fn(x, acc) -> x * acc end)\n"
"    24\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.random(enumerable)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/enum.ex:1639 
msgid ""
"Returns a random element of an enumerable.\n"
"\n"
"Raises `Enum.EmptyError` if `enumerable` is empty.\n"
"\n"
"This function uses Erlang's `:rand` module to calculate\n"
"the random value. Check its documentation for setting a\n"
"different random algorithm or a different seed.\n"
"\n"
"The implementation is based on the\n"
"[reservoir sampling](https://en.wikipedia.org/wiki/Reservoir_sampling#Relation_to_Fisher-Yates_shuffle)\n"
"algorithm.\n"
"It assumes that the sample being returned can fit into memory;\n"
"the input `enumerable` doesn't have to, as it is traversed just once.\n"
"\n"
"If a range is passed into the function, this function will pick a\n"
"random value between the range limits, without traversing the whole\n"
"range (thus executing in constant time and constant memory).\n"
"\n"
"## Examples\n"
"\n"
"    # Although not necessary, let's seed the random algorithm\n"
"    iex> :rand.seed(:exsplus, {101, 102, 103})\n"
"    iex> Enum.random([1, 2, 3])\n"
"    2\n"
"    iex> Enum.random([1, 2, 3])\n"
"    1\n"
"    iex> Enum.random(1..1_000)\n"
"    776\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.join(enumerable, joiner \\ "")
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/enum.ex:1177 
msgid ""
"Joins the given enumerable into a binary using `joiner` as a\n"
"separator.\n"
"\n"
"If `joiner` is not passed at all, it defaults to the empty binary.\n"
"\n"
"All items in the enumerable must be convertible to a binary,\n"
"otherwise an error is raised.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.join([1, 2, 3])\n"
"    \"123\"\n"
"\n"
"    iex> Enum.join([1, 2, 3], \" = \")\n"
"    \"1 = 2 = 3\"\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.count(enumerable, fun)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/enum.ex:477 
msgid ""
"Returns the count of items in the enumerable for which `fun` returns\n"
"a truthy value.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.count([1, 2, 3, 4, 5], fn(x) -> rem(x, 2) == 0 end)\n"
"    2\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.dedup(enumerable)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/enum.ex:494 
msgid ""
"Enumerates the `enumerable`, returning a list where all consecutive\n"
"duplicated elements are collapsed to a single element.\n"
"\n"
"Elements are compared using `===`.\n"
"\n"
"If you want to remove all duplicated elements, regardless of order,\n"
"see `uniq/1`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.dedup([1, 2, 3, 3, 2, 1])\n"
"    [1, 2, 3, 2, 1]\n"
"\n"
"    iex> Enum.dedup([1, 1, 2, 2.0, :three, :\"three\"])\n"
"    [1, 2, 2.0, :three]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.drop(enumerable, amount)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/enum.ex:539 
msgid ""
"Drops the `amount` of items from the enumerable.\n"
"\n"
"If a negative `amount` is given, the `amount` of last values will be dropped.\n"
"\n"
"The `enumerable` is enumerated once to retrieve the proper index and\n"
"the remaining calculation is performed from the end.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.drop([1, 2, 3], 2)\n"
"    [3]\n"
"\n"
"    iex> Enum.drop([1, 2, 3], 10)\n"
"    []\n"
"\n"
"    iex> Enum.drop([1, 2, 3], 0)\n"
"    [1, 2, 3]\n"
"\n"
"    iex> Enum.drop([1, 2, 3], -1)\n"
"    [1, 2]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.min_max(enumerable, empty_fallback \\ fn -> raise(Enum.EmptyError) end)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/enum.ex:1491 
msgid ""
"Returns a tuple with the minimal and the maximal elements in the\n"
"enumerable according to Erlang's term ordering.\n"
"\n"
"If multiple elements are considered maximal or minimal, the first one\n"
"that was found is returned.\n"
"\n"
"Calls the provided `empty_fallback` function and returns its value if\n"
"`enumerable` is empty. The default `empty_fallback` raises `Enum.EmptyError`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.min_max([2, 3, 1])\n"
"    {1, 3}\n"
"\n"
"    iex> Enum.min_max([], fn -> {nil, nil} end)\n"
"    {nil, nil}\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.shuffle(enumerable)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/enum.ex:1939 
msgid ""
"Returns a list with the elements of `enumerable` shuffled.\n"
"\n"
"This function uses Erlang's `:rand` module to calculate\n"
"the random value. Check its documentation for setting a\n"
"different random algorithm or a different seed.\n"
"\n"
"## Examples\n"
"\n"
"    # Although not necessary, let's seed the random algorithm\n"
"    iex> :rand.seed(:exsplus, {1, 2, 3})\n"
"    iex> Enum.shuffle([1, 2, 3])\n"
"    [2, 1, 3]\n"
"    iex> Enum.shuffle([1, 2, 3])\n"
"    [2, 3, 1]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.member?(enumerable, element)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/enum.ex:1395 
msgid ""
"Checks if `element` exists within the enumerable.\n"
"\n"
"Membership is tested with the match (`===`) operator.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.member?(1..10, 5)\n"
"    true\n"
"    iex> Enum.member?(1..10, 5.0)\n"
"    false\n"
"\n"
"    iex> Enum.member?([1.0, 2.0, 3.0], 2)\n"
"    false\n"
"    iex> Enum.member?([1.0, 2.0, 3.0], 2.000)\n"
"    true\n"
"\n"
"    iex> Enum.member?([:a, :b, :c], :d)\n"
"    false\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.sort(enumerable, fun)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/enum.ex:2119 
msgid ""
"Sorts the enumerable by the given function.\n"
"\n"
"This function uses the merge sort algorithm. The given function should compare\n"
"two arguments, and return `true` if the first argument precedes the second one.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.sort([1, 2, 3], &(&1 >= &2))\n"
"    [3, 2, 1]\n"
"\n"
"The sorting algorithm will be stable as long as the given function\n"
"returns `true` for values considered equal:\n"
"\n"
"    iex> Enum.sort [\"some\", \"kind\", \"of\", \"monster\"], &(byte_size(&1) <= byte_size(&2))\n"
"    [\"of\", \"some\", \"kind\", \"monster\"]\n"
"\n"
"If the function does not return `true` for equal values, the sorting\n"
"is not stable and the order of equal terms may be shuffled.\n"
"For example:\n"
"\n"
"    iex> Enum.sort [\"some\", \"kind\", \"of\", \"monster\"], &(byte_size(&1) < byte_size(&2))\n"
"    [\"of\", \"kind\", \"some\", \"monster\"]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.scan(enumerable, acc, fun)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/enum.ex:1922 
msgid ""
"Applies the given function to each element in the enumerable,\n"
"storing the result in a list and passing it as the accumulator\n"
"for the next computation. Uses the given `acc` as the starting value.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.scan(1..5, 0, &(&1 + &2))\n"
"    [1, 3, 6, 10, 15]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.scan(enumerable, fun)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/enum.ex:1905 
msgid ""
"Applies the given function to each element in the enumerable,\n"
"storing the result in a list and passing it as the accumulator\n"
"for the next computation.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.scan(1..5, &(&1 + &2))\n"
"    [1, 3, 6, 10, 15]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.uniq_by(enumerable, fun)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/enum.ex:2551 
msgid ""
"Enumerates the `enumerable`, by removing the elements for which\n"
"function `fun` returned duplicate items.\n"
"\n"
"The function `fun` maps every element to a term which is used to\n"
"determine if two elements are duplicates.\n"
"\n"
"The first occurrence of each element is kept.\n"
"\n"
"## Example\n"
"\n"
"    iex> Enum.uniq_by([{1, :x}, {2, :y}, {1, :z}], fn {x, _} -> x end)\n"
"    [{1, :x}, {2, :y}]\n"
"\n"
"    iex> Enum.uniq_by([a: {:tea, 2}, b: {:tea, 2}, c: {:coffee, 1}], fn {_, y} -> y end)\n"
"    [a: {:tea, 2}, c: {:coffee, 1}]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.take_random(enumerable, count)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/enum.ex:2414 
msgid ""
"Takes `count` random items from `enumerable`.\n"
"\n"
"Notice this function will traverse the whole `enumerable` to\n"
"get the random sublist.\n"
"\n"
"See `random/1` for notes on implementation and random seed.\n"
"\n"
"## Examples\n"
"\n"
"    # Although not necessary, let's seed the random algorithm\n"
"    iex> :rand.seed(:exsplus, {1, 2, 3})\n"
"    iex> Enum.take_random(1..10, 2)\n"
"    [5, 4]\n"
"    iex> Enum.take_random(?a..?z, 5)\n"
"    'ipybz'\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.find_index(enumerable, fun)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/enum.ex:873 
msgid ""
"Similar to `find/3`, but returns the index (zero-based)\n"
"of the element instead of the element itself.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.find_index([2, 4, 6], fn(x) -> rem(x, 2) == 1 end)\n"
"    nil\n"
"\n"
"    iex> Enum.find_index([2, 3, 4], fn(x) -> rem(x, 2) == 1 end)\n"
"    1\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.take(enumerable, count)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/enum.ex:2307 
msgid ""
"Takes the first `count` items from the enumerable.\n"
"\n"
"`count` must be an integer. If a negative `count` is given, the last\n"
"`count` values will be taken.\n"
"For such, the enumerable is fully enumerated keeping up\n"
"to `2 * count` elements in memory. Once the end of the enumerable is\n"
"reached, the last `count` elements are returned.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.take([1, 2, 3], 2)\n"
"    [1, 2]\n"
"\n"
"    iex> Enum.take([1, 2, 3], 10)\n"
"    [1, 2, 3]\n"
"\n"
"    iex> Enum.take([1, 2, 3], 0)\n"
"    []\n"
"\n"
"    iex> Enum.take([1, 2, 3], -1)\n"
"    [3]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.reduce(enumerable, acc, fun)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/enum.ex:1740 
msgid ""
"Invokes `fun` for each element in the `enumerable`, passing that\n"
"element and the accumulator `acc` as arguments. `fun`'s return value\n"
"is stored in `acc`.\n"
"\n"
"Returns the accumulator.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.reduce([1, 2, 3], 0, fn(x, acc) -> x + acc end)\n"
"    6\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.max_by(enumerable, fun, empty_fallback \\ fn -> raise(Enum.EmptyError) end)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/enum.ex:1363 
msgid ""
"Returns the maximal element in the enumerable as calculated\n"
"by the given function.\n"
"\n"
"If multiple elements are considered maximal, the first one that was found\n"
"is returned.\n"
"\n"
"Calls the provided `empty_fallback` function and returns its value if\n"
"`enumerable` is empty. The default `empty_fallback` raises `Enum.EmptyError`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.max_by([\"a\", \"aa\", \"aaa\"], fn(x) -> String.length(x) end)\n"
"    \"aaa\"\n"
"\n"
"    iex> Enum.max_by([\"a\", \"aa\", \"aaa\", \"b\", \"bbb\"], &String.length/1)\n"
"    \"aaa\"\n"
"\n"
"    iex> Enum.max_by([], &String.length/1, fn -> nil end)\n"
"    nil\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.intersperse(enumerable, element)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/enum.ex:1053 
msgid ""
"Intersperses `element` between each element of the enumeration.\n"
"\n"
"Complexity: O(n).\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.intersperse([1, 2, 3], 0)\n"
"    [1, 0, 2, 0, 3]\n"
"\n"
"    iex> Enum.intersperse([1], 0)\n"
"    [1]\n"
"\n"
"    iex> Enum.intersperse([], 0)\n"
"    []\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.all?(enumerable, fun \\ fn x -> x end)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/enum.ex:207 
msgid ""
"Returns true if the given `fun` evaluates to true on all of the items in the enumerable.\n"
"\n"
"It stops the iteration at the first invocation that returns `false` or `nil`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.all?([2, 4, 6], fn(x) -> rem(x, 2) == 0 end)\n"
"    true\n"
"\n"
"    iex> Enum.all?([2, 3, 4], fn(x) -> rem(x, 2) == 0 end)\n"
"    false\n"
"\n"
"If no function is given, it defaults to checking if\n"
"all items in the enumerable are truthy values.\n"
"\n"
"    iex> Enum.all?([1, 2, 3])\n"
"    true\n"
"\n"
"    iex> Enum.all?([1, nil, 3])\n"
"    false\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.unzip(enumerable)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/enum.ex:2580 
msgid ""
"Opposite of `Enum.zip/2`; extracts a two-element tuples from the\n"
"enumerable and groups them together.\n"
"\n"
"It takes an enumerable with items being two-element tuples and returns\n"
"a tuple with two lists, each of which is formed by the first and\n"
"second element of each tuple, respectively.\n"
"\n"
"This function fails unless `enumerable` is or can be converted into a\n"
"list of tuples with *exactly* two elements in each tuple.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.unzip([{:a, 1}, {:b, 2}, {:c, 3}])\n"
"    {[:a, :b, :c], [1, 2, 3]}\n"
"\n"
"    iex> Enum.unzip(%{a: 1, b: 2})\n"
"    {[:a, :b], [1, 2]}\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.concat(enumerables)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/enum.ex:404 
msgid ""
"Given an enumerable of enumerables, concatenates the enumerables into\n"
"a single list.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.concat([1..3, 4..6, 7..9])\n"
"    [1, 2, 3, 4, 5, 6, 7, 8, 9]\n"
"\n"
"    iex> Enum.concat([[1, [2], 3], [4], [5, 6]])\n"
"    [1, [2], 3, 4, 5, 6]\n"
"\n"
msgstr ""
#. TRANSLATORS: @type result
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/enum.ex:65 
msgid ""
"The result of the reduce operation.\n"
"\n"
"It may be *done* when the enumeration is finished by reaching\n"
"its end, or *halted*/*suspended* when the enumeration was halted\n"
"or suspended by the `t:reducer/0` function.\n"
"\n"
"In case a `t:reducer/0` function returns the `:suspend` accumulator, the\n"
"`:suspended` tuple must be explicitly handled by the caller and\n"
"never leak. In practice, this means regular enumeration functions\n"
"just need to be concerned about `:done` and `:halted` results.\n"
"\n"
"Furthermore, a `:suspend` call must always be followed by another call,\n"
"eventually halting or continuing until the end.\n"
msgstr ""
#. TRANSLATORS: def Enum.take_while(enumerable, fun)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/enum.ex:2485 
msgid ""
"Takes the items from the beginning of the enumerable while `fun` returns\n"
"a truthy value.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.take_while([1, 2, 3], fn(x) -> x < 3 end)\n"
"    [1, 2]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enumerable.count(enumerable)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/enum.ex:133 
msgid ""
"Retrieves the enumerable's size.\n"
"\n"
"It should return `{:ok, size}`.\n"
"\n"
"If `{:error, __MODULE__}` is returned a default algorithm using\n"
"`reduce` and the match (`===`) operator is used. This algorithm runs\n"
"in linear time.\n"
"\n"
"_Please force use of the default algorithm unless you can implement an\n"
"algorithm that is significantly faster._\n"
msgstr ""
#. TRANSLATORS: def Enum.into(enumerable, collectable, transform)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/enum.ex:1139 
msgid ""
"Inserts the given `enumerable` into a `collectable` according to the\n"
"transformation function.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.into([2, 3], [3], fn x -> x * 3 end)\n"
"    [3, 6, 9]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.slice(enumerable, start, amount)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/enum.ex:2017 
msgid ""
"Returns a subset list of the given enumerable, from `start` position with `amount` of elements if available.\n"
"\n"
"Given `enumerable`, it drops elements until element position `start`,\n"
"then takes `amount` of elements until the end of the enumerable.\n"
"\n"
"If `start` is out of bounds, it returns `[]`.\n"
"\n"
"If `amount` is greater than `enumerable` length, it returns as many elements as possible.\n"
"If `amount` is zero, then `[]` is returned.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.slice(1..100, 5, 10)\n"
"    [6, 7, 8, 9, 10, 11, 12, 13, 14, 15]\n"
"\n"
"    # amount to take is greater than the number of elements\n"
"    iex> Enum.slice(1..10, 5, 100)\n"
"    [6, 7, 8, 9, 10]\n"
"\n"
"    iex> Enum.slice(1..10, 5, 0)\n"
"    []\n"
"\n"
"    # out of bound start position\n"
"    iex> Enum.slice(1..10, 10, 5)\n"
"    []\n"
"\n"
"    # out of bound start position (negative)\n"
"    iex> Enum.slice(1..10, -11, 5)\n"
"    []\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.count(enumerable)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/enum.ex:452 
msgid ""
"Returns the size of the enumerable.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.count([1, 2, 3])\n"
"    3\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.sort(enumerable)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/enum.ex:2099 
msgid ""
"Sorts the enumerable according to Erlang's term ordering.\n"
"\n"
"Uses the merge sort algorithm.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.sort([3, 2, 1])\n"
"    [1, 2, 3]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.with_index(enumerable, offset \\ 0)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/enum.ex:2610 
msgid ""
"Returns the enumerable with each element wrapped in a tuple\n"
"alongside its index.\n"
"\n"
"If an `offset` is given, we will index from the given offset instead of from zero.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.with_index([:a, :b, :c])\n"
"    [a: 0, b: 1, c: 2]\n"
"\n"
"    iex> Enum.with_index([:a, :b, :c], 3)\n"
"    [a: 3, b: 4, c: 5]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.reverse_slice(enumerable, start, count)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/enum.ex:1878 
msgid ""
"Reverses the enumerable in the range from initial position `start`\n"
"through `count` elements.\n"
"\n"
"If `count` is greater than the size of the rest of the enumerable,\n"
"then this function will reverse the rest of the enumerable.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.reverse_slice([1, 2, 3, 4, 5, 6], 2, 4)\n"
"    [1, 2, 6, 5, 4, 3]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.filter_map(enumerable, filter, mapper)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/enum.ex:821 
msgid ""
"Filters the enumerable and maps its elements in one pass.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.filter_map([1, 2, 3], fn(x) -> rem(x, 2) == 0 end, &(&1 * 2))\n"
"    [4]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.reject(enumerable, fun)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/enum.ex:1819 
msgid ""
"Returns elements of `enumerable` for which the function `fun` returns\n"
"`false` or `nil`.\n"
"\n"
"See also `filter/2`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.reject([1, 2, 3], fn(x) -> rem(x, 2) == 0 end)\n"
"    [1, 3]\n"
"\n"
msgstr ""
#. TRANSLATORS: @type acc
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/enum.ex:37 
msgid ""
"The accumulator value for each step.\n"
"\n"
"It must be a tagged tuple with one of the following \"tags\":\n"
"\n"
"  * `:cont`    - the enumeration should continue\n"
"  * `:halt`    - the enumeration should halt immediately\n"
"  * `:suspend` - the enumeration should be suspended immediately\n"
"\n"
"Depending on the accumulator value, the result returned by\n"
"`Enumerable.reduce/3` will change. Please check the `t:result/0`\n"
"type documentation for more information.\n"
"\n"
"In case a `t:reducer/0` function returns a `:suspend` accumulator,\n"
"it must be explicitly handled by the caller and never leak.\n"
msgstr ""
#. TRANSLATORS: def Enum.flat_map(enumerable, fun)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/enum.ex:933 
msgid ""
"Returns a new enumerable appending the result of invoking `fun` on\n"
"each corresponding item of `enumerable`.\n"
"\n"
"The given function must return an enumerable.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.flat_map([:a, :b, :c], fn(x) -> [x, x] end)\n"
"    [:a, :a, :b, :b, :c, :c]\n"
"\n"
"    iex> Enum.flat_map([{1, 3}, {4, 6}], fn({x, y}) -> x..y end)\n"
"    [1, 2, 3, 4, 5, 6]\n"
"\n"
"    iex> Enum.flat_map([:a, :b, :c], fn(x) -> [[x]] end)\n"
"    [[:a], [:b], [:c]]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.empty?(enumerable)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/enum.ex:657 
msgid ""
"Determines if the enumerable is empty.\n"
"\n"
"Returns `true` if `enumerable` is empty, otherwise `false`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.empty?([])\n"
"    true\n"
"\n"
"    iex> Enum.empty?([1, 2, 3])\n"
"    false\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.min_max_by(enumerable, fun, empty_fallback \\ fn -> raise(Enum.EmptyError) end)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/enum.ex:1519 
msgid ""
"Returns a tuple with the minimal and the maximal elements in the\n"
"enumerable as calculated by the given function.\n"
"\n"
"If multiple elements are considered maximal or minimal, the first one\n"
"that was found is returned.\n"
"\n"
"Calls the provided `empty_fallback` function and returns its value if\n"
"`enumerable` is empty. The default `empty_fallback` raises `Enum.EmptyError`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.min_max_by([\"aaa\", \"bb\", \"c\"], fn(x) -> String.length(x) end)\n"
"    {\"c\", \"aaa\"}\n"
"\n"
"    iex> Enum.min_max_by([\"aaa\", \"a\", \"bb\", \"c\", \"ccc\"], &String.length/1)\n"
"    {\"a\", \"aaa\"}\n"
"\n"
"    iex> Enum.min_max_by([], &String.lenth/1, fn -> {nil, nil} end)\n"
"    {nil, nil}\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.sum(enumerable)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/enum.ex:2279 
msgid ""
"Returns the sum of all elements.\n"
"\n"
"Raises `ArithmeticError` if `enumerable` contains a non-numeric value.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.sum([1, 2, 3])\n"
"    6\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.split(enumerable, count)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/enum.ex:2200 
msgid ""
"Splits the `enumerable` into two enumerables, leaving `count`\n"
"elements in the first one.\n"
"\n"
"If `count` is a negative number, it starts counting from the\n"
"back to the beginning of the enumerable.\n"
"\n"
"Be aware that a negative `count` implies the `enumerable`\n"
"will be enumerated twice: once to calculate the position, and\n"
"a second time to do the actual splitting.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.split([1, 2, 3], 2)\n"
"    {[1, 2], [3]}\n"
"\n"
"    iex> Enum.split([1, 2, 3], 10)\n"
"    {[1, 2, 3], []}\n"
"\n"
"    iex> Enum.split([1, 2, 3], 0)\n"
"    {[], [1, 2, 3]}\n"
"\n"
"    iex> Enum.split([1, 2, 3], -1)\n"
"    {[1, 2], [3]}\n"
"\n"
"    iex> Enum.split([1, 2, 3], -5)\n"
"    {[], [1, 2, 3]}\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.map(enumerable, fun)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/enum.ex:1210 
msgid ""
"Returns a list where each item is the result of invoking\n"
"`fun` on each corresponding item of `enumerable`.\n"
"\n"
"For maps, the function expects a key-value tuple.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.map([1, 2, 3], fn(x) -> x * 2 end)\n"
"    [2, 4, 6]\n"
"\n"
"    iex> Enum.map([a: 1, b: 2], fn({k, v}) -> {k, -v} end)\n"
"    [a: -1, b: -2]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.uniq(enumerable)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/enum.ex:2531 
msgid ""
"Enumerates the `enumerable`, removing all duplicated elements.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.uniq([1, 2, 3, 3, 2, 1])\n"
"    [1, 2, 3]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.slice(enumerable, range)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/enum.ex:1964 
msgid ""
"Returns a subset list of the given enumerable, from `range.first` to `range.last` positions.\n"
"\n"
"Given `enumerable`, it drops elements until element position `range.first`,\n"
"then takes elements until element position `range.last` (inclusive).\n"
"\n"
"Positions are normalized, meaning that negative positions will be counted from the end\n"
"(e.g. `-1` means the last element of the enumerable).\n"
"If `range.last` is out of bounds, then it is assigned as the position of the last element.\n"
"\n"
"If the normalized `range.first` position is out of bounds of the given enumerable,\n"
"or this one is greater than the normalized `range.last` position, then `[]` is returned.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.slice(1..100, 5..10)\n"
"    [6, 7, 8, 9, 10, 11]\n"
"\n"
"    iex> Enum.slice(1..10, 5..20)\n"
"    [6, 7, 8, 9, 10]\n"
"\n"
"    # last five elements (negative positions)\n"
"    iex> Enum.slice(1..30, -5..-1)\n"
"    [26, 27, 28, 29, 30]\n"
"\n"
"    # last five elements (mixed positive and negative positions)\n"
"    iex> Enum.slice(1..30, 25..-1)\n"
"    [26, 27, 28, 29, 30]\n"
"\n"
"    # out of bounds\n"
"    iex> Enum.slice(1..10, 11..20)\n"
"    []\n"
"\n"
"    # range.first is greater than range.last\n"
"    iex> Enum.slice(1..10, 6..5)\n"
"    []\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.map_join(enumerable, joiner \\ "", mapper)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/enum.ex:1269 
msgid ""
"Maps and joins the given enumerable in one pass.\n"
"\n"
"`joiner` can be either a binary or a list and the result will be of\n"
"the same type as `joiner`.\n"
"If `joiner` is not passed at all, it defaults to an empty binary.\n"
"\n"
"All items in the enumerable must be convertible to a binary,\n"
"otherwise an error is raised.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.map_join([1, 2, 3], &(&1 * 2))\n"
"    \"246\"\n"
"\n"
"    iex> Enum.map_join([1, 2, 3], \" = \", &(&1 * 2))\n"
"    \"2 = 4 = 6\"\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.sort_by(enumerable, mapper, sorter \\ &<=/2)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/enum.ex:2154 
msgid ""
"Sorts the mapped results of the enumerable according to the provided `sorter`\n"
"function.\n"
"\n"
"This function maps each element of the enumerable using the provided `mapper`\n"
"function.  The enumerable is then sorted by the mapped elements\n"
"using the `sorter` function, which defaults to `Kernel.<=/2`\n"
"\n"
"`sort_by/3` differs from `sort/2` in that it only calculates the\n"
"comparison value for each element in the enumerable once instead of\n"
"once for each element in each comparison.\n"
"If the same function is being called on both element, it's also more\n"
"compact to use `sort_by/3`.\n"
"\n"
"This technique is also known as a\n"
"_[Schwartzian Transform](https://en.wikipedia.org/wiki/Schwartzian_transform)_,\n"
"or the _Lisp decorate-sort-undecorate idiom_ as the `mapper`\n"
"is decorating the original `enumerable`; then `sorter` is sorting the\n"
"decorations; and finally the enumerable is being undecorated so only\n"
"the original elements remain, but now in sorted order.\n"
"\n"
"## Examples\n"
"\n"
"Using the default `sorter` of `<=/2`:\n"
"\n"
"    iex> Enum.sort_by [\"some\", \"kind\", \"of\", \"monster\"], &byte_size/1\n"
"    [\"of\", \"some\", \"kind\", \"monster\"]\n"
"\n"
"Using a custom `sorter` to override the order:\n"
"\n"
"    iex> Enum.sort_by [\"some\", \"kind\", \"of\", \"monster\"], &byte_size/1, &>=/2\n"
"    [\"monster\", \"some\", \"kind\", \"of\"]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enumerable.member?(enumerable, element)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/enum.ex:118 
msgid ""
"Checks if an element exists within the enumerable.\n"
"\n"
"It should return `{:ok, boolean}`.\n"
"\n"
"If `{:error, __MODULE__}` is returned a default algorithm using\n"
"`reduce` and the match (`===`) operator is used. This algorithm runs\n"
"in linear time.\n"
"\n"
"_Please force use of the default algorithm unless you can implement an\n"
"algorithm that is significantly faster._\n"
msgstr ""
#. TRANSLATORS: def Enum.flat_map_reduce(enumerable, acc, fun)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/enum.ex:975 
msgid ""
"Maps and reduces an enumerable, flattening the given results (only one level deep).\n"
"\n"
"It expects an accumulator and a function that receives each enumerable\n"
"item, and must return a tuple containing a new enumerable (often a list)\n"
"with the new accumulator or a tuple with `:halt` as first element and\n"
"the accumulator as second.\n"
"\n"
"## Examples\n"
"\n"
"    iex> enum = 1..100\n"
"    iex> n = 3\n"
"    iex> Enum.flat_map_reduce(enum, 0, fn i, acc ->\n"
"    ...>   if acc < n, do: {[i], acc + 1}, else: {:halt, acc}\n"
"    ...> end)\n"
"    {[1, 2, 3], 3}\n"
"\n"
"    iex> Enum.flat_map_reduce(1..5, 0, fn(i, acc) -> {[[i]], acc + i} end)\n"
"    {[[1], [2], [3], [4], [5]], 15}\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.fetch!(enumerable, index)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/enum.ex:771 
msgid ""
"Finds the element at the given `index` (zero-based).\n"
"\n"
"Raises `OutOfBoundsError` if the given `index` is outside the range of\n"
"the enumerable.\n"
"\n"
"Note this operation takes linear time. In order to access the element\n"
"at index `index`, it will need to traverse `index` previous elements.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.fetch!([2, 4, 6], 0)\n"
"    2\n"
"\n"
"    iex> Enum.fetch!([2, 4, 6], 2)\n"
"    6\n"
"\n"
"    iex> Enum.fetch!([2, 4, 6], 4)\n"
"    ** (Enum.OutOfBoundsError) out of bounds error\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.zip(enumerables)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/enum.ex:2658 
msgid ""
"Zips corresponding elements from a collection of enumerables\n"
"into one list of tuples.\n"
"\n"
"The zipping finishes as soon as any enumerable completes.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.zip([[1, 2, 3], [:a, :b, :c], [\"foo\", \"bar\", \"baz\"]])\n"
"    [{1, :a, \"foo\"}, {2, :b, \"bar\"}, {3, :c, \"baz\"}]\n"
"\n"
"    iex> Enum.zip([[1, 2, 3, 4, 5], [:a, :b, :c]])\n"
"    [{1, :a}, {2, :b}, {3, :c}]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.each(enumerable, fun)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/enum.ex:630 
msgid ""
"Invokes the given `fun` for each item in the enumerable.\n"
"\n"
"Returns `:ok`.\n"
"\n"
"## Examples\n"
"\n"
"    Enum.each([\"some\", \"example\"], fn(x) -> IO.puts x end)\n"
"    \"some\"\n"
"    \"example\"\n"
"    #=> :ok\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.split_while(enumerable, fun)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/enum.ex:2252 
msgid ""
"Splits enumerable in two at the position of the element for which\n"
"`fun` returns `false` for the first time.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.split_while([1, 2, 3, 4], fn(x) -> x < 3 end)\n"
"    {[1, 2], [3, 4]}\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.zip(enumerable1, enumerable2)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/enum.ex:2633 
msgid ""
"Zips corresponding elements from two enumerables into one list\n"
"of tuples.\n"
"\n"
"The zipping finishes as soon as any enumerable completes.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.zip([1, 2, 3], [:a, :b, :c])\n"
"    [{1, :a}, {2, :b}, {3, :c}]\n"
"\n"
"    iex> Enum.zip([1, 2, 3, 4, 5], [:a, :b, :c])\n"
"    [{1, :a}, {2, :b}, {3, :c}]\n"
"\n"
msgstr ""
#. TRANSLATORS: Elixir.Enumerable Summary
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/enum.ex:2 
msgid ""
"Enumerable protocol used by `Enum` and `Stream` modules.\n"
"\n"
"When you invoke a function in the `Enum` module, the first argument\n"
"is usually a collection that must implement this protocol.\n"
"For example, the expression:\n"
"\n"
"    Enum.map([1, 2, 3], &(&1 * 2))\n"
"\n"
"invokes `Enumerable.reduce/3` to perform the reducing\n"
"operation that builds a mapped list by calling the mapping function\n"
"`&(&1 * 2)` on every element in the collection and consuming the\n"
"element with an accumulated list.\n"
"\n"
"Internally, `Enum.map/2` is implemented as follows:\n"
"\n"
"    def map(enum, fun) do\n"
"      reducer = fn x, acc -> {:cont, [fun.(x) | acc]} end\n"
"      Enumerable.reduce(enum, {:cont, []}, reducer) |> elem(1) |> :lists.reverse()\n"
"    end\n"
"\n"
"Notice the user-supplied function is wrapped into a `t:reducer/0` function.\n"
"The `t:reducer/0` function must return a tagged tuple after each step,\n"
"as described in the `t:acc/0` type.\n"
"\n"
"The reason the accumulator requires a tagged tuple is to allow the\n"
"`t:reducer/0` function to communicate the end of enumeration to the underlying\n"
"enumerable, allowing any open resources to be properly closed.\n"
"It also allows suspension of the enumeration, which is useful when\n"
"interleaving between many enumerables is required (as in zip).\n"
"\n"
"Finally, `Enumerable.reduce/3` will return another tagged tuple,\n"
"as represented by the `t:result/0` type.\n"
msgstr ""
#. TRANSLATORS: def Enum.find(enumerable, default \\ nil, fun)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/enum.ex:844 
msgid ""
"Returns the first item for which `fun` returns a truthy value.\n"
"If no such item is found, returns `default`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.find([2, 4, 6], fn(x) -> rem(x, 2) == 1 end)\n"
"    nil\n"
"\n"
"    iex> Enum.find([2, 4, 6], 0, fn(x) -> rem(x, 2) == 1 end)\n"
"    0\n"
"\n"
"    iex> Enum.find([2, 3, 4], fn(x) -> rem(x, 2) == 1 end)\n"
"    3\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.reduce_while(enumerable, acc, fun)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/enum.ex:1796 
msgid ""
"Reduces the enumerable until `fun` returns `{:halt, term}`.\n"
"\n"
"The return value for `fun` is expected to be\n"
"\n"
"  * `{:cont, acc}` to continue the reduction with `acc` as the new\n"
"    accumulator or\n"
"  * `{:halt, acc}` to halt the reduction and return `acc` as the return\n"
"    value of this function\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.reduce_while(1..100, 0, fn i, acc ->\n"
"    ...>   if i < 3, do: {:cont, acc + i}, else: {:halt, acc}\n"
"    ...> end)\n"
"    3\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.filter(enumerable, fun)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/enum.ex:800 
msgid ""
"Filters the enumerable, i.e. returns only those elements\n"
"for which `fun` returns a truthy value.\n"
"\n"
"See also `reject/2`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.filter([1, 2, 3], fn(x) -> rem(x, 2) == 0 end)\n"
"    [2]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.chunk_by(enumerable, fun)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/enum.ex:380 
msgid ""
"Splits enumerable on every element for which `fun` returns a new\n"
"value.\n"
"\n"
"Returns a list of lists.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.chunk_by([1, 2, 2, 3, 4, 4, 6, 7, 7], &(rem(&1, 2) == 1))\n"
"    [[1], [2, 2], [3], [4, 4, 6], [7, 7]]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.split_with(enumerable, fun)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/enum.ex:1591 
msgid ""
"Splits the `enumerable` in two lists according to the given function `fun`.\n"
"\n"
"Splits the given `enumerable` in two lists by calling `fun` with each element\n"
"in the `enumerable` as its only argument. Returns a tuple with the first list\n"
"containing all the elements in `enumerable` for which applying `fun` returned\n"
"a truthy value, and a second list with all the elements for which applying\n"
"`fun` returned a falsey value (`false` or `nil`).\n"
"\n"
"The elements in both the returned lists are in the same relative order as they\n"
"were in the original enumerable (if such enumerable was ordered, e.g., a\n"
"list); see the examples below.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.split_with([5, 4, 3, 2, 1, 0], fn(x) -> rem(x, 2) == 0 end)\n"
"    {[4, 2, 0], [5, 3, 1]}\n"
"\n"
"    iex> Enum.split_with(%{a: 1, b: -2, c: 1, d: -3}, fn({_k, v}) -> v < 0 end)\n"
"    {[b: -2, d: -3], [a: 1, c: 1]}\n"
"\n"
"    iex> Enum.split_with(%{a: 1, b: -2, c: 1, d: -3}, fn({_k, v}) -> v > 50 end)\n"
"    {[], [a: 1, b: -2, c: 1, d: -3]}\n"
"\n"
"    iex> Enum.split_with(%{}, fn({_k, v}) -> v > 50 end)\n"
"    {[], []}\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.drop_while(enumerable, fun)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/enum.ex:610 
msgid ""
"Drops items at the beginning of the enumerable while `fun` returns a\n"
"truthy value.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.drop_while([1, 2, 3, 2, 1], fn(x) -> x < 3 end)\n"
"    [3, 2, 1]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.find_value(enumerable, default \\ nil, fun)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/enum.ex:903 
msgid ""
"Similar to `find/3`, but returns the value of the function\n"
"invocation instead of the element itself.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.find_value([2, 4, 6], fn(x) -> rem(x, 2) == 1 end)\n"
"    nil\n"
"\n"
"    iex> Enum.find_value([2, 3, 4], fn(x) -> rem(x, 2) == 1 end)\n"
"    true\n"
"\n"
"    iex> Enum.find_value([1, 2, 3], \"no bools!\", &is_boolean/1)\n"
"    \"no bools!\"\n"
"\n"
msgstr ""
#. TRANSLATORS: @type reducer
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/enum.ex:55 
msgid ""
"The reducer function.\n"
"\n"
"Should be called with the enumerable element and the\n"
"accumulator contents.\n"
"\n"
"Returns the accumulator for the next enumeration step.\n"
msgstr ""
#. TRANSLATORS: @type continuation
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/enum.ex:84 
msgid ""
"A partially applied reduce function.\n"
"\n"
"The continuation is the closure returned as a result when\n"
"the enumeration is suspended. When invoked, it expects\n"
"a new accumulator and it returns the result.\n"
"\n"
"A continuation is easily implemented as long as the reduce\n"
"function is defined in a tail recursive fashion. If the function\n"
"is tail recursive, all the state is passed as arguments, so\n"
"the continuation would simply be the reducing function partially\n"
"applied.\n"
msgstr ""
#. TRANSLATORS: def Enum.into(enumerable, collectable)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/enum.ex:1083 
msgid ""
"Inserts the given `enumerable` into a `collectable`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.into([1, 2], [0])\n"
"    [0, 1, 2]\n"
"\n"
"    iex> Enum.into([a: 1, b: 2], %{})\n"
"    %{a: 1, b: 2}\n"
"\n"
"    iex> Enum.into(%{a: 1}, %{b: 2})\n"
"    %{a: 1, b: 2}\n"
"\n"
"    iex> Enum.into([a: 1, a: 2], %{})\n"
"    %{a: 2}\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.chunk(enumerable, count, step, leftover \\ nil)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/enum.ex:325 
msgid ""
"Returns list of lists containing `count` items each, where\n"
"each new chunk starts `step` elements into the enumerable.\n"
"\n"
"`step` is optional and, if not passed, defaults to `count`, i.e.\n"
"chunks do not overlap.\n"
"\n"
"If the final chunk does not have `count` elements to fill the chunk,\n"
"elements are taken as necessary from `leftover` if it was passed.\n"
"\n"
"If `leftover` is passed and does not have enough elements to fill the\n"
"chunk, then a partial chunk is returned with less than `count`\n"
"elements. If `leftover` is not passed at all or is `nil`, then the\n"
"partial chunk is discarded from the result.\n"
"\n"
"If `count` is greater than the number of elements in the enumerable\n"
"and `leftover` is not passed, empty list will be returned.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.chunk([1, 2, 3, 4, 5, 6], 2)\n"
"    [[1, 2], [3, 4], [5, 6]]\n"
"\n"
"    iex> Enum.chunk([1, 2, 3, 4, 5, 6], 3, 2)\n"
"    [[1, 2, 3], [3, 4, 5]]\n"
"\n"
"    iex> Enum.chunk([1, 2, 3, 4, 5, 6], 3, 2, [7])\n"
"    [[1, 2, 3], [3, 4, 5], [5, 6, 7]]\n"
"\n"
"    iex> Enum.chunk([1, 2, 3, 4], 3, 3, [])\n"
"    [[1, 2, 3], [4]]\n"
"\n"
"    iex> Enum.chunk([1, 2, 3, 4], 10)\n"
"    []\n"
"\n"
"    iex> Enum.chunk([1, 2, 3, 4], 10, 10, [])\n"
"    [[1, 2, 3, 4]]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.at(enumerable, index, default \\ nil)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/enum.ex:283 
msgid ""
"Finds the element at the given `index` (zero-based).\n"
"\n"
"Returns `default` if `index` is out of bounds.\n"
"\n"
"A negative `index` can be passed, which means the `enumerable` is\n"
"enumerated once and the `index` is counted from the end (e.g.\n"
"`-1` finds the last element).\n"
"\n"
"Note this operation takes linear time. In order to access\n"
"the element at index `index`, it will need to traverse `index`\n"
"previous elements.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.at([2, 4, 6], 0)\n"
"    2\n"
"\n"
"    iex> Enum.at([2, 4, 6], 2)\n"
"    6\n"
"\n"
"    iex> Enum.at([2, 4, 6], 4)\n"
"    nil\n"
"\n"
"    iex> Enum.at([2, 4, 6], 4, :none)\n"
"    :none\n"
"\n"
msgstr ""
#. TRANSLATORS: Elixir.Enum Summary
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/enum.ex:152 
msgid ""
"Provides a set of algorithms that enumerate over enumerables according\n"
"to the `Enumerable` protocol.\n"
"\n"
"    iex> Enum.map([1, 2, 3], fn(x) -> x * 2 end)\n"
"    [2, 4, 6]\n"
"\n"
"Some particular types, like maps, yield a specific format on enumeration.\n"
"For example, the argument is always a `{key, value}` tuple for maps:\n"
"\n"
"    iex> map = %{a: 1, b: 2}\n"
"    iex> Enum.map(map, fn {k, v} -> {k, v * 2} end)\n"
"    [a: 2, b: 4]\n"
"\n"
"Note that the functions in the `Enum` module are eager: they always\n"
"start the enumeration of the given enumerable. The `Stream` module\n"
"allows lazy enumeration of enumerables and provides infinite streams.\n"
"\n"
"Since the majority of the functions in `Enum` enumerate the whole\n"
"enumerable and return a list as result, infinite streams need to\n"
"be carefully used with such functions, as they can potentially run\n"
"forever. For example:\n"
"\n"
"    Enum.each Stream.cycle([1, 2, 3]), &IO.puts(&1)\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.any?(enumerable, fun \\ fn x -> x end)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/enum.ex:245 
msgid ""
"Returns true if the given `fun` evaluates to true on any of the items in the enumerable.\n"
"\n"
"It stops the iteration at the first invocation that returns a truthy value (not `false` or `nil`).\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.any?([2, 4, 6], fn(x) -> rem(x, 2) == 1 end)\n"
"    false\n"
"\n"
"    iex> Enum.any?([2, 3, 4], fn(x) -> rem(x, 2) == 1 end)\n"
"    true\n"
"\n"
"If no function is given, it defaults to checking if at least one item\n"
"in the enumerable is a truthy value.\n"
"\n"
"    iex> Enum.any?([false, false, false])\n"
"    false\n"
"\n"
"    iex> Enum.any?([false, true, false])\n"
"    true\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.reverse(enumerable, tail)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/enum.ex:1854 
msgid ""
"Reverses the elements in `enumerable`, appends the tail, and returns\n"
"it as a list.\n"
"\n"
"This is an optimization for\n"
"`Enum.concat(Enum.reverse(enumerable), tail)`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.reverse([1, 2, 3], [4, 5, 6])\n"
"    [3, 2, 1, 4, 5, 6]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.dedup_by(enumerable, fun)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/enum.ex:517 
msgid ""
"Enumerates the `enumerable`, returning a list where all consecutive\n"
"duplicated elements are collapsed to a single element.\n"
"\n"
"The function `fun` maps every element to a term which is used to\n"
"determine if two elements are duplicates.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.dedup_by([{1, :a}, {2, :b}, {2, :c}, {1, :a}], fn {x, _} -> x end)\n"
"    [{1, :a}, {2, :b}, {1, :a}]\n"
"\n"
"    iex> Enum.dedup_by([5, 1, 2, 3, 2, 1], fn x -> x > 2 end)\n"
"    [5, 1, 3, 2]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.group_by(enumerable, key_fun, value_fun \\ fn x -> x end)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/enum.ex:1018 
msgid ""
"Splits the enumerable into groups based on `key_fun`.\n"
"\n"
"The result is a map where each key is given by `key_fun` and each\n"
"value is a list of elements given by `value_fun`. Ordering is preserved.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.group_by(~w{ant buffalo cat dingo}, &String.length/1)\n"
"    %{3 => [\"ant\", \"cat\"], 7 => [\"buffalo\"], 5 => [\"dingo\"]}\n"
"\n"
"    iex> Enum.group_by(~w{ant buffalo cat dingo}, &String.length/1, &String.first/1)\n"
"    %{3 => [\"a\", \"c\"], 7 => [\"b\"], 5 => [\"d\"]}\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.min(enumerable, empty_fallback \\ fn -> raise(Enum.EmptyError) end)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/enum.ex:1433 
msgid ""
"Returns the minimal element in the enumerable according\n"
"to Erlang's term ordering.\n"
"\n"
"If multiple elements are considered minimal, the first one that was found\n"
"is returned.\n"
"\n"
"Calls the provided `empty_fallback` function and returns its value if\n"
"`enumerable` is empty. The default `empty_fallback` raises `Enum.EmptyError`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.min([1, 2, 3])\n"
"    1\n"
"\n"
"    iex> Enum.min([], fn -> 0 end)\n"
"    0\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.fetch(enumerable, index)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/enum.ex:687 
msgid ""
"Finds the element at the given `index` (zero-based).\n"
"\n"
"Returns `{:ok, element}` if found, otherwise `:error`.\n"
"\n"
"A negative `index` can be passed, which means the `enumerable` is\n"
"enumerated once and the `index` is counted from the end (e.g.\n"
"`-1` fetches the last element).\n"
"\n"
"Note this operation takes linear time. In order to access\n"
"the element at index `index`, it will need to traverse `index`\n"
"previous elements.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.fetch([2, 4, 6], 0)\n"
"    {:ok, 2}\n"
"\n"
"    iex> Enum.fetch([2, 4, 6], -3)\n"
"    {:ok, 2}\n"
"\n"
"    iex> Enum.fetch([2, 4, 6], 2)\n"
"    {:ok, 6}\n"
"\n"
"    iex> Enum.fetch([2, 4, 6], 4)\n"
"    :error\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.concat(left, right)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/enum.ex:422 
msgid ""
"Concatenates the enumerable on the right with the enumerable on the\n"
"left.\n"
"\n"
"This function produces the same result as the `Kernel.++/2` operator\n"
"for lists.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.concat(1..3, 4..6)\n"
"    [1, 2, 3, 4, 5, 6]\n"
"\n"
"    iex> Enum.concat([1, 2, 3], [4, 5, 6])\n"
"    [1, 2, 3, 4, 5, 6]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.drop_every(enumerable, nth)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/enum.ex:577 
msgid ""
"Returns a list of every `nth` item in the enumerable dropped,\n"
"starting with the first element.\n"
"\n"
"The first item is always dropped, unless `nth` is 0.\n"
"\n"
"The second argument specifying every `nth` item must be a non-negative\n"
"integer.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.drop_every(1..10, 2)\n"
"    [2, 4, 6, 8, 10]\n"
"\n"
"    iex> Enum.drop_every(1..10, 0)\n"
"    [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n"
"\n"
"    iex> Enum.drop_every([1, 2, 3], 1)\n"
"    []\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.map_every(enumerable, nth, fun)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/enum.ex:1236 
msgid ""
"Returns a list of results of invoking `fun` on every `nth`\n"
"item of `enumerable`, starting with the first element.\n"
"\n"
"The first item is always passed to the given function.\n"
"\n"
"The second argument specifying every `nth` item must be a non-negative\n"
"integer.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.map_every(1..10, 2, fn(x) -> x * 2 end)\n"
"    [2, 2, 6, 4, 10, 6, 14, 8, 18, 10]\n"
"\n"
"    iex> Enum.map_every(1..5, 0, fn(x) -> x * 2 end)\n"
"    [1, 2, 3, 4, 5]\n"
"\n"
"    iex> Enum.map_every([1, 2, 3], 1, fn(x) -> x * 2 end)\n"
"    [2, 4, 6]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.min_by(enumerable, fun, empty_fallback \\ fn -> raise(Enum.EmptyError) end)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/enum.ex:1459 
msgid ""
"Returns the minimal element in the enumerable as calculated\n"
"by the given function.\n"
"\n"
"If multiple elements are considered minimal, the first one that was found\n"
"is returned.\n"
"\n"
"Calls the provided `empty_fallback` function and returns its value if\n"
"`enumerable` is empty. The default `empty_fallback` raises `Enum.EmptyError`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.min_by([\"a\", \"aa\", \"aaa\"], fn(x) -> String.length(x) end)\n"
"    \"a\"\n"
"\n"
"    iex> Enum.min_by([\"a\", \"aa\", \"aaa\", \"b\", \"bbb\"], &String.length/1)\n"
"    \"a\"\n"
"\n"
"    iex> Enum.min_by([], &String.length/1, fn -> nil end)\n"
"    nil\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.to_list(enumerable)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/enum.ex:2513 
msgid ""
"Converts `enumerable` to a list.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.to_list(1..3)\n"
"    [1, 2, 3]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enumerable.reduce(enumerable, acc, fun)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/enum.ex:99 
msgid ""
"Reduces the enumerable into an element.\n"
"\n"
"Most of the operations in `Enum` are implemented in terms of reduce.\n"
"This function should apply the given `t:reducer/0` function to each\n"
"item in the enumerable and proceed as expected by the returned\n"
"accumulator.\n"
"\n"
"As an example, here is the implementation of `reduce` for lists:\n"
"\n"
"    def reduce(_,       {:halt, acc}, _fun),   do: {:halted, acc}\n"
"    def reduce(list,    {:suspend, acc}, fun), do: {:suspended, acc, &reduce(list, &1, fun)}\n"
"    def reduce([],      {:cont, acc}, _fun),   do: {:done, acc}\n"
"    def reduce([h | t], {:cont, acc}, fun),    do: reduce(t, fun.(h, acc), fun)\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.max(enumerable, empty_fallback \\ fn -> raise(Enum.EmptyError) end)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/enum.ex:1337 
msgid ""
"Returns the maximal element in the enumerable according\n"
"to Erlang's term ordering.\n"
"\n"
"If multiple elements are considered maximal, the first one that was found\n"
"is returned.\n"
"\n"
"Calls the provided `empty_fallback` function and returns its value if\n"
"`enumerable` is empty. The default `empty_fallback` raises `Enum.EmptyError`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.max([1, 2, 3])\n"
"    3\n"
"\n"
"    iex> Enum.max([], fn -> 0 end)\n"
"    0\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.map_reduce(enumerable, acc, fun)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/enum.ex:1304 
msgid ""
"Invokes the given function to each item in the enumerable to reduce\n"
"it to a single element, while keeping an accumulator.\n"
"\n"
"Returns a tuple where the first element is the mapped enumerable and\n"
"the second one is the final accumulator.\n"
"\n"
"The function, `fun`, receives two arguments: the first one is the\n"
"element, and the second one is the accumulator. `fun` must return\n"
"a tuple with two elements in the form of `{result, accumulator}`.\n"
"\n"
"For maps, the first tuple element must be a `{key, value}` tuple.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.map_reduce([1, 2, 3], 0, fn(x, acc) -> {x * 2, x + acc} end)\n"
"    {[2, 4, 6], 6}\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.reverse(enumerable)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/enum.ex:1840 
msgid ""
"Returns a list of elements in `enumerable` in reverse order.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.reverse([1, 2, 3])\n"
"    [3, 2, 1]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Enum.take_every(enumerable, nth)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/enum.ex:2381 
msgid ""
"Returns a list of every `nth` item in the enumerable,\n"
"starting with the first element.\n"
"\n"
"The first item is always included, unless `nth` is 0.\n"
"\n"
"The second argument specifying every `nth` item must be a non-negative\n"
"integer.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.take_every(1..10, 2)\n"
"    [1, 3, 5, 7, 9]\n"
"\n"
"    iex> Enum.take_every(1..10, 0)\n"
"    []\n"
"\n"
"    iex> Enum.take_every([1, 2, 3], 1)\n"
"    [1, 2, 3]\n"
"\n"
msgstr ""
