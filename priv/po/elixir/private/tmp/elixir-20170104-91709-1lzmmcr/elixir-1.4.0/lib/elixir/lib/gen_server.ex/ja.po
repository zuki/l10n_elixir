msgid ""
msgstr ""
"Project-Id-Version: l 10n_elixir\n"
"PO-Revision-Date: 2016-04-02 12:12+0900\n"
"Last-Translator: 小田 照敬 <EMAIL@ADDRESS>\n"
"Language-Team: Japanese\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#. TRANSLATORS: @callback format_status/2
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/gen_server.ex:488
msgid ""
"Invoked in some cases to retrieve a formatted version of the `GenServer` "
"status.\n"
"\n"
"This callback can be useful to control the *appearance* of the status of "
"the\n"
"`GenServer`. For example, it can be used to return a compact representation "
"of\n"
"the `GenServer`'s state to avoid having large state terms printed.\n"
"\n"
"  * one of `:sys.get_status/1` or `:sys.get_status/2` is invoked to get the\n"
"    status of the `GenServer`; in such cases, `reason` is `:normal`\n"
"\n"
"  * the `GenServer` terminates abnormally and logs an error; in such cases,\n"
"    `reason` is `:terminate`\n"
"\n"
"`pdict_and_state` is a two-elements list `[pdict, state]` where `pdict` is "
"a\n"
"list of `{key, value}` tuples representing the current process dictionary "
"of\n"
"the `GenServer` and `state` is the current state of the `GenServer`.\n"
msgstr ""

#. TRANSLATORS: @callback init/1
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/gen_server.ex:277
#, fuzzy
msgid ""
"Invoked when the server is started. `start_link/3` or `start/3` will\n"
"block until it returns.\n"
"\n"
"`args` is the argument term (second argument) passed to `start_link/3`.\n"
"\n"
"Returning `{:ok, state}` will cause `start_link/3` to return\n"
"`{:ok, pid}` and the process to enter its loop.\n"
"\n"
"Returning `{:ok, state, timeout}` is similar to `{:ok, state}`\n"
"except `handle_info(:timeout, state)` will be called after `timeout`\n"
"milliseconds if no messages are received within the timeout.\n"
"\n"
"Returning `{:ok, state, :hibernate}` is similar to\n"
"`{:ok, state}` except the process is hibernated before entering the loop. "
"See\n"
"`c:handle_call/3` for more information on hibernation.\n"
"\n"
"Returning `:ignore` will cause `start_link/3` to return `:ignore` and the\n"
"process will exit normally without entering the loop or calling `c:"
"terminate/2`.\n"
"If used when part of a supervision tree the parent supervisor will not fail\n"
"to start nor immediately try to restart the `GenServer`. The remainder of "
"the\n"
"supervision tree will be (re)started and so the `GenServer` should not be\n"
"required by other processes. It can be started later with\n"
"`Supervisor.restart_child/2` as the child specification is saved in the "
"parent\n"
"supervisor. The main use cases for this are:\n"
"\n"
"  * The `GenServer` is disabled by configuration but might be enabled "
"later.\n"
"  * An error occurred and it will be handled by a different mechanism than "
"the\n"
"   `Supervisor`. Likely this approach involves calling `Supervisor."
"restart_child/2`\n"
"    after a delay to attempt a restart.\n"
"\n"
"Returning `{:stop, reason}` will cause `start_link/3` to return\n"
"`{:error, reason}` and the process to exit with reason `reason` without\n"
"entering the loop or calling `c:terminate/2`.\n"
msgstr ""
"サーバがスタートするときに起動されます。\n"
"`start_link/3`(または`start/3`)は、この関数から戻るまで\n"
"ブロックされます。\n"
"\n"
"`args` は `start_link/3`へ渡される(2番目の)引数です。\n"
"\n"
"`{:ok, state}`を返すと、`start_link/3`が`{:ok, pid}` を返し、\n"
"プロセスはループに入ります。\n"
"\n"
"`{:ok, state, timeout}`は、\n"
"もしタイムアウト内にメッセージが受信されないと、\n"
"`timeout`ミリ秒後に`handle_info(:timeout, state)`が呼ばれる\n"
"ことを除いて、\n"
"`{:ok, state}`と似ています。\n"
"\n"
"`{:ok, state, :hibernate}`は\n"
"`プロセスがループに入るまえに hibernateされる\n"
"ことを除いては、`{:ok, state}`と似ています。\n"
"hibernationについては`handle_call/3`を参照してください。\n"
"\n"
"`:ignore`を返すと、`start_link/3`が`:ignore`を返し、\n"
"プロセスはループに入らず通常のexitをし\n"
"`terminate/2`を呼ぶこともありません。\n"
"もし、supervisionツリーの一部の時、親のスーパバイザは\n"
"スタートもできないし、すぐに`GenServer`のリスタートも試みないでしょう。\n"
"supervisionツリーの残りは(再)スタートされます。そして、\n"
"`GenServer`は最早他のプロセスには必要とされるべきではありません。\n"
"child仕様が親のスーパバイザで保存され、\n"
"後で`Supervisor.restart_child/2`でスタートすることが出来ます。\n"
"主なユースケースはこんな感じです:\n"
"\n"
"  * `GenServer` はコンフィグレーションにより無効ですが、\n"
"    あとで有効にされるとき\n"
"  * エラーが発生し、`Supervisor`とは異るメカニズムによりハンドル\n"
"    したいとき。このアプローチはリスタートを試みるために後で\n"
"    `Supervisor.restart_child/2`の呼出しを含みます。\n"
"\n"
"`{:stop, reason}`を返すことは、`start_link/3`が`{:error, reason}`を\n"
"返し、`terminate/2`も呼ばす、ループにも入らず、reason `reason`で\n"
"プロセスを`exit`させることになります。\n"

#. TRANSLATORS: @type server
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/gen_server.ex:528
msgid "The server reference"
msgstr "サーバのリファレンス"

#. TRANSLATORS: @callback handle_info/2
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/gen_server.ex:411
#, fuzzy
msgid ""
"Invoked to handle all other messages.\n"
"\n"
"`msg` is the message and `state` is the current state of the `GenServer`. "
"When\n"
"a timeout occurs the message is `:timeout`.\n"
"\n"
"Return values are the same as `c:handle_cast/2`.\n"
"\n"
"If this callback is not implemented, the default implementation by\n"
"`use GenServer` will return `{:noreply, state}`.\n"
msgstr ""
"他の全てのメッセージをハンドルするために起動されます。\n"
"\n"
"`msg`はメッセージで、`state`は`GenServer`の現在のステートです。\n"
"タイムアウトが起きたとき、メッセージは`:timeout`です。\n"
"\n"
"戻値は、`handle_cast/2`と同じです。\n"
"\n"
"もしこのコールバックが実装されていないなら、`use GenServer`に\n"
"よるデフォルト実装が`{:noreply, state}`を返します。\n"

#. TRANSLATORS: @type name
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/gen_server.ex:513
msgid "The GenServer name"
msgstr "GenServerの名前"

#. TRANSLATORS: def GenServer.reply(client, reply)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/gen_server.ex:850
#, fuzzy
msgid ""
"Replies to a client.\n"
"\n"
"This function can be used to explicitly send a reply to a client that "
"called\n"
"`call/3` or `multi_call/4` when the reply cannot be specified in the return\n"
"value of `c:handle_call/3`.\n"
"\n"
"`client` must be the `from` argument (the second argument) accepted by\n"
"`c:handle_call/3` callbacks. `reply` is an arbitrary term which will be "
"given\n"
"back to the client as the return value of the call.\n"
"\n"
"Note that `reply/2` can be called from any process, not just the GenServer\n"
"that originally received the call (as long as that GenServer communicated "
"the\n"
"`from` argument somehow).\n"
"\n"
"This function always returns `:ok`.\n"
"\n"
"## Examples\n"
"\n"
"    def handle_call(:reply_in_one_second, from, state) do\n"
"      Process.send_after(self(), {:reply, from}, 1_000)\n"
"      {:noreply, state}\n"
"    end\n"
"\n"
"    def handle_info({:reply, from}, state) do\n"
"      GenServer.reply(from, :one_second_has_passed)\n"
"      {:noreply, state}\n"
"    end\n"
"\n"
msgstr ""
"clientへ応答します。\n"
"\n"
"この関数は、`call/3`または`multi_call/4`を呼び出したクライアントに、\n"
"明示的に応答を送信するために、サーバによって使われることがあります。\n"
"応答が`handle_call/3`の戻値で定義されることが出来無い時。\n"
"\n"
"`client`は、`handle_call/3`コールバックで受信した、(2番目の引数の)\n"
"`from`引数でなくてはなりません。\n"
"`reply`は、呼び出しの戻値としてクライアントに返される、任意のtermです。\n"
"\n"
"この関数は常に`:ok`を返します。\n"

#. TRANSLATORS: def GenServer.start_link(module, args, options \\ [])
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/gen_server.ex:606
#, fuzzy
msgid ""
"Starts a `GenServer` process linked to the current process.\n"
"\n"
"This is often used to start the `GenServer` as part of a supervision tree.\n"
"\n"
"Once the server is started, the `c:init/1` function of the given `module` "
"is\n"
"called with `args` as its arguments to initialize the server. To ensure a\n"
"synchronized start-up procedure, this function does not return until `c:"
"init/1`\n"
"has returned.\n"
"\n"
"Note that a `GenServer` started with `start_link/3` is linked to the\n"
"parent process and will exit in case of crashes from the parent. The "
"GenServer\n"
"will also exit due to the `:normal` reasons in case it is configured to "
"trap\n"
"exits in the `c:init/1` callback.\n"
"\n"
"## Options\n"
"\n"
"  * `:name` - used for name registration as described in the \"Name\n"
"    registration\" section of the module documentation\n"
"\n"
"  * `:timeout` - if present, the server is allowed to spend the given amount "
"of\n"
"    milliseconds initializing or it will be terminated and the start "
"function\n"
"    will return `{:error, :timeout}`\n"
"\n"
"  * `:debug` - if present, the corresponding function in the [`:sys`\n"
"    module](http://www.erlang.org/doc/man/sys.html) is invoked\n"
"\n"
"  * `:spawn_opt` - if present, its value is passed as options to the\n"
"    underlying process as in `Process.spawn/4`\n"
"\n"
"## Return values\n"
"\n"
"If the server is successfully created and initialized, this function "
"returns\n"
"`{:ok, pid}`, where `pid` is the PID of the server. If a process with the\n"
"specified server name already exists, this function returns\n"
"`{:error, {:already_started, pid}}` with the PID of that process.\n"
"\n"
"If the `c:init/1` callback fails with `reason`, this function returns\n"
"`{:error, reason}`. Otherwise, if it returns `{:stop, reason}`\n"
"or `:ignore`, the process is terminated and this function returns\n"
"`{:error, reason}` or `:ignore`, respectively.\n"
msgstr ""
"現在のプロセスにリンクされた`GenServer`プロセスを開始します。\n"
"\n"
"これは、しばしば監督ツリーの一部として、`GenServer`を開始するために\n"
"使われます。\n"
"\n"
"一旦サーバが開始したら、与えられたモジュールの`init/1`関数を与えらえた\n"
"引数を伴って初期化の為に呼び出します。スタートアップ手続の同期を\n"
"確実にするために、この関数は`init/1`が帰って来るまで、制御を戻しません。\n"
"\n"
"`start_link/3`で開始した`GenServer`は親プロセスにリンクされていて、\n"
"親プロセスがクラッシュした場合、終了することに注意してください。\n"
"`init/1`コールバックでexitをトラップするように構成されている場合もまた、\n"
"GenServerは`:normal` reasonで終了します。\n"
"\n"
"## オプション\n"
"\n"
"`:name`オプションはモジュールドキュメントで記載されているように、登録の\n"
"為に使われます。`:timeout`オプションがあると、エージェントは、最大初期\n"
"値として与えられたミリセカンド秒間起動に時間をかけることを許可します。\n"
"あるいは、エージェントの起動は終了させられて、スタート関数は`{:error,\n"
":timeout}`を返します。\n"
"\n"
"`:debug`オプションがあると、[`:sys` モジュー\n"
"ル](http://www.erlang.org/doc/man/sys.html) で対応する関数が起動されま\n"
"す。\n"
"\n"
"`:spawn_opt`があると、その値は`Process.spawn/4`のように根底にある\n"
"プロセスまでオプションとして渡されます。\n"
"\n"
"## 戻値\n"
"\n"
"もしサーバがうまく作成されて、初期化されたら、関数は、pidをサーバのプロ\n"
"セス識別子として`{:ok, pid}`を返します。もし与えられたサーバ名でプロセス\n"
"が既に存在したら、そのプロセスのプロセス識別子をpidとして、関数は\n"
"`{:error, {:already_started, pid}}`を返します。\n"
"\n"
"もし`init/1`コールバックが`reason`で失敗したら、関数は関数は`{:error,\n"
"reason}`を返します。もしくは、`init/1`が`{:stop, reason}`か`:ignore`を\n"
"返したら、プロセスは終了され、関数は`{:error, reason}`か`:ignore`をそれ\n"
"ぞれ返します。\n"

#. TRANSLATORS: @type from
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/gen_server.ex:531
#, fuzzy
msgid ""
"Tuple describing the client of a call request.\n"
"\n"
"`pid` is the PID of the caller and `tag` is a unique term used to identify "
"the\n"
"call.\n"
msgstr ""
"呼出しリクエストのクライアントを記述するタプルです。\n"
"\n"
"`pid`は呼出し側のpidで、`tag`は呼出しのIDとして使われる\n"
"ユニークなtermです。\n"

#. TRANSLATORS: @type on_start
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/gen_server.ex:510
msgid "Return values of `start*` functions"
msgstr "`start*`関数の戻値"

#. TRANSLATORS: def GenServer.start(module, args, options \\ [])
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/gen_server.ex:653
msgid ""
"Starts a `GenServer` process without links (outside of a supervision tree).\n"
"\n"
"See `start_link/3` for more information.\n"
msgstr ""
"リンクなし(監督ツリーの外側)で`GenServer`プロセスを開始します。\n"
"\n"
"詳細は`start_link/3`を参照してください。\n"

#. TRANSLATORS: def GenServer.stop(server, reason \\ :normal, timeout \\ :infinity)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/gen_server.ex:687
#, fuzzy
msgid ""
"Stops the server with the given `reason`.\n"
"\n"
"The `c:terminate/2` callback of the given `server` will be invoked before\n"
"exiting. This function returns `:ok` if the server terminates with the\n"
"given reason; if it terminates with another reason, the call exits.\n"
"\n"
"This function keeps OTP semantics regarding error reporting.\n"
"If the reason is any other than `:normal`, `:shutdown` or\n"
"`{:shutdown, _}`, an error report is logged.\n"
msgstr ""
"与えられた`reason`でサーバを停止します。\n"
"\n"
"exitする前に`terminate/2`コールバックが呼び出されます。\n"
"サーバが与えられたreasonで終了したら`:ok`が返ります。\n"
"他のreasonで終了したら、exitを呼出します。\n"
"\n"
"この関数はエラーレポートに関するOTPセマンティクスを遵守します。\n"
"もし`:normal`, `:shutdown`あるいは`{:shutdown, _}`以外の\n"
"reasonならエラーレポートがログされるでしょう。\n"

#. TRANSLATORS: def GenServer.abcast(nodes \\ [node() | Node.list()], name, request)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/gen_server.ex:787
#, fuzzy
msgid ""
"Casts all servers locally registered as `name` at the specified nodes.\n"
"\n"
"This function returns immediately and ignores nodes that do not exist, or "
"where the\n"
"server name does not exist.\n"
"\n"
"See `multi_call/4` for more information.\n"
msgstr ""
"指定されたノードに`name`としてローカルに登録された、全てのサーバに\n"
"キャストします。\n"
"\n"
"関数は直ちに戻り、存在しないノード、存在しない\n"
"サーバ名が存在しないノードを無視します。\n"
"\n"
"詳細は、 `multi_call/4` を参照してください。\n"

#. TRANSLATORS: @callback handle_cast/2
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/gen_server.ex:383
#, fuzzy
msgid ""
"Invoked to handle asynchronous `cast/2` messages.\n"
"\n"
"`request` is the request message sent by a `cast/2` and `state` is the "
"current\n"
"state of the `GenServer`.\n"
"\n"
"Returning `{:noreply, new_state}` continues the loop with new state "
"`new_state`.\n"
"\n"
"Returning `{:noreply, new_state, timeout}` is similar to\n"
"`{:noreply, new_state}` except `handle_info(:timeout, new_state)` will be\n"
"called after `timeout` milliseconds if no messages are received.\n"
"\n"
"Returning `{:noreply, new_state, :hibernate}` is similar to\n"
"`{:noreply, new_state}` except the process is hibernated before continuing "
"the\n"
"loop. See `c:handle_call/3` for more information.\n"
"\n"
"Returning `{:stop, reason, new_state}` stops the loop and `c:terminate/2` "
"is\n"
"called with the reason `reason` and state `new_state`. The process exits "
"with\n"
"reason `reason`.\n"
"\n"
"If this callback is not implemented, the default implementation by\n"
"`use GenServer` will return `{:stop, {:bad_cast, request}, state}`.\n"
msgstr ""
"非同期`cast/2`メッセージをハンドルするために起動されます。\n"
"\n"
"`request` は `cast/2`により送信された要求メッセージで、\n"
"`state`は`GenServer`の現在のステートです。\n"
"\n"
"`{:noreply, new_state}`を返すことは\n"
"新しい`new_state`ステートでループを継続\n"
"します。\n"
"\n"
"`{:noreply, new_state, timeout}`を返すことは、\n"
"`timeout`ミリ秒後にメッセージが届かなかったら、\n"
"`handle_info(:timeout, new_state)`が呼ばれることを除いて、\n"
"`{:noreply, new_state}`と似ています。\n"
"\n"
"`{:noreply, new_state, :hibernate}`を返すことは、\n"
"プロセスがループを継続するまえにhibernateされることを\n"
"除いて、`{:noreply, new_state}`と似ています。\n"
"詳細は`handle_call/3`を参照してください。\n"
"\n"
"`{:stop, reason, new_staet}`を返すことは、ループを停止して、\n"
"reason `reason`とstate `new_state`で`terminate/2`が呼ばれます。\n"
"プロセスはreason `reason`でexitします。\n"
"\n"
"もしこのコールバックが実装されていないなら、`use GenServer`による\n"
"デフォルト実装が`{:stop, {:bad_cast, request}, state}`を\n"
"返します。\n"

#. TRANSLATORS: @callback handle_call/3
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/gen_server.ex:318
#, fuzzy
msgid ""
"Invoked to handle synchronous `call/3` messages. `call/3` will block until "
"a\n"
"reply is received (unless the call times out or nodes are disconnected).\n"
"\n"
"`request` is the request message sent by a `call/3`, `from` is a 2-tuple\n"
"containing the caller's PID and a term that uniquely identifies the call, "
"and\n"
"`state` is the current state of the `GenServer`.\n"
"\n"
"Returning `{:reply, reply, new_state}` sends the response `reply` to the\n"
"caller and continues the loop with new state `new_state`.\n"
"\n"
"Returning `{:reply, reply, new_state, timeout}` is similar to\n"
"`{:reply, reply, new_state}` except `handle_info(:timeout, new_state)` will "
"be\n"
"called after `timeout` milliseconds if no messages are received.\n"
"\n"
"Returning `{:reply, reply, new_state, :hibernate}` is similar to\n"
"`{:reply, reply, new_state}` except the process is hibernated and will\n"
"continue the loop once a message is in its message queue. If a message is\n"
"already in the message queue this will be immediately. Hibernating a\n"
"`GenServer` causes garbage collection and leaves a continuous heap that\n"
"minimises the memory used by the process.\n"
"\n"
"Hibernating should not be used aggressively as too much time could be spent\n"
"garbage collecting. Normally it should only be used when a message is not\n"
"expected soon and minimising the memory of the process is shown to be\n"
"beneficial.\n"
"\n"
"Returning `{:noreply, new_state}` does not send a response to the caller "
"and\n"
"continues the loop with new state `new_state`. The response must be sent "
"with\n"
"`reply/2`.\n"
"\n"
"There are three main use cases for not replying using the return value:\n"
"\n"
"  * To reply before returning from the callback because the response is "
"known\n"
"    before calling a slow function.\n"
"  * To reply after returning from the callback because the response is not "
"yet\n"
"    available.\n"
"  * To reply from another process, such as a task.\n"
"\n"
"When replying from another process the `GenServer` should exit if the other\n"
"process exits without replying as the caller will be blocking awaiting a\n"
"reply.\n"
"\n"
"Returning `{:noreply, new_state, timeout | :hibernate}` is similar to\n"
"`{:noreply, new_state}` except a timeout or hibernation occurs as with a\n"
"`:reply` tuple.\n"
"\n"
"Returning `{:stop, reason, reply, new_state}` stops the loop and `c:"
"terminate/2`\n"
"is called with reason `reason` and state `new_state`. Then the `reply` is "
"sent\n"
"as the response to call and the process exits with reason `reason`.\n"
"\n"
"Returning `{:stop, reason, new_state}` is similar to\n"
"`{:stop, reason, reply, new_state}` except a reply is not sent.\n"
"\n"
"If this callback is not implemented, the default implementation by\n"
"`use GenServer` will return `{:stop, {:bad_call, request}, state}`.\n"
msgstr ""
"同期`call/3`メッセージをハンドルするために起動されます。\n"
"`call/3`は応答を受信するまでブロックします(呼出しタイムアウトか\n"
"ノードが切断されないかぎり)。\n"
"\n"
"`request`は`call/3`により送信されたリクエストメッセージで、\n"
"`from`は呼出し側のpidと呼出しを識別するユニークなtermを含む\n"
"2要素のタプルで、`state`は`GenServer`の現在のステートです。\n"
"\n"
"`{:reply, reply, new_state}`を返すと、\n"
"`reply`応答を呼出し側へ送信し、新しい`new_state`ステートでループ\n"
"を継続します。\n"
"\n"
"`{:reply, reply, new_state, timeout}`を返すことは、\n"
"`timeout`ミリ秒後にメッセージが届かなかったら、\n"
"`handle_info(:timeout, new_state)`が呼ばれることを\n"
"除いて、`{:reply, reply, new_state}`と似ています。\n"
"\n"
"`{:reply, reply, new_state, :hibernate}`を返すことは、\n"
"プロセスがhibernateされ、メッセージがメッセージキューに\n"
"来たらループを継続することを\n"
"除いて、`{:reply, reply, new_state}`と似ています。\n"
"もしメッセージが既にメッセージキューに到着していたら、\n"
"これは直ちになされます。`GenServer`をhibernateすることは、\n"
"ガーベッジコレクションを引き起し、プロセスによるメモリ\n"
"利用を最小化しヒープを連続化します。\n"
"\n"
"hibernateはガーベッジコレクションが時間を費しすぎることもあるので、\n"
"積極的に使うべきではありません。通常、メッセージをすぐに\n"
"受信しないことがわかっているときだけに使うべきです。そうすることで、\n"
"プロセスのメモリ利用量を最小化する利点がわかるようになります。\n"
"\n"
"`{:noreply, new_state}`は呼出し側へ応答を送信せず、新しい`new_state`\n"
"ステートでループを継続します。応答は`reply/2`で送信されなければなりません。\n"
"\n"
"戻値として:no_replyを使う主な3つのユースケースは以下の通りです:\n"
"\n"
"  * 遲いことがわかっている関数を呼び出すので、コールバックから\n"
"    戻る前に応答を返す\n"
"  * responseがまだ有効でないため、コールバックから戻った後に応答を返す\n"
"  * タスクのような他のプロセスから応答を返す\n"
"\n"
"他のプロセスから応答を返すとき、もし他のプロセスが\n"
"応答せずにexitするなら、呼出し側は応答を待ってブロッキングしつづけ\n"
"るので、`GenServer`はexitするべきです。\n"
"\n"
"`{:noreply, new_state, timeout | :hibernate}` は、\n"
"`:reply`タプルでのタイムアウトかhibernateが起ることを\n"
"除いて、`{:noreply, new_state}` に似ています。\n"
"\n"
"`{:stop, reason, reply, new_state}`を返すことはループを停止して\n"
"reason `reason`、ステート`new_state`で`terminate/2`が呼び出されます。\n"
"それから、呼出し側`reply`は応答として送信され、プロセスは\n"
"reason `reason`でexitします。\n"
"\n"
"`{:stop, reason, new_state}` を返すことはreplyを送信\n"
"しないことを除いて、\n"
"`{:stop, reason, reply, new_state}`を返すことに似ています。\n"
"\n"
"もしこのコールバックが実装されていないなら、`use GenServer`による\n"
"デフォルト実装が`{:stop, {:bad_call, request}, state}`を\n"
"返します。\n"

#. TRANSLATORS: @type option
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/gen_server.ex:519
msgid "Option values used by the `start*` functions"
msgstr "`start*`関数により使用されるオプション"

#. TRANSLATORS: Elixir.GenServer Summary
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/gen_server.ex:2
#, fuzzy
msgid ""
"A behaviour module for implementing the server of a client-server relation.\n"
"\n"
"A GenServer is a process like any other Elixir process and it can be used\n"
"to keep state, execute code asynchronously and so on. The advantage of "
"using\n"
"a generic server process (GenServer) implemented using this module is that "
"it\n"
"will have a standard set of interface functions and include functionality "
"for\n"
"tracing and error reporting. It will also fit into a supervision tree.\n"
"\n"
"## Example\n"
"\n"
"The GenServer behaviour abstracts the common client-server interaction.\n"
"Developers are only required to implement the callbacks and functionality "
"they are\n"
"interested in.\n"
"\n"
"Let's start with a code example and then explore the available callbacks.\n"
"Imagine we want a GenServer that works like a stack, allowing us to push\n"
"and pop items:\n"
"\n"
"    defmodule Stack do\n"
"      use GenServer\n"
"\n"
"      # Callbacks\n"
"\n"
"      def handle_call(:pop, _from, [h | t]) do\n"
"        {:reply, h, t}\n"
"      end\n"
"\n"
"      def handle_cast({:push, item}, state) do\n"
"        {:noreply, [item | state]}\n"
"      end\n"
"    end\n"
"\n"
"    # Start the server\n"
"    {:ok, pid} = GenServer.start_link(Stack, [:hello])\n"
"\n"
"    # This is the client\n"
"    GenServer.call(pid, :pop)\n"
"    #=> :hello\n"
"\n"
"    GenServer.cast(pid, {:push, :world})\n"
"    #=> :ok\n"
"\n"
"    GenServer.call(pid, :pop)\n"
"    #=> :world\n"
"\n"
"We start our `Stack` by calling `start_link/3`, passing the module\n"
"with the server implementation and its initial argument (a list\n"
"representing the stack containing the item `:hello`). We can primarily\n"
"interact with the server by sending two types of messages. **call**\n"
"messages expect a reply from the server (and are therefore synchronous)\n"
"while **cast** messages do not.\n"
"\n"
"Every time you do a `GenServer.call/3`, the client will send a message\n"
"that must be handled by the `c:handle_call/3` callback in the GenServer.\n"
"A `cast/2` message must be handled by `c:handle_cast/2`.\n"
"\n"
"## Callbacks\n"
"\n"
"There are 6 callbacks required to be implemented in a `GenServer`. By\n"
"adding `use GenServer` to your module, Elixir will automatically define\n"
"all 6 callbacks for you, leaving it up to you to implement the ones\n"
"you want to customize.\n"
"\n"
"## Name Registration\n"
"\n"
"Both `start_link/3` and `start/3` support the `GenServer` to register\n"
"a name on start via the `:name` option. Registered names are also\n"
"automatically cleaned up on termination. The supported values are:\n"
"\n"
"  * an atom - the GenServer is registered locally with the given name\n"
"    using `Process.register/2`.\n"
"\n"
"  * `{:global, term}`- the GenServer is registered globally with the given\n"
"    term using the functions in the `:global` module.\n"
"\n"
"  * `{:via, module, term}` - the GenServer is registered with the given\n"
"    mechanism and name. The `:via` option expects a module that exports\n"
"    `register_name/2`, `unregister_name/1`, `whereis_name/1` and `send/2`.\n"
"    One such example is the `:global` module which uses these functions\n"
"    for keeping the list of names of processes and their associated PIDs\n"
"    that are available globally for a network of Elixir nodes. Elixir also\n"
"    ships with a local, decentralized and scalable registry called "
"`Registry`\n"
"    for locally storing names that are generated dynamically.\n"
"\n"
"For example, we could start and register our `Stack` server locally as "
"follows:\n"
"\n"
"    # Start the server and register it locally with name MyStack\n"
"    {:ok, _} = GenServer.start_link(Stack, [:hello], name: MyStack)\n"
"\n"
"    # Now messages can be sent directly to MyStack\n"
"    GenServer.call(MyStack, :pop) #=> :hello\n"
"\n"
"Once the server is started, the remaining functions in this module "
"(`call/3`,\n"
"`cast/2`, and friends) will also accept an atom, or any `:global` or `:via`\n"
"tuples. In general, the following formats are supported:\n"
"\n"
"  * a `pid`\n"
"  * an `atom` if the server is locally registered\n"
"  * `{atom, node}` if the server is locally registered at another node\n"
"  * `{:global, term}` if the server is globally registered\n"
"  * `{:via, module, name}` if the server is registered through an "
"alternative\n"
"    registry\n"
"\n"
"If there is an interest to register dynamic names locally, do not use\n"
"atoms, as atoms are never garbage collected and therefore dynamically\n"
"generated atoms won't be garbage collected. For such cases, you can\n"
"set up your own local registry by using the `Registry` module.\n"
"\n"
"## Client / Server APIs\n"
"\n"
"Although in the example above we have used `GenServer.start_link/3` and\n"
"friends to directly start and communicate with the server, most of the\n"
"time we don't call the `GenServer` functions directly. Instead, we wrap\n"
"the calls in new functions representing the public API of the server.\n"
"\n"
"Here is a better implementation of our Stack module:\n"
"\n"
"    defmodule Stack do\n"
"      use GenServer\n"
"\n"
"      # Client\n"
"\n"
"      def start_link(default) do\n"
"        GenServer.start_link(__MODULE__, default)\n"
"      end\n"
"\n"
"      def push(pid, item) do\n"
"        GenServer.cast(pid, {:push, item})\n"
"      end\n"
"\n"
"      def pop(pid) do\n"
"        GenServer.call(pid, :pop)\n"
"      end\n"
"\n"
"      # Server (callbacks)\n"
"\n"
"      def handle_call(:pop, _from, [h | t]) do\n"
"        {:reply, h, t}\n"
"      end\n"
"\n"
"      def handle_call(request, from, state) do\n"
"        # Call the default implementation from GenServer\n"
"        super(request, from, state)\n"
"      end\n"
"\n"
"      def handle_cast({:push, item}, state) do\n"
"        {:noreply, [item | state]}\n"
"      end\n"
"\n"
"      def handle_cast(request, state) do\n"
"        super(request, state)\n"
"      end\n"
"    end\n"
"\n"
"In practice, it is common to have both server and client functions in\n"
"the same module. If the server and/or client implementations are growing\n"
"complex, you may want to have them in different modules.\n"
"\n"
"## Receiving \"regular\" messages\n"
"\n"
"The goal of a `GenServer` is to abstract the \"receive\" loop for "
"developers,\n"
"automatically handling system messages, support code change, synchronous\n"
"calls and more. Therefore, you should never call your own \"receive\" "
"inside\n"
"the GenServer callbacks as doing so will cause the GenServer to misbehave.\n"
"\n"
"Besides the synchronous and asynchronous communication provided by `call/3`\n"
"and `cast/2`, \"regular\" messages sent by functions such `Kernel.send/2`,\n"
"`Process.send_after/4` and similar, can be handled inside the `c:"
"handle_info/2`\n"
"callback.\n"
"\n"
"`c:handle_info/2` can be used in many situations, such as handling monitor\n"
"DOWN messages sent by `Process.monitor/1`. Another use case for `c:"
"handle_info/2`\n"
"is to perform periodic work, with the help of `Process.send_after/4`:\n"
"\n"
"    defmodule MyApp.Periodically do\n"
"      use GenServer\n"
"\n"
"      def start_link do\n"
"        GenServer.start_link(__MODULE__, %{})\n"
"      end\n"
"\n"
"      def init(state) do\n"
"        schedule_work() # Schedule work to be performed on start\n"
"        {:ok, state}\n"
"      end\n"
"\n"
"      def handle_info(:work, state) do\n"
"        # Do the desired work here\n"
"        schedule_work() # Reschedule once more\n"
"        {:noreply, state}\n"
"      end\n"
"\n"
"      defp schedule_work() do\n"
"        Process.send_after(self(), :work, 2 * 60 * 60 * 1000) # In 2 hours\n"
"      end\n"
"    end\n"
"\n"
"## Debugging with the :sys module\n"
"\n"
"GenServers, as [special processes](http://erlang.org/doc/design_principles/"
"spec_proc.html),\n"
"can be debugged using the `:sys` module. Through various hooks, this module\n"
"allows developers to introspect the state of the process and trace\n"
"system events that happen during its execution, such as received messages,\n"
"sent replies and state changes.\n"
"\n"
"Let's explore the basic functions from the `:sys` module used for "
"debugging:\n"
"\n"
"  * [`:sys.get_state/2`](http://erlang.org/doc/man/sys.html#get_state-2) -\n"
"    allows retrieval of the state of the process. In the case of\n"
"    a GenServer process, it will be the callback module state, as\n"
"    passed into the callback functions as last argument.\n"
"  * [`:sys.get_status/2`](http://erlang.org/doc/man/sys.html#get_status-2) "
"-\n"
"    allows retrieval of the status of the process. This status includes\n"
"    the process dictionary, if the process is running or is suspended,\n"
"    the parent PID, the debugger state, and the state of the behaviour "
"module,\n"
"    which includes the callback module state (as returned by `:sys."
"get_state/2`).\n"
"    It's possible to change how this status is represented by defining\n"
"    the optional `c:GenServer.format_status/2` callback.\n"
"  * [`:sys.trace/3`](http://erlang.org/doc/man/sys.html#trace-3) -\n"
"    prints all the system events to `:stdio`.\n"
"  * [`:sys.statistics/3`](http://erlang.org/doc/man/sys.html#statistics-3) "
"-\n"
"    manages collection of process statistics.\n"
"  * [`:sys.no_debug/2`](http://erlang.org/doc/man/sys.html#no_debug-2) -\n"
"    turns off all debug handlers for the given process. It is very "
"important\n"
"    to switch off debugging once we're done. Excessive debug handlers or\n"
"    those that should be turned off, but weren't, can seriously damage\n"
"    the performance of the system.\n"
"\n"
"Let's see how we could use those functions for debugging the stack server\n"
"we defined earlier.\n"
"\n"
"    iex> {:ok, pid} = Stack.start_link([])\n"
"    iex> :sys.statistics(pid, true) # turn on collecting process statistics\n"
"    iex> :sys.trace(pid, true) # turn on event printing\n"
"    iex> Stack.push(pid, 1)\n"
"    *DBG* <0.122.0> got cast {push,1}\n"
"    *DBG* <0.122.0> new state [1]\n"
"    :ok\n"
"    iex> :sys.get_state(pid)\n"
"    [1]\n"
"    iex> Stack.pop(pid)\n"
"    *DBG* <0.122.0> got call pop from <0.80.0>\n"
"    *DBG* <0.122.0> sent 1 to <0.80.0>, new state []\n"
"    1\n"
"    iex> :sys.statistics(pid, :get)\n"
"    {:ok,\n"
"     [start_time: {{2016, 7, 16}, {12, 29, 41}},\n"
"      current_time: {{2016, 7, 16}, {12, 29, 50}},\n"
"      reductions: 117, messages_in: 2, messages_out: 0]}\n"
"    iex> :sys.no_debug(pid) # turn off all debug handlers\n"
"    :ok\n"
"    iex> :sys.get_status(pid)\n"
"    {:status, #PID<0.122.0>, {:module, :gen_server},\n"
"     [[\"$initial_call\": {Stack, :init, 1},            # pdict\n"
"       \"$ancestors\": [#PID<0.80.0>, #PID<0.51.0>]],\n"
"      :running,                                       # :running | :"
"suspended\n"
"      #PID<0.80.0>,                                   # parent\n"
"      [],                                             # debugger state\n"
"      [header: 'Status for generic server <0.122.0>', # module status\n"
"       data: [{'Status', :running}, {'Parent', #PID<0.80.0>},\n"
"         {'Logged events', []}], data: [{'State', [1]}]]]}\n"
"\n"
"## Learn more\n"
"\n"
"If you wish to find out more about gen servers, the Elixir Getting Started\n"
"guide provides a tutorial-like introduction. The documentation and links\n"
"in Erlang can also provide extra insight.\n"
"\n"
"  * [GenServer – Elixir's Getting Started Guide](http://elixir-lang.org/"
"getting-started/mix-otp/genserver.html)\n"
"  * [`:gen_server` module documentation](http://www.erlang.org/doc/man/"
"gen_server.html)\n"
"  * [gen_server Behaviour – OTP Design Principles](http://www.erlang.org/doc/"
"design_principles/gen_server_concepts.html)\n"
"  * [Clients and Servers – Learn You Some Erlang for Great Good!](http://"
"learnyousomeerlang.com/clients-and-servers)\n"
msgstr ""
"クライアント-サーバ関係のサーバを実装するためのビヘイビアモジュールです。\n"
"\n"
"GenServerは、\n"
"他の任意のElixirプロセスを使い、ステートを保持し、非同期にコードを実行、\n"
"その他を行う、プロセスです。\n"
"このモジュールによる一般的なサーバプロセス(GenServer)実装の長所は、\n"
"それがインタフェース関数の標準的なセットを持っていて、\n"
"トレースとエラーレポートの為の機能を含んでいることです。\n"
"それは、スーパビジョンツリーにも適合します。\n"
"\n"
"## 例\n"
"\n"
"GenServerビヘイビアは一般のクライアント-サーバインタラクションを抽象化しま"
"す。\n"
"開発者は彼らが興味がある機能とコールバックの実装が要求されるだけです。\n"
"\n"
"コード例から始めましょう。それから有効なコールバックを\n"
"調査しましょう。\n"
"私達はGenServerが、アイテムをプッシュしたりポップしたりする、\n"
"スタックのように、動いて欲しいとします:\n"
"\n"
"    defmodule Stack do\n"
"      use GenServer\n"
"    \n"
"      # Callbacks\n"
"    \n"
"      def handle_call(:pop, _from, [h|t]) do\n"
"        {:reply, h, t}\n"
"      end\n"
"    \n"
"      def handle_cast({:push, item}, state) do\n"
"        {:noreply, [item|state]}\n"
"      end\n"
"    end\n"
"    \n"
"    # Start the server\n"
"    {:ok, pid} = GenServer.start_link(Stack, [:hello])\n"
"    \n"
"    # This is the client\n"
"    GenServer.call(pid, :pop)\n"
"    #=> :hello\n"
"    \n"
"    GenServer.cast(pid, {:push, :world})\n"
"    #=> :ok\n"
"    \n"
"    GenServer.call(pid, :pop)\n"
"    #=> :world\n"
"\n"
"サーバ実装モジュールと、初期値(アイテム`:hello`を含むスタックを\n"
"表現したリスト)を渡し、`start_link/3`を呼び出すことで私達の`Stack`は\n"
"開始します。\n"
"私達は、主に二種類のメッセージを送信することで、\n"
"サーバと対話することができます。\n"
"**call**メッセージはサーバからの応答を期待します(従って同期しています)が、\n"
"**calst**メッセージはそうではありません。\n"
"\n"
"`GenServer.call/3`を呼ぶたびに、クライアントは、GenServerの\n"
"`handle_call/3`コールバックによりハンドルされなければならない、メッセー\n"
"ジを送信します。`cast/2`メッセージは`handle_cast/2`によりハンドルされな\n"
"ければなりません。\n"
"\n"
"## Callbacks\n"
"\n"
"`GenServer`で実装することが要求されている6個のコールバックがあります。\n"
"`use GenServer`をあなたのモジュールに追加することにより、Elixir自動的に\n"
"6個のコールバックを定義し、カスタマイズしたいものの実装をあなたに任せます。\n"
"\n"
"## Name Registration\n"
"\n"
"`start_link/3`と`start/3`の両方は、`GenServer`で\n"
"`:name`オプションにより開始する時に名前を登録することをサポートします。\n"
"登録された名前は、終了時に自動的にクリーンアップされます。サポート\n"
"された値は以下の通りです:\n"
"\n"
"  * an atom - GenServerは`Process.register/2`を使い、与えられた名前を\n"
"    ローカルに登録されます。\n"
"\n"
"  * `{:global, term}`- GenServerは`:global`オジュールの関数を使い、\n"
"    与えられたtermをグローバルに登録されます。\n"
"\n"
"  * `{:via, module, term}` - GenServerは与えられたメカニズムと名前で\n"
"    登録されます。`:via`オプションは、登録メカニズムを制御する\n"
"    モジュール名moduleと、任意の語をとることができるnameを期待します。\n"
"\n"
"例えば、私達のStackサーバを以下のようにローカルとして登録して\n"
"開始できます:\n"
"\n"
"    # Start the server and register it locally with name MyStack\n"
"    {:ok, _} = GenServer.start_link(Stack, [:hello], name: MyStack)\n"
"    \n"
"    # Now messages can be sent directly to MyStack\n"
"    GenServer.call(MyStack, :pop) #=> :hello\n"
"\n"
"一旦サーバが開始したら、このモジュールの残りの関数\n"
"(`call/3`、`cast/2`とその他)も、アトムまたは、任意の`:global`、`:via`タプル\n"
"を受け付けます。一般的に、以下のフォーマットがサポートされています:\n"
"\n"
"  * `pid`\n"
"  * `atom` サーバがローカルに登録されている場合\n"
"  * `{atom, node}` ローカルに登録されているサーバが他のノードにある場合\n"
"  * `{:global, term}` サーバがグローバルに登録されている場合\n"
"  * `{:via, module, name}` サーバが代わりの登録方法を通して登録された場合\n"
"\n"
"## Client / Server APIs\n"
"\n"
"上の例を通じて、サーバを直接開始したり通信するために、\n"
"`GenServer.start_link/3`とそのフレンドを、使いましたが、\n"
"殆ど、私達は`GenServer`関数を直接には呼び出しません。\n"
"代わりに、サーバの公式なAPIを表現する新しい関数で呼び出しを\n"
"ラップします。\n"
"\n"
"これは、私達のStackモジュールのよりよい実装です:\n"
"\n"
"    defmodule Stack do\n"
"      use GenServer\n"
"    \n"
"      # Client\n"
"    \n"
"      def start_link(default) do\n"
"        GenServer.start_link(__MODULE__, default)\n"
"      end\n"
"    \n"
"      def push(pid, item) do\n"
"        GenServer.cast(pid, {:push, item})\n"
"      end\n"
"    \n"
"      def pop(pid) do\n"
"        GenServer.call(pid, :pop)\n"
"      end\n"
"    \n"
"      # Server (callbacks)\n"
"\n"
"      def handle_call(:pop, _from, [h|t]) do\n"
"        {:reply, h, t}\n"
"      end\n"
"    \n"
"      def handle_call(request, from, state) do\n"
"        # Call the default implementation from GenServer\n"
"        super(request, from, state)\n"
"      end\n"
"    \n"
"      def handle_cast({:push, item}, state) do\n"
"        {:noreply, [item|state]}\n"
"      end\n"
"    \n"
"      def handle_cast(request, state) do\n"
"        super(request, state)\n"
"      end\n"
"    end\n"
"\n"
"実際、同じモジュール内でサーバとクライアントの両方の関数を持つことは、\n"
"一般的です。サーバとクライアント実装が複雑になっていくならば、\n"
"それらを別のモジュールにしたくなるかもしれません。\n"
"\n"
"## Receiving custom messages\n"
"\n"
"`GenServer`のゴールは\"receive\"ループを開発者から抽象化し、\n"
"システムメッセージを自動的にハンドリングし、コード変更、\n"
"呼出しを同期などをサポートすることです。\n"
"従って、GenServerが無作法なことをする原因となるので、\n"
"GenServerコールバックの中で、独自に\"receive\"を呼出してはいけません。\n"
"もしカスタムメッセージを受信したい場合、常に`handle_info/2`でそれを\n"
"受信します。\n"
"\n"
"## Learn more\n"
"\n"
"gen serverについてもっと知りたいなら、Elixir getting started guide\n"
"がチュートリアルライクの導入を提供します。Erlangのドキュメントとリンク\n"
"もまた、追加の洞察を提供することができます。\n"
"\n"
"  * [GenServer – Elixir's Getting Started Guide](http://elixir-lang.org/"
"getting-started/mix-otp/genserver.html)\n"
"  * [`:gen_server` module documentation](http://www.erlang.org/doc/man/"
"gen_server.html)\n"
"  * [gen_server Behaviour – OTP Design Principles](http://www.erlang.org/doc/"
"design_principles/gen_server_concepts.html)\n"
"  * [Clients and Servers – Learn You Some Erlang for Great Good!](http://"
"learnyousomeerlang.com/clients-and-servers)\n"

#. TRANSLATORS: def GenServer.call(server, request, timeout \\ 5000)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/gen_server.ex:703
#, fuzzy
msgid ""
"Makes a synchronous call to the `server` and waits for its reply.\n"
"\n"
"The client sends the given `request` to the server and waits until a reply\n"
"arrives or a timeout occurs. `c:handle_call/3` will be called on the server\n"
"to handle the request.\n"
"\n"
"`server` can be any of the values described in the \"Name registration\"\n"
"section of the documentation for this module.\n"
"\n"
"## Timeouts\n"
"\n"
"`timeout` is an integer greater than zero which specifies how many\n"
"milliseconds to wait for a reply, or the atom `:infinity` to wait\n"
"indefinitely. The default value is `5000`. If no reply is received within\n"
"the specified time, the function call fails and the caller exits. If the\n"
"caller catches the failure and continues running, and the server is just "
"late\n"
"with the reply, it may arrive at any time later into the caller's message\n"
"queue. The caller must in this case be prepared for this and discard any "
"such\n"
"garbage messages that are two-element tuples with a reference as the first\n"
"element.\n"
msgstr ""
"`server`を同期的に呼び出し、その応答を待ちます。\n"
"\n"
"クライアントは与えられた`request`をサーバに送信し、\n"
"応答が到着するか、タイムアウトが起きるまで待ちます。\n"
"`handle_call/3`がリクエストをハンドルするためにサーバで呼ばれます。\n"
"\n"
"引数のserverはモジュールドキュメントの`名前登録`セクションで記述された\n"
"任意の値をとることができます。\n"
"\n"
"## タイウアウト\n"
"\n"
"`timeout`は、応答を待つ長さを示すミリ秒で、0より大きな整数か、無限に待\n"
"つことを示すアトムで、`:infinity`のいずれかです。デフォルト値は5000です。\n"
"もし指定された時間内に応答が受信されないなら、関数呼び出しは失敗します。\n"
"もし呼び出し側が失敗を捕捉し、実行を継続し、そして、サーバが送れて応答\n"
"したら、呼び出し側のメッセージキューに送れて到着します。呼び出し側は、\n"
"この場合、これに備えなければならず、最初の要素としてリファレンスである\n"
"2要素のタプルのゴミメッセージを捨てなければなりません。\n"

#. TRANSLATORS: def GenServer.whereis(pid)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/gen_server.ex:892
#, fuzzy
msgid ""
"Returns the `pid` or `{name, node}` of a GenServer process, or `nil` if\n"
"no process is associated with the given name.\n"
"\n"
"## Examples\n"
"\n"
"For example, to lookup a server process, monitor it and send a cast to it:\n"
"\n"
"    process = GenServer.whereis(server)\n"
"    monitor = Process.monitor(process)\n"
"    GenServer.cast(process, :hello)\n"
"\n"
msgstr ""
"GenServerプロセスの`pid`か`{name, node}`を返します。\n"
"与えられた名前に関連するプロセスがない場合`nil`を返します。\n"
"\n"
"以下の例は、サーバプロセスをlookupして、モニタして、\n"
"castを送信しています:\n"
"\n"
"    process = GenServer.whereis(server)\n"
"    monitor = Process.monitor(process)\n"
"    GenServer.cast(process, :hello)\n"
"\n"

#. TRANSLATORS: def GenServer.cast(server, request)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/gen_server.ex:744
#, fuzzy
msgid ""
"Sends an asynchronous request to the `server`.\n"
"\n"
"This function always returns `:ok` regardless of whether\n"
"the destination `server` (or node) exists. Therefore it\n"
"is unknown whether the destination `server` successfully\n"
"handled the message.\n"
"\n"
"`c:handle_cast/2` will be called on the server to handle\n"
"the request. In case the `server` is on a node which is\n"
"not yet connected to the caller one, the call is going to\n"
"block until a connection happens. This is different than\n"
"the behaviour in OTP's `:gen_server` where the message\n"
"is sent by another process in this case, which could cause\n"
"messages to other nodes to arrive out of order.\n"
msgstr ""
"`server`へ非同期要求を送信します。\n"
"\n"
"この関数は、送信先の`server`(またはノード)が存在するか否かを問わず、常\n"
"に`:ok`を返します。従って、送信先の`server`がメッセージを処理に成功した\n"
"かどうかは分りません。\n"
"\n"
"`handle_cast/2`は要求を処理するためにサーバで呼ばれます。\n"
"`server`が呼び出し側にまだ接続していないノードである場\n"
"合に備えて、接続が起こるまでは呼出しはブロックします。\n"
"これは、OTPの`:gen_server`ビヘイビアとは異なります。OTP\n"
"の`:gen_server`ビヘイビアでは、この場合、メッセージはも\n"
"う一つのプロセスまで送られ、その結果、他のノードへのメッ\n"
"セージの順序が乱れて到着するかもしれません。\n"

#. TRANSLATORS: @callback code_change/3
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/gen_server.ex:465
#, fuzzy
msgid ""
"Invoked to change the state of the `GenServer` when a different version of "
"a\n"
"module is loaded (hot code swapping) and the state's term structure should "
"be\n"
"changed.\n"
"\n"
"`old_vsn` is the previous version of the module (defined by the `@vsn`\n"
"attribute) when upgrading. When downgrading the previous version is wrapped "
"in\n"
"a 2-tuple with first element `:down`. `state` is the current state of the\n"
"`GenServer` and `extra` is any extra data required to change the state.\n"
"\n"
"Returning `{:ok, new_state}` changes the state to `new_state` and the code\n"
"change is successful.\n"
"\n"
"Returning `{:error, reason}` fails the code change with reason `reason` and\n"
"the state remains as the previous state.\n"
"\n"
"If `c:code_change/3` raises the code change fails and the loop will "
"continue\n"
"with its previous state. Therefore this callback does not usually contain "
"side effects.\n"
msgstr ""
"異ったバージョンのモジュールがロードされた時\n"
"(ホットコードスワッピング)、`GenServer`のステートを\n"
"変更するために起動され、ステートの構造体は変更されるべきです。\n"
"\n"
"`old_vsn`はアップグレードの時、モジュールの\n"
"(`@vsn`アトリビュートにより定義された)前のバージョンです。\n"
"ダウングレードの時、前のバージョンは\n"
"最初が`:down`となる2要素タプルでラップされます。\n"
"`state`は`GenSerer`の現在のステートで、`extra`は\n"
"ステートの変更に必要な任意の特別なデータです。\n"
"\n"
"`{:ok, new_state}`を返すと、ステートは`new_state`に変更され、\n"
"code changeは成功します。\n"
"\n"
"`{:error, reason}`を返すことは、\n"
"reason `reason`でcode changeは失敗し、ステートは以前の\n"
"ステートのままです。\n"
"\n"
"もし`code_change/3`が例外を上げるなら、code changeは失敗し、\n"
"ループは以前のステートで再開します。したがって、このコール\n"
"バックは通常副作用を含みません。\n"

#. TRANSLATORS: @callback terminate/2
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/gen_server.ex:427
#, fuzzy
msgid ""
"Invoked when the server is about to exit. It should do any cleanup "
"required.\n"
"\n"
"`reason` is exit reason and `state` is the current state of the "
"`GenServer`.\n"
"The return value is ignored.\n"
"\n"
"`c:terminate/2` is called if a callback (except `c:init/1`) returns a `:"
"stop`\n"
"tuple, raises, calls `Kernel.exit/1` or returns an invalid value. It may "
"also\n"
"be called if the `GenServer` traps exits using `Process.flag/2` *and* the\n"
"parent process sends an exit signal.\n"
"\n"
"If part of a supervision tree a `GenServer`'s `Supervisor` will send an "
"exit\n"
"signal when shutting it down. The exit signal is based on the shutdown\n"
"strategy in the child's specification. If it is `:brutal_kill` the "
"`GenServer`\n"
"is killed and so `c:terminate/2` is not called. However if it is a timeout "
"the\n"
"`Supervisor` will send the exit signal `:shutdown` and the `GenServer` will\n"
"have the duration of the timeout to call `c:terminate/2` - if the process "
"is\n"
"still alive after the timeout it is killed.\n"
"\n"
"If the `GenServer` receives an exit signal (that is not `:normal`) from any\n"
"process when it is not trapping exits it will exit abruptly with the same\n"
"reason and so not call `c:terminate/2`. Note that a process does *NOT* trap\n"
"exits by default and an exit signal is sent when a linked process exits or "
"its\n"
"node is disconnected.\n"
"\n"
"Therefore it is not guaranteed that `c:terminate/2` is called when a "
"`GenServer`\n"
"exits. For such reasons, we usually recommend important clean-up rules to\n"
"happen in separated processes either by use of monitoring or by links\n"
"themselves. For example if the `GenServer` controls a `port` (e.g.\n"
"`:gen_tcp.socket`) or `t:File.io_device/0`, they will be closed on receiving "
"a\n"
"`GenServer`'s exit signal and do not need to be closed in `c:terminate/2`.\n"
"\n"
"If `reason` is not `:normal`, `:shutdown` nor `{:shutdown, term}` an error "
"is\n"
"logged.\n"
msgstr ""
"サーバがexitするときに起動されます。必要な任意のクリーンアップ\n"
"を行ってください。\n"
"\n"
"`reason`はexit reasonで`state`は`GenServer`の現在のステートです。\n"
"戻値は無視されます。\n"
"\n"
"`terminate/2`は、(`init/1`を除いた)コールバックが\n"
"以下の場合に呼ばれます: \n"
"`:stop`タプルを返す、例外を上げる、`Kernel.exit/1`を呼出す、\n"
"あるいは、無効な値を返した場合。\n"
"`GenServer`が `Process.flag/2`を使って exit をトラップしていても、\n"
"*そして*\n"
"親プロセスがexitシグナルを送信した場合でも、`terminate/2`が呼ばれます。\n"
"\n"
"supervisionツリーの一部なら、`GenServer`の`Supervisor`は、\n"
"それがシャットダウンするとき、exitシグナルを送信するでしょう。\n"
"exitシグナルはchild仕様のシャットダウンストラテジに基いています。\n"
"もし`:brutal_kill`なら、`GenServer`はkillされ、`terminate/2`は\n"
"呼ばれません。\n"
"しかしながら、もしタイムアウトなら、\n"
"`Supervisor`はexitシグナル`:shutdown`を送信し、\n"
"`GenServer`は`terminate/2`を呼ぶ為のタイムアウト期間を持ちます - \n"
"もし、プロセスがタイムアウト後も生きていれば、killされます。\n"
"\n"
"もし`GenServer`がexitをトラップしていないときに、任意のプロセスから\n"
"(`:normal`でない)exitシグナルを受信したら、\n"
"同じresasonで急にexitするので、`terminate/2`を呼び出さないでしょう。\n"
"デフォルトでは、プロセスがexitをトラップして *いない* ことと、\n"
"exitシグナルはリンクされたプロセスがexitした時あるいは\n"
"そのノードが切断された時に送信されることに注意してください。\n"
"\n"
"したがって、`GenSerer`がexitしたときに、\n"
"`terminate/2`が呼び出されることは保証されません。\n"
"そういう理由で、私達は、\n"
"モニタの利用や、リンクされた別のプロセスに\n"
"行わせるという、重要なクリーンアップルールを推奨します。\n"
"例えば、`GenServer`は`port`(`:gen_tcp.socket`のような)や\n"
"`File.io_device`を制御しているなら、それらは\n"
"`GenServer`のexitシグナルを受信した時にクローズされるでしょう。\n"
"そして、`terminate/2`ではクローズする必要がありません。\n"
"\n"
"`reason`が`:normal`、`:shutdown`、`{:shutdown, term}`の\n"
"どれでもないエラーはログされます。\n"

#. TRANSLATORS: def GenServer.multi_call(nodes \\ [node() | Node.list()], name, request, timeout \\ :infinity)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/gen_server.ex:815
#, fuzzy
msgid ""
"Calls all servers locally registered as `name` at the specified `nodes`.\n"
"\n"
"First, the `request` is sent to every node in `nodes`; then, the caller "
"waits\n"
"for the replies. This function returns a two-element tuple `{replies,\n"
"bad_nodes}` where:\n"
"\n"
"  * `replies` - is a list of `{node, reply}` tuples where `node` is the "
"node\n"
"    that replied and `reply` is its reply\n"
"  * `bad_nodes` - is a list of nodes that either did not exist or where a\n"
"    server with the given `name` did not exist or did not reply\n"
"\n"
"`nodes` is a list of node names to which the request is sent. The default\n"
"value is the list of all known nodes (including this node).\n"
"\n"
"To avoid that late answers (after the timeout) pollute the caller's message\n"
"queue, a middleman process is used to do the actual calls. Late answers "
"will\n"
"then be discarded when they arrive to a terminated process.\n"
"\n"
"## Examples\n"
"\n"
"Assuming the `Stack` GenServer mentioned in the docs for the `GenServer`\n"
"module is registered as `Stack` in the `:\"foo@my-machine\"` and\n"
"`:\"bar@my-machine\"` nodes:\n"
"\n"
"    GenServer.multi_call(Stack, :pop)\n"
"    #=> {[{:\"foo@my-machine\", :hello}, {:\"bar@my-machine\", :world}], "
"[]}\n"
"\n"
msgstr ""
"指定された`nodes`で`name`としてローカルに登録された全てのサーバ\n"
"を呼び出します。\n"
"\n"
"`request`は最初にそれぞれのノードへ送られ、それから、応答を待ちます。\n"
"この関数は、最初の要素として応答したノードとその応答を、2番目の\n"
"要素として全ての悪いノードを含む、\n"
"タプルを返します。\n"
"悪いノードは、\n"
"存在しなかかったか、与えられた`name`のサーバが存在しなかったか、応答が\n"
"なかったノードのリストです。\n"
"\n"
"nodesはrequestが送られる、ノード名のリストです。デフォルト値は\n"
"知っている全てのノード(nodes())です。\n"
"\n"
"(タイムアウトの後での)遲い応答が、呼び出し側のメッセージ\n"
"キューを汚染することを避けるために、実際の呼び出しには仲介者プロセスが使われ"
"ます。\n"
"遲い応答が終了したプロセスに届いたとき、それらは捨てられます。\n"

#. TRANSLATORS: @type debug
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/gen_server.ex:525
msgid "Debug options supported by the `start*` functions"
msgstr "`start*`関数によりサポートされるデバッグオプション"
