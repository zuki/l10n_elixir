#. TRANSLATORS: def Macro.expand(tree, env)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/macro.ex:1147 
msgid ""
"Receives an AST node and expands it until it can no longer\n"
"be expanded.\n"
"\n"
"This function uses `expand_once/2` under the hood. Check\n"
"it out for more information and examples.\n"
msgstr ""
#. TRANSLATORS: def Macro.prewalk(ast, acc, fun)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/macro.ex:309 
msgid ""
"Performs a depth-first, pre-order traversal of quoted expressions\n"
"using an accumulator.\n"
msgstr ""
#. TRANSLATORS: def Macro.postwalk(ast, acc, fun)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/macro.ex:326 
msgid ""
"Performs a depth-first, post-order traversal of quoted expressions\n"
"using an accumulator.\n"
msgstr ""
#. TRANSLATORS: def Macro.validate(expr)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/macro.ex:400 
msgid ""
"Validates the given expressions are valid quoted expressions.\n"
"\n"
"Checks the `t:Macro.t/0` for the specification of a valid\n"
"quoted expression.\n"
"\n"
"It returns `:ok` if the expression is valid. Otherwise it returns a tuple in the form of\n"
"`{:error, remainder}` where `remainder` is the invalid part of the quoted expression.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Macro.validate({:two_element, :tuple})\n"
"    :ok\n"
"    iex> Macro.validate({:three, :element, :tuple})\n"
"    {:error, {:three, :element, :tuple}}\n"
"\n"
"    iex> Macro.validate([1, 2, 3])\n"
"    :ok\n"
"    iex> Macro.validate([1, 2, 3, {4}])\n"
"    {:error, {4}}\n"
"\n"
msgstr ""
#. TRANSLATORS: def Macro.var(var, context)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/macro.ex:226 
msgid ""
"Generates an AST node representing the variable given\n"
"by the atoms `var` and `context`.\n"
"\n"
"## Examples\n"
"\n"
"In order to build a variable, a context is expected.\n"
"Most of the times, in order to preserve hygiene, the\n"
"context must be `__MODULE__/0`:\n"
"\n"
"    iex> Macro.var(:foo, __MODULE__)\n"
"    {:foo, [], __MODULE__}\n"
"\n"
"However, if there is a need to access the user variable,\n"
"nil can be given:\n"
"\n"
"    iex> Macro.var(:foo, nil)\n"
"    {:foo, [], nil}\n"
"\n"
msgstr ""
#. TRANSLATORS: def Macro.prewalk(ast, fun)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/macro.ex:301 
msgid ""
"Performs a depth-first, pre-order traversal of quoted expressions.\n"
msgstr ""
#. TRANSLATORS: def Macro.postwalk(ast, fun)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/macro.ex:318 
msgid ""
"Performs a depth-first, post-order traversal of quoted expressions.\n"
msgstr ""
#. TRANSLATORS: def Macro.unescape_string(chars, map)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/macro.ex:479 
msgid ""
"Unescapes the given chars according to the map given.\n"
"\n"
"Check `unescape_string/1` if you want to use the same map\n"
"as Elixir single- and double-quoted strings.\n"
"\n"
"## Map\n"
"\n"
"The map must be a function. The function receives an integer\n"
"representing the codepoint of the character it wants to unescape.\n"
"Here is the default mapping function implemented by Elixir:\n"
"\n"
"    def unescape_map(?0), do: ?0\n"
"    def unescape_map(?a), do: ?\\a\n"
"    def unescape_map(?b), do: ?\\b\n"
"    def unescape_map(?d), do: ?\\d\n"
"    def unescape_map(?e), do: ?\\e\n"
"    def unescape_map(?f), do: ?\\f\n"
"    def unescape_map(?n), do: ?\\n\n"
"    def unescape_map(?r), do: ?\\r\n"
"    def unescape_map(?s), do: ?\\s\n"
"    def unescape_map(?t), do: ?\\t\n"
"    def unescape_map(?v), do: ?\\v\n"
"    def unescape_map(?x), do: true\n"
"    def unescape_map(?u), do: true\n"
"    def unescape_map(e),  do: e\n"
"\n"
"If the `unescape_map/1` function returns `false`. The char is\n"
"not escaped and the backslash is kept in the string.\n"
"\n"
"Hexadecimals and Unicode codepoints will be escaped if the map\n"
"function returns `true` for `?x`. Unicode codepoints if the map\n"
"function returns `true` for `?u`.\n"
"\n"
"## Examples\n"
"\n"
"Using the `unescape_map/1` function defined above is easy:\n"
"\n"
"    Macro.unescape_string \"example\\\\n\", &unescape_map(&1)\n"
"\n"
msgstr ""
#. TRANSLATORS: def Macro.unescape_tokens(tokens)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/macro.ex:525 
msgid ""
"Unescapes the given tokens according to the default map.\n"
"\n"
"Check `unescape_string/1` and `unescape_string/2` for more\n"
"information about unescaping.\n"
"\n"
"Only tokens that are binaries are unescaped, all others are\n"
"ignored. This function is useful when implementing your own\n"
"sigils. Check the implementation of `Kernel.sigil_s/2`\n"
"for examples.\n"
msgstr ""
#. TRANSLATORS: def Macro.to_string(tree, fun \\ fn _ast, string -> string end)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/macro.ex:551 
msgid ""
"Converts the given expression to a binary.\n"
"\n"
"The given `fun` is called for every node in the AST with two arguments: the\n"
"AST of the node being printed and the string representation of that same\n"
"node. The return value of this function is used as the final string\n"
"representation for that AST node.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Macro.to_string(quote(do: foo.bar(1, 2, 3)))\n"
"    \"foo.bar(1, 2, 3)\"\n"
"\n"
"    iex> Macro.to_string(quote(do: 1 + 2), fn\n"
"    ...>   1, _string -> \"one\"\n"
"    ...>   2, _string -> \"two\"\n"
"    ...>   _ast, string -> string\n"
"    ...> end)\n"
"    \"one + two\"\n"
"\n"
msgstr ""
#. TRANSLATORS: def Macro.underscore(atom)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/macro.ex:1166 
msgid ""
"Converts the given atom or binary to underscore format.\n"
"\n"
"If an atom is given, it is assumed to be an Elixir module,\n"
"so it is converted to a binary and then processed.\n"
"\n"
"This function was designed to underscore language identifiers/tokens,\n"
"that's why it belongs to the `Macro` module. Do not use it as a general\n"
"mechanism for underscoring strings as it does not support Unicode or\n"
"characters that are not valid in Elixir identifiers.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Macro.underscore \"FooBar\"\n"
"    \"foo_bar\"\n"
"\n"
"    iex> Macro.underscore \"Foo.Bar\"\n"
"    \"foo/bar\"\n"
"\n"
"    iex> Macro.underscore Foo.Bar\n"
"    \"foo/bar\"\n"
"\n"
"In general, `underscore` can be thought of as the reverse of\n"
"`camelize`, however, in some cases formatting may be lost:\n"
"\n"
"    iex> Macro.underscore \"SAPExample\"\n"
"    \"sap_example\"\n"
"\n"
"    iex> Macro.camelize \"sap_example\"\n"
"    \"SapExample\"\n"
"\n"
"    iex> Macro.camelize \"hello_10\"\n"
"    \"Hello10\"\n"
"\n"
msgstr ""
#. TRANSLATORS: def Macro.unescape_tokens(tokens, map)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/macro.ex:541 
msgid ""
"Unescapes the given tokens according to the given map.\n"
"\n"
"Check `unescape_tokens/1` and `unescape_string/2` for more information.\n"
msgstr ""
#. TRANSLATORS: def Macro.unpipe(expr)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/macro.ex:101 
msgid ""
"Breaks a pipeline expression into a list.\n"
"\n"
"The AST for a pipeline (a sequence of applications of `|>`) is similar to the\n"
"AST of a sequence of binary operators or function applications: the top-level\n"
"expression is the right-most `:|>` (which is the last one to be executed), and\n"
"its left-hand and right-hand sides are its arguments:\n"
"\n"
"    quote do: 100 |> div(5) |> div(2)\n"
"    #=> {:|>, _, [arg1, arg2]}\n"
"\n"
"In the example above, the `|>` pipe is the right-most pipe; `arg1` is the AST\n"
"for `100 |> div(5)`, and `arg2` is the AST for `div(2)`.\n"
"\n"
"It's often useful to have the AST for such a pipeline as a list of function\n"
"applications. This function does exactly that:\n"
"\n"
"    Macro.unpipe(quote do: 100 |> div(5) |> div(2))\n"
"    #=> [{100, 0}, {{:div, [], [5]}, 0}, {{:div, [], [2]}, 0}]\n"
"\n"
"We get a list that follows the pipeline directly: first the `100`, then the\n"
"`div(5)` (more precisely, its AST), then `div(2)`. The `0` as the second\n"
"element of the tuples is the position of the previous element in the pipeline\n"
"inside the current function application: `{{:div, [], [5]}, 0}` means that the\n"
"previous element (`100`) will be inserted as the 0th (first) argument to the\n"
"`div/2` function, so that the AST for that function will become `{:div, [],\n"
"[100, 5]}` (`div(100, 5)`).\n"
msgstr ""
#. TRANSLATORS: def Macro.camelize(string)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/macro.ex:1234 
msgid ""
"Converts the given string to CamelCase format.\n"
"\n"
"This function was designed to camelize language identifiers/tokens,\n"
"that's why it belongs to the `Macro` module. Do not use it as a general\n"
"mechanism for camelizing strings as it does not support Unicode or\n"
"characters that are not valid in Elixir identifiers.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Macro.camelize \"foo_bar\"\n"
"    \"FooBar\"\n"
"\n"
msgstr ""
#. TRANSLATORS: def Macro.expand_once(ast, env)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/macro.ex:968 
msgid ""
"Receives an AST node and expands it once.\n"
"\n"
"The following contents are expanded:\n"
"\n"
"  * Macros (local or remote)\n"
"  * Aliases are expanded (if possible) and return atoms\n"
"  * Compilation environment macros (`__ENV__/0`, `__MODULE__/0` and `__DIR__/0`)\n"
"  * Module attributes reader (`@foo`)\n"
"\n"
"If the expression cannot be expanded, it returns the expression\n"
"itself. Notice that `expand_once/2` performs the expansion just\n"
"once and it is not recursive. Check `expand/2` for expansion\n"
"until the node can no longer be expanded.\n"
"\n"
"## Examples\n"
"\n"
"In the example below, we have a macro that generates a module\n"
"with a function named `name_length` that returns the length\n"
"of the module name. The value of this function will be calculated\n"
"at compilation time and not at runtime.\n"
"\n"
"Consider the implementation below:\n"
"\n"
"    defmacro defmodule_with_length(name, do: block) do\n"
"      length = length(Atom.to_charlist(name))\n"
"\n"
"      quote do\n"
"        defmodule unquote(name) do\n"
"          def name_length, do: unquote(length)\n"
"          unquote(block)\n"
"        end\n"
"      end\n"
"    end\n"
"\n"
"When invoked like this:\n"
"\n"
"    defmodule_with_length My.Module do\n"
"      def other_function, do: ...\n"
"    end\n"
"\n"
"The compilation will fail because `My.Module` when quoted\n"
"is not an atom, but a syntax tree as follow:\n"
"\n"
"    {:__aliases__, [], [:My, :Module]}\n"
"\n"
"That said, we need to expand the aliases node above to an\n"
"atom, so we can retrieve its length. Expanding the node is\n"
"not straight-forward because we also need to expand the\n"
"caller aliases. For example:\n"
"\n"
"    alias MyHelpers, as: My\n"
"\n"
"    defmodule_with_length My.Module do\n"
"      def other_function, do: ...\n"
"    end\n"
"\n"
"The final module name will be `MyHelpers.Module` and not\n"
"`My.Module`. With `Macro.expand/2`, such aliases are taken\n"
"into consideration. Local and remote macros are also\n"
"expanded. We could rewrite our macro above to use this\n"
"function as:\n"
"\n"
"    defmacro defmodule_with_length(name, do: block) do\n"
"      expanded = Macro.expand(name, __CALLER__)\n"
"      length   = length(Atom.to_charlist(expanded))\n"
"\n"
"      quote do\n"
"        defmodule unquote(name) do\n"
"          def name_length, do: unquote(length)\n"
"          unquote(block)\n"
"        end\n"
"      end\n"
"    end\n"
"\n"
msgstr ""
#. TRANSLATORS: def Macro.unescape_string(chars)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/macro.ex:450 
msgid ""
"Unescapes the given chars.\n"
"\n"
"This is the unescaping behaviour used by default in Elixir\n"
"single- and double-quoted strings. Check `unescape_string/2`\n"
"for information on how to customize the escaping map.\n"
"\n"
"In this setup, Elixir will escape the following: `\\0`, `\\a`, `\\b`,\n"
"`\\d`, `\\e`, `\\f`, `\\n`, `\\r`, `\\s`, `\\t` and `\\v`. Bytes can be\n"
"given as hexadecimals via `\\xNN` and Unicode Codepoints as\n"
"`\\uNNNN` escapes.\n"
"\n"
"This function is commonly used on sigil implementations\n"
"(like `~r`, `~s` and others) which receive a raw, unescaped\n"
"string.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Macro.unescape_string(\"example\\\\n\")\n"
"    \"example\\n\"\n"
"\n"
"In the example above, we pass a string with `\\n` escaped\n"
"and return a version with it unescaped.\n"
msgstr ""
#. TRANSLATORS: def Macro.update_meta(quoted, fun)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/macro.ex:200 
msgid ""
"Applies the given function to the node metadata if it contains one.\n"
"\n"
"This is often useful when used with `Macro.prewalk/2` to remove\n"
"information like lines and hygienic counters from the expression\n"
"for either storage or comparison.\n"
"\n"
"## Examples\n"
"\n"
"    iex> quoted = quote line: 10, do: sample()\n"
"    {:sample, [line: 10], []}\n"
"    iex> Macro.update_meta(quoted, &Keyword.delete(&1, :line))\n"
"    {:sample, [], []}\n"
"\n"
msgstr ""
#. TRANSLATORS: def Macro.escape(expr, opts \\ [])
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/macro.ex:374 
msgid ""
"Recursively escapes a value so it can be inserted\n"
"into a syntax tree.\n"
"\n"
"One may pass `unquote: true` to `escape/2`\n"
"which leaves `unquote/1` statements unescaped, effectively\n"
"unquoting the contents on escape.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Macro.escape(:foo)\n"
"    :foo\n"
"\n"
"    iex> Macro.escape({:a, :b, :c})\n"
"    {:{}, [], [:a, :b, :c]}\n"
"\n"
"    iex> Macro.escape({:unquote, [], [1]}, unquote: true)\n"
"    1\n"
"\n"
msgstr ""
#. TRANSLATORS: def Macro.traverse(ast, acc, pre, post)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/macro.ex:251 
msgid ""
"Performs a depth-first traversal of quoted expressions\n"
"using an accumulator.\n"
msgstr ""
#. TRANSLATORS: def Macro.pipe(expr, call_args, position)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/macro.ex:142 
msgid ""
"Pipes `expr` into the `call_args` at the given `position`.\n"
msgstr ""
#. TRANSLATORS: def Macro.decompose_call(ast)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/macro.ex:335 
msgid ""
"Decomposes a local or remote call into its remote part (when provided),\n"
"function name and argument list.\n"
"\n"
"Returns `:error` when an invalid call syntax is provided.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Macro.decompose_call(quote(do: foo))\n"
"    {:foo, []}\n"
"\n"
"    iex> Macro.decompose_call(quote(do: foo()))\n"
"    {:foo, []}\n"
"\n"
"    iex> Macro.decompose_call(quote(do: foo(1, 2, 3)))\n"
"    {:foo, [1, 2, 3]}\n"
"\n"
"    iex> Macro.decompose_call(quote(do: Elixir.M.foo(1, 2, 3)))\n"
"    {{:__aliases__, [], [:Elixir, :M]}, :foo, [1, 2, 3]}\n"
"\n"
"    iex> Macro.decompose_call(quote(do: 42))\n"
"    :error\n"
"\n"
msgstr ""
#. TRANSLATORS: @type t
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/macro.ex:58 
msgid ""
"Abstract Syntax Tree (AST)"
msgstr ""
#. TRANSLATORS: Elixir.Macro Summary
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/macro.ex:4 
msgid ""
"Conveniences for working with macros.\n"
"\n"
"## Custom Sigils\n"
"\n"
"To create a custom sigil, define a function with the name\n"
"`sigil_{identifier}` that takes two arguments. The first argument will be\n"
"the string, the second will be a charlist containing any modifiers. If the\n"
"sigil is lower case (such as `sigil_x`) then the string argument will allow\n"
"interpolation. If the sigil is upper case (such as `sigil_X`) then the string\n"
"will not be interpolated.\n"
"\n"
"Valid modifiers include only lower and upper case letters. Other characters\n"
"will cause a syntax error.\n"
"\n"
"The module containing the custom sigil must be imported before the sigil\n"
"syntax can be used.\n"
"\n"
"### Examples\n"
"\n"
"    defmodule MySigils do\n"
"      defmacro sigil_x(term, [?r]) do\n"
"        quote do\n"
"          unquote(term) |> String.reverse()\n"
"        end\n"
"      end\n"
"      defmacro sigil_x(term, _modifiers) do\n"
"        term\n"
"      end\n"
"      defmacro sigil_X(term, [?r]) do\n"
"        quote do\n"
"          unquote(term) |> String.reverse()\n"
"        end\n"
"      end\n"
"      defmacro sigil_X(term, _modifiers) do\n"
"        term\n"
"      end\n"
"    end\n"
"\n"
"    import MySigils\n"
"\n"
"    ~x(with #{\"inter\" <> \"polation\"})\n"
"    #=>\"with interpolation\"\n"
"\n"
"    ~x(with #{\"inter\" <> \"polation\"})r\n"
"    #=>\"noitalopretni htiw\"\n"
"\n"
"    ~X(without #{\"interpolation\"})\n"
"    #=>\"without \\#{\"interpolation\"}\"\n"
"\n"
"    ~X(without #{\"interpolation\"})r\n"
"    #=>\"}\\\"noitalopretni\\\"{# tuohtiw\"\n"
msgstr ""
