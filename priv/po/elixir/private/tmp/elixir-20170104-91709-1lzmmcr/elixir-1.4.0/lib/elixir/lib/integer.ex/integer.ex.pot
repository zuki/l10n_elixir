#. TRANSLATORS: def Integer.to_string(integer, base)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/integer.ex:330 
msgid ""
"Returns a binary which corresponds to the text representation\n"
"of `integer` in the given `base`.\n"
"\n"
"`base` can be an integer between 2 and 36.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Integer.to_string(100, 16)\n"
"    \"64\"\n"
"\n"
"    iex> Integer.to_string(-100, 16)\n"
"    \"-64\"\n"
"\n"
"    iex> Integer.to_string(882681651, 36)\n"
"    \"ELIXIR\"\n"
"\n"
msgstr ""
#. TRANSLATORS: defmacro Integer.is_odd(integer)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/integer.ex:8 
msgid ""
"Determines if `integer` is odd.\n"
"\n"
"Returns `true` if the given `integer` is an odd number,\n"
"otherwise it returns `false`.\n"
"\n"
"Allowed in guard clauses.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Integer.is_odd(5)\n"
"    true\n"
"\n"
"    iex> Integer.is_odd(6)\n"
"    false\n"
"\n"
"    iex> Integer.is_odd(-5)\n"
"    true\n"
"\n"
"    iex> Integer.is_odd(0)\n"
"    false\n"
"\n"
msgstr ""
#. TRANSLATORS: def Integer.parse(binary, base \\ 10)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/integer.ex:194 
msgid ""
"Parses a text representation of an integer.\n"
"\n"
"An optional `base` to the corresponding integer can be provided.\n"
"If `base` is not given, 10 will be used.\n"
"\n"
"If successful, returns a tuple in the form of `{integer, remainder_of_binary}`.\n"
"Otherwise `:error`.\n"
"\n"
"Raises an error if `base` is less than 2 or more than 36.\n"
"\n"
"If you want to convert a string-formatted integer directly to a integer,\n"
"`String.to_integer/1` or `String.to_integer/2` can be used instead.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Integer.parse(\"34\")\n"
"    {34, \"\"}\n"
"\n"
"    iex> Integer.parse(\"34.5\")\n"
"    {34, \".5\"}\n"
"\n"
"    iex> Integer.parse(\"three\")\n"
"    :error\n"
"\n"
"    iex> Integer.parse(\"34\", 10)\n"
"    {34, \"\"}\n"
"\n"
"    iex> Integer.parse(\"f4\", 16)\n"
"    {244, \"\"}\n"
"\n"
"    iex> Integer.parse(\"Awww++\", 36)\n"
"    {509216, \"++\"}\n"
"\n"
"    iex> Integer.parse(\"fab\", 10)\n"
"    :error\n"
"\n"
"    iex> Integer.parse(\"a2\", 38)\n"
"    ** (ArgumentError) invalid base 38\n"
"\n"
msgstr ""
#. TRANSLATORS: def Integer.floor_div(dividend, divisor)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/integer.ex:89 
msgid ""
"Performs a floored integer division.\n"
"\n"
"Raises an `ArithmeticError` exception if one of the arguments is not an\n"
"integer, or when the `divisor` is `0`.\n"
"\n"
"`Integer.floor_div/2` performs *floored* integer division. This means that\n"
"the result is always rounded towards negative infinity.\n"
"\n"
"If you want to perform truncated integer division (rounding towards zero),\n"
"use `Kernel.div/2` instead.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Integer.floor_div(5, 2)\n"
"    2\n"
"    iex> Integer.floor_div(6, -4)\n"
"    -2\n"
"    iex> Integer.floor_div(-99, 2)\n"
"    -50\n"
"\n"
msgstr ""
#. TRANSLATORS: def Integer.mod(dividend, divisor)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/integer.ex:62 
msgid ""
"Computes the modulo remainder of an integer division.\n"
"\n"
"`Integer.mod/2` uses floored division, which means that\n"
"the result will always have the sign of the `divisor`.\n"
"\n"
"Raises an `ArithmeticError` exception if one of the arguments is not an\n"
"integer, or when the `divisor` is `0`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Integer.mod(5, 2)\n"
"    1\n"
"    iex> Integer.mod(6, -4)\n"
"    -2\n"
"\n"
msgstr ""
#. TRANSLATORS: def Integer.to_charlist(integer, base)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/integer.ex:380 
msgid ""
"Returns a charlist which corresponds to the text representation of `integer` in the given `base`.\n"
"\n"
"`base` can be an integer between 2 and 36.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Integer.to_charlist(100, 16)\n"
"    '64'\n"
"\n"
"    iex> Integer.to_charlist(-100, 16)\n"
"    '-64'\n"
"\n"
"    iex> Integer.to_charlist(882681651, 36)\n"
"    'ELIXIR'\n"
"\n"
msgstr ""
#. TRANSLATORS: def Integer.to_string(integer)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/integer.ex:304 
msgid ""
"Returns a binary which corresponds to the text representation\n"
"of `integer`.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Integer.to_string(123)\n"
"    \"123\"\n"
"\n"
"    iex> Integer.to_string(+456)\n"
"    \"456\"\n"
"\n"
"    iex> Integer.to_string(-789)\n"
"    \"-789\"\n"
"\n"
"    iex> Integer.to_string(0123)\n"
"    \"123\"\n"
"\n"
msgstr ""
#. TRANSLATORS: Elixir.Integer Summary
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/integer.ex:2 
msgid ""
"Functions for working with integers.\n"
msgstr ""
#. TRANSLATORS: def Integer.to_charlist(integer)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/integer.ex:355 
msgid ""
"Returns a charlist which corresponds to the text representation of the given `integer`.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Integer.to_charlist(123)\n"
"    '123'\n"
"\n"
"    iex> Integer.to_charlist(+456)\n"
"    '456'\n"
"\n"
"    iex> Integer.to_charlist(-789)\n"
"    '-789'\n"
"\n"
"    iex> Integer.to_charlist(0123)\n"
"    '123'\n"
"\n"
msgstr ""
#. TRANSLATORS: defmacro Integer.is_even(integer)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/integer.ex:35 
msgid ""
"Determines if an `integer` is even.\n"
"\n"
"Returns `true` if the given `integer` is an even number,\n"
"otherwise it returns `false`.\n"
"\n"
"Allowed in guard clauses.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Integer.is_even(10)\n"
"    true\n"
"\n"
"    iex> Integer.is_even(5)\n"
"    false\n"
"\n"
"    iex> Integer.is_even(-10)\n"
"    true\n"
"\n"
"    iex> Integer.is_even(0)\n"
"    true\n"
"\n"
msgstr ""
#. TRANSLATORS: def Integer.digits(integer, base \\ 10)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/integer.ex:120 
msgid ""
"Returns the ordered digits for the given `integer`.\n"
"\n"
"An optional `base` value may be provided representing the radix for the returned\n"
"digits. This one must be an integer >= 2.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Integer.digits(123)\n"
"    [1, 2, 3]\n"
"\n"
"    iex> Integer.digits(170, 2)\n"
"    [1, 0, 1, 0, 1, 0, 1, 0]\n"
"\n"
"    iex> Integer.digits(-170, 2)\n"
"    [-1, 0, -1, 0, -1, 0, -1, 0]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Integer.undigits(digits, base \\ 10)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/integer.ex:155 
msgid ""
"Returns the integer represented by the ordered `digits`.\n"
"\n"
"An optional `base` value may be provided representing the radix for the `digits`.\n"
"This one can be an integer >= 2.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Integer.undigits([1, 2, 3])\n"
"    123\n"
"\n"
"    iex> Integer.undigits([1, 4], 16)\n"
"    20\n"
"\n"
"    iex> Integer.undigits([])\n"
"    0\n"
"\n"
msgstr ""
