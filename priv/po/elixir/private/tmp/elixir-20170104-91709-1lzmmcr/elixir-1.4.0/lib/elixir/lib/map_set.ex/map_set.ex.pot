#. TRANSLATORS: def MapSet.member?(map_set, value)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/map_set.ex:241 
msgid ""
"Checks if `set` contains `value`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> MapSet.member?(MapSet.new([1, 2, 3]), 2)\n"
"    true\n"
"    iex> MapSet.member?(MapSet.new([1, 2, 3]), 4)\n"
"    false\n"
"\n"
msgstr ""
#. TRANSLATORS: def MapSet.new(mapset)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/map_set.ex:54 
msgid ""
"Creates a set from an enumerable.\n"
"\n"
"## Examples\n"
"\n"
"    iex> MapSet.new([:b, :a, 3])\n"
"    #MapSet<[3, :a, :b]>\n"
"    iex> MapSet.new([3, 3, 3, 2, 2, 1])\n"
"    #MapSet<[1, 2, 3]>\n"
"\n"
msgstr ""
#. TRANSLATORS: def MapSet.put(set, value)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/map_set.ex:257 
msgid ""
"Inserts `value` into `set` if `set` doesn't already contain it.\n"
"\n"
"## Examples\n"
"\n"
"    iex> MapSet.put(MapSet.new([1, 2, 3]), 3)\n"
"    #MapSet<[1, 2, 3]>\n"
"    iex> MapSet.put(MapSet.new([1, 2, 3]), 4)\n"
"    #MapSet<[1, 2, 3, 4]>\n"
"\n"
msgstr ""
#. TRANSLATORS: def MapSet.intersection(map_set1, map_set2)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/map_set.ex:222 
msgid ""
"Returns a set containing only members that `set1` and `set2` have in common.\n"
"\n"
"## Examples\n"
"\n"
"    iex> MapSet.intersection(MapSet.new([1, 2]), MapSet.new([2, 3, 4]))\n"
"    #MapSet<[2]>\n"
"\n"
"    iex> MapSet.intersection(MapSet.new([1, 2]), MapSet.new([3, 4]))\n"
"    #MapSet<[]>\n"
"\n"
msgstr ""
#. TRANSLATORS: def MapSet.equal?(map_set1, map_set2)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/map_set.ex:204 
msgid ""
"Checks if two sets are equal.\n"
"\n"
"The comparison between elements must be done using `===`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> MapSet.equal?(MapSet.new([1, 2]), MapSet.new([2, 1, 1]))\n"
"    true\n"
"    iex> MapSet.equal?(MapSet.new([1, 2]), MapSet.new([3, 4]))\n"
"    false\n"
"\n"
msgstr ""
#. TRANSLATORS: def MapSet.subset?(map_set1, map_set2)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/map_set.ex:287 
msgid ""
"Checks if `set1`'s members are all contained in `set2`.\n"
"\n"
"This function checks if `set1` is a subset of `set2`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> MapSet.subset?(MapSet.new([1, 2]), MapSet.new([1, 2, 3]))\n"
"    true\n"
"    iex> MapSet.subset?(MapSet.new([1, 2, 3]), MapSet.new([1, 2]))\n"
"    false\n"
"\n"
msgstr ""
#. TRANSLATORS: def MapSet.size(map_set)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/map_set.ex:273 
msgid ""
"Returns the number of elements in `set`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> MapSet.size(MapSet.new([1, 2, 3]))\n"
"    3\n"
"\n"
msgstr ""
#. TRANSLATORS: def MapSet.union(map_set1, map_set2)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/map_set.ex:334 
msgid ""
"Returns a set containing all members of `set1` and `set2`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> MapSet.union(MapSet.new([1, 2]), MapSet.new([2, 3, 4]))\n"
"    #MapSet<[1, 2, 3, 4]>\n"
"\n"
msgstr ""
#. TRANSLATORS: def MapSet.difference(mapset1, mapset2)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/map_set.ex:132 
msgid ""
"Returns a set that is `set1` without the members of `set2`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> MapSet.difference(MapSet.new([1, 2]), MapSet.new([2, 3, 4]))\n"
"    #MapSet<[1]>\n"
"\n"
msgstr ""
#. TRANSLATORS: def MapSet.new(enumerable, transform)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/map_set.ex:76 
msgid ""
"Creates a mapset from an enumerable via the transformation function.\n"
"\n"
"## Examples\n"
"\n"
"    iex> MapSet.new([1, 2, 1], fn x -> 2 * x end)\n"
"    #MapSet<[2, 4]>\n"
"\n"
msgstr ""
#. TRANSLATORS: def MapSet.disjoint?(map_set1, map_set2)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/map_set.ex:174 
msgid ""
"Checks if `set1` and `set2` have no members in common.\n"
"\n"
"## Examples\n"
"\n"
"    iex> MapSet.disjoint?(MapSet.new([1, 2]), MapSet.new([3, 4]))\n"
"    true\n"
"    iex> MapSet.disjoint?(MapSet.new([1, 2]), MapSet.new([2, 3]))\n"
"    false\n"
"\n"
msgstr ""
#. TRANSLATORS: def MapSet.delete(set, value)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/map_set.ex:113 
msgid ""
"Deletes `value` from `set`.\n"
"\n"
"Returns a new set which is a copy of `set` but without `value`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> set = MapSet.new([1, 2, 3])\n"
"    iex> MapSet.delete(set, 4)\n"
"    #MapSet<[1, 2, 3]>\n"
"    iex> MapSet.delete(set, 2)\n"
"    #MapSet<[1, 3]>\n"
"\n"
msgstr ""
#. TRANSLATORS: def MapSet.to_list(map_set)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/map_set.ex:320 
msgid ""
"Converts `set` to a list.\n"
"\n"
"## Examples\n"
"\n"
"    iex> MapSet.to_list(MapSet.new([1, 2, 3]))\n"
"    [1, 2, 3]\n"
"\n"
msgstr ""
#. TRANSLATORS: def MapSet.new()
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/map_set.ex:42 
msgid ""
"Returns a new set.\n"
"\n"
"## Examples\n"
"\n"
"    iex> MapSet.new\n"
"    #MapSet<[]>\n"
"\n"
msgstr ""
#. TRANSLATORS: Elixir.MapSet Summary
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/map_set.ex:2 
msgid ""
"Functions that work on sets.\n"
"\n"
"`MapSet` is the \"go to\" set data structure in Elixir. A set can be constructed\n"
"using `MapSet.new/0`:\n"
"\n"
"    iex> MapSet.new\n"
"    #MapSet<[]>\n"
"\n"
"A set can contain any kind of elements and elements in a set don't have to be\n"
"of the same type. By definition, sets can't contain duplicate elements: when\n"
"inserting an element in a set where it's already present, the insertion is\n"
"simply a no-op.\n"
"\n"
"    iex> set = MapSet.new\n"
"    iex> MapSet.put(set, \"foo\")\n"
"    #MapSet<[\"foo\"]>\n"
"    iex> set |> MapSet.put(\"foo\") |> MapSet.put(\"foo\")\n"
"    #MapSet<[\"foo\"]>\n"
"\n"
"A `MapSet` is represented internally using the `%MapSet{}` struct. This struct\n"
"can be used whenever there's a need to pattern match on something being a `MapSet`:\n"
"\n"
"    iex> match?(%MapSet{}, MapSet.new())\n"
"    true\n"
"\n"
"Note that, however, the struct fields are private and must not be accessed\n"
"directly; use the functions in this module to perform operations on sets.\n"
"\n"
"Sets can also be constructed starting from other collection-type data\n"
"structures: for example, see `MapSet.new/1` or `Enum.into/2`.\n"
msgstr ""
