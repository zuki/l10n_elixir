msgid ""
msgstr ""
"Project-Id-Version: l 10n_elixir\n"
"PO-Revision-Date: 2015-12-16 23:29+0900\n"
"Last-Translator: 小田 照敬 <EMAIL@ADDRESS>\n"
"Language-Team: Japanese\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#. TRANSLATORS: def List.keydelete(list, key, position)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/list.ex:339
#, fuzzy
msgid ""
"Receives a `list` of tuples and deletes the first tuple\n"
"where the item at `position` matches the\n"
"given `key`. Returns the new list.\n"
"\n"
"## Examples\n"
"\n"
"    iex> List.keydelete([a: 1, b: 2], :a, 0)\n"
"    [b: 2]\n"
"\n"
"    iex> List.keydelete([a: 1, b: 2], 2, 1)\n"
"    [a: 1]\n"
"\n"
"    iex> List.keydelete([a: 1, b: 2], :c, 0)\n"
"    [a: 1, b: 2]\n"
"\n"
msgstr ""
"タプルのリストを受け取り、`position`の位置のアイテムが\n"
"与えられた`item`にマッチする最初のタプルを削除します。\n"
"新しいリストを返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> List.keydelete([a: 1, b: 2], :a, 0)\n"
"    [b: 2]\n"
"\n"
"    iex> List.keydelete([a: 1, b: 2], 2, 1)\n"
"    [a: 1]\n"
"\n"
"    iex> List.keydelete([a: 1, b: 2], :c, 0)\n"
"    [a: 1, b: 2]\n"
"\n"

#. TRANSLATORS: def List.foldr(list, acc, function)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/list.ex:188
#, fuzzy
msgid ""
"Folds (reduces) the given list from the right with\n"
"a function. Requires an accumulator.\n"
"\n"
"## Examples\n"
"\n"
"    iex> List.foldr([1, 2, 3, 4], 0, fn(x, acc) -> x - acc end)\n"
"    -2\n"
"\n"
msgstr ""
"与えられたリストを、関数で右からフォールド(reduce)ます。\n"
"アキュムレータは必須です。\n"
"\n"
"## 例\n"
"\n"
"    iex> List.foldr([1, 2, 3, 4], 0, fn (x, acc) -> x - acc end)\n"
"    -2\n"
"\n"

#. TRANSLATORS: def List.keytake(list, key, position)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/list.ex:361
msgid ""
"Receives a `list` of tuples and returns the first tuple\n"
"where the element at `position` in the tuple matches the\n"
"given `key`, as well as the `list` without found tuple.\n"
"\n"
"If such a tuple is not found, `nil` will be returned.\n"
"\n"
"## Examples\n"
"\n"
"    iex> List.keytake([a: 1, b: 2], :a, 0)\n"
"    {{:a, 1}, [b: 2]}\n"
"\n"
"    iex> List.keytake([a: 1, b: 2], 2, 1)\n"
"    {{:b, 2}, [a: 1]}\n"
"\n"
"    iex> List.keytake([a: 1, b: 2], :c, 0)\n"
"    nil\n"
"\n"
msgstr ""
"タプルのリストを受け取り、リストの各タプル内の\n"
"`position`番目のアイテムが、与えられた`key`にマッチする、\n"
"最初のタプルと、それを取り除いたリストで出来たタプルを返\n"
"します。\n"
"\n"
"そのようなタプルがない時は`nil`を返します。\n"
"\n"
"## Examples\n"
"\n"
"    iex> List.keytake([a: 1, b: 2], :a, 0)\n"
"    {{:a, 1}, [b: 2]}\n"
"\n"
"    iex> List.keytake([a: 1, b: 2], 2, 1)\n"
"    {{:b, 2}, [a: 1]}\n"
"\n"
"    iex> List.keytake([a: 1, b: 2], :c, 0)\n"
"    nil\n"
"\n"

#. TRANSLATORS: def List.to_string(list)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/list.ex:686
msgid ""
"Converts a list of integers representing codepoints, lists or\n"
"strings into a string.\n"
"\n"
"Notice that this function expects a list of integers representing\n"
"UTF-8 codepoints. If you have a list of bytes, you must instead use\n"
"the [`:binary` module](http://www.erlang.org/doc/man/binary.html).\n"
"\n"
"## Examples\n"
"\n"
"    iex> List.to_string([0x00E6, 0x00DF])\n"
"    \"æß\"\n"
"\n"
"    iex> List.to_string([0x0061, \"bc\"])\n"
"    \"abc\"\n"
"\n"
msgstr ""
"コードポイントで表現された整数、リスト、文字列のリストを、\n"
"文字列に変換します。\n"
"\n"
"この関数は、UTF-8コードポイントで表現される整数のリストを期待している\n"
"ことに、注意してください。\n"
"もしバイトのリストをもっていたら、[`:binary`モジュール](http://erlang.org/"
"doc/man/binary.html)\n"
"を代りに使わなければなりません。\n"
"\n"
"## 例\n"
"\n"
"    iex> List.to_string([0x00E6, 0x00DF])\n"
"    \"æß\"\n"
"\n"
"    iex> List.to_string([0x0061, \"bc\"])\n"
"    \"abc\"\n"
"\n"

#. TRANSLATORS: def List.myers_difference(list1, list2)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/list.ex:734
msgid ""
"Returns a keyword list that represents an *edit script*.\n"
"\n"
"The algorithm is outlined in the\n"
"\"An O(ND) Difference Algorithm and Its Variations\" paper by E. Myers.\n"
"\n"
"An *edit script* is a keyword list. Each key describes the \"editing action"
"\" to\n"
"take in order to bring `list1` closer to being equal to `list2`; a key can "
"be\n"
"`:eq`, `:ins`, or `:del`. Each value is a sublist of either `list1` or "
"`list2`\n"
"that should be inserted (if the corresponding key `:ins`), deleted (if the\n"
"corresponding key is `:del`), or left alone (if the corresponding key is\n"
"`:eq`) in `list1` in order to be closer to `list2`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> List.myers_difference([1, 4, 2, 3], [1, 2, 3, 4])\n"
"    [eq: [1], del: [4], eq: [2, 3], ins: [4]]\n"
"\n"
msgstr ""

#. TRANSLATORS: def List.flatten(list)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/list.ex:140
msgid ""
"Flattens the given `list` of nested lists.\n"
"\n"
"## Examples\n"
"\n"
"    iex> List.flatten([1, [[2], 3]])\n"
"    [1, 2, 3]\n"
"\n"
msgstr ""
"与えられた、ネストしたリスト`list`をフラット化します。\n"
"\n"
"## 例\n"
"\n"
"    iex> List.flatten([1, [[2], 3]])\n"
"    [1, 2, 3]\n"
"\n"

#. TRANSLATORS: def List.duplicate(elem, n)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/list.ex:123
#, fuzzy
msgid ""
"Duplicates the given element `n` times in a list.\n"
"\n"
"## Examples\n"
"\n"
"    iex> List.duplicate(\"hello\", 3)\n"
"    [\"hello\", \"hello\", \"hello\"]\n"
"\n"
"    iex> List.duplicate([1, 2], 2)\n"
"    [[1, 2], [1, 2]]\n"
"\n"
msgstr ""
"リストの与えられた要素を`n`回複製します。\n"
"\n"
"## 例\n"
"\n"
"    iex> List.duplicate(\"hello\", 3)\n"
"    [\"hello\", \"hello\", \"hello\"]\n"
"\n"
"    iex> List.duplicate([1, 2], 2)\n"
"    [[1, 2], [1, 2]]\n"
"\n"

#. TRANSLATORS: def List.to_integer(charlist)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/list.ex:638
#, fuzzy
msgid ""
"Returns an integer whose text representation is `charlist`.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> List.to_integer('123')\n"
"    123\n"
"\n"
msgstr ""
"テキスト表現が`char_list`である整数を返します。\n"
"\n"
"コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> List.to_integer('123')\n"
"    123\n"
"\n"

#. TRANSLATORS: def List.delete_at(list, index)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/list.ex:529
#, fuzzy
msgid ""
"Produces a new list by removing the value at the specified `index`.\n"
"\n"
"Negative indices indicate an offset from the end of the `list`.\n"
"If `index` is out of bounds, the original `list` is returned.\n"
"\n"
"## Examples\n"
"\n"
"    iex> List.delete_at([1, 2, 3], 0)\n"
"    [2, 3]\n"
"\n"
"    iex> List.delete_at([1, 2, 3], 10)\n"
"    [1, 2, 3]\n"
"\n"
"    iex> List.delete_at([1, 2, 3], -1)\n"
"    [1, 2]\n"
"\n"
msgstr ""
"指定された`index`の値を削除した、新しいリストを提供します。\n"
"負のインデックスはリストの終わりからのオフセットを示します。\n"
"もし`index`が範囲外なら、オリジナルの`list`が返されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> List.delete_at([1, 2, 3], 0)\n"
"    [2, 3]\n"
"\n"
"    iex List.delete_at([1, 2, 3], 10)\n"
"    [1, 2, 3]\n"
"\n"
"    iex> List.delete_at([1, 2, 3], -1)\n"
"    [1, 2]\n"
"\n"

#. TRANSLATORS: def List.insert_at(list, index, value)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/list.ex:439
#, fuzzy
msgid ""
"Returns a list with `value` inserted at the specified `index`.\n"
"\n"
"Note that `index` is capped at the list length. Negative indices\n"
"indicate an offset from the end of the `list`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> List.insert_at([1, 2, 3, 4], 2, 0)\n"
"    [1, 2, 0, 3, 4]\n"
"\n"
"    iex> List.insert_at([1, 2, 3], 10, 0)\n"
"    [1, 2, 3, 0]\n"
"\n"
"    iex> List.insert_at([1, 2, 3], -1, 0)\n"
"    [1, 2, 3, 0]\n"
"\n"
"    iex> List.insert_at([1, 2, 3], -10, 0)\n"
"    [0, 1, 2, 3]\n"
"\n"
msgstr ""
"`value`を指定された`index`の位置に挿入したリストを返します。\n"
"`index`は、リストの長さでキャップされることに注意してください。\n"
"負のインデックスはリストの末尾からのオフセットを指示します。\n"
"\n"
"## 例\n"
"\n"
"    iex> List.insert_at([1, 2, 3, 4], 2, 0)\n"
"    [1, 2, 0, 3, 4]\n"
"\n"
"    iex> List.insert_at([1, 2, 3], 10, 0)\n"
"    [1, 2, 3, 0]\n"
"\n"
"    iex> List.insert_at([1, 2, 3], -1, 0)\n"
"    [1, 2, 3, 0]\n"
"\n"
"    iex> List.insert_at([1, 2, 3], -10, 0)\n"
"    [0, 1, 2, 3]\n"
"\n"

#. TRANSLATORS: def List.to_tuple(list)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/list.ex:670
msgid ""
"Converts a list to a tuple.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> List.to_tuple([:share, [:elixir, 163]])\n"
"    {:share, [:elixir, 163]}\n"
"\n"
msgstr ""
"リストをタプルに変換します。\n"
"\n"
"コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> List.to_tuple([:share, [:elixir, 163]])\n"
"    {:share, [:elixir, 163]}\n"
"\n"

#. TRANSLATORS: def List.keysort(list, position)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/list.ex:301
msgid ""
"Receives a list of tuples and sorts the items\n"
"at `position` of the tuples. The sort is stable.\n"
"\n"
"## Examples\n"
"\n"
"    iex> List.keysort([a: 5, b: 1, c: 3], 1)\n"
"    [b: 1, c: 3, a: 5]\n"
"\n"
"    iex> List.keysort([a: 5, c: 1, b: 3], 0)\n"
"    [a: 5, b: 3, c: 1]\n"
"\n"
msgstr ""
"タプルの`position`でアイテムをソートしタプルのリストを返します。\n"
"ソートは安定的です。\n"
"\n"
"## 例\n"
"\n"
"    iex> List.keysort([a: 5, b: 1, c: 3], 1)\n"
"    [b: 1, c: 3, a: 5]\n"
"\n"
"    iex> List.keysort([a: 5, c: 1, b: 3], 0)\n"
"    [a: 5, b: 3, c: 1]\n"
"\n"

#. TRANSLATORS: Elixir.List Summary
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/list.ex:2
msgid ""
"Functions that work on (linked) lists.\n"
"\n"
"Lists in Elixir are specified between square brackets:\n"
"\n"
"    iex> [1, \"two\", 3, :four]\n"
"    [1, \"two\", 3, :four]\n"
"\n"
"Two lists can be concatenated and subtracted using the\n"
"`Kernel.++/2` and `Kernel.--/2` operators:\n"
"\n"
"    iex> [1, 2, 3] ++ [4, 5, 6]\n"
"    [1, 2, 3, 4, 5, 6]\n"
"    iex> [1, true, 2, false, 3, true] -- [true, false]\n"
"    [1, 2, 3, true]\n"
"\n"
"Lists in Elixir are effectively linked lists, which means\n"
"they are internally represented in pairs containing the\n"
"head and the tail of a list:\n"
"\n"
"    iex> [head | tail] = [1, 2, 3]\n"
"    iex> head\n"
"    1\n"
"    iex> tail\n"
"    [2, 3]\n"
"\n"
"Similarly, we could write the list `[1, 2, 3]` using only\n"
"such pairs (called cons cells):\n"
"\n"
"    iex> [1 | [2 | [3 | []]]]\n"
"    [1, 2, 3]\n"
"\n"
"Some lists, called improper lists, do not have an empty list as\n"
"the second element in the last cons cell:\n"
"\n"
"    iex> [1 | [2 | [3 | 4]]]\n"
"    [1, 2, 3 | 4]\n"
"\n"
"Although improper lists are generally avoided, they are used in some\n"
"special circumstances like iodata and chardata entities (see the `IO` "
"module).\n"
"\n"
"Due to their cons cell based representation, prepending an element\n"
"to a list is always fast (constant time), while appending becomes\n"
"slower as the list grows in size (linear time):\n"
"\n"
"    iex> list = [1, 2, 3]\n"
"    iex> [0 | list]   # fast\n"
"    [0, 1, 2, 3]\n"
"    iex> list ++ [4]  # slow\n"
"    [1, 2, 3, 4]\n"
"\n"
"The `Kernel` module contains many functions to manipulate lists\n"
"and that are allowed in guards. For example, `Kernel.hd/1` to\n"
"retrieve the head, `Kernel.tl/1` to fetch the tail and\n"
"`Kernel.length/1` for calculating the length. Keep in mind that,\n"
"similar to appending to a list, calculating the length needs to\n"
"traverse the whole list.\n"
"\n"
"## Charlists\n"
"\n"
"If a list is made of non-negative integers, it can also be called\n"
"a charlist. Elixir uses single quotes to define charlists:\n"
"\n"
"    iex> 'héllo'\n"
"    [104, 233, 108, 108, 111]\n"
"\n"
"In particular, charlists may be printed back in single\n"
"quotes if they contain only ASCII-printable codepoints:\n"
"\n"
"    iex> 'abc'\n"
"    'abc'\n"
"\n"
"The rationale behind this behaviour is to better support\n"
"Erlang libraries which may return text as charlists\n"
"instead of Elixir strings. One example of such functions\n"
"is `Application.loaded_applications/0`:\n"
"\n"
"    Application.loaded_applications\n"
"    #=>  [{:stdlib, 'ERTS  CXC 138 10', '2.6'},\n"
"          {:compiler, 'ERTS  CXC 138 10', '6.0.1'},\n"
"          {:elixir, 'elixir', '1.0.0'},\n"
"          {:kernel, 'ERTS  CXC 138 10', '4.1'},\n"
"          {:logger, 'logger', '1.0.0'}]\n"
"\n"
"## List and Enum modules\n"
"\n"
"This module aims to provide operations that are specific\n"
"to lists, like conversion between data types, updates,\n"
"deletions and key lookups (for lists of tuples). For traversing\n"
"lists in general, developers should use the functions in the\n"
"`Enum` module that work across a variety of data types.\n"
"\n"
"In both `Enum` and `List` modules, any kind of index access\n"
"on a list is linear. Negative indexes are also supported but\n"
"they imply the list will be iterated twice, one to calculate\n"
"the proper index and another to perform the operation.\n"
msgstr ""

#. TRANSLATORS: def List.keyfind(list, key, position, default \\ nil)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/list.ex:242
msgid ""
"Receives a list of tuples and returns the first tuple\n"
"where the item at `position` in the tuple matches the\n"
"given `key`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> List.keyfind([a: 1, b: 2], :a, 0)\n"
"    {:a, 1}\n"
"\n"
"    iex> List.keyfind([a: 1, b: 2], 2, 1)\n"
"    {:b, 2}\n"
"\n"
"    iex> List.keyfind([a: 1, b: 2], :c, 0)\n"
"    nil\n"
"\n"
msgstr ""
"タプルのリストを受け取り、リストの各タプル内の`position`番目のアイテム\n"
"が、与えられた`key`にマッチする、最初のタプルを返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> List.keyfind([a: 1, b: 2], :a, 0)\n"
"    {:a, 1}\n"
"\n"
"    iex> List.keyfind([a: 1, b: 2], 2, 1)\n"
"    {:b, 2}\n"
"\n"
"    iex> List.keyfind([a: 1, b: 2], :c, 0)\n"
"    nil\n"
"\n"

#. TRANSLATORS: def List.wrap(list)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/list.ex:388
#, fuzzy
msgid ""
"Wraps the argument in a list.\n"
"\n"
"If the argument is already a list, returns the list.\n"
"If the argument is `nil`, returns an empty list.\n"
"\n"
"## Examples\n"
"\n"
"    iex> List.wrap(\"hello\")\n"
"    [\"hello\"]\n"
"\n"
"    iex> List.wrap([1, 2, 3])\n"
"    [1, 2, 3]\n"
"\n"
"    iex> List.wrap(nil)\n"
"    []\n"
"\n"
msgstr ""
"リストに引数をラップします。\n"
"もし引数が既にリストなら、そのリストを返します。\n"
"もし引数が`nil`なら、空のリストを返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> List.wrap(\"hello\")\n"
"    [\"hello\"]\n"
"\n"
"    iex> List.wrap([1, 2, 3])\n"
"    [1, 2, 3]\n"
"\n"
"    iex> List.wrap(nil)\n"
"    []\n"
"\n"

#. TRANSLATORS: def List.update_at(list, index, fun)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/list.ex:499
#, fuzzy
msgid ""
"Returns a list with an updated value at the specified `index`.\n"
"\n"
"Negative indices indicate an offset from the end of the `list`.\n"
"If `index` is out of bounds, the original `list` is returned.\n"
"\n"
"## Examples\n"
"\n"
"    iex> List.update_at([1, 2, 3], 0, &(&1 + 10))\n"
"    [11, 2, 3]\n"
"\n"
"    iex> List.update_at([1, 2, 3], 10, &(&1 + 10))\n"
"    [1, 2, 3]\n"
"\n"
"    iex> List.update_at([1, 2, 3], -1, &(&1 + 10))\n"
"    [1, 2, 13]\n"
"\n"
"    iex> List.update_at([1, 2, 3], -10, &(&1 + 10))\n"
"    [1, 2, 3]\n"
"\n"
msgstr ""
"`index`で指定された場所の値をfunで更新したリストを返します。\n"
"負のインデックスはリストの末尾からのオフセットを示します。\n"
"もし`index`が境界の外なら、オリジナルの`list`が返されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> List.update_at([1, 2, 3], 0, &(&1 + 10))\n"
"    [11, 2, 3]\n"
"\n"
"    iex> List.update_at([1, 2, 3], 10, &(&1 + 10))\n"
"    [1, 2, 3]\n"
"\n"
"    iex> List.update_at([1, 2, 3], -1, &(&1 + 10))\n"
"    [1, 2, 13]\n"
"\n"
"    iex> List.update_at([1, 2, 3], -10, &(&1 + 10))\n"
"    [1, 2, 3]\n"
"\n"

#. TRANSLATORS: def List.last(list)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/list.ex:222
msgid ""
"Returns the last element in `list` or `nil` if `list` is empty.\n"
"\n"
"## Examples\n"
"\n"
"    iex> List.last([])\n"
"    nil\n"
"\n"
"    iex> List.last([1])\n"
"    1\n"
"\n"
"    iex> List.last([1, 2, 3])\n"
"    3\n"
"\n"
msgstr ""
"`list`の最後の要素、または`list`が空なら`nil`を返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> List.last([])\n"
"    nil\n"
"\n"
"    iex> List.last([1])\n"
"    1\n"
"\n"
"    iex> List.last([1, 2, 3])\n"
"    3\n"
"\n"

#. TRANSLATORS: def List.keystore(list, key, position, new_tuple)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/list.ex:319
#, fuzzy
msgid ""
"Receives a `list` of tuples and replaces the item\n"
"identified by `key` at `position`.\n"
"\n"
"If the item does not exist, it is added to the end of the `list`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> List.keystore([a: 1, b: 2], :a, 0, {:a, 3})\n"
"    [a: 3, b: 2]\n"
"\n"
"    iex> List.keystore([a: 1, b: 2], :c, 0, {:c, 3})\n"
"    [a: 1, b: 2, c: 3]\n"
"\n"
msgstr ""
"タプルのリストを受け取り、`position`の位置の`key`により指定された、アイ\n"
"テムを置き換えます。アイテムが存在しないなら、それは、リストの末尾に追\n"
"加されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> List.keystore([a: 1, b: 2], :a, 0, {:a, 3})\n"
"    [a: 3, b: 2]\n"
"\n"
"    iex> List.keystore([a: 1, b: 2], :c, 0, {:c, 3})\n"
"    [a: 1, b: 2, c: 3]\n"
"\n"

#. TRANSLATORS: def List.replace_at(list, index, value)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/list.ex:469
#, fuzzy
msgid ""
"Returns a list with a replaced value at the specified `index`.\n"
"\n"
"Negative indices indicate an offset from the end of the `list`.\n"
"If `index` is out of bounds, the original `list` is returned.\n"
"\n"
"## Examples\n"
"\n"
"    iex> List.replace_at([1, 2, 3], 0, 0)\n"
"    [0, 2, 3]\n"
"\n"
"    iex> List.replace_at([1, 2, 3], 10, 0)\n"
"    [1, 2, 3]\n"
"\n"
"    iex> List.replace_at([1, 2, 3], -1, 0)\n"
"    [1, 2, 0]\n"
"\n"
"    iex> List.replace_at([1, 2, 3], -10, 0)\n"
"    [1, 2, 3]\n"
"\n"
msgstr ""
"`index`で指定された場所の値を入れ替えたリストを返します。\n"
"負のインデックスはリストの末尾からのオフセットを示します。\n"
"もし`index`が境界の外なら、オリジナルの`list`が返されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> List.replace_at([1, 2, 3], 0, 0)\n"
"    [0, 2, 3]\n"
"\n"
"    iex> List.replace_at([1, 2, 3], 10, 0)\n"
"    [1, 2, 3]\n"
"\n"
"    iex> List.replace_at([1, 2, 3], -1, 0)\n"
"    [1, 2, 0]\n"
"\n"
"    iex> List.replace_at([1, 2, 3], -10, 0)\n"
"    [1, 2, 3]\n"
"\n"

#. TRANSLATORS: def List.to_float(charlist)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/list.ex:622
#, fuzzy
msgid ""
"Returns the float whose text representation is `charlist`.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> List.to_float('2.2017764e+0')\n"
"    2.2017764\n"
"\n"
msgstr ""
"テキスト表現が`char_list`である浮動小数点数を返します。\n"
"\n"
"コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> List.to_float('2.2017764e+0')\n"
"    2.2017764\n"
"\n"

#. TRANSLATORS: def List.pop_at(list, index, default \\ nil)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/list.ex:552
#, fuzzy
msgid ""
"Returns and removes the value at the specified `index` in the `list`.\n"
"\n"
"Negative indices indicate an offset from the end of the `list`.\n"
"If `index` is out of bounds, the original `list` is returned.\n"
"\n"
"## Examples\n"
"\n"
"    iex> List.pop_at([1, 2, 3], 0)\n"
"    {1, [2, 3]}\n"
"    iex> List.pop_at([1, 2, 3], 5)\n"
"    {nil, [1, 2, 3]}\n"
"    iex> List.pop_at([1, 2, 3], 5, 10)\n"
"    {10, [1, 2, 3]}\n"
"    iex> List.pop_at([1, 2, 3], -1)\n"
"    {3, [1, 2]}\n"
"\n"
msgstr ""
"`index`で指定された場所の値を入れ替えたリストを返します。\n"
"負のインデックスはリストの末尾からのオフセットを示します。\n"
"もし`index`が境界の外なら、オリジナルの`list`が返されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> List.replace_at([1, 2, 3], 0, 0)\n"
"    [0, 2, 3]\n"
"\n"
"    iex> List.replace_at([1, 2, 3], 10, 0)\n"
"    [1, 2, 3]\n"
"\n"
"    iex> List.replace_at([1, 2, 3], -1, 0)\n"
"    [1, 2, 0]\n"
"\n"
"    iex> List.replace_at([1, 2, 3], -10, 0)\n"
"    [1, 2, 3]\n"
"\n"

#. TRANSLATORS: def List.keymember?(list, key, position)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/list.ex:264
msgid ""
"Receives a list of tuples and returns `true` if there is\n"
"a tuple where the item at `position` in the tuple matches\n"
"the given `key`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> List.keymember?([a: 1, b: 2], :a, 0)\n"
"    true\n"
"\n"
"    iex> List.keymember?([a: 1, b: 2], 2, 1)\n"
"    true\n"
"\n"
"    iex> List.keymember?([a: 1, b: 2], :c, 0)\n"
"    false\n"
"\n"
msgstr ""
"タプルのリストを受け取り、リストの各タプル内の`position`番目のアイテム\n"
"が、与えられた`item`にマッチするタプルがあれば、`true`を\n"
"返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> List.keymember?([a: 1, b: 2], :a, 0)\n"
"    true\n"
"\n"
"    iex> List.keymember?([a: 1, b: 2], 2, 1)\n"
"    true\n"
"\n"
"    iex> List.keymember?([a: 1, b: 2], :c, 0)\n"
"    false\n"
"\n"

#. TRANSLATORS: def List.foldl(list, acc, function)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/list.ex:170
#, fuzzy
msgid ""
"Folds (reduces) the given list from the left with\n"
"a function. Requires an accumulator.\n"
"\n"
"## Examples\n"
"\n"
"    iex> List.foldl([5, 5], 10, fn(x, acc) -> x + acc end)\n"
"    20\n"
"\n"
"    iex> List.foldl([1, 2, 3, 4], 0, fn(x, acc) -> x - acc end)\n"
"    2\n"
"\n"
msgstr ""
"与えられたリストを、関数で左からフォールド(reduce)ます。\n"
"アキュムレータは必須です。\n"
"\n"
"## 例\n"
"\n"
"    iex> List.foldl([5, 5], 10, fn (x, acc) -> x + acc end)\n"
"    20\n"
"\n"
"    iex> List.foldl([1, 2, 3, 4], 0, fn (x, acc) -> x - acc end)\n"
"    2\n"
"\n"

#. TRANSLATORS: def List.keyreplace(list, key, position, new_tuple)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/list.ex:286
msgid ""
"Receives a list of tuples and replaces the item\n"
"identified by `key` at `position` if it exists.\n"
"\n"
"## Examples\n"
"\n"
"    iex> List.keyreplace([a: 1, b: 2], :a, 0, {:a, 3})\n"
"    [a: 3, b: 2]\n"
"\n"
msgstr ""
"タプルのリストを受け取り、もしあれば、`position`の位置の\n"
"`key`により指定されたアイテムを置き換えます。\n"
"\n"
"## 例\n"
"\n"
"    iex> List.keyreplace([a: 1, b: 2], :a, 0, {:a, 3})\n"
"    [a: 3, b: 2]\n"
"\n"

#. TRANSLATORS: def List.zip(list_of_lists)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/list.ex:419
msgid ""
"Zips corresponding elements from each list in `list_of_lists`.\n"
"\n"
"The zipping finishes as soon as any list terminates.\n"
"\n"
"## Examples\n"
"\n"
"    iex> List.zip([[1, 2], [3, 4], [5, 6]])\n"
"    [{1, 3, 5}, {2, 4, 6}]\n"
"\n"
"    iex> List.zip([[1, 2], [3], [5, 6]])\n"
"    [{1, 3, 5}]\n"
"\n"
msgstr ""
"`list_of_list`のそれぞれのリストから対応する要素をzipします。\n"
"\n"
"どれかのリストが終了するとすぐに、zippingも終了します。\n"
"\n"
"## 例\n"
"\n"
"    iex> List.zip([[1, 2], [3, 4], [5, 6]])\n"
"    [{1, 3, 5}, {2, 4, 6}]\n"
"\n"
"    iex> List.zip([[1, 2], [3], [5, 6]])\n"
"    [{1, 3, 5}]\n"
"\n"

#. TRANSLATORS: def List.to_atom(charlist)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/list.ex:579
#, fuzzy
msgid ""
"Converts a charlist to an atom.\n"
"\n"
"Currently Elixir does not support conversions from charlists\n"
"which contains Unicode codepoints greater than 0xFF.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> List.to_atom('elixir')\n"
"    :elixir\n"
"\n"
msgstr ""
"文字リストをアトムに変換します。\n"
"\n"
"現在のElixirは、0xFFを越えるUnicodeコードポイントを含む\n"
"文字リストからの変換をサポートしていません。\n"
"\n"
"コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> List.to_atom('elixir')\n"
"    :elixir\n"
"\n"

#. TRANSLATORS: def List.to_existing_atom(charlist)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/list.ex:598
#, fuzzy
msgid ""
"Converts a charlist to an existing atom. Raises an `ArgumentError`\n"
"if the atom does not exist.\n"
"\n"
"Currently Elixir does not support conversions from charlists\n"
"which contains Unicode codepoints greater than 0xFF.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> _ = :my_atom\n"
"    iex> List.to_existing_atom('my_atom')\n"
"    :my_atom\n"
"\n"
"    iex> List.to_existing_atom('this_atom_will_never_exist')\n"
"    ** (ArgumentError) argument error\n"
"\n"
msgstr ""
"文字リストを既存のatomに変換します。もしatomが存在しないなら\n"
"`ArgumentError`が上ります。\n"
"\n"
"現在のElixirは、0xFFを越えるUnicodeコードポイントを含む\n"
"文字リストからの変換をサポートしていません。\n"
"\n"
"コンパイラによりインライン化されます。\n"
"\n"
"## Examples\n"
"\n"
"    iex> _ = :my_atom\n"
"    iex> List.to_existing_atom('my_atom')\n"
"    :my_atom\n"
"\n"
"    iex> List.to_existing_atom('this_atom_will_never_exist')\n"
"    ** (ArgumentError) argument error\n"
"\n"

#. TRANSLATORS: def List.flatten(list, tail)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/list.ex:154
msgid ""
"Flattens the given `list` of nested lists.\n"
"The list `tail` will be added at the end of\n"
"the flattened list.\n"
"\n"
"## Examples\n"
"\n"
"    iex> List.flatten([1, [[2], 3]], [4, 5])\n"
"    [1, 2, 3, 4, 5]\n"
"\n"
msgstr ""
"与えられた、ネストしたリスト`list`をフラット化します。\n"
"リスト`tail`はフラット化されたlistの終わりに追加されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> List.flatten([1, [[2], 3]], [4, 5])\n"
"    [1, 2, 3, 4, 5]\n"
"\n"

#. TRANSLATORS: def List.first(list)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/list.ex:203
msgid ""
"Returns the first element in `list` or `nil` if `list` is empty.\n"
"\n"
"## Examples\n"
"\n"
"    iex> List.first([])\n"
"    nil\n"
"\n"
"    iex> List.first([1])\n"
"    1\n"
"\n"
"    iex> List.first([1, 2, 3])\n"
"    1\n"
"\n"
msgstr ""
"`list`の最初の要素を返します。`list`が空なら`nil`を返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> List.first([])\n"
"    nil\n"
"\n"
"    iex> List.first([1])\n"
"    1\n"
"\n"
"    iex> List.first([1, 2, 3])\n"
"    1\n"
"\n"

#. TRANSLATORS: def List.to_integer(charlist, base)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/list.ex:654
#, fuzzy
msgid ""
"Returns an integer whose text representation is `charlist` in base `base`.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> List.to_integer('3FF', 16)\n"
"    1023\n"
"\n"
msgstr ""
"テキスト表現が基数`base`の`char_list`である整数を返します。\n"
"\n"
"コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> List.to_integer('3FF', 16)\n"
"    1023\n"
"\n"

#. TRANSLATORS: def List.delete(list, item)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/list.ex:102
#, fuzzy
msgid ""
"Deletes the given `item` from the `list`. Returns a new list without\n"
"the item.\n"
"\n"
"If the `item` occurs more than once in the `list`, just\n"
"the first occurrence is removed.\n"
"\n"
"## Examples\n"
"\n"
"    iex> List.delete([:a, :b, :c], :a)\n"
"    [:b, :c]\n"
"\n"
"    iex> List.delete([:a, :b, :b, :c], :b)\n"
"    [:a, :b, :c]\n"
"\n"
msgstr ""
"リストから与えられたアイテムを削除します。\n"
"そのアイテムを除いたリストを返します。\n"
"もしリストに一つより多くのアイテムがあったら、\n"
"最初の一つだけが削除されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> List.delete([1, 2, 3], 1)\n"
"    [2,3]\n"
"\n"
"    iex> List.delete([1, 2, 2, 3], 2)\n"
"    [1, 2, 3]\n"
"\n"

#~ msgid ""
#~ "Specialized functions that only work on lists.\n"
#~ "\n"
#~ "In general, favor using the `Enum` API instead of `List`.\n"
#~ "\n"
#~ "Index access for list is linear. Negative indexes are also\n"
#~ "supported but they imply the list will be iterated twice,\n"
#~ "one to calculate the proper index and another to perform the\n"
#~ "operation.\n"
#~ "\n"
#~ "A decision was taken to delegate most functions to\n"
#~ "Erlang's standard library but follow Elixir's convention\n"
#~ "of receiving the subject (in this case, a list) as the\n"
#~ "first argument.\n"
#~ "\n"
#~ "## Char lists\n"
#~ "\n"
#~ "If a list is made of non-negative integers, it can also\n"
#~ "be called as a char list. Elixir uses single quotes to\n"
#~ "define char lists:\n"
#~ "\n"
#~ "    iex> 'héllo'\n"
#~ "    [104, 233, 108, 108, 111]\n"
#~ "\n"
#~ "In particular, char lists may be printed back in single\n"
#~ "quotes if they contain only ASCII-printable codepoints:\n"
#~ "\n"
#~ "    iex> 'abc'\n"
#~ "    'abc'\n"
#~ "\n"
#~ "The rationale behind this behaviour is to better support\n"
#~ "Erlang libraries which may return text as char lists\n"
#~ "instead of Elixir strings. One example of such functions\n"
#~ "is `Application.loaded_applications`:\n"
#~ "\n"
#~ "    Application.loaded_applications\n"
#~ "    #=>  [{:stdlib, 'ERTS  CXC 138 10', '2.6'},\n"
#~ "          {:compiler, 'ERTS  CXC 138 10', '6.0.1'},\n"
#~ "          {:elixir, 'elixir', '1.0.0'},\n"
#~ "          {:kernel, 'ERTS  CXC 138 10', '4.1'},\n"
#~ "          {:logger, 'logger', '1.0.0'}]\n"
#~ msgstr ""
#~ "リストでのみ働く特別な関数です。\n"
#~ "\n"
#~ "一般に、`List`の代りに`Enum` API を使うことを好みます。\n"
#~ "\n"
#~ "リストのインデックスアクセスは線形の時間が掛ります。\n"
#~ "負のインデックスもサポートされていますが、リストは\n"
#~ "暗黙的に2囘走査されます。一つは適切なインデックスを\n"
#~ "計算するために、そしてもう一つは操作を実行するためです。\n"
#~ "\n"
#~ "\n"
#~ "Erlangの標準ライブラリに殆どの関数は委譲することを決定\n"
#~ "しましたが、最初の引数として処理対象(この場合、\n"
#~ "リストです)を渡すというElixirの習慣に従っています。\n"
#~ "\n"
#~ "## Char lists\n"
#~ "\n"
#~ "もしリストが非負整数で作られたなら、それはchar listとも\n"
#~ "呼ばれることもあります。Elixirはchar listを定義する\n"
#~ "為にシングルクォーテーションを使います:\n"
#~ "\n"
#~ "    iex> 'héllo'\n"
#~ "    [104, 233, 108, 108, 111]\n"
#~ "\n"
#~ "具体的には、char listはASCII-printableコードポイントのみを\n"
#~ "含むなら、シングルクォーテーションでプリントバックされる\n"
#~ "でしょう:\n"
#~ "\n"
#~ "    iex> 'abc'\n"
#~ "    'abc'\n"
#~ "\n"
#~ "この振る舞いの背後の理論的根拠はElixir文字列の代りに\n"
#~ "char listとしてテキストを返すErlangライブラリのよりよい\n"
#~ "サポートのためです。そのような関数の一つの例が\n"
#~ "`Application.loaded_applications`です:\n"
#~ "\n"
#~ "    Application.loaded_applications\n"
#~ "    #=>  [{:stdlib, 'ERTS  CXC 138 10', '2.6'},\n"
#~ "          {:compiler, 'ERTS  CXC 138 10', '6.0.1'},\n"
#~ "          {:elixir, 'elixir', '1.0.0'},\n"
#~ "          {:kernel, 'ERTS  CXC 138 10', '4.1'},\n"
#~ "          {:logger, 'logger', '1.0.0'}]\n"
