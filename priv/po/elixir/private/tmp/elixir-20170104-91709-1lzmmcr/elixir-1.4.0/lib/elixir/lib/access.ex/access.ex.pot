#. TRANSLATORS: def Access.at(index)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/access.ex:581 
msgid ""
"Returns a function that accesses the element at `index` (zero based) of a list.\n"
"\n"
"The returned function is typically passed as an accessor to `Kernel.get_in/2`,\n"
"`Kernel.get_and_update_in/3`, and friends.\n"
"\n"
"## Examples\n"
"\n"
"    iex> list = [%{name: \"john\"}, %{name: \"mary\"}]\n"
"    iex> get_in(list, [Access.at(1), :name])\n"
"    \"mary\"\n"
"    iex> get_and_update_in(list, [Access.at(0), :name], fn\n"
"    ...>   prev -> {prev, String.upcase(prev)}\n"
"    ...> end)\n"
"    {\"john\", [%{name: \"JOHN\"}, %{name: \"mary\"}]}\n"
"\n"
"`at/1` can also be used to pop elements out of a list or\n"
"a key inside of a list:\n"
"\n"
"    iex> list = [%{name: \"john\"}, %{name: \"mary\"}]\n"
"    iex> pop_in(list, [Access.at(0)])\n"
"    {%{name: \"john\"}, [%{name: \"mary\"}]}\n"
"    iex> pop_in(list, [Access.at(0), :name])\n"
"    {\"john\", [%{}, %{name: \"mary\"}]}\n"
"\n"
"When the index is out of bounds, `nil` is returned and the update function is never called:\n"
"\n"
"    iex> list = [%{name: \"john\"}, %{name: \"mary\"}]\n"
"    iex> get_in(list, [Access.at(10), :name])\n"
"    nil\n"
"    iex> get_and_update_in(list, [Access.at(10), :name], fn\n"
"    ...>   prev -> {prev, String.upcase(prev)}\n"
"    ...> end)\n"
"    {nil, [%{name: \"john\"}, %{name: \"mary\"}]}\n"
"\n"
"An error is raised for negative indexes:\n"
"\n"
"    iex> get_in([], [Access.at(-1)])\n"
"    ** (FunctionClauseError) no function clause matching in Access.at/1\n"
"\n"
"An error is raised if the accessed structure is not a list:\n"
"\n"
"    iex> get_in(%{}, [Access.at(1)])\n"
"    ** (RuntimeError) Access.at/1 expected a list, got: %{}\n"
msgstr ""
#. TRANSLATORS: def Access.fetch(container, key)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/access.ex:232 
msgid ""
"Fetches the value for the given key in a container (a map, keyword\n"
"list, or struct that implements the `Access` behaviour).\n"
msgstr ""
#. TRANSLATORS: @callback pop/2
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/access.ex:204 
msgid ""
"Invoked to \"pop\" the value under `key` out of the given term.\n"
"\n"
"When the key `key` exists in the given `term`, the implementation should\n"
"return a `{value, new_term}` tuple where `value` is the value that was under\n"
"`key` and `new_term` is `term` without `key`.\n"
"\n"
"When the key `key` is not present in the given `term`, a tuple `{value, term}`\n"
"should be returned, where `value` is implementation-defined.\n"
"\n"
"See the implementations for `Map.pop/3` or `Keyword.pop/3` for more examples.\n"
msgstr ""
#. TRANSLATORS: def Access.get(container, key, default \\ nil)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/access.ex:263 
msgid ""
"Gets the value for the given key in a container (a map, keyword\n"
"list, or struct that implements the `Access` behaviour).\n"
msgstr ""
#. TRANSLATORS: def Access.key!(key)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/access.ex:435 
msgid ""
"Returns a function that accesses the given key in a map/struct.\n"
"\n"
"The returned function is typically passed as an accessor to `Kernel.get_in/2`,\n"
"`Kernel.get_and_update_in/3`, and friends.\n"
"\n"
"Raises if the key does not exist.\n"
"\n"
"## Examples\n"
"\n"
"    iex> map = %{user: %{name: \"john\"}}\n"
"    iex> get_in(map, [Access.key!(:user), Access.key!(:name)])\n"
"    \"john\"\n"
"    iex> get_and_update_in(map, [Access.key!(:user), Access.key!(:name)], fn\n"
"    ...>   prev -> {prev, String.upcase(prev)}\n"
"    ...> end)\n"
"    {\"john\", %{user: %{name: \"JOHN\"}}}\n"
"    iex> pop_in(map, [Access.key!(:user), Access.key!(:name)])\n"
"    {\"john\", %{user: %{}}}\n"
"    iex> get_in(map, [Access.key!(:user), Access.key!(:unknown)])\n"
"    ** (KeyError) key :unknown not found in: %{name: \"john\"}\n"
"\n"
"An error is raised if the accessed structure is not a map/struct:\n"
"\n"
"    iex> get_in([], [Access.key!(:foo)])\n"
"    ** (RuntimeError) Access.key!/1 expected a map/struct, got: []\n"
"\n"
msgstr ""
#. TRANSLATORS: Elixir.Access Summary
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/access.ex:2 
msgid ""
"Key-based access to data structures using the `data[key]` syntax.\n"
"\n"
"Elixir provides two syntaxes for accessing values. `user[:name]`\n"
"is used by dynamic structures, like maps and keywords, while\n"
"`user.name` is used by structs. The main difference is that\n"
"`user[:name]` won't raise if the key `:name` is missing but\n"
"`user.name` will raise if there is no `:name` key.\n"
"\n"
"Besides the cases above, this module provides convenience\n"
"functions for accessing other structures, like `at/1` for\n"
"lists and `elem/1` for tuples. Those functions can be used\n"
"by the nested update functions in `Kernel`, such as\n"
"`Kernel.get_in/2`, `Kernel.put_in/3`, `Kernel.update_in/3`,\n"
"`Kernel.get_and_update_in/3` and friends.\n"
"\n"
"## Dynamic lookups\n"
"\n"
"Out of the box, `Access` works with `Keyword` and `Map`:\n"
"\n"
"    iex> keywords = [a: 1, b: 2]\n"
"    iex> keywords[:a]\n"
"    1\n"
"\n"
"    iex> map = %{a: 1, b: 2}\n"
"    iex> map[:a]\n"
"    1\n"
"\n"
"    iex> star_ratings = %{1.0 => \"★\", 1.5 => \"★☆\", 2.0 => \"★★\"}\n"
"    iex> star_ratings[1.5]\n"
"    \"★☆\"\n"
"\n"
"Note that the dynamic lookup syntax (`term[key]`) roughly translates to\n"
"`Access.get(term, key, nil)`.\n"
"\n"
"`Access` can be combined with `Kernel.put_in/3` to put a value\n"
"in a given key:\n"
"\n"
"    iex> map = %{a: 1, b: 2}\n"
"    iex> put_in map[:a], 3\n"
"    %{a: 3, b: 2}\n"
"\n"
"This syntax is very convenient as it can be nested arbitrarily:\n"
"\n"
"    iex> users = %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}\n"
"    iex> put_in users[\"john\"][:age], 28\n"
"    %{\"john\" => %{age: 28}, \"meg\" => %{age: 23}}\n"
"\n"
"Furthermore, `Access` transparently ignores `nil` values:\n"
"\n"
"    iex> keywords = [a: 1, b: 2]\n"
"    iex> keywords[:c][:unknown]\n"
"    nil\n"
"\n"
"Since `Access` is a behaviour, it can be implemented for key-value\n"
"data structures. The implementation should be added to the\n"
"module that defines the struct being accessed. `Access` requires the\n"
"key comparison to be implemented using the `===` operator.\n"
"\n"
"## Static lookups\n"
"\n"
"The `Access` syntax (`foo[bar]`) cannot be used to access fields in\n"
"structs, since structs do not implement the `Access` behaviour by\n"
"default. It is also a design decision: the dynamic access lookup\n"
"is meant to be used for dynamic key-value structures, like maps\n"
"and keywords, and not by static ones like structs (where fields are\n"
"known and not dynamic).\n"
"\n"
"Therefore Elixir provides a static lookup for struct fields and for atom\n"
"fields in maps. Imagine a struct named `User` with a `:name` field.\n"
"The following would raise:\n"
"\n"
"    user = %User{name: \"John\"}\n"
"    user[:name]\n"
"    # ** (UndefinedFunctionError) undefined function User.fetch/2\n"
"    #    (User does not implement the Access behaviour)\n"
"\n"
"Structs instead use the `user.name` syntax to access fields:\n"
"\n"
"    user.name\n"
"    #=> \"John\"\n"
"\n"
"The same `user.name` syntax can also be used by `Kernel.put_in/2`\n"
"to for updating structs fields:\n"
"\n"
"    put_in user.name, \"Mary\"\n"
"    #=> %User{name: \"Mary\"}\n"
"\n"
"Differently from `user[:name]`, `user.name` is not extensible via\n"
"a behaviour and is restricted only to structs and atom keys in maps.\n"
"\n"
"As mentioned above, this works for atom keys in maps as well. Refer to the\n"
"`Map` module for more information on this.\n"
"\n"
"Summing up:\n"
"\n"
"  * `user[:name]` is used by dynamic structures, is extensible and\n"
"    does not raise on missing keys\n"
"  * `user.name` is used by static structures, it is not extensible\n"
"    and it will raise on missing keys\n"
"\n"
"## Accessors\n"
"\n"
"While Elixir provides built-in syntax only for traversing dynamic\n"
"and static key-value structures, this module provides convenience\n"
"functions for traversing other structures, like tuples and lists,\n"
"to be used alongside `Kernel.put_in/2` in others.\n"
"\n"
"For instance, given a user with a list of languages, here is how to\n"
"deeply traverse the map and convert all language names to uppercase:\n"
"\n"
"    iex> user = %{name: \"john\",\n"
"    ...>          languages: [%{name: \"elixir\", type: :functional},\n"
"    ...>                      %{name: \"c\", type: :procedural}]}\n"
"    iex> update_in user, [:languages, Access.all(), :name], &String.upcase/1\n"
"    %{name: \"john\",\n"
"      languages: [%{name: \"ELIXIR\", type: :functional},\n"
"                  %{name: \"C\", type: :procedural}]}\n"
"\n"
"See the functions `key/1`, `key!/1`, `elem/1`, and `all/0` for some of the\n"
"available accessors.\n"
"\n"
"## Implementing the Access behaviour for custom data structures\n"
"\n"
"In order to be able to use the `Access` protocol with custom data structures\n"
"(which have to be structs), such structures have to implement the `Access`\n"
"behaviour. For example, for a `User` struct, this would have to be done:\n"
"\n"
"    defmodule User do\n"
"      defstruct [:name, :email]\n"
"\n"
"      @behaviour Access\n"
"      # Implementation of the Access callbacks...\n"
"    end\n"
"\n"
msgstr ""
#. TRANSLATORS: def Access.pop(container, key)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/access.ex:313 
msgid ""
"Removes the entry with a given key from a container (a map, keyword\n"
"list, or struct that implements the `Access` behaviour).\n"
"\n"
"Returns a tuple containing the value associated with the key and the\n"
"updated container. `nil` is returned for the value if the key isn't\n"
"in the container.\n"
"\n"
"## Examples\n"
"\n"
"With a map:\n"
"\n"
"    iex> Access.pop(%{name: \"Elixir\", creator: \"Valim\"}, :name)\n"
"    {\"Elixir\", %{creator: \"Valim\"}}\n"
"\n"
"A keyword list:\n"
"\n"
"    iex> Access.pop([name: \"Elixir\", creator: \"Valim\"], :name)\n"
"    {\"Elixir\", [creator: \"Valim\"]}\n"
"\n"
"An unknown key:\n"
"\n"
"    iex> Access.pop(%{name: \"Elixir\", creator: \"Valim\"}, :year)\n"
"    {nil, %{creator: \"Valim\", name: \"Elixir\"}}\n"
"\n"
msgstr ""
#. TRANSLATORS: def Access.key(key, default)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/access.ex:383 
msgid ""
"Returns a function that accesses the given key in a map/struct.\n"
"\n"
"The returned function is typically passed as an accessor to `Kernel.get_in/2`,\n"
"`Kernel.get_and_update_in/3`, and friends.\n"
"\n"
"The returned function uses the default value if the key does not exist.\n"
"This can be used to specify defaults and safely traverse missing keys:\n"
"\n"
"    iex> get_in(%{}, [Access.key(:user, %{}), Access.key(:name, nil)])\n"
"    nil\n"
"\n"
"Such is also useful when using update functions, allowing us to introduce\n"
"values as we traverse the data-structure for updates:\n"
"\n"
"    iex> put_in(%{}, [Access.key(:user, %{}), Access.key(:name, nil)], \"Mary\")\n"
"    %{user: %{name: \"Mary\"}}\n"
"\n"
"## Examples\n"
"\n"
"    iex> map = %{user: %{name: \"john\"}}\n"
"    iex> get_in(map, [Access.key(:unknown, %{}), Access.key(:name, \"john\")])\n"
"    \"john\"\n"
"    iex> get_and_update_in(map, [Access.key!(:user), Access.key!(:name)], fn\n"
"    ...>   prev -> {prev, String.upcase(prev)}\n"
"    ...> end)\n"
"    {\"john\", %{user: %{name: \"JOHN\"}}}\n"
"    iex> pop_in(map, [Access.key!(:user), Access.key!(:name)])\n"
"    {\"john\", %{user: %{}}}\n"
"\n"
"An error is raised if the accessed structure is not a map or a struct:\n"
"\n"
"    iex> get_in(nil, [Access.key(:foo, nil)])\n"
"    ** (BadMapError) expected a map, got: nil\n"
"\n"
"    iex> get_in([], [Access.key(:foo, nil)])\n"
"    ** (BadMapError) expected a map, got: []\n"
"\n"
msgstr ""
#. TRANSLATORS: def Access.get_and_update(container, key, fun)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/access.ex:275 
msgid ""
"Gets and updates the given key in a container (a map, keyword\n"
"list, or struct that implements the `Access` behaviour).\n"
"\n"
"This `fun` argument receives the value of `key` (or `nil` if `key`\n"
"is not present) and must return a two-element tuple: the \"get\" value\n"
"(the retrieved value, which can be operated on before being returned)\n"
"and the new value to be stored under `key`. The `fun` may also\n"
"return `:pop`, implying the current value shall be removed\n"
"from the container and returned.\n"
"\n"
"The returned value is a two-element tuple with the \"get\" value returned by\n"
"`fun` and a new container with the updated value under `key`.\n"
msgstr ""
#. TRANSLATORS: def Access.elem(index)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/access.ex:478 
msgid ""
"Returns a function that accesses the element at the given index in a tuple.\n"
"\n"
"The returned function is typically passed as an accessor to `Kernel.get_in/2`,\n"
"`Kernel.get_and_update_in/3`, and friends.\n"
"\n"
"Raises if the index is out of bounds.\n"
"\n"
"## Examples\n"
"\n"
"    iex> map = %{user: {\"john\", 27}}\n"
"    iex> get_in(map, [:user, Access.elem(0)])\n"
"    \"john\"\n"
"    iex> get_and_update_in(map, [:user, Access.elem(0)], fn\n"
"    ...>   prev -> {prev, String.upcase(prev)}\n"
"    ...> end)\n"
"    {\"john\", %{user: {\"JOHN\", 27}}}\n"
"    iex> pop_in(map, [:user, Access.elem(0)])\n"
"    ** (RuntimeError) cannot pop data from a tuple\n"
"\n"
"An error is raised if the accessed structure is not a tuple:\n"
"\n"
"    iex> get_in(%{}, [Access.elem(0)])\n"
"    ** (RuntimeError) Access.elem/1 expected a tuple, got: %{}\n"
"\n"
msgstr ""
#. TRANSLATORS: @callback fetch/2
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/access.ex:143 
msgid ""
"Invoked in order to access the value stored under `key` in the given term `term`.\n"
"\n"
"This function should return `{:ok, value}` where `value` is the value under\n"
"`key` if it succeeded, or `:error` if the key does not exist in the structure.\n"
"\n"
"Many of the functions defined in the `Access` module internally call this\n"
"function. This function is also used when the square-brackets access syntax\n"
"(`structure[key]`) is used: the `fetch/2` callback implemented by the module\n"
"that defines the `structure` struct is invoked and if it returns `{:ok,\n"
"value}` then `value` is returned, or if it returns `:error` then `nil` is\n"
"returned.\n"
"\n"
"\n"
"See the `Map.fetch/2` and `Keyword.fetch/2` implementations for examples of\n"
"how to implement this callback.\n"
msgstr ""
#. TRANSLATORS: def Access.all()
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/access.ex:521 
msgid ""
"Returns a function that accesses all the elements in a list.\n"
"\n"
"The returned function is typically passed as an accessor to `Kernel.get_in/2`,\n"
"`Kernel.get_and_update_in/3`, and friends.\n"
"\n"
"## Examples\n"
"\n"
"    iex> list = [%{name: \"john\"}, %{name: \"mary\"}]\n"
"    iex> get_in(list, [Access.all(), :name])\n"
"    [\"john\", \"mary\"]\n"
"    iex> get_and_update_in(list, [Access.all(), :name], fn\n"
"    ...>   prev -> {prev, String.upcase(prev)}\n"
"    ...> end)\n"
"    {[\"john\", \"mary\"], [%{name: \"JOHN\"}, %{name: \"MARY\"}]}\n"
"    iex> pop_in(list, [Access.all(), :name])\n"
"    {[\"john\", \"mary\"], [%{}, %{}]}\n"
"\n"
"Here is an example that traverses the list dropping even\n"
"numbers and multipling odd numbers by 2:\n"
"\n"
"    iex> require Integer\n"
"    iex> get_and_update_in([1, 2, 3, 4, 5], [Access.all], fn\n"
"    ...>   num -> if Integer.is_even(num), do: :pop, else: {num, num * 2}\n"
"    ...> end)\n"
"    {[1, 2, 3, 4, 5], [2, 6, 10]}\n"
"\n"
"An error is raised if the accessed structure is not a list:\n"
"\n"
"    iex> get_in(%{}, [Access.all()])\n"
"    ** (RuntimeError) Access.all/0 expected a list, got: %{}\n"
"\n"
msgstr ""
#. TRANSLATORS: @callback get/3
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/access.ex:162 
msgid ""
"Invoked in order to access the value stored under `key` in the given term `term`,\n"
"defaulting to `default` if not present.\n"
"\n"
"This function should return the value under the key `key` in `term` if there's\n"
"such key, otherwise `default`.\n"
"\n"
"For most data structures, this can be implemented using `fetch/2` internally;\n"
"for example:\n"
"\n"
"    def get(structure, key, default) do\n"
"      case fetch(structure, key) do\n"
"        {:ok, value} -> value\n"
"        :error       -> default\n"
"      end\n"
"    end\n"
"\n"
"See the `Map.get/3` and `Keyword.get/3` implementations for more examples.\n"
msgstr ""
#. TRANSLATORS: @callback get_and_update/3
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/access.ex:183 
msgid ""
"Invoked in order to access the value under `key` and update it at the same time.\n"
"\n"
"The implementation of this callback should invoke the passed function with the\n"
"value under key `key` in the passed structure, or `nil` if the key is not\n"
"present. This function should return either `{value_to_return, new_value}` or\n"
"`:pop`.\n"
"\n"
"If it returns `{value_to_return, new_value}`, the return value of this\n"
"callback should be `{value_to_return, new_term}` where `new_term` is `term`\n"
"after updating the value of `key` with `new_value`.\n"
"\n"
"If it returns `:pop`, the return value of this callback should be `{value,\n"
"new_term}` where `value` is the value under `key` or `nil` if not present, and\n"
"`new_term` is `term` without the key `key`.\n"
"\n"
"See the implementations of `Map.get_and_update/3` or `Keyword.get_and_update/3`\n"
"for more examples.\n"
msgstr ""
