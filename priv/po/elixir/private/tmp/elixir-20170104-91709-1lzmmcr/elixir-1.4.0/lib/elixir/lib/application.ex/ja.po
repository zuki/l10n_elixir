msgid ""
msgstr ""
"Project-Id-Version: l 10n_elixir\n"
"POT-Creation-Date: \n"
"PO-Revision-Date: 2017-01-25 17:23+0900\n"
"Last-Translator: 小田 照敬 <EMAIL@ADDRESS>\n"
"Language-Team: Japanese\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Poedit 1.8.11\n"

#. TRANSLATORS: def Application.loaded_applications()
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/application.ex:451
msgid ""
"Returns a list with information about the applications which have been "
"loaded.\n"
msgstr "ロードされたアプリケーションについての情報をリストで返します。\n"

#. TRANSLATORS: def Application.fetch_env(app, key)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/application.ex:238
msgid ""
"Returns the value for `key` in `app`'s environment in a tuple.\n"
"\n"
"If the configuration parameter does not exist, the function returns `:"
"error`.\n"
msgstr ""
"`app`の環境の`key`に対応する値を返します。\n"
"\n"
"もしconfigurationパラメータが存在しない場合、`:error`を返します。\n"

#. TRANSLATORS: def Application.app_dir(app, path)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/application.ex:432
msgid "Returns the given path inside `app_dir/1`.\n"
msgstr "`app_dir/1`の内側に与えられたパスを追加して返します。\n"

#. TRANSLATORS: def Application.format_error(reason)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/application.ex:459
msgid ""
"Formats the error reason returned by `start/2`,\n"
"`ensure_started/2`, `stop/1`, `load/1` and `unload/1`,\n"
"returns a string.\n"
msgstr ""
"`start/2`、`ensure_started/2`、`stop/1`、`load/1`、`unload/1`で\n"
"返された、エラーのreasonをフォーマットし、文字列を返します。\n"

#. TRANSLATORS: def Application.put_env(app, key, value, opts \\ [])
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/application.ex:267
msgid ""
"Puts the `value` in `key` for the given `app`.\n"
"\n"
"## Options\n"
"\n"
"  * `:timeout`    - the timeout for the change (defaults to 5000ms)\n"
"  * `:persistent` - persists the given value on application load and "
"reloads\n"
"\n"
"If `put_env/4` is called before the application is loaded, the application\n"
"environment values specified in the `.app` file will override the ones\n"
"previously set.\n"
"\n"
"The persistent option can be set to `true` when there is a need to "
"guarantee\n"
"parameters set with this function will not be overridden by the ones "
"defined\n"
"in the application resource file on load. This means persistent values will\n"
"stick after the application is loaded and also on application reload.\n"
msgstr ""
"与えられた`value`を`key`に与えられた`app`の為にプットします。\n"
"\n"
"## オプション\n"
"\n"
"  * `:timeout`    - 変更の為のタイムアウト (デフォルト 5000ms)\n"
"  * `:persistent` - アプリケーションをロードやリロードでしても値を永続化しま"
"す\n"
"\n"
"もしアプリケーションがロードされる前に`put_env/4`が呼ばれると、\n"
"`.app`ファイルで指定されたアプリケーション環境変数は、以前の値を\n"
"上書きされます。\n"
"\n"
"ロードしているアプリケーションリソースファイルで定義された値により、こ\n"
"の関数によりセットされたパラメタが、オーバライドされないように保証する\n"
"必要があるときに、persistent オプションを`true`にセットできます。これは、\n"
"永続化された値はアプリケーションがロードされ、アプリケーションがリロー\n"
"ドされた後も定着することを意味します。\n"

#. TRANSLATORS: def Application.ensure_started(app, type \\ :temporary)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/application.ex:299
msgid ""
"Ensures the given `app` is started.\n"
"\n"
"Same as `start/2` but returns `:ok` if the application was already\n"
"started. This is useful in scripts and in test setup, where test\n"
"applications need to be explicitly started:\n"
"\n"
"    :ok = Application.ensure_started(:my_test_dep)\n"
"\n"
msgstr ""
"与えられた`app`が開始しているのを確実にします。\n"
"\n"
"`start/2`と同じですが、そのアプリケーションが既に開始していたら、\n"
"`:ok`を返します。これは、スクリプト中やテストのセットアップで\n"
"テストアプリケーションを明示的に開始させる必要がある場合に、\n"
"便利です:\n"
"\n"
"    :ok = Application.ensure_started(:my_test_dep)\n"
"\n"

#. TRANSLATORS: def Application.unload(app)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/application.ex:389
msgid ""
"Unloads the given `app`.\n"
"\n"
"It will also unload all `:included_applications`.\n"
"Note that the function does not purge the application modules.\n"
msgstr ""
"与えられた`app`をアンロードします。\n"
"\n"
"それは`:included_applications`全てをもアンロードします。\n"
"関数はアプリケーションモジュールをパージしないことに\n"
"注意してください。\n"

#. TRANSLATORS: def Application.get_all_env(app)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/application.ex:219
msgid "Returns all key-value pairs for `app`.\n"
msgstr "`app`の環境リストについて全てのキーバリューの組を返します。\n"

#. TRANSLATORS: def Application.spec(app)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/application.ex:171
msgid ""
"Returns the spec for `app`.\n"
"\n"
"The following keys are returned:\n"
"\n"
"  * :description\n"
"  * :id\n"
"  * :vsn\n"
"  * :modules\n"
"  * :maxP\n"
"  * :maxT\n"
"  * :registered\n"
"  * :included_applications\n"
"  * :applications\n"
"  * :mod\n"
"  * :start_phases\n"
"\n"
"Note the environment is not returned as it can be accessed via\n"
"`fetch_env/2`. Returns `nil` if the application is not loaded.\n"
msgstr ""
"`app`のspecを返します。\n"
"\n"
"以下のキーを返します:\n"
"\n"
"  * :description\n"
"  * :id\n"
"  * :vsn\n"
"  * :modules\n"
"  * :maxP\n"
"  * :maxT\n"
"  * :registered\n"
"  * :included_applications\n"
"  * :applications\n"
"  * :mod\n"
"  * :start_phases\n"
"\n"
"`fetch_env/2` を通してアクセスできるので、environmentは\n"
"返されない点に注意してください。アプリケーションが\n"
"ロードされていない時、`nil`を返します。\n"

#. TRANSLATORS: def Application.start(app, type \\ :temporary)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/application.ex:326
msgid ""
"Starts the given `app`.\n"
"\n"
"If the `app` is not loaded, the application will first be loaded using "
"`load/1`.\n"
"Any included application, defined in the `:included_applications` key of "
"the\n"
"`.app` file will also be loaded, but they won't be started.\n"
"\n"
"Furthermore, all applications listed in the `:applications` key must be "
"explicitly\n"
"started before this application is. If not, `{:error, {:not_started, app}}` "
"is\n"
"returned, where `app` is the name of the missing application.\n"
"\n"
"In case you want to automatically  load **and start** all of `app`'s "
"dependencies,\n"
"see `ensure_all_started/2`.\n"
"\n"
"The `type` argument specifies the type of the application:\n"
"\n"
"  * `:permanent` - if `app` terminates, all other applications and the "
"entire\n"
"    node are also terminated.\n"
"\n"
"  * `:transient` - if `app` terminates with `:normal` reason, it is "
"reported\n"
"    but no other applications are terminated. If a transient application\n"
"    terminates abnormally, all other applications and the entire node are\n"
"    also terminated.\n"
"\n"
"  * `:temporary` - if `app` terminates, it is reported but no other\n"
"    applications are terminated (the default).\n"
"\n"
"Note that it is always possible to stop an application explicitly by "
"calling\n"
"`stop/1`. Regardless of the type of the application, no other applications "
"will\n"
"be affected.\n"
"\n"
"Note also that the `:transient` type is of little practical use, since when "
"a\n"
"supervision tree terminates, the reason is set to `:shutdown`, not `:"
"normal`.\n"
msgstr ""
"与えられた`app`を開始します。\n"
"\n"
"`app`がロードされていないなら、アプリケーションは最初に`load/1`を使って\n"
"ロードされます。`.app`ファイルの`:included_applications`キーで定義され\n"
"た任意の含まれたアプリケーションもまた、ロードされますが、開始はされま\n"
"せん。\n"
"\n"
"さらに、`:application`キーにリストされた全てのアプリケーションはアプリケー"
"ションを\n"
"開始する前に、明示的に開始されなければなりません。もしそうでないなら、\n"
"`app`が足りないアプリケーションの名前で`{:error, {:not_started, app}}`が返さ"
"れます。\n"
"\n"
"自動的に`app`に依存する全てのアプリケーションをロードし「開始」したい場合、\n"
"`ensure_all_started/2`を参照してください。\n"
"\n"
"`type`引数はアプリケーションのタイプを指定します:\n"
"\n"
"  * `:permanent` - `app`が終了したら、全ての他のアプリケーションと\n"
"     ノード全体も終了されます。\n"
"\n"
"  * `:transient` - `app`が`:normal` reasonで終了したら、\n"
"    レポートされますが、他のアプリケーションは終了しません。\n"
"    もしtransient(一時的)なアプリケーションが異常終了したら、\n"
"    全ての他のアプリケーションとノード全体も終了されます。\n"
"\n"
"  * `:temporary` - `app`が終了したら、レポートされますが、\n"
"    他のアプリケーションは終了されません(これがデフォルトです)。\n"
"\n"
"`stop/1`を呼ぶことで、明示的にアプリケーションを終了することが常にできる\n"
"ことに、気を付けてください。アプリケーションのタイプに関係なく、\n"
"他のいかなるアプリケーションも影響を受けません。\n"
"\n"
"`:transient`タイプはほとんど実用的でないことに注意してください。\n"
"監視ツリーが終了した際に、理由に`:normal`ではなく、`:shutdown`がセットされる"
"からです。n\n"
"\n"

#. TRANSLATORS: def Application.stop(app)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/application.ex:365
msgid ""
"Stops the given `app`.\n"
"\n"
"When stopped, the application is still loaded.\n"
msgstr ""
"与えられた`app`を停止します。\n"
"\n"
"停止したとき、アプリケーションはまだロードされたままです。\n"

#. TRANSLATORS: def Application.fetch_env!(app, key)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/application.ex:251
msgid ""
"Returns the value for `key` in `app`'s environment.\n"
"\n"
"If the configuration parameter does not exist, raises `ArgumentError`.\n"
msgstr ""
"`app`の環境の`key`に対応する値を返します。\n"
"\n"
"もし指定されたconfigurationパラメータが存在しない場合、\n"
"`ArgumentError`を上げます。\n"

#. TRANSLATORS: def Application.started_applications(timeout \\ 5000)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/application.ex:443
msgid ""
"Returns a list with information about the applications which are currently "
"running.\n"
msgstr "現在動いているアプリケーションについての情報をリストで返します。\n"

#. TRANSLATORS: @callback start/2
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/application.ex:93
msgid ""
"Called when an application is started.\n"
"\n"
"This function is called when an the application is started using\n"
"`Application.start/2` (and functions on top of that, such as\n"
"`Application.ensure_started/2`). This function should start the top-level\n"
"process of the application (which should be the top supervisor of the\n"
"application's supervision tree if the application follows the OTP design\n"
"principles around supervision).\n"
"\n"
"`start_type` defines how the application is started:\n"
"\n"
"  * `:normal` - used if the startup is a normal startup or if the "
"application\n"
"    is distributed and is started on the current node because of a failover\n"
"    from another mode and the application specification key `:start_phases`\n"
"    is `:undefined`.\n"
"  * `{:takeover, node}` - used if the application is distributed and is\n"
"    started on the current node because of a failover on the node `node`.\n"
"  * `{:failover, node}` - used if the application is distributed and is\n"
"    started on the current node because of a failover on node `node`, and "
"the\n"
"    application specification key `:start_phases` is not `:undefined`.\n"
"\n"
"`start_args` are the arguments passed to the application in the `:mod`\n"
"specification key (e.g., `mod: {MyApp, [:my_args]}`).\n"
"\n"
"This function should either return `{:ok, pid}` or `{:ok, pid, state}` if\n"
"startup is successful. `pid` should be the PID of the top supervisor. "
"`state`\n"
"can be an arbitrary term, and if omitted will default to `[]`; if the\n"
"application is later stopped, `state` is passed to the `stop/1` callback "
"(see\n"
"the documentation for the `c:stop/1` callback for more information).\n"
"\n"
"`use Application` provides no default implementation for the `start/2`\n"
"callback.\n"
msgstr ""
"アプリケーションの開始時に呼び出されます。\n"
"\n"
"この関数はアプリケーションが`Application.start/2` を使って\n"
"開始された時に呼び出されます（そして、`Application.ensure_started/2`の\n"
"ようにその上で機能します）。この関数はアプリケーションの最上位\n"
"プロセスを開始するべきです（これはアプリケーションが監視に\n"
"関するOPT設計原則にしたがうのであれば、アプリケーションの監視ツリーの\n"
"最上位スーパバイザであるべきです）。\n"
"\n"
"`start_type` はアプリケーションが開始する方法を定義します。\n"
"\n"
"  * `:normal` - スタートアップが通常のスタートアップの場合、あるいは\n"
"    アプリケーションが分散型であり、他のノードからのフェイルオーバのために\n"
"    カレントノードで開始され、アプリケーションの識別キー`:start_phases`が\n"
"    `:undefined`の場合に使用されます。\n"
"  * `{:takeover, node}` - アプリケーションが分散型であり、ノード`node`の\n"
"    フェイルオーバのためにカレントノードで開始される場合に使用されます。\n"
"  * `{:failover, node}` - アプリケーションが分散型であり、ノード`node`の\n"
"    フェイルオーバのためにカレントノードで開始され、アプリケーションの識別\n"
"    キー`:start_phases`が`:undefined`の場合に使用されます。\n"
"\n"
"`start_args`は`:mod`識別きーによりアプリケーションに渡される引数です\n"
"（たとえば、`mod: {MyApp, [:my_args]}`）。\n"
"\n"
"この関数はスタートが成功した場合は、`{:ok, pid}`か`{:ok, pid, state}`のいずれ"
"かを\n"
"返さなければなりません。`pid`は最上位のスーパバイザのPIDでなければなりませ"
"ん。\n"
"`state`は任意の項を設定できます。指定しない場合のデフォルトは`[]`です。\n"
"後にアプリケーションが停止した場合、`state`はコールバック`stop/1`に渡されま"
"す\n"
"（詳しい情報は`c:stop/1`のドキュメントを参照してください）。\n"
"\n"
"`use Application`はコールバック`start/2`のデフォルト実装は\n"
"提供しません。\n"

#. TRANSLATORS: @callback stop/1
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/application.ex:132
msgid ""
"Called when an application is stopped.\n"
"\n"
"This function is called when an application has stopped, i.e., when its\n"
"supervision tree has been stopped. It should do the opposite of what the\n"
"`start/2` callback did, and should perform any necessary cleanup. The "
"return\n"
"value of this callback is ignored.\n"
"\n"
"`state` is the return value of the `start/2` callback or the return value "
"of\n"
"the `prep_stop/1` function if the application module defines such a "
"function.\n"
"\n"
"`use Application` defines a default implementation of this function which "
"does\n"
"nothing and just returns `:ok`.\n"
msgstr ""
"アプリケーションが停止した際に呼び出されます。\n"
"\n"
"この関数はアプリケーションが停止した時に呼び出されます。すなわち、\n"
"その監視ツリーが停止させられたときです。これはコールバック`start/2`が\n"
"したことの反対のことを行わなければなりません。また、必要なクリーンアップも\n"
"実行しなければなりません。このコールバックの返り値は無視されます。\n"
"\n"
"`stete`はコールバック`start/2`の返り値か、アプリケーションモジュールが\n"
"関数`prep_stop/1`を定義していた場合はその返り値のいずれかです。\n"
"\n"
"`use Application`は何もせず、ただ`:ok`を返す、この関数のデフォルト実装を\n"
"定義します。\n"

#. TRANSLATORS: def Application.app_dir(app)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/application.ex:400
msgid ""
"Gets the directory for app.\n"
"\n"
"This information is returned based on the code path. Here is an\n"
"example:\n"
"\n"
"    File.mkdir_p!(\"foo/ebin\")\n"
"    Code.prepend_path(\"foo/ebin\")\n"
"    Application.app_dir(:foo)\n"
"    #=> \"foo\"\n"
"\n"
"Even though the directory is empty and there is no `.app` file\n"
"it is considered the application directory based on the name\n"
"\"foo/ebin\". The name may contain a dash `-` which is considered\n"
"to be the app version and it is removed for the lookup purposes:\n"
"\n"
"    File.mkdir_p!(\"bar-123/ebin\")\n"
"    Code.prepend_path(\"bar-123/ebin\")\n"
"    Application.app_dir(:bar)\n"
"    #=> \"bar-123\"\n"
"\n"
"For more information on code paths, check the `Code` module in\n"
"Elixir and also Erlang's `:code` module.\n"
msgstr ""
"appのディレクトリを取得します。\n"
"\n"
"この関数はコードパスに基いて返されます。以下は\n"
"例です:\n"
"\n"
"    File.mkdir_p!(\"foo/ebin\")\n"
"    Code.prepend_path(\"foo/ebin\")\n"
"    Application.app_dir(:foo)\n"
"    #=> \"foo\"\n"
"\n"
"ディレクトリが空で、`.app`ファイルが無くても、名前\"foo/ebin\"に\n"
"基いてアプリケーションディレクトリと考えられます。\n"
"名前は、appのバージョンとして考えられ検索目的では取り除かれる、\n"
"ダッシュ`-`を含むかもしれません:\n"
"\n"
"    File.mkdir_p!(\"bar-123/ebin\")\n"
"    Code.prepend_path(\"bar-123/ebin\")\n"
"    Application.app_dir(:bar)\n"
"    #=> \"bar-123\"\n"
"\n"
"コードパスについての詳細は、Elixirの`Code`モジュールと、Erlangの\n"
"`:code`モジュールもチェックしてください。\n"

#. TRANSLATORS: def Application.get_env(app, key, default \\ nil)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/application.ex:227
msgid ""
"Returns the value for `key` in `app`'s environment.\n"
"\n"
"If the configuration parameter does not exist, the function returns the\n"
"`default` value.\n"
msgstr ""
"`app`の環境の中の`key`に対応する値を返します。\n"
"\n"
"もしconfigurationパラメタが存在しない場合、関数は`default`値を\n"
"返します。\n"

#. TRANSLATORS: def Application.load(app)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/application.ex:375
msgid ""
"Loads the given `app`.\n"
"\n"
"In order to be loaded, an `.app` file must be in the load paths.\n"
"All `:included_applications` will also be loaded.\n"
"\n"
"Loading the application does not start it nor load its modules, but\n"
"it does load its environment.\n"
msgstr ""
"与えられた`app`をロードします。\n"
"\n"
"ロードされる為には、`.app`ファイルはロードパス上になければなりません。\n"
"全ての`:included_applications`もロードされます。\n"
"\n"
"ロードするアプリケーションは開始しませんし、モジュールのロードもしませ\n"
"んが、その環境をロードします。\n"

#. TRANSLATORS: def Application.delete_env(app, key, opts \\ [])
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/application.ex:289
msgid ""
"Deletes the `key` from the given `app` environment.\n"
"\n"
"See `put_env/4` for a description of the options.\n"
msgstr ""
"与えられた`app`環境から`key`を削除します。\n"
"\n"
"オプションの詳細は`put_env/4`を参照してください。\n"

#. TRANSLATORS: def Application.spec(app, key)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/application.ex:189
msgid ""
"Returns the value for `key` in `app`'s specification.\n"
"\n"
"See `spec/1` for the supported keys. If the given\n"
"specification parameter does not exist, this function\n"
"will raise. Returns `nil` if the application is not loaded.\n"
msgstr ""
"`app`の仕様の`key`に対応する値を返します。\n"
"\n"
"サポートされているキーについては`spec/1`を参照してください。\n"
"もし与えられた仕様パラメータが存在しない場合、この関数は例外を\n"
"上げます。アプリケーションがロードされていないなら、`nil`を\n"
"返します。\n"

#. TRANSLATORS: def Application.ensure_all_started(app, type \\ :temporary)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/application.ex:314
msgid ""
"Ensures the given `app` and its applications are started.\n"
"\n"
"Same as `start/2` but also starts the applications listed under\n"
"`:applications` in the `.app` file in case they were not previously\n"
"started.\n"
msgstr ""
"与えられた`app`とそれが依存しているアプリケーションが開始していることを\n"
"確実にします。\n"
"\n"
"`start/2`と同じですが、`.app`ファイルに`:applications`でリストされている\n"
"アプリケーションも、まだ開始していない場合には、開始します。\n"

#. TRANSLATORS: Elixir.Application Summary
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/application.ex:2
msgid ""
"A module for working with applications and defining application callbacks.\n"
"\n"
"In Elixir (actually, in Erlang/OTP), an application is a component\n"
"implementing some specific functionality, that can be started and stopped\n"
"as a unit, and which can be re-used in other systems.\n"
"\n"
"Applications are defined with an application file named `APP.app` where\n"
"`APP` is the application name, usually in `underscore_case`. The "
"application\n"
"file must reside in the same `ebin` directory as the compiled modules of "
"the\n"
"application.\n"
"\n"
"In Elixir, Mix is responsible for compiling your source code and\n"
"generating your application `.app` file. Furthermore, Mix is also\n"
"responsible for configuring, starting and stopping your application\n"
"and its dependencies. For this reason, this documentation will focus\n"
"on the remaining aspects of your application: the application environment\n"
"and the application callback module.\n"
"\n"
"You can learn more about Mix generation of `.app` files by typing\n"
"`mix help compile.app`.\n"
"\n"
"## Application environment\n"
"\n"
"Once an application is started, OTP provides an application environment\n"
"that can be used to configure the application.\n"
"\n"
"Assuming you are inside a Mix project, you can edit the `application/0`\n"
"function in the `mix.exs` file to the following:\n"
"\n"
"    def application do\n"
"      [env: [hello: :world]]\n"
"    end\n"
"\n"
"In the application function, we can define the default environment values\n"
"for our application. By starting your application with `iex -S mix`, you\n"
"can access the default value:\n"
"\n"
"    Application.get_env(:APP_NAME, :hello)\n"
"    #=> :world\n"
"\n"
"It is also possible to put and delete values from the application value,\n"
"including new values that are not defined in the environment file (although\n"
"this should be avoided).\n"
"\n"
"Keep in mind that each application is responsible for its environment.\n"
"Do not use the functions in this module for directly accessing or modifying\n"
"the environment of other applications (as it may lead to inconsistent\n"
"data in the application environment).\n"
"\n"
"## Application module callback\n"
"\n"
"Often times, an application defines a supervision tree that must be started\n"
"and stopped when the application starts and stops. For such, we need to\n"
"define an application module callback. The first step is to define the\n"
"module callback in the application definition in the `mix.exs` file:\n"
"\n"
"    def application do\n"
"      [mod: {MyApp, []}]\n"
"    end\n"
"\n"
"Our application now requires the `MyApp` module to provide an application\n"
"callback. This can be done by invoking `use Application` in that module and\n"
"defining a `start/2` callback, for example:\n"
"\n"
"    defmodule MyApp do\n"
"      use Application\n"
"\n"
"      def start(_type, _args) do\n"
"        MyApp.Supervisor.start_link()\n"
"      end\n"
"    end\n"
"\n"
"`start/2` typically returns `{:ok, pid}` or `{:ok, pid, state}` where\n"
"`pid` identifies the supervision tree and `state` is the application state.\n"
"`args` is the second element of the tuple given to the `:mod` option.\n"
"\n"
"The `type` argument passed to `start/2` is usually `:normal` unless in a\n"
"distributed setup where application takeovers and failovers are configured.\n"
"This particular aspect of applications is explained in more detail in the\n"
"OTP documentation:\n"
"\n"
"  * [`:application` module](http://www.erlang.org/doc/man/application.html)\n"
"  * [Applications – OTP Design Principles](http://www.erlang.org/doc/"
"design_principles/applications.html)\n"
"\n"
"A developer may also implement the `stop/1` callback (automatically defined\n"
"by `use Application`) which does any application cleanup. It receives the\n"
"application state and can return any value. Note that shutting down the\n"
"supervisor is automatically handled by the VM.\n"
msgstr ""
"アプリケーションで動き、アプリケーションコールバックを定義するモジュールで"
"す。\n"
"\n"
"Elixirでは(実際には、Erlang/OTPでは)、アプリケーションとは、いくつかの\n"
"特定の機能(単位としてスタートやストップができ、他のシステムでも\n"
"再利用できるような)を実装したコンポーネントです。\n"
"\n"
"アプリケーションは、`APP.app`と名付けられたアプリケーションファイルで\n"
"定義されます。`APP`は通常`underscore_case`変換されたアプリケーションの\n"
"名前です。アプリケーションファイルは、アプリケーションモジュールの\n"
"バイトコードと同じ`ebin`ディレクトリに置かれなければなりません。\n"
"\n"
"Elixirでは、Mixはソースコードのコンパイルとアプリケーション\n"
"`.app`ファイルの生成に責任をもちます。さらにまた、Mixは\n"
"アプリケーションの依存関係を構成し、開始と停止を行う役割を果します。\n"
"この理由から、このドキュメントはあなたのアプリケーションの残りの\n"
"面に集中します: アプリケーション環境、アプリケーションコールバック\n"
"モジュールです。\n"
"\n"
"Mixで`.app`ファイルを生成することについては、`mix help\n"
"compile.app`とタイプすることで学ぶことができます。\n"
"\n"
"## アプリケーション環境\n"
"\n"
"アプリケーションが開始したら、OTPは、アプリケーションを構成するために\n"
"使うことができる、アプリケーション環境を提供します。\n"
"\n"
"Mixプロジェクトにあるならば、`mix.exs`ファイルの中の`application`関数を\n"
"次のように編集することができます:\n"
"\n"
"    def application do\n"
"      [env: [hello: :world]]\n"
"    end\n"
"\n"
"application関数で、アプリケーションのためのデフォルトの環境の値を\n"
"定義できます。`iex -S mix`でアプリケーションを開始することによって、\n"
"そのデフォルト値にアクセスできます:\n"
"\n"
"    Application.get_env(:APP_NAME, :hello)\n"
"    #=> {:ok, :hello}\n"
"\n"
"(避けるべきことですが)環境ファイルで定義されない新しい値を含み、\n"
"アプリケーションから値をputし、deleteすることも\n"
"可能です。\n"
"\n"
"それぞれのアプリケーションがその環境に責任を果すことを心にとめておいて\n"
"ください。(アプリケーション環境で矛盾しているデータに至るかもしれないの\n"
"で)他のアプリケーションの環境への直接アクセスや変更のために、このモジュー\n"
"ルの関数を使わないでください。\n"
"\n"
"## アプリケーショモジュールコールバック\n"
"\n"
"しばしば、アプリケーションは、アプリケーションが開始と停止するときに、\n"
"開始と停止する、スーパビジョンツリーを定義します。それで、アプリケーション\n"
"モジュールコールバックを定義する必要があります。最初のステップは`mix.exs`\n"
"ファイルのapplicationの定義に、モジュールコールバックを定義することです:\n"
"\n"
"    def application do\n"
"      [mod: {MyApp, []}]\n"
"    end\n"
"\n"
"今や、私達のアプリケーションは、アプリケーションコールバックを提供すること"
"を\n"
"`MyApp`モジュールに要求します。これは、そのモジュールで`use Application`を\n"
"実行することによりなされ、`start/2`コールバックを定義します。例えば:\n"
"\n"
"    defmodule MyApp do\n"
"      use Application\n"
"\n"
"      def start(_type, _args) do\n"
"        MyApp.Supervisor.start_link()\n"
"      end\n"
"    end\n"
"\n"
"`start/2`は最も一般的には`{:ok, pid}`か`{:ok, pid, state}`を返します。\n"
"`pid`はスーパビジョンツリーの識別子で、`state`はアプリケーションのステート\n"
"です。\n"
"`args`は`:mod`オプションに与えたタプルの2番目の要素です。\n"
"\n"
"`start/2`へ送る`type`は、アプリケーションのテイクオーバーとフェイルオーバが\n"
"構成される分散セットアップでないかぎり、通常`:normal`です。\n"
"アプリケーションのこの特定の側面は、OTPドキュメントでより多く詳細に読む\n"
"ことができます:\n"
"\n"
"  * [`:application` module](http://www.erlang.org/doc/man/application.html)\n"
"  * [Applications – OTP Design Principles](http://www.erlang.org/doc/"
"design_principles/applications.html)\n"
"\n"
"開発者は、`stop/1`コールバック(`use Application`により自動的に定義されていま"
"す)を、\n"
"アプリケーションのなんらかのクリーンアップの為に、実装するかもしれません。そ"
"れは、\n"
"アプリケーションステートを受け取り、任意の値を返すことができます。スーパバイ"
"ザの\n"
"シャットダウンは、VMにより自動的にハンドルされることに注意してください。\n"

#. TRANSLATORS: def Application.get_application(module)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/elixir/lib/application.ex:204
msgid ""
"Gets the application for the given module.\n"
"\n"
"The application is located by analyzing the spec\n"
"of all loaded applications. Returns `nil` if\n"
"the module is not listed in any application spec.\n"
msgstr ""
"指定したmoduleのアプリケーションを取得します。\n"
"\n"
"アプリケーションはロードされたすべてのアプリケーションのspecを分析する\n"
"ことによって特定されます。モジュールがどのアプリケーションのspecに\n"
"もリストされていない場合は、`nil`を返します。\n"
