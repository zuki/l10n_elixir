#. TRANSLATORS: @callback date_to_string/3
#: lib/calendar.ex:87 
msgid ""
"Converts the date into a string according to the calendar.\n"
msgstr ""
#. TRANSLATORS: @callback datetime_to_string/11
#: lib/calendar.ex:97 
msgid ""
"Coverts the date time (with time zone) into a string according to the calendar.\n"
msgstr ""
#. TRANSLATORS: @callback leap_year?/1
#: lib/calendar.ex:73 
msgid ""
"Returns true if the given year is a leap year.\n"
"\n"
"A leap year is a year of a longer length than normal. The exact meaning\n"
"is up to the calendar. A calendar must return `false` if it does not support\n"
"the concept of leap years.\n"
msgstr ""
#. TRANSLATORS: def Date.from_iso8601!(string)
#: lib/calendar.ex:274 
msgid ""
"Parses the extended \"Date and time of day\" format described by\n"
"[ISO 8601:2004](https://en.wikipedia.org/wiki/ISO_8601).\n"
"\n"
"Raises if the format is invalid.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Date.from_iso8601!(\"2015-01-23\")\n"
"    ~D[2015-01-23]\n"
"    iex> Date.from_iso8601!(\"2015:01:23\")\n"
"    ** (ArgumentError) cannot parse \"2015:01:23\" as date, reason: :invalid_format\n"
msgstr ""
#. TRANSLATORS: def Date.to_erl(map)
#: lib/calendar.ex:317 
msgid ""
"Converts a `Date` struct to an Erlang date tuple.\n"
"\n"
"Only supports converting dates which are in the ISO calendar,\n"
"attempting to convert dates from other calendars will raise.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Date.to_erl(~D[2000-01-01])\n"
"    {2000, 1, 1}\n"
"    iex> Date.to_erl(~N[2000-01-01 01:23:45])\n"
"    {2000, 1, 1}\n"
"\n"
msgstr ""
#. TRANSLATORS: def NaiveDateTime.from_iso8601(arg)
#: lib/calendar.ex:1037 
msgid ""
"Parses the extended \"Date and time of day\" format described by\n"
"[ISO 8601:2004](https://en.wikipedia.org/wiki/ISO_8601).\n"
"\n"
"Timezone offset may be included in the string but they will be\n"
"simply discarded as such information is not included in naive date\n"
"times.\n"
"\n"
"As specified in the standard, the separator \"T\" may be omitted if\n"
"desired as there is no ambiguity within this function.\n"
"\n"
"Time representations with reduced accuracy are not supported.\n"
"\n"
"## Examples\n"
"\n"
"    iex> NaiveDateTime.from_iso8601(\"2015-01-23 23:50:07\")\n"
"    {:ok, ~N[2015-01-23 23:50:07]}\n"
"    iex> NaiveDateTime.from_iso8601(\"2015-01-23T23:50:07\")\n"
"    {:ok, ~N[2015-01-23 23:50:07]}\n"
"    iex> NaiveDateTime.from_iso8601(\"2015-01-23T23:50:07Z\")\n"
"    {:ok, ~N[2015-01-23 23:50:07]}\n"
"\n"
"    iex> NaiveDateTime.from_iso8601(\"2015-01-23 23:50:07.0\")\n"
"    {:ok, ~N[2015-01-23 23:50:07.0]}\n"
"    iex> NaiveDateTime.from_iso8601(\"2015-01-23 23:50:07.0123456\")\n"
"    {:ok, ~N[2015-01-23 23:50:07.012345]}\n"
"    iex> NaiveDateTime.from_iso8601(\"2015-01-23T23:50:07.123Z\")\n"
"    {:ok, ~N[2015-01-23 23:50:07.123]}\n"
"\n"
"    iex> NaiveDateTime.from_iso8601(\"2015-01-23P23:50:07\")\n"
"    {:error, :invalid_format}\n"
"    iex> NaiveDateTime.from_iso8601(\"2015:01:23 23-50-07\")\n"
"    {:error, :invalid_format}\n"
"    iex> NaiveDateTime.from_iso8601(\"2015-01-23 23:50:07A\")\n"
"    {:error, :invalid_format}\n"
"    iex> NaiveDateTime.from_iso8601(\"2015-01-23 23:50:61\")\n"
"    {:error, :invalid_time}\n"
"    iex> NaiveDateTime.from_iso8601(\"2015-01-32 23:50:07\")\n"
"    {:error, :invalid_date}\n"
"\n"
"    iex> NaiveDateTime.from_iso8601(\"2015-01-23T23:50:07.123+02:30\")\n"
"    {:ok, ~N[2015-01-23 23:50:07.123]}\n"
"    iex> NaiveDateTime.from_iso8601(\"2015-01-23T23:50:07.123+00:00\")\n"
"    {:ok, ~N[2015-01-23 23:50:07.123]}\n"
"    iex> NaiveDateTime.from_iso8601(\"2015-01-23T23:50:07.123-02:30\")\n"
"    {:ok, ~N[2015-01-23 23:50:07.123]}\n"
"    iex> NaiveDateTime.from_iso8601(\"2015-01-23T23:50:07.123-00:00\")\n"
"    {:error, :invalid_format}\n"
"    iex> NaiveDateTime.from_iso8601(\"2015-01-23T23:50:07.123-00:60\")\n"
"    {:error, :invalid_format}\n"
"    iex> NaiveDateTime.from_iso8601(\"2015-01-23T23:50:07.123-24:00\")\n"
"    {:error, :invalid_format}\n"
"\n"
msgstr ""
#. TRANSLATORS: def Date.to_string(map)
#: lib/calendar.ex:222 
msgid ""
"Converts the given date to a string according to its calendar.\n"
"\n"
"### Examples\n"
"\n"
"    iex> Date.to_string(~D[2000-02-28])\n"
"    \"2000-02-28\"\n"
"    iex> Date.to_string(~N[2000-02-28 01:23:45])\n"
"    \"2000-02-28\"\n"
"\n"
msgstr ""
#. TRANSLATORS: @callback naive_datetime_to_string/7
#: lib/calendar.ex:92 
msgid ""
"Converts the date time (without time zone) into a string according to the calendar.\n"
msgstr ""
#. TRANSLATORS: def Date.compare(date1, date2)
#: lib/calendar.ex:373 
msgid ""
"Compares two `Date` structs.\n"
"\n"
"Returns `:gt` if first date is later than the second\n"
"and `:lt` for vice versa. If the two dates are equal\n"
"`:eq` is returned.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Date.compare(~D[2016-04-16], ~D[2016-04-28])\n"
"    :lt\n"
"\n"
"This function can also be used to compare across more\n"
"complex calendar types by considering only the date fields:\n"
"\n"
"    iex> Date.compare(~D[2016-04-16], ~N[2016-04-28 01:23:45])\n"
"    :lt\n"
"    iex> Date.compare(~D[2016-04-16], ~N[2016-04-16 01:23:45])\n"
"    :eq\n"
"    iex> Date.compare(~N[2016-04-16 12:34:56], ~N[2016-04-16 01:23:45])\n"
"    :eq\n"
"\n"
msgstr ""
#. TRANSLATORS: def Date.to_iso8601(map)
#: lib/calendar.ex:297 
msgid ""
"Converts the given datetime to\n"
"[ISO 8601:2004](https://en.wikipedia.org/wiki/ISO_8601).\n"
"\n"
"Only supports converting datetimes which are in the ISO calendar,\n"
"attempting to convert datetimes from other calendars will raise.\n"
"\n"
"### Examples\n"
"\n"
"    iex> Date.to_iso8601(~D[2000-02-28])\n"
"    \"2000-02-28\"\n"
"    iex> Date.to_iso8601(~N[2000-02-28 01:23:45])\n"
"    \"2000-02-28\"\n"
"\n"
msgstr ""
#. TRANSLATORS: def DateTime.from_naive!(naive_datetime, time_zone)
#: lib/calendar.ex:1487 
msgid ""
"Converts the given NaiveDateTime to DateTime.\n"
"\n"
"It expects a time zone to put the NaiveDateTime in.\n"
"Currently it only supports \"Etc/UTC\" as time zone.\n"
"\n"
"## Examples\n"
"\n"
"    iex> DateTime.from_naive!(~N[2016-05-24 13:26:08.003], \"Etc/UTC\")\n"
"    %DateTime{calendar: Calendar.ISO, day: 24, hour: 13, microsecond: {3000, 3}, minute: 26,\n"
"              month: 5, second: 8, std_offset: 0, time_zone: \"Etc/UTC\", utc_offset: 0,\n"
"              year: 2016, zone_abbr: \"UTC\"}\n"
"\n"
msgstr ""
#. TRANSLATORS: def Date.new(year, month, day)
#: lib/calendar.ex:196 
msgid ""
"Builds a new ISO date.\n"
"\n"
"Expects all values to be integers. Returns `{:ok, date}` if each\n"
"entry fits its appropriate range, returns `{:error, reason}` otherwise.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Date.new(2000, 1, 1)\n"
"    {:ok, ~D[2000-01-01]}\n"
"    iex> Date.new(2000, 13, 1)\n"
"    {:error, :invalid_date}\n"
"    iex> Date.new(2000, 2, 29)\n"
"    {:ok, ~D[2000-02-29]}\n"
"\n"
"    iex> Date.new(2000, 2, 30)\n"
"    {:error, :invalid_date}\n"
"    iex> Date.new(2001, 2, 29)\n"
"    {:error, :invalid_date}\n"
"\n"
msgstr ""
#. TRANSLATORS: def Time.from_erl(arg, microsecond \\ {0, 0})
#: lib/calendar.ex:691 
msgid ""
"Converts an Erlang time tuple to a `Time` struct.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Time.from_erl({23, 30, 15}, {5000, 3})\n"
"    {:ok, ~T[23:30:15.005]}\n"
"    iex> Time.from_erl({24, 30, 15})\n"
"    {:error, :invalid_time}\n"
msgstr ""
#. TRANSLATORS: @type date
#: lib/calendar.ex:53 
msgid ""
"Any map/struct that contains the date fields"
msgstr ""
#. TRANSLATORS: def Date.from_iso8601(arg)
#: lib/calendar.ex:238 
msgid ""
"Parses the extended \"Date and time of day\" format described by\n"
"[ISO 8601:2004](https://en.wikipedia.org/wiki/ISO_8601).\n"
"\n"
"Timezone offset may be included in the string but they will be\n"
"simply discarded as such information is not included in naive date\n"
"times.\n"
"\n"
"Time representations with reduced accuracy are not supported.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Date.from_iso8601(\"2015-01-23\")\n"
"    {:ok, ~D[2015-01-23]}\n"
"\n"
"    iex> Date.from_iso8601(\"2015:01:23\")\n"
"    {:error, :invalid_format}\n"
"    iex> Date.from_iso8601(\"2015-01-32\")\n"
"    {:error, :invalid_date}\n"
"\n"
msgstr ""
#. TRANSLATORS: def DateTime.compare(datetime1, datetime2)
#: lib/calendar.ex:1769 
msgid ""
"Compares two `DateTime` structs.\n"
"\n"
"Returns `:gt` if first datetime is later than the second\n"
"and `:lt` for vice versa. If the two datetimes are equal\n"
"`:eq` is returned.\n"
"\n"
"Note that both utc and stc offsets will be taken into\n"
"account when comparison is done.\n"
"\n"
"## Examples\n"
"\n"
"    iex> dt1 = %DateTime{year: 2000, month: 2, day: 29, zone_abbr: \"AMT\",\n"
"    ...>                 hour: 23, minute: 0, second: 7, microsecond: {0, 0},\n"
"    ...>                 utc_offset: -14400, std_offset: 0, time_zone: \"America/Manaus\"}\n"
"    iex> dt2 = %DateTime{year: 2000, month: 2, day: 29, zone_abbr: \"CET\",\n"
"    ...>                 hour: 23, minute: 0, second: 7, microsecond: {0, 0},\n"
"    ...>                 utc_offset: 3600, std_offset: 0, time_zone: \"Europe/Warsaw\"}\n"
"    iex> DateTime.compare(dt1, dt2)\n"
"    :gt\n"
msgstr ""
#. TRANSLATORS: def DateTime.to_iso8601(map)
#: lib/calendar.ex:1610 
msgid ""
"Converts the given datetime to\n"
"[ISO 8601:2004](https://en.wikipedia.org/wiki/ISO_8601) format.\n"
"\n"
"Only supports converting datetimes which are in the ISO calendar,\n"
"attempting to convert datetimes from other calendars will raise.\n"
"\n"
"WARNING: the ISO 8601 datetime format does not contain the time zone nor\n"
"its abbreviation, which means information is lost when converting to such\n"
"format.\n"
"\n"
"### Examples\n"
"\n"
"    iex> dt = %DateTime{year: 2000, month: 2, day: 29, zone_abbr: \"CET\",\n"
"    ...>                hour: 23, minute: 0, second: 7, microsecond: {0, 0},\n"
"    ...>                utc_offset: 3600, std_offset: 0, time_zone: \"Europe/Warsaw\"}\n"
"    iex> DateTime.to_iso8601(dt)\n"
"    \"2000-02-29T23:00:07+01:00\"\n"
"\n"
"    iex> dt = %DateTime{year: 2000, month: 2, day: 29, zone_abbr: \"UTC\",\n"
"    ...>                hour: 23, minute: 0, second: 7, microsecond: {0, 0},\n"
"    ...>                utc_offset: 0, std_offset: 0, time_zone: \"Etc/UTC\"}\n"
"    iex> DateTime.to_iso8601(dt)\n"
"    \"2000-02-29T23:00:07Z\"\n"
"\n"
"    iex> dt = %DateTime{year: 2000, month: 2, day: 29, zone_abbr: \"AMT\",\n"
"    ...>                hour: 23, minute: 0, second: 7, microsecond: {0, 0},\n"
"    ...>                utc_offset: -14400, std_offset: 0, time_zone: \"America/Manaus\"}\n"
"    iex> DateTime.to_iso8601(dt)\n"
"    \"2000-02-29T23:00:07-04:00\"\n"
msgstr ""
#. TRANSLATORS: @type zone_abbr
#: lib/calendar.ex:44 
msgid ""
"The time zone abbreviation (e.g. CET or CEST or BST etc.)"
msgstr ""
#. TRANSLATORS: def NaiveDateTime.diff(naive_datetime1, naive_datetime2, unit \\ :second)
#: lib/calendar.ex:950 
msgid ""
"Subtract `naive_datetime2` from `naive_datetime1`.\n"
"\n"
"The answer can be returned in any `unit` available from `t:System.time_unit/0`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> NaiveDateTime.diff(~N[2014-10-02 00:29:12], ~N[2014-10-02 00:29:10])\n"
"    2\n"
"    iex> NaiveDateTime.diff(~N[2014-10-02 00:29:12], ~N[2014-10-02 00:29:10], :microsecond)\n"
"    2_000_000\n"
"    iex> NaiveDateTime.diff(~N[2014-10-02 00:29:10.042], ~N[2014-10-02 00:29:10.021], :millisecond)\n"
"    21\n"
"    # to gregorian seconds\n"
"    iex> NaiveDateTime.diff(~N[2014-10-02 00:29:10], ~N[0000-01-01 00:00:00])\n"
"    63579428950\n"
msgstr ""
#. TRANSLATORS: @type second
#: lib/calendar.ex:25 
msgid ""
"From 0 to 60 to account for leap seconds"
msgstr ""
#. TRANSLATORS: def NaiveDateTime.to_iso8601(map)
#: lib/calendar.ex:1136 
msgid ""
"Converts the given naive datetime to\n"
"[ISO 8601:2004](https://en.wikipedia.org/wiki/ISO_8601).\n"
"\n"
"Only supports converting naive datetimes which are in the ISO calendar,\n"
"attempting to convert naive datetimes from other calendars will raise.\n"
"\n"
"### Examples\n"
"\n"
"    iex> NaiveDateTime.to_iso8601(~N[2000-02-28 23:00:13])\n"
"    \"2000-02-28T23:00:13\"\n"
"\n"
"    iex> NaiveDateTime.to_iso8601(~N[2000-02-28 23:00:13.001])\n"
"    \"2000-02-28T23:00:13.001\"\n"
"\n"
"This function can also be used to convert a DateTime to ISO8601 without\n"
"the time zone information:\n"
"\n"
"    iex> dt = %DateTime{year: 2000, month: 2, day: 29, zone_abbr: \"CET\",\n"
"    ...>                hour: 23, minute: 0, second: 7, microsecond: {0, 0},\n"
"    ...>                utc_offset: 3600, std_offset: 0, time_zone: \"Europe/Warsaw\"}\n"
"    iex> NaiveDateTime.to_iso8601(dt)\n"
"    \"2000-02-29T23:00:07\"\n"
"\n"
msgstr ""
#. TRANSLATORS: def DateTime.to_string(map)
#: lib/calendar.ex:1729 
msgid ""
"Converts the given datetime to a string according to its calendar.\n"
"\n"
"### Examples\n"
"\n"
"    iex> dt = %DateTime{year: 2000, month: 2, day: 29, zone_abbr: \"CET\",\n"
"    ...>                hour: 23, minute: 0, second: 7, microsecond: {0, 0},\n"
"    ...>                utc_offset: 3600, std_offset: 0, time_zone: \"Europe/Warsaw\"}\n"
"    iex> DateTime.to_string(dt)\n"
"    \"2000-02-29 23:00:07+01:00 CET Europe/Warsaw\"\n"
"\n"
"    iex> dt = %DateTime{year: 2000, month: 2, day: 29, zone_abbr: \"UTC\",\n"
"    ...>                hour: 23, minute: 0, second: 7, microsecond: {0, 0},\n"
"    ...>                utc_offset: 0, std_offset: 0, time_zone: \"Etc/UTC\"}\n"
"    iex> DateTime.to_string(dt)\n"
"    \"2000-02-29 23:00:07Z\"\n"
"\n"
"    iex> dt = %DateTime{year: 2000, month: 2, day: 29, zone_abbr: \"AMT\",\n"
"    ...>                hour: 23, minute: 0, second: 7, microsecond: {0, 0},\n"
"    ...>                utc_offset: -14400, std_offset: 0, time_zone: \"America/Manaus\"}\n"
"    iex> DateTime.to_string(dt)\n"
"    \"2000-02-29 23:00:07-04:00 AMT America/Manaus\"\n"
msgstr ""
#. TRANSLATORS: def NaiveDateTime.from_erl(arg, microsecond \\ {0, 0})
#: lib/calendar.ex:1197 
msgid ""
"Converts an Erlang datetime tuple to a `NaiveDateTime` struct.\n"
"\n"
"Attempting to convert an invalid ISO calendar date will produce an error tuple.\n"
"\n"
"## Examples\n"
"\n"
"    iex> NaiveDateTime.from_erl({{2000, 1, 1}, {13, 30, 15}})\n"
"    {:ok, ~N[2000-01-01 13:30:15]}\n"
"    iex> NaiveDateTime.from_erl({{2000, 1, 1}, {13, 30, 15}}, {5000, 3})\n"
"    {:ok, ~N[2000-01-01 13:30:15.005]}\n"
"    iex> NaiveDateTime.from_erl({{2000, 13, 1}, {13, 30, 15}})\n"
"    {:error, :invalid_date}\n"
"    iex> NaiveDateTime.from_erl({{2000, 13, 1},{13, 30, 15}})\n"
"    {:error, :invalid_date}\n"
msgstr ""
#. TRANSLATORS: def DateTime.to_time(date_time)
#: lib/calendar.ex:1591 
msgid ""
"Converts a `DateTime` into `Time`.\n"
"\n"
"Because `Time` does not hold date nor time zone information,\n"
"data will be lost during the conversion.\n"
"\n"
"## Examples\n"
"\n"
"    iex> dt = %DateTime{year: 2000, month: 2, day: 29, zone_abbr: \"CET\",\n"
"    ...>                hour: 23, minute: 0, second: 7, microsecond: {0, 1},\n"
"    ...>                utc_offset: 3600, std_offset: 0, time_zone: \"Europe/Warsaw\"}\n"
"    iex> DateTime.to_time(dt)\n"
"    ~T[23:00:07.0]\n"
"\n"
msgstr ""
#. TRANSLATORS: @type time_zone
#: lib/calendar.ex:41 
msgid ""
"The time zone ID according to the IANA tz database (e.g. Europe/Zurich)"
msgstr ""
#. TRANSLATORS: def NaiveDateTime.to_string(map)
#: lib/calendar.ex:1011 
msgid ""
"Converts the given naive datetime to a string according to its calendar.\n"
"\n"
"### Examples\n"
"\n"
"    iex> NaiveDateTime.to_string(~N[2000-02-28 23:00:13])\n"
"    \"2000-02-28 23:00:13\"\n"
"    iex> NaiveDateTime.to_string(~N[2000-02-28 23:00:13.001])\n"
"    \"2000-02-28 23:00:13.001\"\n"
"\n"
"This function can also be used to convert a DateTime to a string without\n"
"the time zone information:\n"
"\n"
"    iex> dt = %DateTime{year: 2000, month: 2, day: 29, zone_abbr: \"CET\",\n"
"    ...>                hour: 23, minute: 0, second: 7, microsecond: {0, 0},\n"
"    ...>                utc_offset: 3600, std_offset: 0, time_zone: \"Europe/Warsaw\"}\n"
"    iex> NaiveDateTime.to_string(dt)\n"
"    \"2000-02-29 23:00:07\"\n"
"\n"
msgstr ""
#. TRANSLATORS: @type utc_offset
#: lib/calendar.ex:47 
msgid ""
"The time zone UTC offset in seconds"
msgstr ""
#. TRANSLATORS: @type naive_datetime
#: lib/calendar.ex:59 
msgid ""
"Any map/struct that contains the naive_datetime fields"
msgstr ""
#. TRANSLATORS: @type std_offset
#: lib/calendar.ex:50 
msgid ""
"The time zone standard offset in seconds (not zero in summer times)"
msgstr ""
#. TRANSLATORS: def Date.leap_year?(map)
#: lib/calendar.ex:156 
msgid ""
"Returns true if the year in `date` is a leap year.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Date.leap_year?(~D[2000-01-01])\n"
"    true\n"
"    iex> Date.leap_year?(~D[2001-01-01])\n"
"    false\n"
"    iex> Date.leap_year?(~D[2004-01-01])\n"
"    true\n"
"    iex> Date.leap_year?(~D[1900-01-01])\n"
"    false\n"
"    iex> Date.leap_year?(~N[2004-01-01 01:23:45])\n"
"    true\n"
"\n"
msgstr ""
#. TRANSLATORS: def NaiveDateTime.to_erl(map)
#: lib/calendar.ex:1167 
msgid ""
"Converts a `NaiveDateTime` struct to an Erlang datetime tuple.\n"
"\n"
"Only supports converting naive datetimes which are in the ISO calendar,\n"
"attempting to convert naive datetimes from other calendars will raise.\n"
"\n"
"WARNING: Loss of precision may occur, as Erlang time tuples only store\n"
"hour/minute/second.\n"
"\n"
"## Examples\n"
"\n"
"    iex> NaiveDateTime.to_erl(~N[2000-01-01 13:30:15])\n"
"    {{2000, 1, 1}, {13, 30, 15}}\n"
"\n"
"This function can also be used to convert a DateTime to a erl format\n"
"without the time zone information:\n"
"\n"
"    iex> dt = %DateTime{year: 2000, month: 2, day: 29, zone_abbr: \"CET\",\n"
"    ...>                hour: 23, minute: 0, second: 7, microsecond: {0, 0},\n"
"    ...>                utc_offset: 3600, std_offset: 0, time_zone: \"Europe/Warsaw\"}\n"
"    iex> NaiveDateTime.to_erl(dt)\n"
"    {{2000, 2, 29}, {23, 00, 07}}\n"
"\n"
msgstr ""
#. TRANSLATORS: def DateTime.from_unix!(integer, unit \\ :second)
#: lib/calendar.ex:1421 
msgid ""
"Converts the given Unix time to DateTime.\n"
"\n"
"The integer can be given in different unit\n"
"according to `System.convert_time_unit/3` and it will\n"
"be converted to microseconds internally.\n"
"\n"
"Unix times are always in UTC and therefore the DateTime\n"
"will be returned in UTC.\n"
"\n"
"## Examples\n"
"\n"
"    iex> DateTime.from_unix!(1464096368)\n"
"    %DateTime{calendar: Calendar.ISO, day: 24, hour: 13, microsecond: {0, 0}, minute: 26,\n"
"              month: 5, second: 8, std_offset: 0, time_zone: \"Etc/UTC\", utc_offset: 0,\n"
"              year: 2016, zone_abbr: \"UTC\"}\n"
"\n"
"    iex> DateTime.from_unix!(1432560368868569, :microsecond)\n"
"    %DateTime{calendar: Calendar.ISO, day: 25, hour: 13, microsecond: {868569, 6}, minute: 26,\n"
"              month: 5, second: 8, std_offset: 0, time_zone: \"Etc/UTC\", utc_offset: 0,\n"
"              year: 2015, zone_abbr: \"UTC\"}\n"
"\n"
"Negative Unix times are supported, up to -62167219200 seconds,\n"
"which is equivalent to \"0000-01-01T00:00:00Z\" or 0 gregorian seconds.\n"
"\n"
"    iex> DateTime.from_unix(-12345678910)\n"
"    {:ok, %DateTime{calendar: Calendar.ISO, day: 13, hour: 4, microsecond: {0, 0}, minute: 44,\n"
"                    month: 10, second: 50, std_offset: 0, time_zone: \"Etc/UTC\", utc_offset: 0,\n"
"                    year: 1578, zone_abbr: \"UTC\"}}\n"
"\n"
"When a Unix time before that moment is passed to `from_unix!/2`, an ArgumentError will be raised.\n"
msgstr ""
#. TRANSLATORS: def NaiveDateTime.compare(naive_datetime1, naive_datetime2)
#: lib/calendar.ex:1243 
msgid ""
"Compares two `NaiveDateTime` structs.\n"
"\n"
"Returns `:gt` if first is later than the second\n"
"and `:lt` for vice versa. If the two NaiveDateTime\n"
"are equal `:eq` is returned\n"
"\n"
"## Examples\n"
"\n"
"    iex> NaiveDateTime.compare(~N[2016-04-16 13:30:15], ~N[2016-04-28 16:19:25])\n"
"    :lt\n"
"    iex> NaiveDateTime.compare(~N[2016-04-16 13:30:15.1], ~N[2016-04-16 13:30:15.01])\n"
"    :gt\n"
"\n"
"This function can also be used to compare a DateTime without\n"
"the time zone information:\n"
"\n"
"    iex> dt = %DateTime{year: 2000, month: 2, day: 29, zone_abbr: \"CET\",\n"
"    ...>                hour: 23, minute: 0, second: 7, microsecond: {0, 0},\n"
"    ...>                utc_offset: 3600, std_offset: 0, time_zone: \"Europe/Warsaw\"}\n"
"    iex> NaiveDateTime.compare(dt, ~N[2000-02-29 23:00:07])\n"
"    :eq\n"
"    iex> NaiveDateTime.compare(dt, ~N[2000-01-29 23:00:07])\n"
"    :gt\n"
"    iex> NaiveDateTime.compare(dt, ~N[2000-03-29 23:00:07])\n"
"    :lt\n"
"\n"
msgstr ""
#. TRANSLATORS: @type datetime
#: lib/calendar.ex:63 
msgid ""
"Any map/struct that contains the datetime fields"
msgstr ""
#. TRANSLATORS: def NaiveDateTime.utc_now()
#: lib/calendar.ex:822 
msgid ""
"Returns the current naive datetime in UTC.\n"
"\n"
"Prefer using `DateTime.utc_now/0` when possible as, opposite\n"
"to `NaiveDateTime`, it will keep the time zone information.\n"
"\n"
"## Examples\n"
"\n"
"    iex> naive_datetime = NaiveDateTime.utc_now()\n"
"    iex> naive_datetime.year >= 2016\n"
"    true\n"
"\n"
msgstr ""
#. TRANSLATORS: def Time.new(hour, minute, second, microsecond \\ {0, 0})
#: lib/calendar.ex:497 
msgid ""
"Builds a new time.\n"
"\n"
"Expects all values to be integers. Returns `{:ok, time}` if each\n"
"entry fits its appropriate range, returns `{:error, reason}` otherwise.\n"
"\n"
"Note a time may have 60 seconds in case of leap seconds.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Time.new(0, 0, 0, 0)\n"
"    {:ok, ~T[00:00:00.000000]}\n"
"    iex> Time.new(23, 59, 59, 999_999)\n"
"    {:ok, ~T[23:59:59.999999]}\n"
"    iex> Time.new(23, 59, 60, 999_999)\n"
"    {:ok, ~T[23:59:60.999999]}\n"
"\n"
"    # Time with microseconds and their precision\n"
"    iex> Time.new(23, 59, 60, {10_000, 2})\n"
"    {:ok, ~T[23:59:60.01]}\n"
"\n"
"    iex> Time.new(24, 59, 59, 999_999)\n"
"    {:error, :invalid_time}\n"
"    iex> Time.new(23, 60, 59, 999_999)\n"
"    {:error, :invalid_time}\n"
"    iex> Time.new(23, 59, 61, 999_999)\n"
"    {:error, :invalid_time}\n"
"    iex> Time.new(23, 59, 59, 1_000_000)\n"
"    {:error, :invalid_time}\n"
"\n"
msgstr ""
#. TRANSLATORS: def NaiveDateTime.add(naive_datetime, integer, unit \\ :second)
#: lib/calendar.ex:907 
msgid ""
"Adds a specified amount of time to a `NaiveDateTime`.\n"
"\n"
"Accepts an `integer` in any `unit` available from `t:System.time_unit/0`.\n"
"Negative values will be move backwards in time.\n"
"\n"
"## Examples\n"
"\n"
"    # adds seconds by default\n"
"    iex> NaiveDateTime.add(~N[2014-10-02 00:29:10], 2)\n"
"    ~N[2014-10-02 00:29:12]\n"
"    # accepts negative offsets\n"
"    iex> NaiveDateTime.add(~N[2014-10-02 00:29:10], -2)\n"
"    ~N[2014-10-02 00:29:08]\n"
"    # can work with other units\n"
"    iex> NaiveDateTime.add(~N[2014-10-02 00:29:10], 2_000, :millisecond)\n"
"    ~N[2014-10-02 00:29:12]\n"
"    # keeps the same precision\n"
"    iex> NaiveDateTime.add(~N[2014-10-02 00:29:10.021], 21, :second)\n"
"    ~N[2014-10-02 00:29:31.021]\n"
"    # changes below the precision will not be visible\n"
"    iex> hidden = NaiveDateTime.add(~N[2014-10-02 00:29:10], 21, :millisecond)\n"
"    iex> hidden.microsecond  # ~N[2014-10-02 00:29:10]\n"
"    {21000, 0}\n"
"    # from gregorian seconds\n"
"    iex> NaiveDateTime.add(~N[0000-01-01 00:00:00], 63579428950)\n"
"    ~N[2014-10-02 00:29:10]\n"
msgstr ""
#. TRANSLATORS: def Time.from_erl!(tuple, microsecond \\ {0, 0})
#: lib/calendar.ex:706 
msgid ""
"Converts an Erlang time tuple to a `Time` struct.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Time.from_erl!({23, 30, 15})\n"
"    ~T[23:30:15]\n"
"    iex> Time.from_erl!({23, 30, 15}, {5000, 3})\n"
"    ~T[23:30:15.005]\n"
"    iex> Time.from_erl!({24, 30, 15})\n"
"    ** (ArgumentError) cannot convert {24, 30, 15} to time, reason: :invalid_time\n"
msgstr ""
#. TRANSLATORS: Elixir.DateTime Summary
#: lib/calendar.ex:1316 
msgid ""
"A datetime implementation with a time zone.\n"
"\n"
"This datetime can be seen as an ephemeral snapshot\n"
"of a datetime at a given time zone. For such purposes,\n"
"it also includes both UTC and Standard offsets, as\n"
"well as the zone abbreviation field used exclusively\n"
"for formatting purposes.\n"
"\n"
"Developers should avoid creating the DateTime struct directly\n"
"and instead rely on the functions provided by this module as\n"
"well as the ones in 3rd party calendar libraries.\n"
"\n"
"## Where are my functions?\n"
"\n"
"You will notice this module only contains conversion\n"
"functions as well as functions that work on UTC. This\n"
"is because a proper DateTime implementation requires a\n"
"TimeZone database which currently is not provided as part\n"
"of Elixir.\n"
"\n"
"Such may be addressed in upcoming versions, meanwhile,\n"
"use 3rd party packages to provide DateTime building and\n"
"similar functionality with time zone backing.\n"
msgstr ""
#. TRANSLATORS: def DateTime.from_unix(integer, unit \\ :second)
#: lib/calendar.ex:1370 
msgid ""
"Converts the given Unix time to DateTime.\n"
"\n"
"The integer can be given in different unit\n"
"according to `System.convert_time_unit/3` and it will\n"
"be converted to microseconds internally.\n"
"\n"
"Unix times are always in UTC and therefore the DateTime\n"
"will be returned in UTC.\n"
"\n"
"## Examples\n"
"\n"
"    iex> DateTime.from_unix(1464096368)\n"
"    {:ok, %DateTime{calendar: Calendar.ISO, day: 24, hour: 13, microsecond: {0, 0}, minute: 26,\n"
"                    month: 5, second: 8, std_offset: 0, time_zone: \"Etc/UTC\", utc_offset: 0,\n"
"                    year: 2016, zone_abbr: \"UTC\"}}\n"
"\n"
"    iex> DateTime.from_unix(1432560368868569, :microsecond)\n"
"    {:ok, %DateTime{calendar: Calendar.ISO, day: 25, hour: 13, microsecond: {868569, 6}, minute: 26,\n"
"                    month: 5, second: 8, std_offset: 0, time_zone: \"Etc/UTC\", utc_offset: 0,\n"
"                    year: 2015, zone_abbr: \"UTC\"}}\n"
"\n"
"The unit can also be an integer as in `t:System.time_unit/0`:\n"
"\n"
"    iex> DateTime.from_unix(1432560368868569, 1024)\n"
"    {:ok, %DateTime{calendar: Calendar.ISO, day: 23, hour: 22, microsecond: {211914, 3}, minute: 53,\n"
"                    month: 1, second: 43, std_offset: 0, time_zone: \"Etc/UTC\", utc_offset: 0,\n"
"                    year: 46302, zone_abbr: \"UTC\"}}\n"
"\n"
"Negative Unix times are supported, up to -62167219200 seconds,\n"
"which is equivalent to \"0000-01-01T00:00:00Z\" or 0 gregorian seconds.\n"
"\n"
"    iex> DateTime.from_unix(-12345678910)\n"
"    {:ok, %DateTime{calendar: Calendar.ISO, day: 13, hour: 4, microsecond: {0, 0}, minute: 44,\n"
"                    month: 10, second: 50, std_offset: 0, time_zone: \"Etc/UTC\", utc_offset: 0,\n"
"                    year: 1578, zone_abbr: \"UTC\"}}\n"
"\n"
"When a Unix time before that moment is passed to `from_unix/2`, `:error` will be returned.\n"
msgstr ""
#. TRANSLATORS: def NaiveDateTime.new(date, time)
#: lib/calendar.ex:889 
msgid ""
"Builds a naive datetime from date and time structs.\n"
"\n"
"## Examples\n"
"\n"
"    iex> NaiveDateTime.new(~D[2010-01-13], ~T[23:00:07.005])\n"
"    {:ok, ~N[2010-01-13 23:00:07.005]}\n"
"\n"
msgstr ""
#. TRANSLATORS: Elixir.Calendar Summary
#: lib/calendar.ex:2 
msgid ""
"This module defines the responsibilities for working with\n"
"calendars, dates, times and datetimes in Elixir.\n"
"\n"
"Currently it defines types and the minimal implementation\n"
"for a calendar behaviour in Elixir. The goal of the Calendar\n"
"features in Elixir is to provide a base for interoperability\n"
"instead of full-featured datetime API.\n"
"\n"
"For the actual date, time and datetime structures, see `Date`,\n"
"`Time`, `NaiveDateTime` and `DateTime`.\n"
"\n"
"Note the year, month, day, etc designations are overspecified\n"
"(i.e. an integer instead of 1..12 for months) because different\n"
"calendars may have a different number of days per month, months per year and so on.\n"
msgstr ""
#. TRANSLATORS: @callback day_of_week/3
#: lib/calendar.ex:82 
msgid ""
"Calculates the day of the week from the given `year`, `month`, and `day`.\n"
msgstr ""
#. TRANSLATORS: def Date.days_in_month(map)
#: lib/calendar.ex:178 
msgid ""
"Returns the number of days in the given date month.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Date.days_in_month(~D[1900-01-13])\n"
"    31\n"
"    iex> Date.days_in_month(~D[1900-02-09])\n"
"    28\n"
"    iex> Date.days_in_month(~N[2000-02-20 01:23:45])\n"
"    29\n"
"\n"
msgstr ""
#. TRANSLATORS: def DateTime.to_date(date_time)
#: lib/calendar.ex:1572 
msgid ""
"Converts a `DateTime` into a `Date`.\n"
"\n"
"Because `Date` does not hold time nor time zone information,\n"
"data will be lost during the conversion.\n"
"\n"
"## Examples\n"
"\n"
"    iex> dt = %DateTime{year: 2000, month: 2, day: 29, zone_abbr: \"CET\",\n"
"    ...>                hour: 23, minute: 0, second: 7, microsecond: {0, 0},\n"
"    ...>                utc_offset: 3600, std_offset: 0, time_zone: \"Europe/Warsaw\"}\n"
"    iex> DateTime.to_date(dt)\n"
"    ~D[2000-02-29]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Time.to_iso8601(map)
#: lib/calendar.ex:649 
msgid ""
"Converts the given time to\n"
"[ISO 8601:2004](https://en.wikipedia.org/wiki/ISO_8601).\n"
"\n"
"### Examples\n"
"\n"
"    iex> Time.to_iso8601(~T[23:00:13])\n"
"    \"23:00:13\"\n"
"    iex> Time.to_iso8601(~T[23:00:13.001])\n"
"    \"23:00:13.001\"\n"
"\n"
"    iex> Time.to_iso8601(~N[2015-01-01 23:00:13])\n"
"    \"23:00:13\"\n"
"    iex> Time.to_iso8601(~N[2015-01-01 23:00:13.001])\n"
"    \"23:00:13.001\"\n"
"\n"
msgstr ""
#. TRANSLATORS: Elixir.Date Summary
#: lib/calendar.ex:105 
msgid ""
"A Date struct and functions.\n"
"\n"
"The Date struct contains the fields year, month, day and calendar.\n"
"New dates can be built with the `new/3` function or using the `~D`\n"
"sigil:\n"
"\n"
"    iex> ~D[2000-01-01]\n"
"    ~D[2000-01-01]\n"
"\n"
"Both `new/3` and sigil return a struct where the date fields can\n"
"be accessed directly:\n"
"\n"
"    iex> date = ~D[2000-01-01]\n"
"    iex> date.year\n"
"    2000\n"
"    iex> date.month\n"
"    1\n"
"\n"
"The functions on this module work with the `Date` struct as well\n"
"as any struct that contains the same fields as the `Date` struct,\n"
"such as `NaiveDateTime` and `DateTime`. Such functions expect\n"
"`Calendar.date` in their typespecs (instead of `t`).\n"
"\n"
"Developers should avoid creating the Date struct directly and\n"
"instead rely on the functions provided by this module as well as\n"
"the ones in 3rd party calendar libraries.\n"
msgstr ""
#. TRANSLATORS: def NaiveDateTime.from_iso8601!(string)
#: lib/calendar.ex:1112 
msgid ""
"Parses the extended \"Date and time of day\" format described by\n"
"[ISO 8601:2004](https://en.wikipedia.org/wiki/ISO_8601).\n"
"\n"
"Raises if the format is invalid.\n"
"\n"
"## Examples\n"
"\n"
"    iex> NaiveDateTime.from_iso8601!(\"2015-01-23T23:50:07.123Z\")\n"
"    ~N[2015-01-23 23:50:07.123]\n"
"    iex> NaiveDateTime.from_iso8601!(\"2015-01-23P23:50:07\")\n"
"    ** (ArgumentError) cannot parse \"2015-01-23P23:50:07\" as naive datetime, reason: :invalid_format\n"
"\n"
msgstr ""
#. TRANSLATORS: Elixir.NaiveDateTime Summary
#: lib/calendar.ex:780 
msgid ""
"A NaiveDateTime struct (without a time zone) and functions.\n"
"\n"
"The NaiveDateTime struct contains the fields year, month, day, hour,\n"
"minute, second, microsecond and calendar. New naive datetimes can be\n"
"built with the `new/7` function or using the `~N` sigil:\n"
"\n"
"    iex> ~N[2000-01-01 23:00:07]\n"
"    ~N[2000-01-01 23:00:07]\n"
"\n"
"Both `new/7` and sigil return a struct where the date fields can\n"
"be accessed directly:\n"
"\n"
"    iex> naive = ~N[2000-01-01 23:00:07]\n"
"    iex> naive.year\n"
"    2000\n"
"    iex> naive.second\n"
"    7\n"
"\n"
"The naive bit implies this datetime representation does\n"
"not have a time zone. This means the datetime may not\n"
"actually exist in certain areas in the world even though\n"
"it is valid.\n"
"\n"
"For example, when daylight saving changes are applied\n"
"by a region, the clock typically moves forward or backward\n"
"by one hour. This means certain datetimes never occur or\n"
"may occur more than once. Since `NaiveDateTime` is not\n"
"validated against a time zone, such errors would go unnoticed.\n"
"\n"
"Developers should avoid creating the NaiveDateTime struct directly\n"
"and instead rely on the functions provided by this module as well\n"
"as the ones in 3rd party calendar libraries.\n"
msgstr ""
#. TRANSLATORS: Elixir.Time Summary
#: lib/calendar.ex:446 
msgid ""
"A Time struct and functions.\n"
"\n"
"The Time struct contains the fields hour, minute, second and microseconds.\n"
"New times can be built with the `new/4` function or using the `~T`\n"
"sigil:\n"
"\n"
"    iex> ~T[23:00:07.001]\n"
"    ~T[23:00:07.001]\n"
"\n"
"Both `new/4` and sigil return a struct where the time fields can\n"
"be accessed directly:\n"
"\n"
"    iex> time = ~T[23:00:07.001]\n"
"    iex> time.hour\n"
"    23\n"
"    iex> time.microsecond\n"
"    {1000, 3}\n"
"\n"
"The functions on this module work with the `Time` struct as well\n"
"as any struct that contains the same fields as the `Time` struct,\n"
"such as `NaiveDateTime` and `DateTime`. Such functions expect\n"
"`Calendar.time` in their typespecs (instead of `t`).\n"
"\n"
"Developers should avoid creating the Time struct directly and\n"
"instead rely on the functions provided by this module as well as\n"
"the ones in 3rd party calendar libraries.\n"
msgstr ""
#. TRANSLATORS: def Time.from_iso8601!(string)
#: lib/calendar.ex:626 
msgid ""
"Parses the extended \"Local time\" format described by\n"
"[ISO 8601:2004](https://en.wikipedia.org/wiki/ISO_8601).\n"
"\n"
"Raises if the format is invalid.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Time.from_iso8601!(\"23:50:07.123Z\")\n"
"    ~T[23:50:07.123]\n"
"    iex> Time.from_iso8601!(\"2015:01:23 23-50-07\")\n"
"    ** (ArgumentError) cannot parse \"2015:01:23 23-50-07\" as time, reason: :invalid_format\n"
msgstr ""
#. TRANSLATORS: def DateTime.utc_now()
#: lib/calendar.ex:1355 
msgid ""
"Returns the current datetime in UTC.\n"
"\n"
"## Examples\n"
"\n"
"    iex> datetime = DateTime.utc_now()\n"
"    iex> datetime.time_zone\n"
"    \"Etc/UTC\"\n"
"\n"
msgstr ""
#. TRANSLATORS: def DateTime.to_unix(datetime, unit \\ :second)
#: lib/calendar.ex:1511 
msgid ""
"Converts the given DateTime to Unix time.\n"
"\n"
"The DateTime is expected to be using the ISO calendar\n"
"with a year greater than or equal to 0.\n"
"\n"
"It will return the integer with the given unit,\n"
"according to `System.convert_time_unit/3`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> 1464096368 |> DateTime.from_unix!() |> DateTime.to_unix()\n"
"    1464096368\n"
"\n"
"    iex> dt = %DateTime{calendar: Calendar.ISO, day: 20, hour: 18, microsecond: {273806, 6},\n"
"    ...>                minute: 58, month: 11, second: 19, time_zone: \"America/Montevideo\",\n"
"    ...>                utc_offset: -10800, std_offset: 3600, year: 2014, zone_abbr: \"UYST\"}\n"
"    iex> DateTime.to_unix(dt)\n"
"    1416517099\n"
"\n"
"    iex> flamel = %DateTime{calendar: Calendar.ISO, day: 22, hour: 8, microsecond: {527771, 6},\n"
"    ...>                minute: 2, month: 3, second: 25, std_offset: 0, time_zone: \"Etc/UTC\",\n"
"    ...>                utc_offset: 0, year: 1418, zone_abbr: \"UTC\"}\n"
"    iex> DateTime.to_unix(flamel)\n"
"    -17412508655\n"
"\n"
msgstr ""
#. TRANSLATORS: def DateTime.from_naive(naive_datetime, time_zone)
#: lib/calendar.ex:1463 
msgid ""
"Converts the given NaiveDateTime to DateTime.\n"
"\n"
"It expects a time zone to put the NaiveDateTime in.\n"
"Currently it only supports \"Etc/UTC\" as time zone.\n"
"\n"
"## Examples\n"
"\n"
"    iex> DateTime.from_naive(~N[2016-05-24 13:26:08.003], \"Etc/UTC\")\n"
"    {:ok, %DateTime{calendar: Calendar.ISO, day: 24, hour: 13, microsecond: {3000, 3}, minute: 26,\n"
"                    month: 5, second: 8, std_offset: 0, time_zone: \"Etc/UTC\", utc_offset: 0,\n"
"                    year: 2016, zone_abbr: \"UTC\"}}\n"
"\n"
msgstr ""
#. TRANSLATORS: @callback days_in_month/2
#: lib/calendar.ex:68 
msgid ""
"Returns how many days there are in the given year-month.\n"
msgstr ""
#. TRANSLATORS: def Date.from_erl!(tuple)
#: lib/calendar.ex:353 
msgid ""
"Converts an Erlang date tuple but raises for invalid dates.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Date.from_erl!({2000, 1, 1})\n"
"    ~D[2000-01-01]\n"
"    iex> Date.from_erl!({2000, 13, 1})\n"
"    ** (ArgumentError) cannot convert {2000, 13, 1} to date, reason: :invalid_date\n"
msgstr ""
#. TRANSLATORS: def DateTime.to_naive(date_time)
#: lib/calendar.ex:1551 
msgid ""
"Converts a `DateTime` into a `NaiveDateTime`.\n"
"\n"
"Because `NaiveDateTime` does not hold time zone information,\n"
"any time zone related data will be lost during the conversion.\n"
"\n"
"## Examples\n"
"\n"
"    iex> dt = %DateTime{year: 2000, month: 2, day: 29, zone_abbr: \"CET\",\n"
"    ...>                hour: 23, minute: 0, second: 7, microsecond: {0, 1},\n"
"    ...>                utc_offset: 3600, std_offset: 0, time_zone: \"Europe/Warsaw\"}\n"
"    iex> DateTime.to_naive(dt)\n"
"    ~N[2000-02-29 23:00:07.0]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Date.day_of_week(map)
#: lib/calendar.ex:405 
msgid ""
"Calculates the day of the week of a given `Date` struct.\n"
"\n"
"Returns the day of the week as an integer. For the ISO 8601\n"
"calendar (the default), it is an integer from 1 to 7, where\n"
"1 is Monday and 7 is Sunday.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Date.day_of_week(~D[2016-10-31])\n"
"    1\n"
"    iex> Date.day_of_week(~D[2016-11-01])\n"
"    2\n"
"    iex> Date.day_of_week(~N[2016-11-01 01:23:45])\n"
"    2\n"
msgstr ""
#. TRANSLATORS: def NaiveDateTime.from_erl!(tuple, microsecond \\ {0, 0})
#: lib/calendar.ex:1218 
msgid ""
"Converts an Erlang datetime tuple to a `NaiveDateTime` struct.\n"
"\n"
"Raises if the datetime is invalid.\n"
"Attempting to convert an invalid ISO calendar date will produce an error tuple.\n"
"\n"
"## Examples\n"
"\n"
"    iex> NaiveDateTime.from_erl!({{2000, 1, 1}, {13, 30, 15}})\n"
"    ~N[2000-01-01 13:30:15]\n"
"    iex> NaiveDateTime.from_erl!({{2000, 1, 1}, {13, 30, 15}}, {5000, 3})\n"
"    ~N[2000-01-01 13:30:15.005]\n"
"    iex> NaiveDateTime.from_erl!({{2000, 13, 1}, {13, 30, 15}})\n"
"    ** (ArgumentError) cannot convert {{2000, 13, 1}, {13, 30, 15}} to naive datetime, reason: :invalid_date\n"
msgstr ""
#. TRANSLATORS: def Time.compare(time1, time2)
#: lib/calendar.ex:728 
msgid ""
"Compares two `Time` structs.\n"
"\n"
"Returns `:gt` if first time is later than the second\n"
"and `:lt` for vice versa. If the two times are equal\n"
"`:eq` is returned\n"
"\n"
"## Examples\n"
"\n"
"    iex> Time.compare(~T[16:04:16], ~T[16:04:28])\n"
"    :lt\n"
"    iex> Time.compare(~T[16:04:16.01], ~T[16:04:16.001])\n"
"    :gt\n"
"\n"
"This function can also be used to compare across more\n"
"complex calendar types by considering only the time fields:\n"
"\n"
"    iex> Time.compare(~N[2015-01-01 16:04:16], ~N[2015-01-01 16:04:28])\n"
"    :lt\n"
"    iex> Time.compare(~N[2015-01-01 16:04:16.01], ~N[2000-01-01 16:04:16.001])\n"
"    :gt\n"
"\n"
msgstr ""
#. TRANSLATORS: @type calendar
#: lib/calendar.ex:38 
msgid ""
"A calendar implementation"
msgstr ""
#. TRANSLATORS: def Date.utc_today()
#: lib/calendar.ex:140 
msgid ""
"Returns the current date in UTC.\n"
"\n"
"## Examples\n"
"\n"
"    iex> date = Date.utc_today()\n"
"    iex> date.year >= 2016\n"
"    true\n"
"\n"
msgstr ""
#. TRANSLATORS: @type microsecond
#: lib/calendar.ex:28 
msgid ""
"Microseconds with stored precision.\n"
"\n"
"The precision represents the number of digits\n"
"that must be used when representing the microseconds\n"
"to external format. If the precision is 0, it means\n"
"microseconds must be skipped.\n"
msgstr ""
#. TRANSLATORS: def Date.from_erl(arg)
#: lib/calendar.ex:336 
msgid ""
"Converts an Erlang date tuple to a `Date` struct.\n"
"\n"
"Attempting to convert an invalid ISO calendar date will produce an error tuple.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Date.from_erl({2000, 1, 1})\n"
"    {:ok, ~D[2000-01-01]}\n"
"    iex> Date.from_erl({2000, 13, 1})\n"
"    {:error, :invalid_date}\n"
msgstr ""
#. TRANSLATORS: def NaiveDateTime.new(year, month, day, hour, minute, second, microsecond \\ {0, 0})
#: lib/calendar.ex:844 
msgid ""
"Builds a new ISO naive datetime.\n"
"\n"
"Expects all values to be integers. Returns `{:ok, naive_datetime}`\n"
"if each entry fits its appropriate range, returns `{:error, reason}`\n"
"otherwise.\n"
"\n"
"## Examples\n"
"\n"
"    iex> NaiveDateTime.new(2000, 1, 1, 0, 0, 0)\n"
"    {:ok, ~N[2000-01-01 00:00:00]}\n"
"    iex> NaiveDateTime.new(2000, 13, 1, 0, 0, 0)\n"
"    {:error, :invalid_date}\n"
"    iex> NaiveDateTime.new(2000, 2, 29, 0, 0, 0)\n"
"    {:ok, ~N[2000-02-29 00:00:00]}\n"
"    iex> NaiveDateTime.new(2000, 2, 30, 0, 0, 0)\n"
"    {:error, :invalid_date}\n"
"    iex> NaiveDateTime.new(2001, 2, 29, 0, 0, 0)\n"
"    {:error, :invalid_date}\n"
"\n"
"    iex> NaiveDateTime.new(2000, 1, 1, 23, 59, 59, {0, 1})\n"
"    {:ok, ~N[2000-01-01 23:59:59.0]}\n"
"    iex> NaiveDateTime.new(2000, 1, 1, 23, 59, 59, 999_999)\n"
"    {:ok, ~N[2000-01-01 23:59:59.999999]}\n"
"    iex> NaiveDateTime.new(2000, 1, 1, 23, 59, 60, 999_999)\n"
"    {:ok, ~N[2000-01-01 23:59:60.999999]}\n"
"    iex> NaiveDateTime.new(2000, 1, 1, 24, 59, 59, 999_999)\n"
"    {:error, :invalid_time}\n"
"    iex> NaiveDateTime.new(2000, 1, 1, 23, 60, 59, 999_999)\n"
"    {:error, :invalid_time}\n"
"    iex> NaiveDateTime.new(2000, 1, 1, 23, 59, 61, 999_999)\n"
"    {:error, :invalid_time}\n"
"    iex> NaiveDateTime.new(2000, 1, 1, 23, 59, 59, 1_000_000)\n"
"    {:error, :invalid_time}\n"
"\n"
msgstr ""
#. TRANSLATORS: def Time.from_iso8601(arg)
#: lib/calendar.ex:570 
msgid ""
"Parses the extended \"Local time\" format described by\n"
"[ISO 8601:2004](https://en.wikipedia.org/wiki/ISO_8601).\n"
"\n"
"Timezone offset may be included in the string but they will be\n"
"simply discarded as such information is not included in times.\n"
"\n"
"As specified in the standard, the separator \"T\" may be omitted if\n"
"desired as there is no ambiguity within this function.\n"
"\n"
"Time representations with reduced accuracy are not supported.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Time.from_iso8601(\"23:50:07\")\n"
"    {:ok, ~T[23:50:07]}\n"
"    iex> Time.from_iso8601(\"23:50:07Z\")\n"
"    {:ok, ~T[23:50:07]}\n"
"    iex> Time.from_iso8601(\"T23:50:07Z\")\n"
"    {:ok, ~T[23:50:07]}\n"
"\n"
"    iex> Time.from_iso8601(\"23:50:07.0123456\")\n"
"    {:ok, ~T[23:50:07.012345]}\n"
"    iex> Time.from_iso8601(\"23:50:07.123Z\")\n"
"    {:ok, ~T[23:50:07.123]}\n"
"\n"
"    iex> Time.from_iso8601(\"2015:01:23 23-50-07\")\n"
"    {:error, :invalid_format}\n"
"    iex> Time.from_iso8601(\"23:50:07A\")\n"
"    {:error, :invalid_format}\n"
"    iex> Time.from_iso8601(\"23:50:07.\")\n"
"    {:error, :invalid_format}\n"
"    iex> Time.from_iso8601(\"23:50:61\")\n"
"    {:error, :invalid_time}\n"
"\n"
msgstr ""
#. TRANSLATORS: def Time.utc_now()
#: lib/calendar.ex:481 
msgid ""
"Returns the current time in UTC.\n"
"\n"
"## Examples\n"
"\n"
"    iex> time = Time.utc_now()\n"
"    iex> time.hour >= 0\n"
"    true\n"
"\n"
msgstr ""
#. TRANSLATORS: def NaiveDateTime.to_date(naive_date_time)
#: lib/calendar.ex:977 
msgid ""
"Converts a `NaiveDateTime` into a `Date`.\n"
"\n"
"Because `Date` does not hold time information,\n"
"data will be lost during the conversion.\n"
"\n"
"## Examples\n"
"\n"
"    iex> NaiveDateTime.to_date(~N[2002-01-13 23:00:07])\n"
"    ~D[2002-01-13]\n"
"\n"
msgstr ""
#. TRANSLATORS: @type time
#: lib/calendar.ex:56 
msgid ""
"Any map/struct that contains the time fields"
msgstr ""
#. TRANSLATORS: def Time.to_string(map)
#: lib/calendar.ex:547 
msgid ""
"Converts the given time to a string.\n"
"\n"
"### Examples\n"
"\n"
"    iex> Time.to_string(~T[23:00:00])\n"
"    \"23:00:00\"\n"
"    iex> Time.to_string(~T[23:00:00.001])\n"
"    \"23:00:00.001\"\n"
"    iex> Time.to_string(~T[23:00:00.123456])\n"
"    \"23:00:00.123456\"\n"
"\n"
"    iex> Time.to_string(~N[2015-01-01 23:00:00.001])\n"
"    \"23:00:00.001\"\n"
"    iex> Time.to_string(~N[2015-01-01 23:00:00.123456])\n"
"    \"23:00:00.123456\"\n"
"\n"
msgstr ""
#. TRANSLATORS: def DateTime.from_iso8601(arg1)
#: lib/calendar.ex:1649 
msgid ""
"Parses the extended \"Date and time of day\" format described by\n"
"[ISO 8601:2004](https://en.wikipedia.org/wiki/ISO_8601).\n"
"\n"
"Since ISO8601 does not include the proper time zone, the given\n"
"string will be converted to UTC and its offset in seconds will be\n"
"returned as part of this function. Therefore offset information\n"
"must be present in the string.\n"
"\n"
"As specified in the standard, the separator \"T\" may be omitted if\n"
"desired as there is no ambiguity within this function.\n"
"\n"
"Time representations with reduced accuracy are not supported.\n"
"\n"
"## Examples\n"
"\n"
"    iex> DateTime.from_iso8601(\"2015-01-23T23:50:07Z\")\n"
"    {:ok, %DateTime{calendar: Calendar.ISO, day: 23, hour: 23, microsecond: {0, 0}, minute: 50, month: 1, second: 7, std_offset: 0,\n"
"                    time_zone: \"Etc/UTC\", utc_offset: 0, year: 2015, zone_abbr: \"UTC\"}, 0}\n"
"    iex> DateTime.from_iso8601(\"2015-01-23T23:50:07.123+02:30\")\n"
"    {:ok, %DateTime{calendar: Calendar.ISO, day: 23, hour: 21, microsecond: {123000, 3}, minute: 20, month: 1, second: 7, std_offset: 0,\n"
"                    time_zone: \"Etc/UTC\", utc_offset: 0, year: 2015, zone_abbr: \"UTC\"}, 9000}\n"
"\n"
"    iex> DateTime.from_iso8601(\"2015-01-23P23:50:07\")\n"
"    {:error, :invalid_format}\n"
"    iex> DateTime.from_iso8601(\"2015-01-23 23:50:07A\")\n"
"    {:error, :invalid_format}\n"
"    iex> DateTime.from_iso8601(\"2015-01-23T23:50:07\")\n"
"    {:error, :missing_offset}\n"
"    iex> DateTime.from_iso8601(\"2015-01-23 23:50:61\")\n"
"    {:error, :invalid_time}\n"
"    iex> DateTime.from_iso8601(\"2015-01-32 23:50:07\")\n"
"    {:error, :invalid_date}\n"
"\n"
"    iex> DateTime.from_iso8601(\"2015-01-23T23:50:07.123-00:00\")\n"
"    {:error, :invalid_format}\n"
"    iex> DateTime.from_iso8601(\"2015-01-23T23:50:07.123-00:60\")\n"
"    {:error, :invalid_format}\n"
"\n"
msgstr ""
#. TRANSLATORS: def Time.to_erl(map)
#: lib/calendar.ex:671 
msgid ""
"Converts a `Time` struct to an Erlang time tuple.\n"
"\n"
"WARNING: Loss of precision may occur, as Erlang time tuples\n"
"only contain hours/minutes/seconds.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Time.to_erl(~T[23:30:15.999])\n"
"    {23, 30, 15}\n"
"\n"
"    iex> Time.to_erl(~N[2015-01-01 23:30:15.999])\n"
"    {23, 30, 15}\n"
"\n"
msgstr ""
#. TRANSLATORS: def NaiveDateTime.to_time(naive_date_time)
#: lib/calendar.ex:994 
msgid ""
"Converts a `NaiveDateTime` into `Time`.\n"
"\n"
"Because `Time` does not hold date information,\n"
"data will be lost during the conversion.\n"
"\n"
"## Examples\n"
"\n"
"    iex> NaiveDateTime.to_time(~N[2002-01-13 23:00:07])\n"
"    ~T[23:00:07]\n"
"\n"
msgstr ""
