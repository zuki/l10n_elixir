msgid ""
msgstr ""
"Project-Id-Version: l 10n_elixir\n"
"PO-Revision-Date: 2017-01-30 15:24+0900\n"
"Last-Translator: 小田 照敬 <EMAIL@ADDRESS>\n"
"Language-Team: Japanese\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"POT-Creation-Date: \n"
"X-Generator: Poedit 1.8.11\n"

#. TRANSLATORS: @callback date_to_string/3
#: lib/calendar.ex:87
msgid "Converts the date into a string according to the calendar.\n"
msgstr "カレンダーに従い日付を文字列に変換する。\n"

#. TRANSLATORS: @callback datetime_to_string/11
#: lib/calendar.ex:97
msgid ""
"Coverts the date time (with time zone) into a string according to the "
"calendar.\n"
msgstr "カレンダーに従い日時（タイムゾーンあり）を文字列に変換する。\n"

#. TRANSLATORS: @callback leap_year?/1
#: lib/calendar.ex:73
msgid ""
"Returns true if the given year is a leap year.\n"
"\n"
"A leap year is a year of a longer length than normal. The exact meaning\n"
"is up to the calendar. A calendar must return `false` if it does not "
"support\n"
"the concept of leap years.\n"
msgstr ""
"指定された年がうるう年の場合、trueを返します。\n"
"\n"
"うるう年とは通常より長い長い年のことです。正確な意味は\n"
"カレンダーによります。うるう年の概念をサポートしていない\n"
"カレンダーは`false`を返さなければなりません。\n"

#. TRANSLATORS: def Date.to_erl(map)
#: lib/calendar.ex:317
msgid ""
"Converts a `Date` struct to an Erlang date tuple.\n"
"\n"
"Only supports converting dates which are in the ISO calendar,\n"
"attempting to convert dates from other calendars will raise.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Date.to_erl(~D[2000-01-01])\n"
"    {2000, 1, 1}\n"
"    iex> Date.to_erl(~N[2000-01-01 01:23:45])\n"
"    {2000, 1, 1}\n"
"\n"
msgstr ""
"Erlangの日付タプルを`Date`構造体に変換します。\n"
"\n"
"ISOカレンダーの日付の変換だけをサポートしています。\n"
"他のカレンダーの日付を変換しようとすると例外が発生します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Date.to_erl(~D[2000-01-01])\n"
"    {2000, 1, 1}\n"
"    iex> Date.to_erl(~N[2000-01-01 01:23:45])\n"
"    {2000, 1, 1}\n"
"\n"

#. TRANSLATORS: @type time
#: lib/calendar.ex:56
msgid "Any map/struct that contains the time fields"
msgstr "時間フィールドを持つ任意のマップまたは構造体"

#. TRANSLATORS: def Date.from_iso8601!(string)
#: lib/calendar.ex:274
msgid ""
"Parses the extended \"Date and time of day\" format described by\n"
"[ISO 8601:2004](https://en.wikipedia.org/wiki/ISO_8601).\n"
"\n"
"Raises if the format is invalid.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Date.from_iso8601!(\"2015-01-23\")\n"
"    ~D[2015-01-23]\n"
"    iex> Date.from_iso8601!(\"2015:01:23\")\n"
"    ** (ArgumentError) cannot parse \"2015:01:23\" as date, reason: :"
"invalid_format\n"
msgstr ""
"[ISO 8601:2004](https://en.wikipedia.org/wiki/ISO_8601)に\n"
"記載された拡張された「日付と時刻」形式をパースします。\n"
"\n"
"形式が不正な場合は例外を発生させます。\n"
"\n"
"## 例\n"
"\n"
"    iex> Date.from_iso8601!(\"2015-01-23\")\n"
"    ~D[2015-01-23]\n"
"    iex> Date.from_iso8601!(\"2015:01:23\")\n"
"    ** (ArgumentError) cannot parse \"2015:01:23\" as date, reason: :"
"invalid_format\n"

#. TRANSLATORS: def Date.compare(date1, date2)
#: lib/calendar.ex:373
msgid ""
"Compares two `Date` structs.\n"
"\n"
"Returns `:gt` if first date is later than the second\n"
"and `:lt` for vice versa. If the two dates are equal\n"
"`:eq` is returned.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Date.compare(~D[2016-04-16], ~D[2016-04-28])\n"
"    :lt\n"
"\n"
"This function can also be used to compare across more\n"
"complex calendar types by considering only the date fields:\n"
"\n"
"    iex> Date.compare(~D[2016-04-16], ~N[2016-04-28 01:23:45])\n"
"    :lt\n"
"    iex> Date.compare(~D[2016-04-16], ~N[2016-04-16 01:23:45])\n"
"    :eq\n"
"    iex> Date.compare(~N[2016-04-16 12:34:56], ~N[2016-04-16 01:23:45])\n"
"    :eq\n"
"\n"
msgstr ""
"2つの`Date`構造体を比較します。\n"
"\n"
"最初の日付が2番めの日付より後の場合は`:gt`を、\n"
"逆の場合は`:lt`を返します。2つの日付が同じ場合は\n"
"`:eq`が返されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> Date.compare(~D[2016-04-16], ~D[2016-04-28])\n"
"    :lt\n"
"\n"
"この関数は、日付フィールドだけを考慮することにより、より複雑な\n"
"カレンダー型間の比較にも使用することができます。\n"
"\n"
"    iex> Date.compare(~D[2016-04-16], ~N[2016-04-28 01:23:45])\n"
"    :lt\n"
"    iex> Date.compare(~D[2016-04-16], ~N[2016-04-16 01:23:45])\n"
"    :eq\n"
"    iex> Date.compare(~N[2016-04-16 12:34:56], ~N[2016-04-16 01:23:45])\n"
"    :eq\n"
"\n"

#. TRANSLATORS: @callback naive_datetime_to_string/7
#: lib/calendar.ex:92
msgid ""
"Converts the date time (without time zone) into a string according to the "
"calendar.\n"
msgstr "カレンダーに従い日時（タイムゾーンなし）を文字列に変換する。\n"

#. TRANSLATORS: def Date.to_string(map)
#: lib/calendar.ex:222
msgid ""
"Converts the given date to a string according to its calendar.\n"
"\n"
"### Examples\n"
"\n"
"    iex> Date.to_string(~D[2000-02-28])\n"
"    \"2000-02-28\"\n"
"    iex> Date.to_string(~N[2000-02-28 01:23:45])\n"
"    \"2000-02-28\"\n"
"\n"
msgstr ""
"指定された日付をそのカレンダーに従って文字列に変換します。\n"
"\n"
"### 例\n"
"\n"
"    iex> Date.to_string(~D[2000-02-28])\n"
"    \"2000-02-28\"\n"
"    iex> Date.to_string(~N[2000-02-28 01:23:45])\n"
"    \"2000-02-28\"\n"
"\n"

#. TRANSLATORS: def Date.to_iso8601(map)
#: lib/calendar.ex:297
msgid ""
"Converts the given datetime to\n"
"[ISO 8601:2004](https://en.wikipedia.org/wiki/ISO_8601).\n"
"\n"
"Only supports converting datetimes which are in the ISO calendar,\n"
"attempting to convert datetimes from other calendars will raise.\n"
"\n"
"### Examples\n"
"\n"
"    iex> Date.to_iso8601(~D[2000-02-28])\n"
"    \"2000-02-28\"\n"
"    iex> Date.to_iso8601(~N[2000-02-28 01:23:45])\n"
"    \"2000-02-28\"\n"
"\n"
msgstr ""
"指定された日時を[ISO 8601:2004](https://en.wikipedia.org/wiki/ISO_8601)に\n"
"変換します。\n"
"\n"
"ISOカレンダーの日時の変換だけをサポートしています。\n"
"他のカレンダーの日時を変換しようとすると例外が発生します。\n"
"\n"
"### 例\n"
"\n"
"    iex> Date.to_iso8601(~D[2000-02-28])\n"
"    \"2000-02-28\"\n"
"    iex> Date.to_iso8601(~N[2000-02-28 01:23:45])\n"
"    \"2000-02-28\"\n"
"\n"

#. TRANSLATORS: def Time.from_erl(arg, microsecond \\ {0, 0})
#: lib/calendar.ex:691
msgid ""
"Converts an Erlang time tuple to a `Time` struct.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Time.from_erl({23, 30, 15}, {5000, 3})\n"
"    {:ok, ~T[23:30:15.005]}\n"
"    iex> Time.from_erl({24, 30, 15})\n"
"    {:error, :invalid_time}\n"
msgstr ""
"Erlangの時間タプルを`Time`構造体に変換します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Time.from_erl({23, 30, 15}, {5000, 3})\n"
"    {:ok, ~T[23:30:15.005]}\n"
"    iex> Time.from_erl({24, 30, 15})\n"
"    {:error, :invalid_time}\n"

#. TRANSLATORS: def DateTime.from_naive!(naive_datetime, time_zone)
#: lib/calendar.ex:1487
msgid ""
"Converts the given NaiveDateTime to DateTime.\n"
"\n"
"It expects a time zone to put the NaiveDateTime in.\n"
"Currently it only supports \"Etc/UTC\" as time zone.\n"
"\n"
"## Examples\n"
"\n"
"    iex> DateTime.from_naive!(~N[2016-05-24 13:26:08.003], \"Etc/UTC\")\n"
"    %DateTime{calendar: Calendar.ISO, day: 24, hour: 13, microsecond: {3000, "
"3}, minute: 26,\n"
"              month: 5, second: 8, std_offset: 0, time_zone: \"Etc/UTC\", "
"utc_offset: 0,\n"
"              year: 2016, zone_abbr: \"UTC\"}\n"
"\n"
msgstr ""
"指定されたNaiveDateTimeをDateTimeに変換します。\n"
"\n"
"NaiveDateTimeに追加するタイムゾーンを期待します。\n"
"現在のところ、タイムゾーンとしてサポートしているのは”Etc/UTC”のみです。\n"
"\n"
"## 例\n"
"\n"
"    iex> DateTime.from_naive!(~N[2016-05-24 13:26:08.003], \"Etc/UTC\")\n"
"    %DateTime{calendar: Calendar.ISO, day: 24, hour: 13, microsecond: {3000, "
"3}, minute: 26,\n"
"              month: 5, second: 8, std_offset: 0, time_zone: \"Etc/UTC\", "
"utc_offset: 0,\n"
"              year: 2016, zone_abbr: \"UTC\"}\n"
"\n"

#. TRANSLATORS: def Date.new(year, month, day)
#: lib/calendar.ex:196
msgid ""
"Builds a new ISO date.\n"
"\n"
"Expects all values to be integers. Returns `{:ok, date}` if each\n"
"entry fits its appropriate range, returns `{:error, reason}` otherwise.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Date.new(2000, 1, 1)\n"
"    {:ok, ~D[2000-01-01]}\n"
"    iex> Date.new(2000, 13, 1)\n"
"    {:error, :invalid_date}\n"
"    iex> Date.new(2000, 2, 29)\n"
"    {:ok, ~D[2000-02-29]}\n"
"\n"
"    iex> Date.new(2000, 2, 30)\n"
"    {:error, :invalid_date}\n"
"    iex> Date.new(2001, 2, 29)\n"
"    {:error, :invalid_date}\n"
"\n"
msgstr ""
"新たなISO日付を作成します。\n"
"\n"
"引数の値はすべて整数であることを期待します。各項目が\n"
"適切な範囲に適合する場合は`{:ok, date}`を、そうでない場合は\n"
"`{:error, reason}`を返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Date.new(2000, 1, 1)\n"
"    {:ok, ~D[2000-01-01]}\n"
"    iex> Date.new(2000, 13, 1)\n"
"    {:error, :invalid_date}\n"
"    iex> Date.new(2000, 2, 29)\n"
"    {:ok, ~D[2000-02-29]}\n"
"\n"
"    iex> Date.new(2000, 2, 30)\n"
"    {:error, :invalid_date}\n"
"    iex> Date.new(2001, 2, 29)\n"
"    {:error, :invalid_date}\n"
"\n"

#. TRANSLATORS: def Time.compare(time1, time2)
#: lib/calendar.ex:728
msgid ""
"Compares two `Time` structs.\n"
"\n"
"Returns `:gt` if first time is later than the second\n"
"and `:lt` for vice versa. If the two times are equal\n"
"`:eq` is returned\n"
"\n"
"## Examples\n"
"\n"
"    iex> Time.compare(~T[16:04:16], ~T[16:04:28])\n"
"    :lt\n"
"    iex> Time.compare(~T[16:04:16.01], ~T[16:04:16.001])\n"
"    :gt\n"
"\n"
"This function can also be used to compare across more\n"
"complex calendar types by considering only the time fields:\n"
"\n"
"    iex> Time.compare(~N[2015-01-01 16:04:16], ~N[2015-01-01 16:04:28])\n"
"    :lt\n"
"    iex> Time.compare(~N[2015-01-01 16:04:16.01], ~N[2000-01-01 "
"16:04:16.001])\n"
"    :gt\n"
"\n"
msgstr ""
"2つの`Time`構造体を比較します。\n"
"\n"
"最初の時間が2番めの時間より後の場合は`:gt`を、\n"
"逆の場合は`:lt`を返します。2つの時間が同じ場合は\n"
"`:eq`が返されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> Time.compare(~T[16:04:16], ~T[16:04:28])\n"
"    :lt\n"
"    iex> Time.compare(~T[16:04:16.01], ~T[16:04:16.001])\n"
"    :gt\n"
"\n"
"この関数は、時間フィールドだけを考慮することにより、より複雑な\n"
"カレンダー型間の比較にも使用することができます。\n"
"\n"
"    iex> Time.compare(~N[2015-01-01 16:04:16], ~N[2015-01-01 16:04:28])\n"
"    :lt\n"
"    iex> Time.compare(~N[2015-01-01 16:04:16.01], ~N[2000-01-01 "
"16:04:16.001])\n"
"    :gt\n"
"\n"

#. TRANSLATORS: def NaiveDateTime.diff(naive_datetime1, naive_datetime2, unit \\ :second)
#: lib/calendar.ex:950
msgid ""
"Subtract `naive_datetime2` from `naive_datetime1`.\n"
"\n"
"The answer can be returned in any `unit` available from `t:System."
"time_unit/0`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> NaiveDateTime.diff(~N[2014-10-02 00:29:12], ~N[2014-10-02 "
"00:29:10])\n"
"    2\n"
"    iex> NaiveDateTime.diff(~N[2014-10-02 00:29:12], ~N[2014-10-02 "
"00:29:10], :microsecond)\n"
"    2_000_000\n"
"    iex> NaiveDateTime.diff(~N[2014-10-02 00:29:10.042], ~N[2014-10-02 "
"00:29:10.021], :millisecond)\n"
"    21\n"
"    # to gregorian seconds\n"
"    iex> NaiveDateTime.diff(~N[2014-10-02 00:29:10], ~N[0000-01-01 "
"00:00:00])\n"
"    63579428950\n"
msgstr ""
"`naive_datetime1`から`naive_datetime2`を引きます。\n"
"\n"
"解答は`t:System.time_unit/0`で利用可能な任意の`unit`で返すことができます。\n"
"\n"
"## 例\n"
"\n"
"    iex> NaiveDateTime.diff(~N[2014-10-02 00:29:12], ~N[2014-10-02 "
"00:29:10])\n"
"    2\n"
"    iex> NaiveDateTime.diff(~N[2014-10-02 00:29:12], ~N[2014-10-02 "
"00:29:10], :microsecond)\n"
"    2_000_000\n"
"    iex> NaiveDateTime.diff(~N[2014-10-02 00:29:10.042], ~N[2014-10-02 "
"00:29:10.021], :millisecond)\n"
"    21\n"
"    # グレゴリア暦秒に\n"
"    iex> NaiveDateTime.diff(~N[2014-10-02 00:29:10], ~N[0000-01-01 "
"00:00:00])\n"
"    63579428950\n"

#. TRANSLATORS: @type second
#: lib/calendar.ex:25
msgid "From 0 to 60 to account for leap seconds"
msgstr "うるう秒を表すために0から60"

#. TRANSLATORS: @type date
#: lib/calendar.ex:53
msgid "Any map/struct that contains the date fields"
msgstr "日付フィールドを持つ任意のマップまたは構造体"

#. TRANSLATORS: @type zone_abbr
#: lib/calendar.ex:44
msgid "The time zone abbreviation (e.g. CET or CEST or BST etc.)"
msgstr "タイムゾーンの略称（たとえば、CET, CEST, BSTなど）"

#. TRANSLATORS: def NaiveDateTime.from_erl(arg, microsecond \\ {0, 0})
#: lib/calendar.ex:1197
msgid ""
"Converts an Erlang datetime tuple to a `NaiveDateTime` struct.\n"
"\n"
"Attempting to convert an invalid ISO calendar date will produce an error "
"tuple.\n"
"\n"
"## Examples\n"
"\n"
"    iex> NaiveDateTime.from_erl({{2000, 1, 1}, {13, 30, 15}})\n"
"    {:ok, ~N[2000-01-01 13:30:15]}\n"
"    iex> NaiveDateTime.from_erl({{2000, 1, 1}, {13, 30, 15}}, {5000, 3})\n"
"    {:ok, ~N[2000-01-01 13:30:15.005]}\n"
"    iex> NaiveDateTime.from_erl({{2000, 13, 1}, {13, 30, 15}})\n"
"    {:error, :invalid_date}\n"
"    iex> NaiveDateTime.from_erl({{2000, 13, 1},{13, 30, 15}})\n"
"    {:error, :invalid_date}\n"
msgstr ""
"Erlangの日時タプルを`NaiveDateTime`構造体に変換します。\n"
"\n"
"不正なISOカレンダー日付を変換しようとするとエラータプルを返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> NaiveDateTime.from_erl({{2000, 1, 1}, {13, 30, 15}})\n"
"    {:ok, ~N[2000-01-01 13:30:15]}\n"
"    iex> NaiveDateTime.from_erl({{2000, 1, 1}, {13, 30, 15}}, {5000, 3})\n"
"    {:ok, ~N[2000-01-01 13:30:15.005]}\n"
"    iex> NaiveDateTime.from_erl({{2000, 13, 1}, {13, 30, 15}})\n"
"    {:error, :invalid_date}\n"
"    iex> NaiveDateTime.from_erl({{2000, 13, 1},{13, 30, 15}})\n"
"    {:error, :invalid_date}\n"

#. TRANSLATORS: def NaiveDateTime.to_iso8601(map)
#: lib/calendar.ex:1136
msgid ""
"Converts the given naive datetime to\n"
"[ISO 8601:2004](https://en.wikipedia.org/wiki/ISO_8601).\n"
"\n"
"Only supports converting naive datetimes which are in the ISO calendar,\n"
"attempting to convert naive datetimes from other calendars will raise.\n"
"\n"
"### Examples\n"
"\n"
"    iex> NaiveDateTime.to_iso8601(~N[2000-02-28 23:00:13])\n"
"    \"2000-02-28T23:00:13\"\n"
"\n"
"    iex> NaiveDateTime.to_iso8601(~N[2000-02-28 23:00:13.001])\n"
"    \"2000-02-28T23:00:13.001\"\n"
"\n"
"This function can also be used to convert a DateTime to ISO8601 without\n"
"the time zone information:\n"
"\n"
"    iex> dt = %DateTime{year: 2000, month: 2, day: 29, zone_abbr: \"CET\",\n"
"    ...>                hour: 23, minute: 0, second: 7, microsecond: {0, "
"0},\n"
"    ...>                utc_offset: 3600, std_offset: 0, time_zone: \"Europe/"
"Warsaw\"}\n"
"    iex> NaiveDateTime.to_iso8601(dt)\n"
"    \"2000-02-29T23:00:07\"\n"
"\n"
msgstr ""
"指定されたナイーブ日時を[ISO 8601:2004](https://en.wikipedia.org/wiki/"
"ISO_8601)\n"
"形式に変換します。\n"
"\n"
"ISOカレンダーのナイーブ日時の変換だけをサポートしています。\n"
"他のカレンダーのナイーブ日時を変更しようとすると例外を発生します。\n"
"\n"
"### 例\n"
"\n"
"    iex> NaiveDateTime.to_iso8601(~N[2000-02-28 23:00:13])\n"
"    \"2000-02-28T23:00:13\"\n"
"\n"
"    iex> NaiveDateTime.to_iso8601(~N[2000-02-28 23:00:13.001])\n"
"    \"2000-02-28T23:00:13.001\"\n"
"\n"
"この関数はDateTimeをタイムゾーン情報を持たないISO8601に変更するのにも\n"
"使用できます。\n"
"\n"
"    iex> dt = %DateTime{year: 2000, month: 2, day: 29, zone_abbr: \"CET\",\n"
"    ...>                hour: 23, minute: 0, second: 7, microsecond: {0, "
"0},\n"
"    ...>                utc_offset: 3600, std_offset: 0, time_zone: \"Europe/"
"Warsaw\"}\n"
"    iex> NaiveDateTime.to_iso8601(dt)\n"
"    \"2000-02-29T23:00:07\"\n"
"\n"

#. TRANSLATORS: def DateTime.to_string(map)
#: lib/calendar.ex:1729
msgid ""
"Converts the given datetime to a string according to its calendar.\n"
"\n"
"### Examples\n"
"\n"
"    iex> dt = %DateTime{year: 2000, month: 2, day: 29, zone_abbr: \"CET\",\n"
"    ...>                hour: 23, minute: 0, second: 7, microsecond: {0, "
"0},\n"
"    ...>                utc_offset: 3600, std_offset: 0, time_zone: \"Europe/"
"Warsaw\"}\n"
"    iex> DateTime.to_string(dt)\n"
"    \"2000-02-29 23:00:07+01:00 CET Europe/Warsaw\"\n"
"\n"
"    iex> dt = %DateTime{year: 2000, month: 2, day: 29, zone_abbr: \"UTC\",\n"
"    ...>                hour: 23, minute: 0, second: 7, microsecond: {0, "
"0},\n"
"    ...>                utc_offset: 0, std_offset: 0, time_zone: \"Etc/UTC"
"\"}\n"
"    iex> DateTime.to_string(dt)\n"
"    \"2000-02-29 23:00:07Z\"\n"
"\n"
"    iex> dt = %DateTime{year: 2000, month: 2, day: 29, zone_abbr: \"AMT\",\n"
"    ...>                hour: 23, minute: 0, second: 7, microsecond: {0, "
"0},\n"
"    ...>                utc_offset: -14400, std_offset: 0, time_zone: "
"\"America/Manaus\"}\n"
"    iex> DateTime.to_string(dt)\n"
"    \"2000-02-29 23:00:07-04:00 AMT America/Manaus\"\n"
msgstr ""
"指定された日時をそのカレンダーに従って文字列に変換します。\n"
"\n"
"### 例\n"
"\n"
"    iex> dt = %DateTime{year: 2000, month: 2, day: 29, zone_abbr: \"CET\",\n"
"    ...>                hour: 23, minute: 0, second: 7, microsecond: {0, "
"0},\n"
"    ...>                utc_offset: 3600, std_offset: 0, time_zone: \"Europe/"
"Warsaw\"}\n"
"    iex> DateTime.to_string(dt)\n"
"    \"2000-02-29 23:00:07+01:00 CET Europe/Warsaw\"\n"
"\n"
"    iex> dt = %DateTime{year: 2000, month: 2, day: 29, zone_abbr: \"UTC\",\n"
"    ...>                hour: 23, minute: 0, second: 7, microsecond: {0, "
"0},\n"
"    ...>                utc_offset: 0, std_offset: 0, time_zone: \"Etc/UTC"
"\"}\n"
"    iex> DateTime.to_string(dt)\n"
"    \"2000-02-29 23:00:07Z\"\n"
"\n"
"    iex> dt = %DateTime{year: 2000, month: 2, day: 29, zone_abbr: \"AMT\",\n"
"    ...>                hour: 23, minute: 0, second: 7, microsecond: {0, "
"0},\n"
"    ...>                utc_offset: -14400, std_offset: 0, time_zone: "
"\"America/Manaus\"}\n"
"    iex> DateTime.to_string(dt)\n"
"    \"2000-02-29 23:00:07-04:00 AMT America/Manaus\"\n"

#. TRANSLATORS: def NaiveDateTime.compare(naive_datetime1, naive_datetime2)
#: lib/calendar.ex:1243
msgid ""
"Compares two `NaiveDateTime` structs.\n"
"\n"
"Returns `:gt` if first is later than the second\n"
"and `:lt` for vice versa. If the two NaiveDateTime\n"
"are equal `:eq` is returned\n"
"\n"
"## Examples\n"
"\n"
"    iex> NaiveDateTime.compare(~N[2016-04-16 13:30:15], ~N[2016-04-28 "
"16:19:25])\n"
"    :lt\n"
"    iex> NaiveDateTime.compare(~N[2016-04-16 13:30:15.1], ~N[2016-04-16 "
"13:30:15.01])\n"
"    :gt\n"
"\n"
"This function can also be used to compare a DateTime without\n"
"the time zone information:\n"
"\n"
"    iex> dt = %DateTime{year: 2000, month: 2, day: 29, zone_abbr: \"CET\",\n"
"    ...>                hour: 23, minute: 0, second: 7, microsecond: {0, "
"0},\n"
"    ...>                utc_offset: 3600, std_offset: 0, time_zone: \"Europe/"
"Warsaw\"}\n"
"    iex> NaiveDateTime.compare(dt, ~N[2000-02-29 23:00:07])\n"
"    :eq\n"
"    iex> NaiveDateTime.compare(dt, ~N[2000-01-29 23:00:07])\n"
"    :gt\n"
"    iex> NaiveDateTime.compare(dt, ~N[2000-03-29 23:00:07])\n"
"    :lt\n"
"\n"
msgstr ""
"2つの`NaiveDateTime `構造体を比較します。\n"
"\n"
"前者が後者より後の場合は`:gt`を、\n"
" 逆の場合は`:lt`を返します。2つのNaiveDateTimeが同じ場合は\n"
"`:eq`が返されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> NaiveDateTime.compare(~N[2016-04-16 13:30:15], ~N[2016-04-28 "
"16:19:25])\n"
"    :lt\n"
"    iex> NaiveDateTime.compare(~N[2016-04-16 13:30:15.1], ~N[2016-04-16 "
"13:30:15.01])\n"
"    :gt\n"
"\n"
"この関数はタイムゾーン情報を持たないDatetimeの比較にも\n"
"使用することができます。\n"
"\n"
"    iex> dt = %DateTime{year: 2000, month: 2, day: 29, zone_abbr: \"CET\",\n"
"    ...>                hour: 23, minute: 0, second: 7, microsecond: {0, "
"0},\n"
"    ...>                utc_offset: 3600, std_offset: 0, time_zone: \"Europe/"
"Warsaw\"}\n"
"    iex> NaiveDateTime.compare(dt, ~N[2000-02-29 23:00:07])\n"
"    :eq\n"
"    iex> NaiveDateTime.compare(dt, ~N[2000-01-29 23:00:07])\n"
"    :gt\n"
"    iex> NaiveDateTime.compare(dt, ~N[2000-03-29 23:00:07])\n"
"    :lt\n"
"\n"

#. TRANSLATORS: def Date.leap_year?(map)
#: lib/calendar.ex:156
msgid ""
"Returns true if the year in `date` is a leap year.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Date.leap_year?(~D[2000-01-01])\n"
"    true\n"
"    iex> Date.leap_year?(~D[2001-01-01])\n"
"    false\n"
"    iex> Date.leap_year?(~D[2004-01-01])\n"
"    true\n"
"    iex> Date.leap_year?(~D[1900-01-01])\n"
"    false\n"
"    iex> Date.leap_year?(~N[2004-01-01 01:23:45])\n"
"    true\n"
"\n"
msgstr ""
"`date`中の年がうるう年の場合、trueを返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Date.leap_year?(~D[2000-01-01])\n"
"    true\n"
"    iex> Date.leap_year?(~D[2001-01-01])\n"
"    false\n"
"    iex> Date.leap_year?(~D[2004-01-01])\n"
"    true\n"
"    iex> Date.leap_year?(~D[1900-01-01])\n"
"    false\n"
"    iex> Date.leap_year?(~N[2004-01-01 01:23:45])\n"
"    true\n"
"\n"

#. TRANSLATORS: @type date_time
#: lib/calendar.ex:63
msgid "Any map/struct that contains the datetime fields"
msgstr "日時フィールドを持つ任意のマップまたは構造体"

#. TRANSLATORS: def Date.days_in_month(map)
#: lib/calendar.ex:178
msgid ""
"Returns the number of days in the given date month.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Date.days_in_month(~D[1900-01-13])\n"
"    31\n"
"    iex> Date.days_in_month(~D[1900-02-09])\n"
"    28\n"
"    iex> Date.days_in_month(~N[2000-02-20 01:23:45])\n"
"    29\n"
"\n"
msgstr ""
"指定された月日の日数を返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Date.days_in_month(~D[1900-01-13])\n"
"    31\n"
"    iex> Date.days_in_month(~D[1900-02-09])\n"
"    28\n"
"    iex> Date.days_in_month(~N[2000-02-20 01:23:45])\n"
"    29\n"
"\n"

#. TRANSLATORS: def NaiveDateTime.to_erl(map)
#: lib/calendar.ex:1167
msgid ""
"Converts a `NaiveDateTime` struct to an Erlang datetime tuple.\n"
"\n"
"Only supports converting naive datetimes which are in the ISO calendar,\n"
"attempting to convert naive datetimes from other calendars will raise.\n"
"\n"
"WARNING: Loss of precision may occur, as Erlang time tuples only store\n"
"hour/minute/second.\n"
"\n"
"## Examples\n"
"\n"
"    iex> NaiveDateTime.to_erl(~N[2000-01-01 13:30:15])\n"
"    {{2000, 1, 1}, {13, 30, 15}}\n"
"\n"
"This function can also be used to convert a DateTime to a erl format\n"
"without the time zone information:\n"
"\n"
"    iex> dt = %DateTime{year: 2000, month: 2, day: 29, zone_abbr: \"CET\",\n"
"    ...>                hour: 23, minute: 0, second: 7, microsecond: {0, "
"0},\n"
"    ...>                utc_offset: 3600, std_offset: 0, time_zone: \"Europe/"
"Warsaw\"}\n"
"    iex> NaiveDateTime.to_erl(dt)\n"
"    {{2000, 2, 29}, {23, 00, 07}}\n"
"\n"
msgstr ""
"`NaiveDateTime`構造体をErlangの日時タプルに変換します。\n"
"\n"
"ISOカレンダーのナイーブ日時の変換だけをサポートしています。\n"
"他のカレンダのナイーブ日時を変更しようとした場合は、例外が発生します。\n"
"\n"
"警告: Erlangの時間タプルは時/分/秒しか格納しませんので、\n"
"精度が落ちる可能性があります。\n"
"\n"
"## 例\n"
"\n"
"    iex> NaiveDateTime.to_erl(~N[2000-01-01 13:30:15])\n"
"    {{2000, 1, 1}, {13, 30, 15}}\n"
"\n"
"この関数はDateTimeをタイムゾーン情報を持たないerl形式に変換するのにも\n"
"使用できます。\n"
"\n"
"    iex> dt = %DateTime{year: 2000, month: 2, day: 29, zone_abbr: \"CET\",\n"
"    ...>                hour: 23, minute: 0, second: 7, microsecond: {0, "
"0},\n"
"    ...>                utc_offset: 3600, std_offset: 0, time_zone: \"Europe/"
"Warsaw\"}\n"
"    iex> NaiveDateTime.to_erl(dt)\n"
"    {{2000, 2, 29}, {23, 00, 07}}\n"

#. TRANSLATORS: @type naive_date_time
#: lib/calendar.ex:59
msgid "Any map/struct that contains the naive_datetime fields"
msgstr "ナイーブな日時フィールドを持つ任意のマップまたは構造体"

#. TRANSLATORS: @type std_offset
#: lib/calendar.ex:50
msgid "The time zone standard offset in seconds (not zero in summer times)"
msgstr "タイムゾーンの標準オフセット(秒単位、夏時間ではゼロでない)"

#. TRANSLATORS: def DateTime.from_unix(integer, unit \\ :second)
#: lib/calendar.ex:1370
msgid ""
"Converts the given Unix time to DateTime.\n"
"\n"
"The integer can be given in different unit\n"
"according to `System.convert_time_unit/3` and it will\n"
"be converted to microseconds internally.\n"
"\n"
"Unix times are always in UTC and therefore the DateTime\n"
"will be returned in UTC.\n"
"\n"
"## Examples\n"
"\n"
"    iex> DateTime.from_unix(1464096368)\n"
"    {:ok, %DateTime{calendar: Calendar.ISO, day: 24, hour: 13, microsecond: "
"{0, 0}, minute: 26,\n"
"                    month: 5, second: 8, std_offset: 0, time_zone: \"Etc/UTC"
"\", utc_offset: 0,\n"
"                    year: 2016, zone_abbr: \"UTC\"}}\n"
"\n"
"    iex> DateTime.from_unix(1432560368868569, :microsecond)\n"
"    {:ok, %DateTime{calendar: Calendar.ISO, day: 25, hour: 13, microsecond: "
"{868569, 6}, minute: 26,\n"
"                    month: 5, second: 8, std_offset: 0, time_zone: \"Etc/UTC"
"\", utc_offset: 0,\n"
"                    year: 2015, zone_abbr: \"UTC\"}}\n"
"\n"
"The unit can also be an integer as in `t:System.time_unit/0`:\n"
"\n"
"    iex> DateTime.from_unix(1432560368868569, 1024)\n"
"    {:ok, %DateTime{calendar: Calendar.ISO, day: 23, hour: 22, microsecond: "
"{211914, 3}, minute: 53,\n"
"                    month: 1, second: 43, std_offset: 0, time_zone: \"Etc/UTC"
"\", utc_offset: 0,\n"
"                    year: 46302, zone_abbr: \"UTC\"}}\n"
"\n"
"Negative Unix times are supported, up to -62167219200 seconds,\n"
"which is equivalent to \"0000-01-01T00:00:00Z\" or 0 gregorian seconds.\n"
"\n"
"    iex> DateTime.from_unix(-12345678910)\n"
"    {:ok, %DateTime{calendar: Calendar.ISO, day: 13, hour: 4, microsecond: "
"{0, 0}, minute: 44,\n"
"                    month: 10, second: 50, std_offset: 0, time_zone: \"Etc/"
"UTC\", utc_offset: 0,\n"
"                    year: 1578, zone_abbr: \"UTC\"}}\n"
"\n"
"When a Unix time before that moment is passed to `from_unix/2`, `:error` "
"will be returned.\n"
msgstr ""
"指定されたUnix時間をDateTimeに変換します。\n"
"\n"
"`System.convert_time_unit/3`に従うさまざまな単位の\n"
"整数を指定することができます。内部ではマイクロ秒に\n"
"変換されます。\n"
"\n"
"Unix時間は常にUTCです。そのため、DateTImeは\n"
"UTCで返されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> DateTime.from_unix(1464096368)\n"
"    {:ok, %DateTime{calendar: Calendar.ISO, day: 24, hour: 13, microsecond: "
"{0, 0}, minute: 26,\n"
"                    month: 5, second: 8, std_offset: 0, time_zone: \"Etc/UTC"
"\", utc_offset: 0,\n"
"                    year: 2016, zone_abbr: \"UTC\"}}\n"
"\n"
"    iex> DateTime.from_unix(1432560368868569, :microsecond)\n"
"    {:ok, %DateTime{calendar: Calendar.ISO, day: 25, hour: 13, microsecond: "
"{868569, 6}, minute: 26,\n"
"                    month: 5, second: 8, std_offset: 0, time_zone: \"Etc/UTC"
"\", utc_offset: 0,\n"
"                    year: 2015, zone_abbr: \"UTC\"}}\n"
"\n"
"引数unitも`t:System.time_unit/0`による整数で指定できます。\n"
"\n"
"    iex> DateTime.from_unix(1432560368868569, 1024)\n"
"    {:ok, %DateTime{calendar: Calendar.ISO, day: 23, hour: 22, microsecond: "
"{211914, 3}, minute: 53,\n"
"                    month: 1, second: 43, std_offset: 0, time_zone: \"Etc/UTC"
"\", utc_offset: 0,\n"
"                    year: 46302, zone_abbr: \"UTC\"}}\n"
"\n"
"\"0000-01-01T00:00:00Z”またはグレゴリア暦0秒に相当する\n"
"-62167219200秒までの負のUnix時間もサポートされています。\n"
"\n"
"    iex> DateTime.from_unix(-12345678910)\n"
"    {:ok, %DateTime{calendar: Calendar.ISO, day: 13, hour: 4, microsecond: "
"{0, 0}, minute: 44,\n"
"                    month: 10, second: 50, std_offset: 0, time_zone: \"Etc/"
"UTC\", utc_offset: 0,\n"
"                    year: 1578, zone_abbr: \"UTC\"}}\n"
"\n"
"上記以前のUnix時間が`from_unix/2`に渡された場合は、\n"
"`:error`が返されます。\n"

#. TRANSLATORS: def NaiveDateTime.new(date, time)
#: lib/calendar.ex:889
msgid ""
"Builds a naive datetime from date and time structs.\n"
"\n"
"## Examples\n"
"\n"
"    iex> NaiveDateTime.new(~D[2010-01-13], ~T[23:00:07.005])\n"
"    {:ok, ~N[2010-01-13 23:00:07.005]}\n"
"\n"
msgstr ""
"日付構造体と時間構造体からナイーブ日時を作成します。\n"
"\n"
"## 例\n"
"\n"
"    iex> NaiveDateTime.new(~D[2010-01-13], ~T[23:00:07.005])\n"
"    {:ok, ~N[2010-01-13 23:00:07.005]}\n"
"\n"

#. TRANSLATORS: def Time.from_erl!(tuple, microsecond \\ {0, 0})
#: lib/calendar.ex:706
msgid ""
"Converts an Erlang time tuple to a `Time` struct.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Time.from_erl!({23, 30, 15})\n"
"    ~T[23:30:15]\n"
"    iex> Time.from_erl!({23, 30, 15}, {5000, 3})\n"
"    ~T[23:30:15.005]\n"
"    iex> Time.from_erl!({24, 30, 15})\n"
"    ** (ArgumentError) cannot convert {24, 30, 15} to time, reason: :"
"invalid_time\n"
msgstr ""
"Erlangの時間タプルを`Time`構造体に変換します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Time.from_erl!({23, 30, 15})\n"
"    ~T[23:30:15]\n"
"    iex> Time.from_erl!({23, 30, 15}, {5000, 3})\n"
"    ~T[23:30:15.005]\n"
"    iex> Time.from_erl!({24, 30, 15})\n"
"    ** (ArgumentError) cannot convert {24, 30, 15} to time, reason: :"
"invalid_time\n"

#. TRANSLATORS: Elixir.DateTime Summary
#: lib/calendar.ex:1316
msgid ""
"A datetime implementation with a time zone.\n"
"\n"
"This datetime can be seen as an ephemeral snapshot\n"
"of a datetime at a given time zone. For such purposes,\n"
"it also includes both UTC and Standard offsets, as\n"
"well as the zone abbreviation field used exclusively\n"
"for formatting purposes.\n"
"\n"
"Developers should avoid creating the DateTime struct directly\n"
"and instead rely on the functions provided by this module as\n"
"well as the ones in 3rd party calendar libraries.\n"
"\n"
"## Where are my functions?\n"
"\n"
"You will notice this module only contains conversion\n"
"functions as well as functions that work on UTC. This\n"
"is because a proper DateTime implementation requires a\n"
"TimeZone database which currently is not provided as part\n"
"of Elixir.\n"
"\n"
"Such may be addressed in upcoming versions, meanwhile,\n"
"use 3rd party packages to provide DateTime building and\n"
"similar functionality with time zone backing.\n"
msgstr ""
"タイムゾーンを持つ日時の実装です。\n"
"\n"
"この日時は、指定されたタイムゾーンでの日時の一時的な\n"
"スナップショットだと見ることができます。 このような目的の\n"
"ために、UTCと標準オフセットだけでなく、書式設定のために\n"
"排他的に使用されるゾーン短縮形フィールドも\n"
"含まれています。\n"
"\n"
"開発者は、DateTime構造体を直接作成するのは避け、この\n"
"モジュールが提供する関数やサードパーティのカレンダーライブラリの\n"
"関数を使用するべきです。\n"
"\n"
"## 関数はどこにあるのか?\n"
"\n"
"このモジュールは変換関数とUTCを扱う関数のみを含んでいることに\n"
"気が付かれるでしょう。これは、適切なDateTimeの実装には、現在\n"
"Elixirでは提供されていないTimeZoneデータベースが必要だから\n"
"です。\n"
"\n"
"これは今後のバージョンで対処されると思われますが、当分の間は、\n"
"タイムゾーンの裏付けのあるDateTimeビルドや同等な機能をを提供\n"
"するサードパーティパッケージを使用してください。\n"

#. TRANSLATORS: def NaiveDateTime.utc_now()
#: lib/calendar.ex:822
msgid ""
"Returns the current naive datetime in UTC.\n"
"\n"
"Prefer using `DateTime.utc_now/0` when possible as, opposite\n"
"to `NaiveDateTime`, it will keep the time zone information.\n"
"\n"
"## Examples\n"
"\n"
"    iex> naive_datetime = NaiveDateTime.utc_now()\n"
"    iex> naive_datetime.year >= 2016\n"
"    true\n"
"\n"
msgstr ""
"現在のナイーブ日時をUTCで返します。\n"
"\n"
"可能であれば、`NaiveDateTime`ではなく`DateTime.utc_now/0`の\n"
"使用を勧めます。タイムゾーン情報を保持するからです。\n"
"\n"
"## 例\n"
"\n"
"    iex> naive_datetime = NaiveDateTime.utc_now()\n"
"    iex> naive_datetime.year >= 2016\n"
"    true\n"
"\n"

#. TRANSLATORS: def Time.new(hour, minute, second, microsecond \\ {0, 0})
#: lib/calendar.ex:497
msgid ""
"Builds a new time.\n"
"\n"
"Expects all values to be integers. Returns `{:ok, time}` if each\n"
"entry fits its appropriate range, returns `{:error, reason}` otherwise.\n"
"\n"
"Note a time may have 60 seconds in case of leap seconds.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Time.new(0, 0, 0, 0)\n"
"    {:ok, ~T[00:00:00.000000]}\n"
"    iex> Time.new(23, 59, 59, 999_999)\n"
"    {:ok, ~T[23:59:59.999999]}\n"
"    iex> Time.new(23, 59, 60, 999_999)\n"
"    {:ok, ~T[23:59:60.999999]}\n"
"\n"
"    # Time with microseconds and their precision\n"
"    iex> Time.new(23, 59, 60, {10_000, 2})\n"
"    {:ok, ~T[23:59:60.01]}\n"
"\n"
"    iex> Time.new(24, 59, 59, 999_999)\n"
"    {:error, :invalid_time}\n"
"    iex> Time.new(23, 60, 59, 999_999)\n"
"    {:error, :invalid_time}\n"
"    iex> Time.new(23, 59, 61, 999_999)\n"
"    {:error, :invalid_time}\n"
"    iex> Time.new(23, 59, 59, 1_000_000)\n"
"    {:error, :invalid_time}\n"
"\n"
msgstr ""
"新たな時間を作成します。\n"
"\n"
"すべての値は整数であることが期待されます。各項目が適切な範囲に適合する場合"
"は\n"
"`{:ok, time}`を、そうでない場合は`{:error, reason}`を返します。\n"
"\n"
"うるう秒の場合に時間は60秒を持つ場合があることに注意してください。\n"
"\n"
"## 例\n"
"\n"
"    iex> Time.new(0, 0, 0, 0)\n"
"    {:ok, ~T[00:00:00.000000]}\n"
"    iex> Time.new(23, 59, 59, 999_999)\n"
"    {:ok, ~T[23:59:59.999999]}\n"
"    iex> Time.new(23, 59, 60, 999_999)\n"
"    {:ok, ~T[23:59:60.999999]}\n"
"\n"
"    # マイクロ秒とその精度を持つ時間\n"
"    iex> Time.new(23, 59, 60, {10_000, 2})\n"
"    {:ok, ~T[23:59:60.01]}\n"
"\n"
"    iex> Time.new(24, 59, 59, 999_999)\n"
"    {:error, :invalid_time}\n"
"    iex> Time.new(23, 60, 59, 999_999)\n"
"    {:error, :invalid_time}\n"
"    iex> Time.new(23, 59, 61, 999_999)\n"
"    {:error, :invalid_time}\n"
"    iex> Time.new(23, 59, 59, 1_000_000)\n"
"    {:error, :invalid_time}\n"
"\n"

#. TRANSLATORS: Elixir.Calendar Summary
#: lib/calendar.ex:2
msgid ""
"This module defines the responsibilities for working with\n"
"calendars, dates, times and datetimes in Elixir.\n"
"\n"
"Currently it defines types and the minimal implementation\n"
"for a calendar behaviour in Elixir. The goal of the Calendar\n"
"features in Elixir is to provide a base for interoperability\n"
"instead of full-featured datetime API.\n"
"\n"
"For the actual date, time and datetime structures, see `Date`,\n"
"`Time`, `NaiveDateTime` and `DateTime`.\n"
"\n"
"Note the year, month, day, etc designations are overspecified\n"
"(i.e. an integer instead of 1..12 for months) because different\n"
"calendars may have a different number of days per month, months per year and "
"so on.\n"
msgstr ""
"このモジュールは、Elixirにおけるカレンダ、日付、時間、日時を扱う\n"
"ための責任を定義します。\n"
"\n"
"現在のところ、Elixirにおけるカレンダービヘイビアのための型と最低限の\n"
"実装を定義しています。Elilxirにおけるカレンダー機能の目的は、フル装備の\n"
"日時APIの提供ではなく、相互運用性の基本を提供することに\n"
"あります。\n"
"\n"
"実際の日時、時間、日時構造については、`Date`, `Time`, `NaiveDateTime`\n"
"`DateTime`を参照してください。\n"
"\n"
"カレンダーにより月の日数や年の月数などが異なる場合がありますので、\n"
"年、月、日などの指定に過度の条件が付いています（月が1..12ではなく\n"
"整数であることなど）。\n"

#. TRANSLATORS: @callback day_of_week/3
#: lib/calendar.ex:82
msgid ""
"Calculates the day of the week from the given `year`, `month`, and `day`.\n"
msgstr "指定された`year`, `month`, `day`から曜日を計算します。\n"

#. TRANSLATORS: def DateTime.to_date(date_time)
#: lib/calendar.ex:1572
msgid ""
"Converts a `DateTime` into a `Date`.\n"
"\n"
"Because `Date` does not hold time nor time zone information,\n"
"data will be lost during the conversion.\n"
"\n"
"## Examples\n"
"\n"
"    iex> dt = %DateTime{year: 2000, month: 2, day: 29, zone_abbr: \"CET\",\n"
"    ...>                hour: 23, minute: 0, second: 7, microsecond: {0, "
"0},\n"
"    ...>                utc_offset: 3600, std_offset: 0, time_zone: \"Europe/"
"Warsaw\"}\n"
"    iex> DateTime.to_date(dt)\n"
"    ~D[2000-02-29]\n"
"\n"
msgstr ""
"`DateTime`を`Date`に変換します。\n"
"\n"
"`Date`は時間もタイムゾーン情報も保持しませんので、\n"
"データは変換時に失われます。\n"
"\n"
"## 例\n"
"\n"
"    iex> dt = %DateTime{year: 2000, month: 2, day: 29, zone_abbr: \"CET\",\n"
"    ...>                hour: 23, minute: 0, second: 7, microsecond: {0, "
"0},\n"
"    ...>                utc_offset: 3600, std_offset: 0, time_zone: \"Europe/"
"Warsaw\"}\n"
"    iex> DateTime.to_date(dt)\n"
"    ~D[2000-02-29]\n"
"\n"

#. TRANSLATORS: def Time.to_iso8601(map)
#: lib/calendar.ex:649
msgid ""
"Converts the given time to\n"
"[ISO 8601:2004](https://en.wikipedia.org/wiki/ISO_8601).\n"
"\n"
"### Examples\n"
"\n"
"    iex> Time.to_iso8601(~T[23:00:13])\n"
"    \"23:00:13\"\n"
"    iex> Time.to_iso8601(~T[23:00:13.001])\n"
"    \"23:00:13.001\"\n"
"\n"
"    iex> Time.to_iso8601(~N[2015-01-01 23:00:13])\n"
"    \"23:00:13\"\n"
"    iex> Time.to_iso8601(~N[2015-01-01 23:00:13.001])\n"
"    \"23:00:13.001\"\n"
"\n"
msgstr ""
"指定された時間を[ISO 8601:2004](https://en.wikipedia.org/wiki/ISO_8601)\n"
"形式に変換します。\n"
"\n"
"### 例\n"
"\n"
"    iex> Time.to_iso8601(~T[23:00:13])\n"
"    \"23:00:13\"\n"
"    iex> Time.to_iso8601(~T[23:00:13.001])\n"
"    \"23:00:13.001\"\n"
"\n"
"    iex> Time.to_iso8601(~N[2015-01-01 23:00:13])\n"
"    \"23:00:13\"\n"
"    iex> Time.to_iso8601(~N[2015-01-01 23:00:13.001])\n"
"    \"23:00:13.001\"\n"
"\n"

#. TRANSLATORS: def NaiveDateTime.add(naive_datetime, integer, unit \\ :second)
#: lib/calendar.ex:907
msgid ""
"Adds a specified amount of time to a `NaiveDateTime`.\n"
"\n"
"Accepts an `integer` in any `unit` available from `t:System.time_unit/0`.\n"
"Negative values will be move backwards in time.\n"
"\n"
"## Examples\n"
"\n"
"    # adds seconds by default\n"
"    iex> NaiveDateTime.add(~N[2014-10-02 00:29:10], 2)\n"
"    ~N[2014-10-02 00:29:12]\n"
"    # accepts negative offsets\n"
"    iex> NaiveDateTime.add(~N[2014-10-02 00:29:10], -2)\n"
"    ~N[2014-10-02 00:29:08]\n"
"    # can work with other units\n"
"    iex> NaiveDateTime.add(~N[2014-10-02 00:29:10], 2_000, :millisecond)\n"
"    ~N[2014-10-02 00:29:12]\n"
"    # keeps the same precision\n"
"    iex> NaiveDateTime.add(~N[2014-10-02 00:29:10.021], 21, :second)\n"
"    ~N[2014-10-02 00:29:31.021]\n"
"    # changes below the precision will not be visible\n"
"    iex> hidden = NaiveDateTime.add(~N[2014-10-02 00:29:10], 21, :"
"millisecond)\n"
"    iex> hidden.microsecond  # ~N[2014-10-02 00:29:10]\n"
"    {21000, 0}\n"
"    # from gregorian seconds\n"
"    iex> NaiveDateTime.add(~N[0000-01-01 00:00:00], 63579428950)\n"
"    ~N[2014-10-02 00:29:10]\n"
msgstr ""
"`NaiveDateTime`に指定した量の時間を加えます。\n"
"\n"
"`t:System.time_unit/0`で利用可能な任意の`unit`による`integer`を\n"
"受け付けます。負の値は時間を過去に移動します。\n"
"\n"
"## 例\n"
"\n"
"    # デフォルトでは秒を加える\n"
"    iex> NaiveDateTime.add(~N[2014-10-02 00:29:10], 2)\n"
"    ~N[2014-10-02 00:29:12]\n"
"    # 負のオフセットを受け付ける\n"
"    iex> NaiveDateTime.add(~N[2014-10-02 00:29:10], -2)\n"
"    ~N[2014-10-02 00:29:08]\n"
"    # 他の単位も扱える\n"
"    iex> NaiveDateTime.add(~N[2014-10-02 00:29:10], 2_000, :millisecond)\n"
"    ~N[2014-10-02 00:29:12]\n"
"    # 同じ精度を保つ\n"
"    iex> NaiveDateTime.add(~N[2014-10-02 00:29:10.021], 21, :second)\n"
"    ~N[2014-10-02 00:29:31.021]\n"
"    # 精度以下の変更は見えない\n"
"    iex> hidden = NaiveDateTime.add(~N[2014-10-02 00:29:10], 21, :"
"millisecond)\n"
"    iex> hidden.microsecond  # ~N[2014-10-02 00:29:10]\n"
"    {21000, 0}\n"
"    # グレゴリア暦秒から\n"
"    iex> NaiveDateTime.add(~N[0000-01-01 00:00:00], 63579428950)\n"
"    ~N[2014-10-02 00:29:10]\n"

#. TRANSLATORS: def DateTime.compare(datetime1, datetime2)
#: lib/calendar.ex:1769
msgid ""
"Compares two `DateTime` structs.\n"
"\n"
"Returns `:gt` if first datetime is later than the second\n"
"and `:lt` for vice versa. If the two datetimes are equal\n"
"`:eq` is returned.\n"
"\n"
"Note that both utc and stc offsets will be taken into\n"
"account when comparison is done.\n"
"\n"
"## Examples\n"
"\n"
"    iex> dt1 = %DateTime{year: 2000, month: 2, day: 29, zone_abbr: \"AMT\",\n"
"    ...>                 hour: 23, minute: 0, second: 7, microsecond: {0, "
"0},\n"
"    ...>                 utc_offset: -14400, std_offset: 0, time_zone: "
"\"America/Manaus\"}\n"
"    iex> dt2 = %DateTime{year: 2000, month: 2, day: 29, zone_abbr: \"CET\",\n"
"    ...>                 hour: 23, minute: 0, second: 7, microsecond: {0, "
"0},\n"
"    ...>                 utc_offset: 3600, std_offset: 0, time_zone: "
"\"Europe/Warsaw\"}\n"
"    iex> DateTime.compare(dt1, dt2)\n"
"    :gt\n"
msgstr ""
"2つの`DateTime`構造体を比較します。\n"
"\n"
"最初の日時が2番めの日時より後の場合は`:gt`を、\n"
" 逆の場合は`:lt`を返します。2つの日時が同じ場合は\n"
"`:eq`が返されます。\n"
"\n"
"比較を行う際、UTCとSTC両オフセットが考慮されることに\n"
"注意してください。\n"
"\n"
"## 例\n"
"\n"
"    iex> dt1 = %DateTime{year: 2000, month: 2, day: 29, zone_abbr: \"AMT\",\n"
"    ...>                 hour: 23, minute: 0, second: 7, microsecond: {0, "
"0},\n"
"    ...>                 utc_offset: -14400, std_offset: 0, time_zone: "
"\"America/Manaus\"}\n"
"    iex> dt2 = %DateTime{year: 2000, month: 2, day: 29, zone_abbr: \"CET\",\n"
"    ...>                 hour: 23, minute: 0, second: 7, microsecond: {0, "
"0},\n"
"    ...>                 utc_offset: 3600, std_offset: 0, time_zone: "
"\"Europe/Warsaw\"}\n"
"    iex> DateTime.compare(dt1, dt2)\n"
"    :gt\n"
"\n"
"\n"

#. TRANSLATORS: Elixir.Date Summary
#: lib/calendar.ex:105
msgid ""
"A Date struct and functions.\n"
"\n"
"The Date struct contains the fields year, month, day and calendar.\n"
"New dates can be built with the `new/3` function or using the `~D`\n"
"sigil:\n"
"\n"
"    iex> ~D[2000-01-01]\n"
"    ~D[2000-01-01]\n"
"\n"
"Both `new/3` and sigil return a struct where the date fields can\n"
"be accessed directly:\n"
"\n"
"    iex> date = ~D[2000-01-01]\n"
"    iex> date.year\n"
"    2000\n"
"    iex> date.month\n"
"    1\n"
"\n"
"The functions on this module work with the `Date` struct as well\n"
"as any struct that contains the same fields as the `Date` struct,\n"
"such as `NaiveDateTime` and `DateTime`. Such functions expect\n"
"`Calendar.date` in their typespecs (instead of `t`).\n"
"\n"
"Developers should avoid creating the Date struct directly and\n"
"instead rely on the functions provided by this module as well as\n"
"the ones in 3rd party calendar libraries.\n"
msgstr ""
"Date構造体と関数です。\n"
"\n"
"Date構造体は、year, month, day, calendarの各フィールドを持ちます。\n"
"新たな日付は、関数`new/3`か`~D`シジルを使用して作成\n"
"できます。\n"
"\n"
"    iex> ~D[2000-01-01]\n"
"    ~D[2000-01-01]\n"
"\n"
"`new/3`もシジルも日付フィールに直接アクセスできる構造体を\n"
"返します。\n"
"\n"
"    iex> date = ~D[2000-01-01]\n"
"    iex> date.year\n"
"    2000\n"
"    iex> date.month\n"
"    1\n"
"\n"
"このモジュールの関数は`Date`構造体だけでなく、`NaiveDateTime`\n"
"や`DateTime`など、`Date`構造体と同じフィールドを持つ任意の構造体でも\n"
"動作するものがあります。そのような関数は型仕様で（`t`ではなく）\n"
"`Calendar.date`を求めています。\n"
"\n"
"開発者は日付構造体を直接作成することは避け、代わりに、このモジュールで\n"
"提供されている関数やサードパーティのカレンダーライブラリの\n"
"関数を使用するべきです。\n"

#. TRANSLATORS: def NaiveDateTime.from_iso8601!(string)
#: lib/calendar.ex:1112
msgid ""
"Parses the extended \"Date and time of day\" format described by\n"
"[ISO 8601:2004](https://en.wikipedia.org/wiki/ISO_8601).\n"
"\n"
"Raises if the format is invalid.\n"
"\n"
"## Examples\n"
"\n"
"    iex> NaiveDateTime.from_iso8601!(\"2015-01-23T23:50:07.123Z\")\n"
"    ~N[2015-01-23 23:50:07.123]\n"
"    iex> NaiveDateTime.from_iso8601!(\"2015-01-23P23:50:07\")\n"
"    ** (ArgumentError) cannot parse \"2015-01-23P23:50:07\" as naive "
"datetime, reason: :invalid_format\n"
"\n"
msgstr ""
"[ISO 8601:2004](https://en.wikipedia.org/wiki/ISO_8601)に\n"
"記載された拡張された「日付と時刻」形式をパースします。\n"
"\n"
"形式が不正な場合は例外を発生させます。\n"
"\n"
"## 例\n"
"\n"
"    iex> NaiveDateTime.from_iso8601!(\"2015-01-23T23:50:07.123Z\")\n"
"    ~N[2015-01-23 23:50:07.123]\n"
"    iex> NaiveDateTime.from_iso8601!(\"2015-01-23P23:50:07\")\n"
"    ** (ArgumentError) cannot parse \"2015-01-23P23:50:07\" as naive "
"datetime, reason: :invalid_format\n"
"\n"

#. TRANSLATORS: def DateTime.to_iso8601(map)
#: lib/calendar.ex:1610
msgid ""
"Converts the given datetime to\n"
"[ISO 8601:2004](https://en.wikipedia.org/wiki/ISO_8601) format.\n"
"\n"
"Only supports converting datetimes which are in the ISO calendar,\n"
"attempting to convert datetimes from other calendars will raise.\n"
"\n"
"WARNING: the ISO 8601 datetime format does not contain the time zone nor\n"
"its abbreviation, which means information is lost when converting to such\n"
"format.\n"
"\n"
"### Examples\n"
"\n"
"    iex> dt = %DateTime{year: 2000, month: 2, day: 29, zone_abbr: \"CET\",\n"
"    ...>                hour: 23, minute: 0, second: 7, microsecond: {0, "
"0},\n"
"    ...>                utc_offset: 3600, std_offset: 0, time_zone: \"Europe/"
"Warsaw\"}\n"
"    iex> DateTime.to_iso8601(dt)\n"
"    \"2000-02-29T23:00:07+01:00\"\n"
"\n"
"    iex> dt = %DateTime{year: 2000, month: 2, day: 29, zone_abbr: \"UTC\",\n"
"    ...>                hour: 23, minute: 0, second: 7, microsecond: {0, "
"0},\n"
"    ...>                utc_offset: 0, std_offset: 0, time_zone: \"Etc/UTC"
"\"}\n"
"    iex> DateTime.to_iso8601(dt)\n"
"    \"2000-02-29T23:00:07Z\"\n"
"\n"
"    iex> dt = %DateTime{year: 2000, month: 2, day: 29, zone_abbr: \"AMT\",\n"
"    ...>                hour: 23, minute: 0, second: 7, microsecond: {0, "
"0},\n"
"    ...>                utc_offset: -14400, std_offset: 0, time_zone: "
"\"America/Manaus\"}\n"
"    iex> DateTime.to_iso8601(dt)\n"
"    \"2000-02-29T23:00:07-04:00\"\n"
msgstr ""
"指定された日時を[ISO 8601:2004](https://en.wikipedia.org/wiki/ISO_8601)\n"
"形式に変換します。\n"
"\n"
"ISOカレンダーの日時の変換のみサポートしています。他のカレンダーの\n"
"日時を変更しようとすると例外を発生させます。\n"
"\n"
"警告: ISO 8601日時形式はタイムゾーンもその省略形も含んでいません。\n"
"これはこの形式への変換時に情報が失われることを\n"
"意味します。\n"
"\n"
"### 例\n"
"\n"
"    iex> dt = %DateTime{year: 2000, month: 2, day: 29, zone_abbr: \"CET\",\n"
"    ...>                hour: 23, minute: 0, second: 7, microsecond: {0, "
"0},\n"
"    ...>                utc_offset: 3600, std_offset: 0, time_zone: \"Europe/"
"Warsaw\"}\n"
"    iex> DateTime.to_iso8601(dt)\n"
"    \"2000-02-29T23:00:07+01:00\"\n"
"\n"
"    iex> dt = %DateTime{year: 2000, month: 2, day: 29, zone_abbr: \"UTC\",\n"
"    ...>                hour: 23, minute: 0, second: 7, microsecond: {0, "
"0},\n"
"    ...>                utc_offset: 0, std_offset: 0, time_zone: \"Etc/UTC"
"\"}\n"
"    iex> DateTime.to_iso8601(dt)\n"
"    \"2000-02-29T23:00:07Z\"\n"
"\n"
"    iex> dt = %DateTime{year: 2000, month: 2, day: 29, zone_abbr: \"AMT\",\n"
"    ...>                hour: 23, minute: 0, second: 7, microsecond: {0, "
"0},\n"
"    ...>                utc_offset: -14400, std_offset: 0, time_zone: "
"\"America/Manaus\"}\n"
"    iex> DateTime.to_iso8601(dt)\n"
"    \"2000-02-29T23:00:07-04:00\"\n"

#. TRANSLATORS: Elixir.NaiveDateTime Summary
#: lib/calendar.ex:780
msgid ""
"A NaiveDateTime struct (without a time zone) and functions.\n"
"\n"
"The NaiveDateTime struct contains the fields year, month, day, hour,\n"
"minute, second, microsecond and calendar. New naive datetimes can be\n"
"built with the `new/7` function or using the `~N` sigil:\n"
"\n"
"    iex> ~N[2000-01-01 23:00:07]\n"
"    ~N[2000-01-01 23:00:07]\n"
"\n"
"Both `new/7` and sigil return a struct where the date fields can\n"
"be accessed directly:\n"
"\n"
"    iex> naive = ~N[2000-01-01 23:00:07]\n"
"    iex> naive.year\n"
"    2000\n"
"    iex> naive.second\n"
"    7\n"
"\n"
"The naive bit implies this datetime representation does\n"
"not have a time zone. This means the datetime may not\n"
"actually exist in certain areas in the world even though\n"
"it is valid.\n"
"\n"
"For example, when daylight saving changes are applied\n"
"by a region, the clock typically moves forward or backward\n"
"by one hour. This means certain datetimes never occur or\n"
"may occur more than once. Since `NaiveDateTime` is not\n"
"validated against a time zone, such errors would go unnoticed.\n"
"\n"
"Developers should avoid creating the NaiveDateTime struct directly\n"
"and instead rely on the functions provided by this module as well\n"
"as the ones in 3rd party calendar libraries.\n"
msgstr ""
"NaiveDateTime構造体（タイムゾーンなし)と関数です。\n"
"\n"
"NaiveDateTime構造体は、year, month, day, hour, minute,\n"
"second, microsectond, canlendarをフィールドに持ちます。\n"
"新たなナイーブ日時は関数`new/7`または`~N`シジルで作成できます。\n"
"\n"
"    iex> ~N[2000-01-01 23:00:07]\n"
"    ~N[2000-01-01 23:00:07]\n"
"\n"
"`new/7`もシジルも日付フィールドに直接アクセスできる構造体を\n"
"返します。\n"
"\n"
"    iex> naive = ~N[2000-01-01 23:00:07]\n"
"    iex> naive.year\n"
"    2000\n"
"    iex> naive.second\n"
"    7\n"
"\n"
"ナイーブな部分はこの日時表現がタイムゾーンを持たないことを\n"
"暗示しています。これは、たとえ有効であっても日時が実際には\n"
"世界中のどこにも存在しない可能性があることを\n"
"意味します。\n"
"\n"
"たとえば、地域によって夏時間の変更が適用されると、時計は通常、\n"
"1時間前または後に移動します。 これは、ある日時が決して発生しない、\n"
"または、複数回発生する可能性があることを意味します。 \n"
"`NaiveDateTime`はタイムゾーンに対して検証されないため、\n"
"このようなエラーは気付かれないでしょう。\n"
"\n"
"開発者はNaiveDateTime構造体を直接作成するは避け、代わりに\n"
"このモジュールが提供する関数やサードパーティのカレンダー\n"
"ライブラリの関数を使用するべきです。\n"
"\n"

#. TRANSLATORS: def Date.from_iso8601(arg)
#: lib/calendar.ex:238
msgid ""
"Parses the extended \"Date and time of day\" format described by\n"
"[ISO 8601:2004](https://en.wikipedia.org/wiki/ISO_8601).\n"
"\n"
"Timezone offset may be included in the string but they will be\n"
"simply discarded as such information is not included in naive date\n"
"times.\n"
"\n"
"Time representations with reduced accuracy are not supported.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Date.from_iso8601(\"2015-01-23\")\n"
"    {:ok, ~D[2015-01-23]}\n"
"\n"
"    iex> Date.from_iso8601(\"2015:01:23\")\n"
"    {:error, :invalid_format}\n"
"    iex> Date.from_iso8601(\"2015-01-32\")\n"
"    {:error, :invalid_date}\n"
"\n"
msgstr ""
"[ISO 8601:2004](https://en.wikipedia.org/wiki/ISO_8601)に\n"
"記載された拡張された「日付と時刻」形式をパースします。\n"
"\n"
"タイムゾーンオフセットを文字列に含めることができますが、\n"
"ナイーブな日時にはそのような情報は含まれませんので\n"
"単に破棄されます。\n"
"\n"
"精度の低い時間表現はサポートされていません。\n"
"\n"
"## 例\n"
"\n"
"    iex> Date.from_iso8601(\"2015-01-23\")\n"
"    {:ok, ~D[2015-01-23]}\n"
"\n"
"    iex> Date.from_iso8601(\"2015:01:23\")\n"
"    {:error, :invalid_format}\n"
"    iex> Date.from_iso8601(\"2015-01-32\")\n"
"    {:error, :invalid_date}\n"
"\n"

#. TRANSLATORS: def DateTime.to_time(date_time)
#: lib/calendar.ex:1591
msgid ""
"Converts a `DateTime` into `Time`.\n"
"\n"
"Because `Time` does not hold date nor time zone information,\n"
"data will be lost during the conversion.\n"
"\n"
"## Examples\n"
"\n"
"    iex> dt = %DateTime{year: 2000, month: 2, day: 29, zone_abbr: \"CET\",\n"
"    ...>                hour: 23, minute: 0, second: 7, microsecond: {0, "
"1},\n"
"    ...>                utc_offset: 3600, std_offset: 0, time_zone: \"Europe/"
"Warsaw\"}\n"
"    iex> DateTime.to_time(dt)\n"
"    ~T[23:00:07.0]\n"
"\n"
msgstr ""
"`DateTime`を`Time`に変換します。\n"
"\n"
"`Time`は日付もタイムゾーン情報も保持しませんので、\n"
"データは変換時に失われます。\n"
"\n"
"## 例\n"
"\n"
"    iex> dt = %DateTime{year: 2000, month: 2, day: 29, zone_abbr: \"CET\",\n"
"    ...>                hour: 23, minute: 0, second: 7, microsecond: {0, "
"1},\n"
"    ...>                utc_offset: 3600, std_offset: 0, time_zone: \"Europe/"
"Warsaw\"}\n"
"    iex> DateTime.to_time(dt)\n"
"    ~T[23:00:07.0]\n"
"\n"

#. TRANSLATORS: Elixir.Time Summary
#: lib/calendar.ex:446
msgid ""
"A Time struct and functions.\n"
"\n"
"The Time struct contains the fields hour, minute, second and microseconds.\n"
"New times can be built with the `new/4` function or using the `~T`\n"
"sigil:\n"
"\n"
"    iex> ~T[23:00:07.001]\n"
"    ~T[23:00:07.001]\n"
"\n"
"Both `new/4` and sigil return a struct where the time fields can\n"
"be accessed directly:\n"
"\n"
"    iex> time = ~T[23:00:07.001]\n"
"    iex> time.hour\n"
"    23\n"
"    iex> time.microsecond\n"
"    {1000, 3}\n"
"\n"
"The functions on this module work with the `Time` struct as well\n"
"as any struct that contains the same fields as the `Time` struct,\n"
"such as `NaiveDateTime` and `DateTime`. Such functions expect\n"
"`Calendar.time` in their typespecs (instead of `t`).\n"
"\n"
"Developers should avoid creating the Time struct directly and\n"
"instead rely on the functions provided by this module as well as\n"
"the ones in 3rd party calendar libraries.\n"
msgstr ""
"Time構造体と関数です。\n"
"\n"
"Time構造体は、hour, minute, second, microsectondを\n"
"フィールドに持ちます。\n"
"新たな時間は関数`new/4`または`~T`シジルで作成できます。\n"
"\n"
"    iex> ~T[23:00:07.001]\n"
"    ~T[23:00:07.001]\n"
"\n"
"`new/4`もシジルも時間フィールドに直接アクセスできる構造体を\n"
"返します。\n"
"\n"
"    iex> time = ~T[23:00:07.001]\n"
"    iex> time.hour\n"
"    23\n"
"    iex> time.microsecond\n"
"    {1000, 3}\n"
"\n"
"このモジュールの関数には`Time`構造体だけでなく、`NaiveDateTime`や\n"
"`DateTime`など、`Time`構造体と同じフィールドを持つ任意の構造体も\n"
"扱うことができるものがあります。そのような関数では\n"
"型仕様において（`t`ではなく）`Calendar.time`が求められています。\n"
"\n"
"開発者は、Time構造体を直接作成するのは避け、この\n"
"モジュールが提供する関数やサードパーティのカレンダーライブラリの\n"
"関数を使用するべきです。\n"

#. TRANSLATORS: def Time.from_iso8601!(string)
#: lib/calendar.ex:626
msgid ""
"Parses the extended \"Local time\" format described by\n"
"[ISO 8601:2004](https://en.wikipedia.org/wiki/ISO_8601).\n"
"\n"
"Raises if the format is invalid.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Time.from_iso8601!(\"23:50:07.123Z\")\n"
"    ~T[23:50:07.123]\n"
"    iex> Time.from_iso8601!(\"2015:01:23 23-50-07\")\n"
"    ** (ArgumentError) cannot parse \"2015:01:23 23-50-07\" as time, "
"reason: :invalid_format\n"
msgstr ""
"[ISO 8601:2004](https://en.wikipedia.org/wiki/ISO_8601)に\n"
"記載された拡張された「ローカル時間」形式をパースします。\n"
"\n"
"形式が不正な場合は例外を発生させます。\n"
"\n"
"## 例\n"
"\n"
"    iex> Time.from_iso8601!(\"23:50:07.123Z\")\n"
"    ~T[23:50:07.123]\n"
"    iex> Time.from_iso8601!(\"2015:01:23 23-50-07\")\n"
"    ** (ArgumentError) cannot parse \"2015:01:23 23-50-07\" as time, "
"reason: :invalid_format\n"
"\n"
"\n"
"タイムゾーンオフセットを文字列に含めることができますが、\n"
"時間にはそのような情報は含まれませんので 単に破棄されます。\n"
"\n"
"規格で指定されているように、この関数内では曖昧さがありませんので\n"
"必要であればセパレータ “T” は省略できます。\n"
"\n"
"精度の低い時間表現はサポートされていません。\n"

#. TRANSLATORS: @type time_zone
#: lib/calendar.ex:41
msgid "The time zone ID according to the IANA tz database (e.g. Europe/Zurich)"
msgstr " IANA tzデータベースによるタイムゾーンID（たとえば、Europe/Zurich）"

#. TRANSLATORS: def DateTime.from_unix!(integer, unit \\ :second)
#: lib/calendar.ex:1421
msgid ""
"Converts the given Unix time to DateTime.\n"
"\n"
"The integer can be given in different unit\n"
"according to `System.convert_time_unit/3` and it will\n"
"be converted to microseconds internally.\n"
"\n"
"Unix times are always in UTC and therefore the DateTime\n"
"will be returned in UTC.\n"
"\n"
"## Examples\n"
"\n"
"    iex> DateTime.from_unix!(1464096368)\n"
"    %DateTime{calendar: Calendar.ISO, day: 24, hour: 13, microsecond: {0, "
"0}, minute: 26,\n"
"              month: 5, second: 8, std_offset: 0, time_zone: \"Etc/UTC\", "
"utc_offset: 0,\n"
"              year: 2016, zone_abbr: \"UTC\"}\n"
"\n"
"    iex> DateTime.from_unix!(1432560368868569, :microsecond)\n"
"    %DateTime{calendar: Calendar.ISO, day: 25, hour: 13, microsecond: "
"{868569, 6}, minute: 26,\n"
"              month: 5, second: 8, std_offset: 0, time_zone: \"Etc/UTC\", "
"utc_offset: 0,\n"
"              year: 2015, zone_abbr: \"UTC\"}\n"
"\n"
"Negative Unix times are supported, up to -62167219200 seconds,\n"
"which is equivalent to \"0000-01-01T00:00:00Z\" or 0 gregorian seconds.\n"
"\n"
"    iex> DateTime.from_unix(-12345678910)\n"
"    {:ok, %DateTime{calendar: Calendar.ISO, day: 13, hour: 4, microsecond: "
"{0, 0}, minute: 44,\n"
"                    month: 10, second: 50, std_offset: 0, time_zone: \"Etc/"
"UTC\", utc_offset: 0,\n"
"                    year: 1578, zone_abbr: \"UTC\"}}\n"
"\n"
"When a Unix time before that moment is passed to `from_unix!/2`, an "
"ArgumentError will be raised.\n"
msgstr ""
"指定されたUnix時間をDateTimeに変換します。\n"
"\n"
"`System.convert_time_unit/3`に従うさまざまな単位の\n"
"整数を指定することができます。内部ではマイクロ秒に\n"
"変換されます。\n"
"\n"
"Unix時間は常にUTCです。そのため、DateTImeは\n"
"UTCで返されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> DateTime.from_unix!(1464096368)\n"
"    %DateTime{calendar: Calendar.ISO, day: 24, hour: 13, microsecond: {0, "
"0}, minute: 26,\n"
"              month: 5, second: 8, std_offset: 0, time_zone: \"Etc/UTC\", "
"utc_offset: 0,\n"
"              year: 2016, zone_abbr: \"UTC\"}\n"
"\n"
"    iex> DateTime.from_unix!(1432560368868569, :microsecond)\n"
"    %DateTime{calendar: Calendar.ISO, day: 25, hour: 13, microsecond: "
"{868569, 6}, minute: 26,\n"
"              month: 5, second: 8, std_offset: 0, time_zone: \"Etc/UTC\", "
"utc_offset: 0,\n"
"              year: 2015, zone_abbr: \"UTC\"}\n"
"\n"
"\"0000-01-01T00:00:00Z”またはグレゴリア暦0秒に相当する\n"
"-62167219200秒までの負のUnix時間もサポートされています。\n"
"\n"
"    iex> DateTime.from_unix(-12345678910)\n"
"    {:ok, %DateTime{calendar: Calendar.ISO, day: 13, hour: 4, microsecond: "
"{0, 0}, minute: 44,\n"
"                    month: 10, second: 50, std_offset: 0, time_zone: \"Etc/"
"UTC\", utc_offset: 0,\n"
"                    year: 1578, zone_abbr: \"UTC\"}}\n"
"\n"
"上記以前のUnix時間が`from_unix/2`に渡された場合は、\n"
"ArgumentErrorが発生します。\n"

#. TRANSLATORS: def DateTime.utc_now()
#: lib/calendar.ex:1355
msgid ""
"Returns the current datetime in UTC.\n"
"\n"
"## Examples\n"
"\n"
"    iex> datetime = DateTime.utc_now()\n"
"    iex> datetime.time_zone\n"
"    \"Etc/UTC\"\n"
"\n"
msgstr ""
"現在の日時をUTCで返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> datetime = DateTime.utc_now()\n"
"    iex> datetime.time_zone\n"
"    \"Etc/UTC\"\n"
"\n"

#. TRANSLATORS: @type calendar
#: lib/calendar.ex:38
msgid "A calendar implementation"
msgstr "カレンダの実装"

#. TRANSLATORS: def DateTime.to_unix(datetime, unit \\ :second)
#: lib/calendar.ex:1511
msgid ""
"Converts the given DateTime to Unix time.\n"
"\n"
"The DateTime is expected to be using the ISO calendar\n"
"with a year greater than or equal to 0.\n"
"\n"
"It will return the integer with the given unit,\n"
"according to `System.convert_time_unit/3`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> 1464096368 |> DateTime.from_unix!() |> DateTime.to_unix()\n"
"    1464096368\n"
"\n"
"    iex> dt = %DateTime{calendar: Calendar.ISO, day: 20, hour: 18, "
"microsecond: {273806, 6},\n"
"    ...>                minute: 58, month: 11, second: 19, time_zone: "
"\"America/Montevideo\",\n"
"    ...>                utc_offset: -10800, std_offset: 3600, year: 2014, "
"zone_abbr: \"UYST\"}\n"
"    iex> DateTime.to_unix(dt)\n"
"    1416517099\n"
"\n"
"    iex> flamel = %DateTime{calendar: Calendar.ISO, day: 22, hour: 8, "
"microsecond: {527771, 6},\n"
"    ...>                minute: 2, month: 3, second: 25, std_offset: 0, "
"time_zone: \"Etc/UTC\",\n"
"    ...>                utc_offset: 0, year: 1418, zone_abbr: \"UTC\"}\n"
"    iex> DateTime.to_unix(flamel)\n"
"    -17412508655\n"
"\n"
msgstr ""
"指定されたDateTimeをUnix時間に変換します。\n"
"\n"
"DateTimeはISOカレンダーを使用し、0以上の年を持つことを\n"
"期待されます。\n"
"\n"
"`System.convert_time_unit/3`に従って、指定の\n"
"単位の整数を返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> 1464096368 |> DateTime.from_unix!() |> DateTime.to_unix()\n"
"    1464096368\n"
"\n"
"    iex> dt = %DateTime{calendar: Calendar.ISO, day: 20, hour: 18, "
"microsecond: {273806, 6},\n"
"    ...>                minute: 58, month: 11, second: 19, time_zone: "
"\"America/Montevideo\",\n"
"    ...>                utc_offset: -10800, std_offset: 3600, year: 2014, "
"zone_abbr: \"UYST\"}\n"
"    iex> DateTime.to_unix(dt)\n"
"    1416517099\n"
"\n"
"    iex> flamel = %DateTime{calendar: Calendar.ISO, day: 22, hour: 8, "
"microsecond: {527771, 6},\n"
"    ...>                minute: 2, month: 3, second: 25, std_offset: 0, "
"time_zone: \"Etc/UTC\",\n"
"    ...>                utc_offset: 0, year: 1418, zone_abbr: \"UTC\"}\n"
"    iex> DateTime.to_unix(flamel)\n"
"    -17412508655\n"
"\n"

#. TRANSLATORS: def Date.from_erl!(tuple)
#: lib/calendar.ex:353
msgid ""
"Converts an Erlang date tuple but raises for invalid dates.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Date.from_erl!({2000, 1, 1})\n"
"    ~D[2000-01-01]\n"
"    iex> Date.from_erl!({2000, 13, 1})\n"
"    ** (ArgumentError) cannot convert {2000, 13, 1} to date, reason: :"
"invalid_date\n"
msgstr ""
"Erlangの日付タプルを変換します。不正な日付の場合は例外を発生します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Date.from_erl!({2000, 1, 1})\n"
"    ~D[2000-01-01]\n"
"    iex> Date.from_erl!({2000, 13, 1})\n"
"    ** (ArgumentError) cannot convert {2000, 13, 1} to date, reason: :"
"invalid_date\n"

#. TRANSLATORS: def DateTime.from_naive(naive_datetime, time_zone)
#: lib/calendar.ex:1463
msgid ""
"Converts the given NaiveDateTime to DateTime.\n"
"\n"
"It expects a time zone to put the NaiveDateTime in.\n"
"Currently it only supports \"Etc/UTC\" as time zone.\n"
"\n"
"## Examples\n"
"\n"
"    iex> DateTime.from_naive(~N[2016-05-24 13:26:08.003], \"Etc/UTC\")\n"
"    {:ok, %DateTime{calendar: Calendar.ISO, day: 24, hour: 13, microsecond: "
"{3000, 3}, minute: 26,\n"
"                    month: 5, second: 8, std_offset: 0, time_zone: \"Etc/UTC"
"\", utc_offset: 0,\n"
"                    year: 2016, zone_abbr: \"UTC\"}}\n"
"\n"
msgstr ""
"指定されたNaiveDateTimeをDateTimeに変換します。\n"
"\n"
"NaiveDateTimeに追加するタイムゾーンを期待します。\n"
"現在のところ、タイムゾーンとしてサポートしているのは”Etc/UTC”のみです。\n"
"\n"
"## 例\n"
"\n"
"    iex> DateTime.from_naive(~N[2016-05-24 13:26:08.003], \"Etc/UTC\")\n"
"    {:ok, %DateTime{calendar: Calendar.ISO, day: 24, hour: 13, microsecond: "
"{3000, 3}, minute: 26,\n"
"                    month: 5, second: 8, std_offset: 0, time_zone: \"Etc/UTC"
"\", utc_offset: 0,\n"
"                    year: 2016, zone_abbr: \"UTC\"}}\n"
"\n"

#. TRANSLATORS: @callback days_in_month/2
#: lib/calendar.ex:68
msgid "Returns how many days there are in the given year-month.\n"
msgstr "指定された年月が何日あるかを返します。\n"

#. TRANSLATORS: def Date.utc_today()
#: lib/calendar.ex:140
msgid ""
"Returns the current date in UTC.\n"
"\n"
"## Examples\n"
"\n"
"    iex> date = Date.utc_today()\n"
"    iex> date.year >= 2016\n"
"    true\n"
"\n"
msgstr ""
"現在の日付をUTCに変換します。\n"
"\n"
"## 例\n"
"\n"
"    iex> date = Date.utc_today()\n"
"    iex> date.year >= 2016\n"
"    true\n"
"\n"

#. TRANSLATORS: def DateTime.to_naive(date_time)
#: lib/calendar.ex:1551
msgid ""
"Converts a `DateTime` into a `NaiveDateTime`.\n"
"\n"
"Because `NaiveDateTime` does not hold time zone information,\n"
"any time zone related data will be lost during the conversion.\n"
"\n"
"## Examples\n"
"\n"
"    iex> dt = %DateTime{year: 2000, month: 2, day: 29, zone_abbr: \"CET\",\n"
"    ...>                hour: 23, minute: 0, second: 7, microsecond: {0, "
"1},\n"
"    ...>                utc_offset: 3600, std_offset: 0, time_zone: \"Europe/"
"Warsaw\"}\n"
"    iex> DateTime.to_naive(dt)\n"
"    ~N[2000-02-29 23:00:07.0]\n"
"\n"
msgstr ""
"`DateTime`を`NaiveDateTime`に変換します。\n"
"\n"
"`NaiveDateTime `はタイムゾーン情報も保持しませんので、\n"
"タイムゾーン関係のデータはすべて変換時に失われます。\n"
"\n"
"## 例\n"
"\n"
"    iex> dt = %DateTime{year: 2000, month: 2, day: 29, zone_abbr: \"CET\",\n"
"    ...>                hour: 23, minute: 0, second: 7, microsecond: {0, "
"1},\n"
"    ...>                utc_offset: 3600, std_offset: 0, time_zone: \"Europe/"
"Warsaw\"}\n"
"    iex> DateTime.to_naive(dt)\n"
"    ~N[2000-02-29 23:00:07.0]\n"
"\n"

#. TRANSLATORS: def Time.to_string(map)
#: lib/calendar.ex:547
msgid ""
"Converts the given time to a string.\n"
"\n"
"### Examples\n"
"\n"
"    iex> Time.to_string(~T[23:00:00])\n"
"    \"23:00:00\"\n"
"    iex> Time.to_string(~T[23:00:00.001])\n"
"    \"23:00:00.001\"\n"
"    iex> Time.to_string(~T[23:00:00.123456])\n"
"    \"23:00:00.123456\"\n"
"\n"
"    iex> Time.to_string(~N[2015-01-01 23:00:00.001])\n"
"    \"23:00:00.001\"\n"
"    iex> Time.to_string(~N[2015-01-01 23:00:00.123456])\n"
"    \"23:00:00.123456\"\n"
"\n"
msgstr ""
"指定された時間を文字列に変換します。\n"
"\n"
"### 例\n"
"\n"
"    iex> Time.to_string(~T[23:00:00])\n"
"    \"23:00:00\"\n"
"    iex> Time.to_string(~T[23:00:00.001])\n"
"    \"23:00:00.001\"\n"
"    iex> Time.to_string(~T[23:00:00.123456])\n"
"    \"23:00:00.123456\"\n"
"\n"
"    iex> Time.to_string(~N[2015-01-01 23:00:00.001])\n"
"    \"23:00:00.001\"\n"
"    iex> Time.to_string(~N[2015-01-01 23:00:00.123456])\n"
"    \"23:00:00.123456\"\n"
"\n"

#. TRANSLATORS: @type utc_offset
#: lib/calendar.ex:47
msgid "The time zone UTC offset in seconds"
msgstr "タイムゾーンのUTCからのオフセット（秒単位）"

#. TRANSLATORS: def NaiveDateTime.to_date(naive_date_time)
#: lib/calendar.ex:977
msgid ""
"Converts a `NaiveDateTime` into a `Date`.\n"
"\n"
"Because `Date` does not hold time information,\n"
"data will be lost during the conversion.\n"
"\n"
"## Examples\n"
"\n"
"    iex> NaiveDateTime.to_date(~N[2002-01-13 23:00:07])\n"
"    ~D[2002-01-13]\n"
"\n"
msgstr ""
"`NaiveDateTime`を`Date`に変換します。\n"
"\n"
"`Date`は時間情報を保持しませんので、データは変換時に\n"
"失われます。\n"
"\n"
"## 例\n"
"\n"
"    iex> NaiveDateTime.to_date(~N[2002-01-13 23:00:07])\n"
"    ~D[2002-01-13]\n"
"\n"

#. TRANSLATORS: def Date.from_erl(arg)
#: lib/calendar.ex:336
msgid ""
"Converts an Erlang date tuple to a `Date` struct.\n"
"\n"
"Attempting to convert an invalid ISO calendar date will produce an error "
"tuple.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Date.from_erl({2000, 1, 1})\n"
"    {:ok, ~D[2000-01-01]}\n"
"    iex> Date.from_erl({2000, 13, 1})\n"
"    {:error, :invalid_date}\n"
msgstr ""
"Erlangの日付タプルを`Date`構造体に変換します。\n"
"\n"
"不正なISOカレンダー日付を変更しようとすると、エラータプルを返します。\n"
"\n"
"## Examples\n"
"\n"
"    iex> Date.from_erl({2000, 1, 1})\n"
"    {:ok, ~D[2000-01-01]}\n"
"    iex> Date.from_erl({2000, 13, 1})\n"
"    {:error, :invalid_date}\n"

#. TRANSLATORS: def Date.day_of_week(map)
#: lib/calendar.ex:405
msgid ""
"Calculates the day of the week of a given `Date` struct.\n"
"\n"
"Returns the day of the week as an integer. For the ISO 8601\n"
"calendar (the default), it is an integer from 1 to 7, where\n"
"1 is Monday and 7 is Sunday.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Date.day_of_week(~D[2016-10-31])\n"
"    1\n"
"    iex> Date.day_of_week(~D[2016-11-01])\n"
"    2\n"
"    iex> Date.day_of_week(~N[2016-11-01 01:23:45])\n"
"    2\n"
msgstr ""
"指定された`Date`構造体の曜日を計算します。\n"
"\n"
"曜日を整数で返します。（デフォルトの）ISO 8601カレンダーでは\n"
"1から7の整数で、1は月曜日、7は日曜日です。\n"
"\n"
"## 例\n"
"\n"
"    iex> Date.day_of_week(~D[2016-10-31])\n"
"    1\n"
"    iex> Date.day_of_week(~D[2016-11-01])\n"
"    2\n"
"    iex> Date.day_of_week(~N[2016-11-01 01:23:45])\n"
"    2\n"

#. TRANSLATORS: def NaiveDateTime.from_erl!(tuple, microsecond \\ {0, 0})
#: lib/calendar.ex:1218
msgid ""
"Converts an Erlang datetime tuple to a `NaiveDateTime` struct.\n"
"\n"
"Raises if the datetime is invalid.\n"
"Attempting to convert an invalid ISO calendar date will produce an error "
"tuple.\n"
"\n"
"## Examples\n"
"\n"
"    iex> NaiveDateTime.from_erl!({{2000, 1, 1}, {13, 30, 15}})\n"
"    ~N[2000-01-01 13:30:15]\n"
"    iex> NaiveDateTime.from_erl!({{2000, 1, 1}, {13, 30, 15}}, {5000, 3})\n"
"    ~N[2000-01-01 13:30:15.005]\n"
"    iex> NaiveDateTime.from_erl!({{2000, 13, 1}, {13, 30, 15}})\n"
"    ** (ArgumentError) cannot convert {{2000, 13, 1}, {13, 30, 15}} to naive "
"datetime, reason: :invalid_date\n"
msgstr ""
"Erlangの日時タプルを`NaiveDateTime`構造体に変換します。\n"
"\n"
"日時が不正の場合、例外を発生させます。\n"
"不正なISOカレンダー日付を変換しようとするとエラータプルを返します。（訳注: 削"
"除漏れか）\n"
"\n"
"## 例\n"
"\n"
"    iex> NaiveDateTime.from_erl!({{2000, 1, 1}, {13, 30, 15}})\n"
"    ~N[2000-01-01 13:30:15]\n"
"    iex> NaiveDateTime.from_erl!({{2000, 1, 1}, {13, 30, 15}}, {5000, 3})\n"
"    ~N[2000-01-01 13:30:15.005]\n"
"    iex> NaiveDateTime.from_erl!({{2000, 13, 1}, {13, 30, 15}})\n"
"    ** (ArgumentError) cannot convert {{2000, 13, 1}, {13, 30, 15}} to naive "
"datetime, reason: :invalid_date\n"

#. TRANSLATORS: @type microsecond
#: lib/calendar.ex:28
msgid ""
"Microseconds with stored precision.\n"
"\n"
"The precision represents the number of digits\n"
"that must be used when representing the microseconds\n"
"to external format. If the precision is 0, it means\n"
"microseconds must be skipped.\n"
msgstr ""
"格納される精度はマイクロ秒です。\n"
"\n"
"精度は、外部形式のためにマイクロ秒を表す際に使用\n"
"しなければならない数字の数を表します。精度が0の\n"
"場合は、マイクロ秒は省略しなければならないことを\n"
"意味します。\n"

#. TRANSLATORS: def NaiveDateTime.new(year, month, day, hour, minute, second, microsecond \\ {0, 0})
#: lib/calendar.ex:844
msgid ""
"Builds a new ISO naive datetime.\n"
"\n"
"Expects all values to be integers. Returns `{:ok, naive_datetime}`\n"
"if each entry fits its appropriate range, returns `{:error, reason}`\n"
"otherwise.\n"
"\n"
"## Examples\n"
"\n"
"    iex> NaiveDateTime.new(2000, 1, 1, 0, 0, 0)\n"
"    {:ok, ~N[2000-01-01 00:00:00]}\n"
"    iex> NaiveDateTime.new(2000, 13, 1, 0, 0, 0)\n"
"    {:error, :invalid_date}\n"
"    iex> NaiveDateTime.new(2000, 2, 29, 0, 0, 0)\n"
"    {:ok, ~N[2000-02-29 00:00:00]}\n"
"    iex> NaiveDateTime.new(2000, 2, 30, 0, 0, 0)\n"
"    {:error, :invalid_date}\n"
"    iex> NaiveDateTime.new(2001, 2, 29, 0, 0, 0)\n"
"    {:error, :invalid_date}\n"
"\n"
"    iex> NaiveDateTime.new(2000, 1, 1, 23, 59, 59, {0, 1})\n"
"    {:ok, ~N[2000-01-01 23:59:59.0]}\n"
"    iex> NaiveDateTime.new(2000, 1, 1, 23, 59, 59, 999_999)\n"
"    {:ok, ~N[2000-01-01 23:59:59.999999]}\n"
"    iex> NaiveDateTime.new(2000, 1, 1, 23, 59, 60, 999_999)\n"
"    {:ok, ~N[2000-01-01 23:59:60.999999]}\n"
"    iex> NaiveDateTime.new(2000, 1, 1, 24, 59, 59, 999_999)\n"
"    {:error, :invalid_time}\n"
"    iex> NaiveDateTime.new(2000, 1, 1, 23, 60, 59, 999_999)\n"
"    {:error, :invalid_time}\n"
"    iex> NaiveDateTime.new(2000, 1, 1, 23, 59, 61, 999_999)\n"
"    {:error, :invalid_time}\n"
"    iex> NaiveDateTime.new(2000, 1, 1, 23, 59, 59, 1_000_000)\n"
"    {:error, :invalid_time}\n"
"\n"
msgstr ""
"新たなISOナイーブ日時を作成します。\n"
"\n"
"すべての値は整数であることが期待されます。各項目が\n"
"適切な範囲に適合する場合は`{:ok, naive_datetime}`を、そうでない場合は\n"
"`{:error, reason}`を返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> NaiveDateTime.new(2000, 1, 1, 0, 0, 0)\n"
"    {:ok, ~N[2000-01-01 00:00:00]}\n"
"    iex> NaiveDateTime.new(2000, 13, 1, 0, 0, 0)\n"
"    {:error, :invalid_date}\n"
"    iex> NaiveDateTime.new(2000, 2, 29, 0, 0, 0)\n"
"    {:ok, ~N[2000-02-29 00:00:00]}\n"
"    iex> NaiveDateTime.new(2000, 2, 30, 0, 0, 0)\n"
"    {:error, :invalid_date}\n"
"    iex> NaiveDateTime.new(2001, 2, 29, 0, 0, 0)\n"
"    {:error, :invalid_date}\n"
"\n"
"    iex> NaiveDateTime.new(2000, 1, 1, 23, 59, 59, {0, 1})\n"
"    {:ok, ~N[2000-01-01 23:59:59.0]}\n"
"    iex> NaiveDateTime.new(2000, 1, 1, 23, 59, 59, 999_999)\n"
"    {:ok, ~N[2000-01-01 23:59:59.999999]}\n"
"    iex> NaiveDateTime.new(2000, 1, 1, 23, 59, 60, 999_999)\n"
"    {:ok, ~N[2000-01-01 23:59:60.999999]}\n"
"    iex> NaiveDateTime.new(2000, 1, 1, 24, 59, 59, 999_999)\n"
"    {:error, :invalid_time}\n"
"    iex> NaiveDateTime.new(2000, 1, 1, 23, 60, 59, 999_999)\n"
"    {:error, :invalid_time}\n"
"    iex> NaiveDateTime.new(2000, 1, 1, 23, 59, 61, 999_999)\n"
"    {:error, :invalid_time}\n"
"    iex> NaiveDateTime.new(2000, 1, 1, 23, 59, 59, 1_000_000)\n"
"    {:error, :invalid_time}\n"
"\n"

#. TRANSLATORS: def Time.from_iso8601(arg)
#: lib/calendar.ex:570
msgid ""
"Parses the extended \"Local time\" format described by\n"
"[ISO 8601:2004](https://en.wikipedia.org/wiki/ISO_8601).\n"
"\n"
"Timezone offset may be included in the string but they will be\n"
"simply discarded as such information is not included in times.\n"
"\n"
"As specified in the standard, the separator \"T\" may be omitted if\n"
"desired as there is no ambiguity within this function.\n"
"\n"
"Time representations with reduced accuracy are not supported.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Time.from_iso8601(\"23:50:07\")\n"
"    {:ok, ~T[23:50:07]}\n"
"    iex> Time.from_iso8601(\"23:50:07Z\")\n"
"    {:ok, ~T[23:50:07]}\n"
"    iex> Time.from_iso8601(\"T23:50:07Z\")\n"
"    {:ok, ~T[23:50:07]}\n"
"\n"
"    iex> Time.from_iso8601(\"23:50:07.0123456\")\n"
"    {:ok, ~T[23:50:07.012345]}\n"
"    iex> Time.from_iso8601(\"23:50:07.123Z\")\n"
"    {:ok, ~T[23:50:07.123]}\n"
"\n"
"    iex> Time.from_iso8601(\"2015:01:23 23-50-07\")\n"
"    {:error, :invalid_format}\n"
"    iex> Time.from_iso8601(\"23:50:07A\")\n"
"    {:error, :invalid_format}\n"
"    iex> Time.from_iso8601(\"23:50:07.\")\n"
"    {:error, :invalid_format}\n"
"    iex> Time.from_iso8601(\"23:50:61\")\n"
"    {:error, :invalid_time}\n"
"\n"
msgstr ""
"[ISO 8601:2004](https://en.wikipedia.org/wiki/ISO_8601)に\n"
"記載された拡張された「ローカル時間」形式をパースします。\n"
"\n"
"タイムゾーンオフセットを文字列に含めることができますが、\n"
"時間にはそのような情報は含まれませんので 単に破棄されます。\n"
"\n"
"規格で指定されているように、この関数内では曖昧さがありませんので\n"
"必要であればセパレータ “T” は省略できます。\n"
"\n"
"精度の低い時間表現はサポートされていません。\n"
"\n"
"## 例\n"
"\n"
"    iex> Time.from_iso8601(\"23:50:07\")\n"
"    {:ok, ~T[23:50:07]}\n"
"    iex> Time.from_iso8601(\"23:50:07Z\")\n"
"    {:ok, ~T[23:50:07]}\n"
"    iex> Time.from_iso8601(\"T23:50:07Z\")\n"
"    {:ok, ~T[23:50:07]}\n"
"\n"
"    iex> Time.from_iso8601(\"23:50:07.0123456\")\n"
"    {:ok, ~T[23:50:07.012345]}\n"
"    iex> Time.from_iso8601(\"23:50:07.123Z\")\n"
"    {:ok, ~T[23:50:07.123]}\n"
"\n"
"    iex> Time.from_iso8601(\"2015:01:23 23-50-07\")\n"
"    {:error, :invalid_format}\n"
"    iex> Time.from_iso8601(\"23:50:07A\")\n"
"    {:error, :invalid_format}\n"
"    iex> Time.from_iso8601(\"23:50:07.\")\n"
"    {:error, :invalid_format}\n"
"    iex> Time.from_iso8601(\"23:50:61\")\n"
"    {:error, :invalid_time}\n"
"\n"

#. TRANSLATORS: def Time.utc_now()
#: lib/calendar.ex:481
msgid ""
"Returns the current time in UTC.\n"
"\n"
"## Examples\n"
"\n"
"    iex> time = Time.utc_now()\n"
"    iex> time.hour >= 0\n"
"    true\n"
"\n"
msgstr ""
"現在の時間をUTCで返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> time = Time.utc_now()\n"
"    iex> time.hour >= 0\n"
"    true\n"
"\n"

#. TRANSLATORS: def DateTime.from_iso8601(arg1)
#: lib/calendar.ex:1649
msgid ""
"Parses the extended \"Date and time of day\" format described by\n"
"[ISO 8601:2004](https://en.wikipedia.org/wiki/ISO_8601).\n"
"\n"
"Since ISO8601 does not include the proper time zone, the given\n"
"string will be converted to UTC and its offset in seconds will be\n"
"returned as part of this function. Therefore offset information\n"
"must be present in the string.\n"
"\n"
"As specified in the standard, the separator \"T\" may be omitted if\n"
"desired as there is no ambiguity within this function.\n"
"\n"
"Time representations with reduced accuracy are not supported.\n"
"\n"
"## Examples\n"
"\n"
"    iex> DateTime.from_iso8601(\"2015-01-23T23:50:07Z\")\n"
"    {:ok, %DateTime{calendar: Calendar.ISO, day: 23, hour: 23, microsecond: "
"{0, 0}, minute: 50, month: 1, second: 7, std_offset: 0,\n"
"                    time_zone: \"Etc/UTC\", utc_offset: 0, year: 2015, "
"zone_abbr: \"UTC\"}, 0}\n"
"    iex> DateTime.from_iso8601(\"2015-01-23T23:50:07.123+02:30\")\n"
"    {:ok, %DateTime{calendar: Calendar.ISO, day: 23, hour: 21, microsecond: "
"{123000, 3}, minute: 20, month: 1, second: 7, std_offset: 0,\n"
"                    time_zone: \"Etc/UTC\", utc_offset: 0, year: 2015, "
"zone_abbr: \"UTC\"}, 9000}\n"
"\n"
"    iex> DateTime.from_iso8601(\"2015-01-23P23:50:07\")\n"
"    {:error, :invalid_format}\n"
"    iex> DateTime.from_iso8601(\"2015-01-23 23:50:07A\")\n"
"    {:error, :invalid_format}\n"
"    iex> DateTime.from_iso8601(\"2015-01-23T23:50:07\")\n"
"    {:error, :missing_offset}\n"
"    iex> DateTime.from_iso8601(\"2015-01-23 23:50:61\")\n"
"    {:error, :invalid_time}\n"
"    iex> DateTime.from_iso8601(\"2015-01-32 23:50:07\")\n"
"    {:error, :invalid_date}\n"
"\n"
"    iex> DateTime.from_iso8601(\"2015-01-23T23:50:07.123-00:00\")\n"
"    {:error, :invalid_format}\n"
"    iex> DateTime.from_iso8601(\"2015-01-23T23:50:07.123-00:60\")\n"
"    {:error, :invalid_format}\n"
"\n"
msgstr ""
"[ISO 8601:2004](https://en.wikipedia.org/wiki/ISO_8601)に\n"
"記載された拡張された「日付と時刻」形式をパースします。\n"
"\n"
"ISO8601は適当なタイムゾーンを含みませんので、指定された\n"
"文字列はUTCに変換され、秒単位のオフセットはこの関数の一部として\n"
"返されます。\n"
"\n"
"規格で指定されているように、この関数内では曖昧さがありませんので\n"
"必要であればセパレータ “T” は省略できます。\n"
"\n"
"精度の低い時間表現はサポートされていません。\n"
"\n"
"## 例\n"
"\n"
"    iex> DateTime.from_iso8601(\"2015-01-23T23:50:07Z\")\n"
"    {:ok, %DateTime{calendar: Calendar.ISO, day: 23, hour: 23, microsecond: "
"{0, 0}, minute: 50, month: 1, second: 7, std_offset: 0,\n"
"                    time_zone: \"Etc/UTC\", utc_offset: 0, year: 2015, "
"zone_abbr: \"UTC\"}, 0}\n"
"    iex> DateTime.from_iso8601(\"2015-01-23T23:50:07.123+02:30\")\n"
"    {:ok, %DateTime{calendar: Calendar.ISO, day: 23, hour: 21, microsecond: "
"{123000, 3}, minute: 20, month: 1, second: 7, std_offset: 0,\n"
"                    time_zone: \"Etc/UTC\", utc_offset: 0, year: 2015, "
"zone_abbr: \"UTC\"}, 9000}\n"
"\n"
"    iex> DateTime.from_iso8601(\"2015-01-23P23:50:07\")\n"
"    {:error, :invalid_format}\n"
"    iex> DateTime.from_iso8601(\"2015-01-23 23:50:07A\")\n"
"    {:error, :invalid_format}\n"
"    iex> DateTime.from_iso8601(\"2015-01-23T23:50:07\")\n"
"    {:error, :missing_offset}\n"
"    iex> DateTime.from_iso8601(\"2015-01-23 23:50:61\")\n"
"    {:error, :invalid_time}\n"
"    iex> DateTime.from_iso8601(\"2015-01-32 23:50:07\")\n"
"    {:error, :invalid_date}\n"
"\n"
"    iex> DateTime.from_iso8601(\"2015-01-23T23:50:07.123-00:00\")\n"
"    {:error, :invalid_format}\n"
"    iex> DateTime.from_iso8601(\"2015-01-23T23:50:07.123-00:60\")\n"
"    {:error, :invalid_format}\n"
"\n"

#. TRANSLATORS: def NaiveDateTime.from_iso8601(arg)
#: lib/calendar.ex:1037
msgid ""
"Parses the extended \"Date and time of day\" format described by\n"
"[ISO 8601:2004](https://en.wikipedia.org/wiki/ISO_8601).\n"
"\n"
"Timezone offset may be included in the string but they will be\n"
"simply discarded as such information is not included in naive date\n"
"times.\n"
"\n"
"As specified in the standard, the separator \"T\" may be omitted if\n"
"desired as there is no ambiguity within this function.\n"
"\n"
"Time representations with reduced accuracy are not supported.\n"
"\n"
"## Examples\n"
"\n"
"    iex> NaiveDateTime.from_iso8601(\"2015-01-23 23:50:07\")\n"
"    {:ok, ~N[2015-01-23 23:50:07]}\n"
"    iex> NaiveDateTime.from_iso8601(\"2015-01-23T23:50:07\")\n"
"    {:ok, ~N[2015-01-23 23:50:07]}\n"
"    iex> NaiveDateTime.from_iso8601(\"2015-01-23T23:50:07Z\")\n"
"    {:ok, ~N[2015-01-23 23:50:07]}\n"
"\n"
"    iex> NaiveDateTime.from_iso8601(\"2015-01-23 23:50:07.0\")\n"
"    {:ok, ~N[2015-01-23 23:50:07.0]}\n"
"    iex> NaiveDateTime.from_iso8601(\"2015-01-23 23:50:07.0123456\")\n"
"    {:ok, ~N[2015-01-23 23:50:07.012345]}\n"
"    iex> NaiveDateTime.from_iso8601(\"2015-01-23T23:50:07.123Z\")\n"
"    {:ok, ~N[2015-01-23 23:50:07.123]}\n"
"\n"
"    iex> NaiveDateTime.from_iso8601(\"2015-01-23P23:50:07\")\n"
"    {:error, :invalid_format}\n"
"    iex> NaiveDateTime.from_iso8601(\"2015:01:23 23-50-07\")\n"
"    {:error, :invalid_format}\n"
"    iex> NaiveDateTime.from_iso8601(\"2015-01-23 23:50:07A\")\n"
"    {:error, :invalid_format}\n"
"    iex> NaiveDateTime.from_iso8601(\"2015-01-23 23:50:61\")\n"
"    {:error, :invalid_time}\n"
"    iex> NaiveDateTime.from_iso8601(\"2015-01-32 23:50:07\")\n"
"    {:error, :invalid_date}\n"
"\n"
"    iex> NaiveDateTime.from_iso8601(\"2015-01-23T23:50:07.123+02:30\")\n"
"    {:ok, ~N[2015-01-23 23:50:07.123]}\n"
"    iex> NaiveDateTime.from_iso8601(\"2015-01-23T23:50:07.123+00:00\")\n"
"    {:ok, ~N[2015-01-23 23:50:07.123]}\n"
"    iex> NaiveDateTime.from_iso8601(\"2015-01-23T23:50:07.123-02:30\")\n"
"    {:ok, ~N[2015-01-23 23:50:07.123]}\n"
"    iex> NaiveDateTime.from_iso8601(\"2015-01-23T23:50:07.123-00:00\")\n"
"    {:error, :invalid_format}\n"
"    iex> NaiveDateTime.from_iso8601(\"2015-01-23T23:50:07.123-00:60\")\n"
"    {:error, :invalid_format}\n"
"    iex> NaiveDateTime.from_iso8601(\"2015-01-23T23:50:07.123-24:00\")\n"
"    {:error, :invalid_format}\n"
"\n"
msgstr ""
"[ISO 8601:2004](https://en.wikipedia.org/wiki/ISO_8601)に\n"
"記載された拡張された「日付と時刻」形式をパースします。\n"
"\n"
"タイムゾーンオフセットを文字列に含めることができますが、\n"
"ナイーブな日時にはそのような情報は含まれませんので\n"
"単に破棄されます。\n"
"\n"
"規格で指定されているように、この関数内では曖昧さがありませんので、\n"
"必要であればセパレータ “T” は省略できます。\n"
"\n"
"精度の低い時間表現はサポートされていません。\n"
"\n"
"## 例\n"
"\n"
"    iex> NaiveDateTime.from_iso8601(\"2015-01-23 23:50:07\")\n"
"    {:ok, ~N[2015-01-23 23:50:07]}\n"
"    iex> NaiveDateTime.from_iso8601(\"2015-01-23T23:50:07\")\n"
"    {:ok, ~N[2015-01-23 23:50:07]}\n"
"    iex> NaiveDateTime.from_iso8601(\"2015-01-23T23:50:07Z\")\n"
"    {:ok, ~N[2015-01-23 23:50:07]}\n"
"\n"
"    iex> NaiveDateTime.from_iso8601(\"2015-01-23 23:50:07.0\")\n"
"    {:ok, ~N[2015-01-23 23:50:07.0]}\n"
"    iex> NaiveDateTime.from_iso8601(\"2015-01-23 23:50:07.0123456\")\n"
"    {:ok, ~N[2015-01-23 23:50:07.012345]}\n"
"    iex> NaiveDateTime.from_iso8601(\"2015-01-23T23:50:07.123Z\")\n"
"    {:ok, ~N[2015-01-23 23:50:07.123]}\n"
"\n"
"    iex> NaiveDateTime.from_iso8601(\"2015-01-23P23:50:07\")\n"
"    {:error, :invalid_format}\n"
"    iex> NaiveDateTime.from_iso8601(\"2015:01:23 23-50-07\")\n"
"    {:error, :invalid_format}\n"
"    iex> NaiveDateTime.from_iso8601(\"2015-01-23 23:50:07A\")\n"
"    {:error, :invalid_format}\n"
"    iex> NaiveDateTime.from_iso8601(\"2015-01-23 23:50:61\")\n"
"    {:error, :invalid_time}\n"
"    iex> NaiveDateTime.from_iso8601(\"2015-01-32 23:50:07\")\n"
"    {:error, :invalid_date}\n"
"\n"
"    iex> NaiveDateTime.from_iso8601(\"2015-01-23T23:50:07.123+02:30\")\n"
"    {:ok, ~N[2015-01-23 23:50:07.123]}\n"
"    iex> NaiveDateTime.from_iso8601(\"2015-01-23T23:50:07.123+00:00\")\n"
"    {:ok, ~N[2015-01-23 23:50:07.123]}\n"
"    iex> NaiveDateTime.from_iso8601(\"2015-01-23T23:50:07.123-02:30\")\n"
"    {:ok, ~N[2015-01-23 23:50:07.123]}\n"
"    iex> NaiveDateTime.from_iso8601(\"2015-01-23T23:50:07.123-00:00\")\n"
"    {:error, :invalid_format}\n"
"    iex> NaiveDateTime.from_iso8601(\"2015-01-23T23:50:07.123-00:60\")\n"
"    {:error, :invalid_format}\n"
"    iex> NaiveDateTime.from_iso8601(\"2015-01-23T23:50:07.123-24:00\")\n"
"    {:error, :invalid_format}\n"
"\n"

#. TRANSLATORS: def NaiveDateTime.to_string(map)
#: lib/calendar.ex:1011
msgid ""
"Converts the given naive datetime to a string according to its calendar.\n"
"\n"
"### Examples\n"
"\n"
"    iex> NaiveDateTime.to_string(~N[2000-02-28 23:00:13])\n"
"    \"2000-02-28 23:00:13\"\n"
"    iex> NaiveDateTime.to_string(~N[2000-02-28 23:00:13.001])\n"
"    \"2000-02-28 23:00:13.001\"\n"
"\n"
"This function can also be used to convert a DateTime to a string without\n"
"the time zone information:\n"
"\n"
"    iex> dt = %DateTime{year: 2000, month: 2, day: 29, zone_abbr: \"CET\",\n"
"    ...>                hour: 23, minute: 0, second: 7, microsecond: {0, "
"0},\n"
"    ...>                utc_offset: 3600, std_offset: 0, time_zone: \"Europe/"
"Warsaw\"}\n"
"    iex> NaiveDateTime.to_string(dt)\n"
"    \"2000-02-29 23:00:07\"\n"
"\n"
msgstr ""
"指定されたナイーブ日時をカレンダーに従って文字列に変換します。\n"
"\n"
"### 例\n"
"\n"
"    iex> NaiveDateTime.to_string(~N[2000-02-28 23:00:13])\n"
"    \"2000-02-28 23:00:13\"\n"
"    iex> NaiveDateTime.to_string(~N[2000-02-28 23:00:13.001])\n"
"    \"2000-02-28 23:00:13.001\"\n"
"\n"
"この関数はDateTimeをタイムゾーン情報を持たない文字列に変換するのにも\n"
"利用できます。\n"
"\n"
"    iex> dt = %DateTime{year: 2000, month: 2, day: 29, zone_abbr: \"CET\",\n"
"    ...>                hour: 23, minute: 0, second: 7, microsecond: {0, "
"0},\n"
"    ...>                utc_offset: 3600, std_offset: 0, time_zone: \"Europe/"
"Warsaw\"}\n"
"    iex> NaiveDateTime.to_string(dt)\n"
"    \"2000-02-29 23:00:07\"\n"
"\n"

#. TRANSLATORS: def Time.to_erl(map)
#: lib/calendar.ex:671
msgid ""
"Converts a `Time` struct to an Erlang time tuple.\n"
"\n"
"WARNING: Loss of precision may occur, as Erlang time tuples\n"
"only contain hours/minutes/seconds.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Time.to_erl(~T[23:30:15.999])\n"
"    {23, 30, 15}\n"
"\n"
"    iex> Time.to_erl(~N[2015-01-01 23:30:15.999])\n"
"    {23, 30, 15}\n"
"\n"
msgstr ""
"`Time`構造体をErlangの時間トリプルに変換します。\n"
"\n"
"警告: Erlangの時間トリプルは時/分/秒しかもっていませんので\n"
"精度が落ちる場合があります。\n"
"\n"
"## 例\n"
"\n"
"    iex> Time.to_erl(~T[23:30:15.999])\n"
"    {23, 30, 15}\n"
"\n"
"    iex> Time.to_erl(~N[2015-01-01 23:30:15.999])\n"
"    {23, 30, 15}\n"
"\n"

#. TRANSLATORS: def NaiveDateTime.to_time(naive_date_time)
#: lib/calendar.ex:994
msgid ""
"Converts a `NaiveDateTime` into `Time`.\n"
"\n"
"Because `Time` does not hold date information,\n"
"data will be lost during the conversion.\n"
"\n"
"## Examples\n"
"\n"
"    iex> NaiveDateTime.to_time(~N[2002-01-13 23:00:07])\n"
"    ~T[23:00:07]\n"
"\n"
msgstr ""
"`NaiveDateTime`を`Time`に変換します。\n"
"\n"
"`Time`は日付情報を保持しませんので、\n"
"データは変換時に失われます。\n"
"\n"
"## 例\n"
"\n"
"    iex> NaiveDateTime.to_time(~N[2002-01-13 23:00:07])\n"
"    ~T[23:00:07]\n"
"\n"

#~ msgid "The timezone ID according to Unicode's CLDR"
#~ msgstr "UnicodeのCLDRによるタイムゾーンID"

#~ msgid ""
#~ "A datetime implementation with a time zone.\n"
#~ "\n"
#~ "This datetime can be seen as a ephemeral snapshot\n"
#~ "of a datetime at a given timezone. For such purposes,\n"
#~ "it also includes both UTC and Standard offsets, as\n"
#~ "well as the zone abbreviation field used exclusively\n"
#~ "for formatting purposes.\n"
#~ msgstr ""
#~ "タイムゾーン付のdatetime実装です。\n"
#~ "\n"
#~ "このdatetimeは特定のタイムゾーンの日時の束の間の\n"
#~ "スナップショットとして見做されます。そのような目\n"
#~ "的のために、UTCと書式化目的のためだけに使われる\n"
#~ "ゾーンの略称としての標準のオフセットの両方を含み\n"
#~ "ます。\n"

#~ msgid "A time implementation.\n"
#~ msgstr "時刻実装です。\n"

#~ msgid "A date implementation.\n"
#~ msgstr "日付実装です。\n"
