msgid ""
msgstr ""
"Project-Id-Version: l 10n_elixir\n"
"POT-Creation-Date: \n"
"PO-Revision-Date: 2017-03-15 15:25+0900\n"
"Last-Translator: 小田 照敬 <EMAIL@ADDRESS>\n"
"Language-Team: Japanese\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Poedit 1.8.12\n"

#. TRANSLATORS: def Keyword.pop(keywords, key, default \\ nil)
#: lib/keyword.ex:809
msgid ""
"Returns and removes all values associated with `key` in the keyword list.\n"
"\n"
"All duplicated keys are removed. See `pop_first/3` for\n"
"removing only the first entry.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.pop([a: 1], :a)\n"
"    {1, []}\n"
"    iex> Keyword.pop([a: 1], :b)\n"
"    {nil, [a: 1]}\n"
"    iex> Keyword.pop([a: 1], :b, 3)\n"
"    {3, [a: 1]}\n"
"    iex> Keyword.pop([a: 1, a: 2], :a)\n"
"    {1, []}\n"
"\n"
msgstr ""
"キーワードリストの`key`に関連付けられたすべての値を返して、エントリを削除しま"
"す。\n"
"\n"
"すべての重複キーは削除されます。最初のエントリだけを削除するには、\n"
"`pop_first/3`を参照してください。\n"
"\n"
"## 例\n"
"\n"
"    iex> Keyword.pop([a: 1], :a)\n"
"    {1, []}\n"
"    iex> Keyword.pop([a: 1], :b)\n"
"    {nil, [a: 1]}\n"
"    iex> Keyword.pop([a: 1], :b, 3)\n"
"    {3, [a: 1]}\n"
"    iex> Keyword.pop([a: 1, a: 2], :a)\n"
"    {1, []}\n"
"\n"

#. TRANSLATORS: def Keyword.pop_first(keywords, key, default \\ nil)
#: lib/keyword.ex:870
msgid ""
"Returns and removes the first value associated with `key` in the keyword "
"list.\n"
"\n"
"Duplicated keys are not removed.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.pop_first([a: 1], :a)\n"
"    {1, []}\n"
"    iex> Keyword.pop_first([a: 1], :b)\n"
"    {nil, [a: 1]}\n"
"    iex> Keyword.pop_first([a: 1], :b, 3)\n"
"    {3, [a: 1]}\n"
"    iex> Keyword.pop_first([a: 1, a: 2], :a)\n"
"    {1, [a: 2]}\n"
"\n"
msgstr ""
"キーワードリストの`key`に関連付けられた最初の値を返し、そのエントリを削除しま"
"す。\n"
"\n"
"重複したキーは削除されません。\n"
"\n"
"## 例\n"
"\n"
"    iex> Keyword.pop_first([a: 1], :a)\n"
"    {1, []}\n"
"    iex> Keyword.pop_first([a: 1], :b)\n"
"    {nil, [a: 1]}\n"
"    iex> Keyword.pop_first([a: 1], :b, 3)\n"
"    {3, [a: 1]}\n"
"    iex> Keyword.pop_first([a: 1, a: 2], :a)\n"
"    {1, [a: 2]}\n"
"\n"

#. TRANSLATORS: def Keyword.merge(keywords1, keywords2, fun)
#: lib/keyword.ex:593
msgid ""
"Merges two keyword lists into one.\n"
"\n"
"All keys, including duplicated keys, given in `keywords2` will be added\n"
"to `keywords1`. The given function will be invoked to solve conflicts.\n"
"\n"
"If `keywords2` has duplicate keys, the given function will be invoked\n"
"for each matching pair in `keywords1`.\n"
"\n"
"There are no guarantees about the order of keys in the returned keyword.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.merge([a: 1, b: 2], [a: 3, d: 4], fn _k, v1, v2 ->\n"
"    ...>   v1 + v2\n"
"    ...> end)\n"
"    [b: 2, a: 4, d: 4]\n"
"\n"
"    iex> Keyword.merge([a: 1, b: 2], [a: 3, d: 4, a: 5], fn :a, v1, v2 ->\n"
"    ...>  v1 + v2\n"
"    ...> end)\n"
"    [b: 2, a: 4, d: 4, a: 5]\n"
"\n"
"    iex> Keyword.merge([a: 1, b: 2, a: 3], [a: 3, d: 4, a: 5], fn :a, v1, v2 "
"->\n"
"    ...>  v1 + v2\n"
"    ...> end)\n"
"    [b: 2, a: 4, d: 4, a: 8]\n"
"\n"
"    iex> Keyword.merge([a: 1, b: 2], [:a, :b], fn :a, v1, v2 ->\n"
"    ...>  v1 + v2\n"
"    ...> end)\n"
"    ** (ArgumentError) expected a keyword list as the second argument, got: "
"[:a, :b]\n"
"\n"
msgstr ""
"2つのキーワードリストを1つにマージします。\n"
"\n"
"指定した`keyword2`の重複キーを含めたすべてのキーが\n"
"`keyword1`に追加されます。指定した関数が起動され、\n"
"衝突が解決されます。\n"
"\n"
"`keyword2`に重複キーがある場合、`keyword1`のマッチした\n"
"ペアの各々に対して指定した関数が起動されます。\n"
"\n"
"返されるキーワードリストのキーの順序は保証されません。\n"
"\n"
"## 例\n"
"\n"
"    iex> Keyword.merge([a: 1, b: 2], [a: 3, d: 4], fn _k, v1, v2 ->\n"
"    ...>   v1 + v2\n"
"    ...> end)\n"
"    [b: 2, a: 4, d: 4]\n"
"\n"
"    iex> Keyword.merge([a: 1, b: 2], [a: 3, d: 4, a: 5], fn :a, v1, v2 ->\n"
"    ...>  v1 + v2\n"
"    ...> end)\n"
"    [b: 2, a: 4, d: 4, a: 5]\n"
"\n"
"    iex> Keyword.merge([a: 1, b: 2, a: 3], [a: 3, d: 4, a: 5], fn :a, v1, v2 "
"->\n"
"    ...>  v1 + v2\n"
"    ...> end)\n"
"    [b: 2, a: 4, d: 4, a: 8]\n"
"\n"

#. TRANSLATORS: def Keyword.get_and_update(keywords, key, fun)
#: lib/keyword.ex:190
msgid ""
"Gets the value from `key` and updates it, all in one pass.\n"
"\n"
"This `fun` argument receives the value of `key` (or `nil` if `key`\n"
"is not present) and must return a two-element tuple: the \"get\" value\n"
"(the retrieved value, which can be operated on before being returned)\n"
"and the new value to be stored under `key`. The `fun` may also\n"
"return `:pop`, implying the current value shall be removed from the\n"
"keyword list and returned.\n"
"\n"
"The returned value is a tuple with the \"get\" value returned by\n"
"`fun` and a new keyword list with the updated value under `key`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.get_and_update([a: 1], :a, fn current_value ->\n"
"    ...>   {current_value, \"new value!\"}\n"
"    ...> end)\n"
"    {1, [a: \"new value!\"]}\n"
"\n"
"    iex> Keyword.get_and_update([a: 1], :b, fn current_value ->\n"
"    ...>   {current_value, \"new value!\"}\n"
"    ...> end)\n"
"    {nil, [b: \"new value!\", a: 1]}\n"
"\n"
"    iex> Keyword.get_and_update([a: 1], :a, fn _ -> :pop end)\n"
"    {1, []}\n"
"\n"
"    iex> Keyword.get_and_update([a: 1], :b, fn _ -> :pop end)\n"
"    {nil, [a: 1]}\n"
"\n"
msgstr ""
"`key`の値を取得して更新する動作を1回で行います。\n"
"\n"
"`fun`引数は、`key`の値（`key`が存在しない場合は`nil`）を引数にとり、\n"
"「取得」値（取り出した値で返す前に操作できます）と、`key`の下に\n"
"格納される新しい値からなる2要素タプルを返さなければなりません。\n"
"`fun`は`:pop`を返すこともできます。これは、現在の値をキーワードリストから\n"
"削除して、その値を返すことを意味します。\n"
"\n"
"返り値は、`fun`が返す「取得」値と`key`の値が更新された新しい\n"
"キーワードリストからなるタプルです。\n"
"\n"
"## 例\n"
"\n"
"    iex> Keyword.get_and_update([a: 1], :a, fn current_value ->\n"
"    ...>   {current_value, \"new value!\"}\n"
"    ...> end)\n"
"    {1, [a: \"new value!\"]}\n"
"\n"
"    iex> Keyword.get_and_update([a: 1], :b, fn current_value ->\n"
"    ...>   {current_value, \"new value!\"}\n"
"    ...> end)\n"
"    {nil, [b: \"new value!\", a: 1]}\n"
"\n"
"    iex> Keyword.get_and_update([a: 1], :a, fn _ -> :pop end)\n"
"    {1, []}\n"
"\n"
"    iex> Keyword.get_and_update([a: 1], :b, fn _ -> :pop end)\n"
"    {nil, [a: 1]}\n"
"\n"

#. TRANSLATORS: Elixir.Keyword Summary
#: lib/keyword.ex:2
msgid ""
"A set of functions for working with keywords.\n"
"\n"
"A keyword is a list of two-element tuples where the first\n"
"element of the tuple is an atom and the second element\n"
"can be any value.\n"
"\n"
"A keyword may have duplicated keys so it is not strictly\n"
"a key-value store. However most of the functions in this module\n"
"behave exactly as a dictionary so they work similarly to\n"
"the functions you would find in the `Map` module.\n"
"\n"
"For example, `Keyword.get/3` will get the first entry matching\n"
"the given key, regardless if duplicated entries exist.\n"
"Similarly, `Keyword.put/3` and `Keyword.delete/3` ensure all\n"
"duplicated entries for a given key are removed when invoked.\n"
"\n"
"A handful of functions exist to handle duplicated keys, in\n"
"particular, `Enum.into/2` allows creating new keywords without\n"
"removing duplicated keys, `get_values/2` returns all values for\n"
"a given key and `delete_first/2` deletes just one of the existing\n"
"entries.\n"
"\n"
"The functions in Keyword do not guarantee any property when\n"
"it comes to ordering. However, since a keyword list is simply a\n"
"list, all the operations defined in `Enum` and `List` can be\n"
"applied too, especially when ordering is required.\n"
msgstr ""
"キーワードを処理する一連の関数です。\n"
"\n"
"キーワードは2要素タプルのリストです。タプルの第1要素はアトムで、\n"
"第2要素には任意の値をとることができます。\n"
"\n"
"キーワードは重複したキーを持つことができます。そのため、厳密には\n"
"キー・バリューストアではありません。しかし、このモジュールの\n"
"ほとんどの関数は辞書として正確に動作するため、`Map`モジュールに\n"
"ある関数と同じように機能します。\n"
"\n"
"たとえば、`Keyword.get/3`は、重複したエントリが存在するか否かに\n"
"かかわらず、指定したキーにマッチする最初のエントリを取得します。\n"
"同様に、`Keyword.put/3`と`Keyword.delete/3`を実行すると、\n"
"指定したキーの重複したエントリがすべて削除されます。\n"
"\n"
"重複キーを扱う関数も小数ながら存在します。特に、`Enum.into/2`は、\n"
"重複キーを削除することなく新しいキーワードを作成することができ、\n"
"`get_values/2`は指定したキーのすべての値を返し、`delete_first/2`は\n"
"存在するエントリを1つだけ削除します。\n"
"\n"
"キーワードモジュールの関数はプロパティの順序は保証しません。\n"
"しかし、キーワドリストは単なるリストですので、特に順序付けが\n"
"必要な場合は、`Enum`モジュールと`List`モジュールで定義されて\n"
"いるすべての操作を適用できます。\n"
"\n"

#. TRANSLATORS: def Keyword.delete(keywords, key, value)
#: lib/keyword.ex:405
msgid ""
"Deletes the entries in the keyword list for a `key` with `value`.\n"
"\n"
"If no `key` with `value` exists, returns the keyword list unchanged.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.delete([a: 1, b: 2], :a, 1)\n"
"    [b: 2]\n"
"    iex> Keyword.delete([a: 1, b: 2, a: 3], :a, 3)\n"
"    [a: 1, b: 2]\n"
"    iex> Keyword.delete([a: 1], :a, 5)\n"
"    [a: 1]\n"
"    iex> Keyword.delete([a: 1], :b, 5)\n"
"    [a: 1]\n"
"\n"
msgstr ""
"キーワードリストの`key`の値が`value`のエントリをすべて削除します。\n"
"\n"
"`key`の値が`value`のエントリが存在しない場合、変更せずに\n"
"キーワードリストを返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Keyword.delete([a: 1, b: 2], :a, 1)\n"
"    [b: 2]\n"
"    iex> Keyword.delete([a: 1, b: 2, a: 3], :a, 3)\n"
"    [a: 1, b: 2]\n"
"    iex> Keyword.delete([a: 1], :a, 5)\n"
"    [a: 1]\n"
"    iex> Keyword.delete([a: 1], :b, 5)\n"
"    [a: 1]\n"
"\n"

#. TRANSLATORS: def Keyword.new(pairs)
#: lib/keyword.ex:77
msgid ""
"Creates a keyword from an enumerable.\n"
"\n"
"Duplicated entries are removed, the latest one prevails.\n"
"Unlike `Enum.into(enumerable, [])`, `Keyword.new(enumerable)`\n"
"guarantees the keys are unique.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.new([{:b, 1}, {:a, 2}])\n"
"    [b: 1, a: 2]\n"
"\n"
"    iex> Keyword.new([{:a, 1}, {:a, 2}, {:a, 3}])\n"
"    [a: 3]\n"
"\n"
msgstr ""
"enumerableからキーワードリストを作成します。\n"
"\n"
"重複したエントリは削除され、最後のエントリが残ります。\n"
"`Enum.into(enumerable, [])`とは異なり、`Keyword.new(enumerable)`は\n"
"キーのユニーク性を保証します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Keyword.new([{:b, 1}, {:a, 2}])\n"
"    [b: 1, a: 2]\n"
"\n"
"    iex> Keyword.new([{:a, 1}, {:a, 2}, {:a, 3}])\n"
"    [a: 3]\n"
"\n"

#. TRANSLATORS: def Keyword.put(keywords, key, value)
#: lib/keyword.ex:467
msgid ""
"Puts the given `value` under `key`.\n"
"\n"
"If a previous value is already stored, all entries are\n"
"removed and the value is overridden.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.put([a: 1], :b, 2)\n"
"    [b: 2, a: 1]\n"
"    iex> Keyword.put([a: 1, b: 2], :a, 3)\n"
"    [a: 3, b: 2]\n"
"    iex> Keyword.put([a: 1, b: 2, a: 4], :a, 3)\n"
"    [a: 3, b: 2]\n"
"\n"
msgstr ""
"指定した`value`を`key`の下に格納します。\n"
"\n"
"値が既に格納されている場合、すべてのエントリは\n"
"削除され、指定した値で上書きされます。\n"
"\n"
"## 例\n"
"\n"
"    iex> Keyword.put([a: 1], :b, 2)\n"
"    [b: 2, a: 1]\n"
"    iex> Keyword.put([a: 1, b: 2], :a, 3)\n"
"    [a: 3, b: 2]\n"
"    iex> Keyword.put([a: 1, b: 2, a: 4], :a, 3)\n"
"    [a: 3, b: 2]\n"
"\n"

#. TRANSLATORS: def Keyword.to_list(keyword)
#: lib/keyword.ex:895
msgid ""
"Returns the keyword list itself.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.to_list([a: 1])\n"
"    [a: 1]\n"
"\n"
msgstr ""
"キーワードリスト自身を返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Keyword.to_list([a: 1])\n"
"    [a: 1]\n"
"\n"

#. TRANSLATORS: def Keyword.put_new_lazy(keywords, key, fun)
#: lib/keyword.ex:488
msgid ""
"Evaluates `fun` and puts the result under `key`\n"
"in keyword list unless `key` is already present.\n"
"\n"
"This is useful if the value is very expensive to calculate or\n"
"generally difficult to setup and teardown again.\n"
"\n"
"## Examples\n"
"\n"
"    iex> keyword = [a: 1]\n"
"    iex> fun = fn ->\n"
"    ...>   # some expensive operation here\n"
"    ...>   3\n"
"    ...> end\n"
"    iex> Keyword.put_new_lazy(keyword, :a, fun)\n"
"    [a: 1]\n"
"    iex> Keyword.put_new_lazy(keyword, :b, fun)\n"
"    [b: 3, a: 1]\n"
"\n"
msgstr ""
"キーワードリストに`key`が存在しない場合に限り、\n"
"`fun`を評価し、結果を`key`の下に格納します。\n"
"\n"
"これは、デフォルト値の計算コストが非常に高い場合や\n"
"再度設定や解体を行うことが一般に難しい場合に役に立ちます。\n"
"\n"
"## 例\n"
"\n"
"    iex> keyword = [a: 1]\n"
"    iex> fun = fn ->\n"
"    ...>   # 何らかの高価な操作をここで行う\n"
"    ...>   3\n"
"    ...> end\n"
"    iex> Keyword.put_new_lazy(keyword, :a, fun)\n"
"    [a: 1]\n"
"    iex> Keyword.put_new_lazy(keyword, :b, fun)\n"
"    [b: 3, a: 1]\n"
"\n"

#. TRANSLATORS: def Keyword.put_new(keywords, key, value)
#: lib/keyword.ex:517
msgid ""
"Puts the given `value` under `key` unless the entry `key`\n"
"already exists.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.put_new([a: 1], :b, 2)\n"
"    [b: 2, a: 1]\n"
"    iex> Keyword.put_new([a: 1, b: 2], :a, 3)\n"
"    [a: 1, b: 2]\n"
"\n"
msgstr ""
"`key`のエントリが存在しない場合に限り、指定した`value`を\n"
"`key`の下に格納します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Keyword.put_new([a: 1], :b, 2)\n"
"    [b: 2, a: 1]\n"
"    iex> Keyword.put_new([a: 1, b: 2], :a, 3)\n"
"    [a: 1, b: 2]\n"
"\n"

#. TRANSLATORS: def Keyword.pop_lazy(keywords, key, fun)
#: lib/keyword.ex:837
msgid ""
"Lazily returns and removes all values associated with `key` in the keyword "
"list.\n"
"\n"
"This is useful if the default value is very expensive to calculate or\n"
"generally difficult to setup and teardown again.\n"
"\n"
"All duplicated keys are removed. See `pop_first/3` for\n"
"removing only the first entry.\n"
"\n"
"## Examples\n"
"\n"
"    iex> keyword = [a: 1]\n"
"    iex> fun = fn ->\n"
"    ...>   # some expensive operation here\n"
"    ...>   13\n"
"    ...> end\n"
"    iex> Keyword.pop_lazy(keyword, :a, fun)\n"
"    {1, []}\n"
"    iex> Keyword.pop_lazy(keyword, :b, fun)\n"
"    {13, [a: 1]}\n"
"\n"
msgstr ""
"キーワードリストの`key`に関連付けられたすべての値を返して、エントリを削除しま"
"す。\n"
"する動作を遅延処理します。\n"
"\n"
"keyが存在しない場合は、funを遅延評価してその結果を返します。\n"
"\n"
"これは、デフォルト値の計算コストが非常に高い場合や\n"
"再度設定や解体を行うことが一般に難しい場合に役に立ちます。\n"
"\n"
"すべての重複キーは削除されます。最初のエントリだけを削除するには、\n"
"`pop_first/3`を参照してください。\n"
"\n"
"## 例\n"
"\n"
"    iex> keyword = [a: 1]\n"
"    iex> fun = fn ->\n"
"    ...>   # 何らかの高価な操作をここで行う\n"
"    ...>   13\n"
"    ...> end\n"
"    iex> Keyword.pop_lazy(keyword, :a, fun)\n"
"    {1, []}\n"
"    iex> Keyword.pop_lazy(keyword, :b, fun)\n"
"    {13, [a: 1]}\n"
"\n"

#. TRANSLATORS: def Keyword.merge(keywords1, keywords2)
#: lib/keyword.ex:558
msgid ""
"Merges two keyword lists into one.\n"
"\n"
"All keys, including duplicated keys, given in `keywords2` will be added\n"
"to `keywords1`, overriding any existing one.\n"
"\n"
"There are no guarantees about the order of keys in the returned keyword.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.merge([a: 1, b: 2], [a: 3, d: 4])\n"
"    [b: 2, a: 3, d: 4]\n"
"\n"
"    iex> Keyword.merge([a: 1, b: 2], [a: 3, d: 4, a: 5])\n"
"    [b: 2, a: 3, d: 4, a: 5]\n"
"\n"
"    iex> Keyword.merge([a: 1], [2, 3])\n"
"    ** (ArgumentError) expected a keyword list as the second argument, got: "
"[2, 3]\n"
"\n"
msgstr ""
"2つのキーワードリストを1つにマージします。\n"
"\n"
"指定した`keyword2`の重複キーを含むすべてのキーが\n"
"`keyword1`に追加され、既存のキーは上書きされます。\n"
"\n"
"返されるキーワードリストのキーの順序は保証されません。\n"
"\n"
"## 例\n"
"\n"
"    iex> Keyword.merge([a: 1, b: 2], [a: 3, d: 4])\n"
"    [b: 2, a: 3, d: 4]\n"
"\n"
"    iex> Keyword.merge([a: 1, b: 2], [a: 3, d: 4, a: 5])\n"
"    [b: 2, a: 3, d: 4, a: 5]\n"
"\n"

#. TRANSLATORS: def Keyword.get(keywords, key, default \\ nil)
#: lib/keyword.ex:120
msgid ""
"Gets the value for a specific `key`.\n"
"\n"
"If `key` does not exist, return the default value\n"
"(`nil` if no default value).\n"
"\n"
"If duplicated entries exist, the first one is returned.\n"
"Use `get_values/2` to retrieve all entries.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.get([], :a)\n"
"    nil\n"
"    iex> Keyword.get([a: 1], :a)\n"
"    1\n"
"    iex> Keyword.get([a: 1], :b)\n"
"    nil\n"
"    iex> Keyword.get([a: 1], :b, 3)\n"
"    3\n"
"\n"
"With duplicated keys:\n"
"\n"
"    iex> Keyword.get([a: 1, a: 2], :a, 3)\n"
"    1\n"
"    iex> Keyword.get([a: 1, a: 2], :b, 3)\n"
"    3\n"
"\n"
msgstr ""
"指定した`key`の値を取得します。\n"
"\n"
"`key`が存在しない場合、デフォルト値（デフォルト値が指定されない\n"
"場合は`nil`）を返します。\n"
"\n"
"重複したエントリが存在する場合は、最初のエントリが返ります。\n"
"すべてのエントリを取得するには`get_values/2`を使用してください。\n"
"\n"
"## 例\n"
"\n"
"    iex> Keyword.get([], :a)\n"
"    nil\n"
"    iex> Keyword.get([a: 1], :a)\n"
"    1\n"
"    iex> Keyword.get([a: 1], :b)\n"
"    nil\n"
"    iex> Keyword.get([a: 1], :b, 3)\n"
"    3\n"
"\n"
"重複キーがある場合\n"
"\n"
"    iex> Keyword.get([a: 1, a: 2], :a, 3)\n"
"    1\n"
"    iex> Keyword.get([a: 1, a: 2], :b, 3)\n"
"    3\n"
"\n"

#. TRANSLATORS: def Keyword.keys(keywords)
#: lib/keyword.ex:369
msgid ""
"Returns all keys from the keyword list.\n"
"\n"
"Duplicated keys appear duplicated in the final list of keys.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.keys([a: 1, b: 2])\n"
"    [:a, :b]\n"
"    iex> Keyword.keys([a: 1, b: 2, a: 3])\n"
"    [:a, :b, :a]\n"
"\n"
msgstr ""
"キーワードリストのすべてのキーを返します。\n"
"\n"
"重複キーは最終的なキーのリストに重複して現れます。\n"
"\n"
"## 例\n"
"\n"
"    iex> Keyword.keys([a: 1, b: 2])\n"
"    [:a, :b]\n"
"    iex> Keyword.keys([a: 1, b: 2, a: 3])\n"
"    [:a, :b, :a]\n"
"\n"

#. TRANSLATORS: def Keyword.update(keywords, key, initial, fun)
#: lib/keyword.ex:707
msgid ""
"Updates the `key` in `keywords` with the given function.\n"
"\n"
"If the `key` does not exist, inserts the given `initial` value.\n"
"\n"
"If there are duplicated keys, they are all removed and only the first one\n"
"is updated.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.update([a: 1], :a, 13, &(&1 * 2))\n"
"    [a: 2]\n"
"    iex> Keyword.update([a: 1, a: 2], :a, 13, &(&1 * 2))\n"
"    [a: 2]\n"
"    iex> Keyword.update([a: 1], :b, 11, &(&1 * 2))\n"
"    [a: 1, b: 11]\n"
"\n"
msgstr ""
"指定した関数で`keywords`の`key`を更新します。\n"
"\n"
"`key`が存在しない場合、指定した`initial`値を挿入します。\n"
"\n"
"キーが重複している場合、すべて削除され、最初の値だけ更新されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> Keyword.update([a: 1], :a, 13, &(&1 * 2))\n"
"    [a: 2]\n"
"    iex> Keyword.update([a: 1, a: 2], :a, 13, &(&1 * 2))\n"
"    [a: 2]\n"
"    iex> Keyword.update([a: 1], :b, 11, &(&1 * 2))\n"
"    [a: 1, b: 11]\n"
"\n"

#. TRANSLATORS: def Keyword.new()
#: lib/keyword.ex:65
msgid ""
"Returns an empty keyword list, i.e. an empty list.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.new()\n"
"    []\n"
"\n"
msgstr ""
"空のキーワードリスト、すなわち、空のリストを返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Keyword.new()\n"
"    []\n"
"\n"

#. TRANSLATORS: def Keyword.keyword?(term)
#: lib/keyword.ex:39
msgid ""
"Returns `true` if `term` is a keyword list; otherwise returns `false`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.keyword?([])\n"
"    true\n"
"    iex> Keyword.keyword?([a: 1])\n"
"    true\n"
"    iex> Keyword.keyword?([{Foo, 1}])\n"
"    true\n"
"    iex> Keyword.keyword?([{}])\n"
"    false\n"
"    iex> Keyword.keyword?([:key])\n"
"    false\n"
"    iex> Keyword.keyword?(%{})\n"
"    false\n"
"\n"
msgstr ""
"`term`がキーワードリストの場合は`true`を、そうでない場合は`false`を返しま"
"す。\n"
"\n"
"## 例\n"
"\n"
"    iex> Keyword.keyword?([])\n"
"    true\n"
"    iex> Keyword.keyword?([a: 1])\n"
"    true\n"
"    iex> Keyword.keyword?([{Foo, 1}])\n"
"    true\n"
"    iex> Keyword.keyword?([{}])\n"
"    false\n"
"    iex> Keyword.keyword?([:key])\n"
"    false\n"
"    iex> Keyword.keyword?(%{})\n"
"    false\n"
"\n"

#. TRANSLATORS: def Keyword.equal?(left, right)
#: lib/keyword.ex:537
msgid ""
"Checks if two keywords are equal.\n"
"\n"
"Two keywords are considered to be equal if they contain\n"
"the same keys and those keys contain the same values.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.equal?([a: 1, b: 2], [b: 2, a: 1])\n"
"    true\n"
"    iex> Keyword.equal?([a: 1, b: 2], [b: 1, a: 2])\n"
"    false\n"
"    iex> Keyword.equal?([a: 1, b: 2, a: 3], [b: 2, a: 3, a: 1])\n"
"    true\n"
"\n"
msgstr ""
"二つのキーワードリストが等しいかチェックします。\n"
"\n"
"二つのキーワードリストが、同じキーを持ち、かつ、それらのキーが同じ値を\n"
"持つ場合、等しいとみなします。\n"
"\n"
"## 例\n"
"\n"
"    iex> Keyword.equal?([a: 1, b: 2], [b: 2, a: 1])\n"
"    true\n"
"    iex> Keyword.equal?([a: 1, b: 2], [b: 1, a: 2])\n"
"    false\n"
"    iex> Keyword.equal?([a: 1, b: 2, a: 3], [b: 2, a: 3, a: 1])\n"
"    true\n"
"\n"

#. TRANSLATORS: def Keyword.fetch!(keywords, key)
#: lib/keyword.ex:326
msgid ""
"Fetches the value for specific `key`.\n"
"\n"
"If `key` does not exist, a `KeyError` is raised.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.fetch!([a: 1], :a)\n"
"    1\n"
"    iex> Keyword.fetch!([a: 1], :b)\n"
"    ** (KeyError) key :b not found in: [a: 1]\n"
"\n"
msgstr ""
"指定した`key`の値を取り出します。\n"
"\n"
"`key`が存在しない場合は`KeyError`が発生します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Keyword.fetch!([a: 1], :a)\n"
"    1\n"
"    iex> Keyword.fetch!([a: 1], :b)\n"
"    ** (KeyError) key :b not found in: [a: 1]\n"
"\n"

#. TRANSLATORS: def Keyword.update!(keywords, key, fun)
#: lib/keyword.ex:671
msgid ""
"Updates the `key` with the given function.\n"
"\n"
"If the `key` does not exist, raises `KeyError`.\n"
"\n"
"If there are duplicated keys, they are all removed and only the first one\n"
"is updated.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.update!([a: 1], :a, &(&1 * 2))\n"
"    [a: 2]\n"
"    iex> Keyword.update!([a: 1, a: 2], :a, &(&1 * 2))\n"
"    [a: 2]\n"
"\n"
"    iex> Keyword.update!([a: 1], :b, &(&1 * 2))\n"
"    ** (KeyError) key :b not found in: [a: 1]\n"
"\n"
msgstr ""
"指定した関数で`key`を更新します。\n"
"\n"
"`key`が存在しない場合は`KeyError`が発生します。\n"
"\n"
"キーが重複している場合は、すべて削除され、最初の値だけが更新されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> Keyword.update!([a: 1], :a, &(&1 * 2))\n"
"    [a: 2]\n"
"    iex> Keyword.update!([a: 1, a: 2], :a, &(&1 * 2))\n"
"    [a: 2]\n"
"\n"
"    iex> Keyword.update!([a: 1], :b, &(&1 * 2))\n"
"    ** (KeyError) key :b not found in: [a: 1]\n"
"\n"

#. TRANSLATORS: def Keyword.delete(keywords, key)
#: lib/keyword.ex:427
msgid ""
"Deletes the entries in the keyword list for a specific `key`.\n"
"\n"
"If the `key` does not exist, returns the keyword list unchanged.\n"
"Use `delete_first/2` to delete just the first entry in case of\n"
"duplicated keys.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.delete([a: 1, b: 2], :a)\n"
"    [b: 2]\n"
"    iex> Keyword.delete([a: 1, b: 2, a: 3], :a)\n"
"    [b: 2]\n"
"    iex> Keyword.delete([b: 2], :a)\n"
"    [b: 2]\n"
"\n"
msgstr ""
"キーワードリストの指定した`key`のエントリをすべて削除します。\n"
"\n"
"`key`が存在しない場合は、変更せずにキーワードリストを返します。\n"
"重複キーが存在する場合に、最初のエントリだけを削除するには、\n"
"`delete_first/2`を使ってください。\n"
"\n"
"## 例\n"
"\n"
"    iex> Keyword.delete([a: 1, b: 2], :a)\n"
"    [b: 2]\n"
"    iex> Keyword.delete([a: 1, b: 2, a: 3], :a)\n"
"    [b: 2]\n"
"    iex> Keyword.delete([b: 2], :a)\n"
"    [b: 2]\n"
"\n"

#. TRANSLATORS: def Keyword.take(keywords, keys)
#: lib/keyword.ex:772
msgid ""
"Takes all entries corresponding to the given keys and returns them in a new\n"
"keyword list.\n"
"\n"
"Duplicated keys are preserved in the new keyword list.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.take([a: 1, b: 2, c: 3], [:a, :c, :e])\n"
"    [a: 1, c: 3]\n"
"    iex> Keyword.take([a: 1, b: 2, c: 3, a: 5], [:a, :c, :e])\n"
"    [a: 1, c: 3, a: 5]\n"
"\n"
msgstr ""
"指定したキーに一致するすべてのエントリを取出し、新しい\n"
"キーワードリストにして返します。\n"
"\n"
"重複キーは新しいキーワードリストに保存されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> Keyword.take([a: 1, b: 2, c: 3], [:a, :c, :e])\n"
"    [a: 1, c: 3]\n"
"    iex> Keyword.take([a: 1, b: 2, c: 3, a: 5], [:a, :c, :e])\n"
"    [a: 1, c: 3, a: 5]\n"
"\n"

#. TRANSLATORS: def Keyword.has_key?(keywords, key)
#: lib/keyword.ex:655
msgid ""
"Returns whether a given `key` exists in the given `keywords`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.has_key?([a: 1], :a)\n"
"    true\n"
"    iex> Keyword.has_key?([a: 1], :b)\n"
"    false\n"
"\n"
msgstr ""
"指定した`keywords`に指定した`key`があるか否かを返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Keyword.has_key?([a: 1], :a)\n"
"    true\n"
"    iex> Keyword.has_key?([a: 1], :b)\n"
"    false\n"
"\n"

#. TRANSLATORS: def Keyword.split(keywords, keys)
#: lib/keyword.ex:740
msgid ""
"Takes all entries corresponding to the given keys and extracts them into a\n"
"separate keyword list.\n"
"\n"
"Returns a tuple with the new list and the old list with removed keys.\n"
"\n"
"Keys for which there are no entries in the keyword list are ignored.\n"
"\n"
"Entries with duplicated keys end up in the same keyword list.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.split([a: 1, b: 2, c: 3], [:a, :c, :e])\n"
"    {[a: 1, c: 3], [b: 2]}\n"
"    iex> Keyword.split([a: 1, b: 2, c: 3, a: 4], [:a, :c, :e])\n"
"    {[a: 1, c: 3, a: 4], [b: 2]}\n"
"\n"
msgstr ""
"指定したキーに一致するすべてのエントリを別のキーワードリストに取出します。\n"
"\n"
"新しいリストと指定したキーを削除した古いリストからなるタプルを返します。\n"
"\n"
"キーワードリストにエントリがないキーは無視されます。\n"
"\n"
"重複キーのエントリは同じキーワードリストに入ります。\n"
"\n"
"## 例\n"
"\n"
"    iex> Keyword.split([a: 1, b: 2, c: 3], [:a, :c, :e])\n"
"    {[a: 1, c: 3], [b: 2]}\n"
"    iex> Keyword.split([a: 1, b: 2, c: 3, a: 4], [:a, :c, :e])\n"
"    {[a: 1, c: 3, a: 4], [b: 2]}\n"
"\n"

#. TRANSLATORS: def Keyword.get_and_update!(keywords, key, fun)
#: lib/keyword.ex:252
msgid ""
"Gets the value from `key` and updates it. Raises if there is no `key`.\n"
"\n"
"This `fun` argument receives the value of `key` and must return a\n"
"two-element tuple: the \"get\" value (the retrieved value, which can be\n"
"operated on before being returned) and the new value to be stored under\n"
"`key`.\n"
"\n"
"The returned value is a tuple with the \"get\" value returned by `fun` and a "
"new\n"
"keyword list with the updated value under `key`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.get_and_update!([a: 1], :a, fn current_value ->\n"
"    ...>   {current_value, \"new value!\"}\n"
"    ...> end)\n"
"    {1, [a: \"new value!\"]}\n"
"\n"
"    iex> Keyword.get_and_update!([a: 1], :b, fn current_value ->\n"
"    ...>   {current_value, \"new value!\"}\n"
"    ...> end)\n"
"    ** (KeyError) key :b not found in: [a: 1]\n"
"\n"
"    iex> Keyword.get_and_update!([a: 1], :a, fn _ ->\n"
"    ...>   :pop\n"
"    ...> end)\n"
"    {1, []}\n"
"\n"
msgstr ""
"`key`の値を取得して更新します。`key`が存在しない場合は例外を発生させます。\n"
"\n"
"`fun`引数は、`key`の値（`key`が存在しない場合は`nil`）を引数にとり、\n"
"「取得」値（取り出した値で返す前に操作できます）と、`key`の下に\n"
"格納される新しい値からなる2要素タプルを返さなければなりません。\n"
"\n"
"返り値は、`fun`が返す「取得」値と`key`の値が更新された新しい\n"
"キーワードリストからなるタプルです。\n"
"\n"
"## 例\n"
"\n"
"    iex> Keyword.get_and_update!([a: 1], :a, fn current_value ->\n"
"    ...>   {current_value, \"new value!\"}\n"
"    ...> end)\n"
"    {1, [a: \"new value!\"]}\n"
"\n"
"    iex> Keyword.get_and_update!([a: 1], :b, fn current_value ->\n"
"    ...>   {current_value, \"new value!\"}\n"
"    ...> end)\n"
"    ** (KeyError) key :b not found in: [a: 1]\n"
"\n"
"    iex> Keyword.get_and_update!([a: 1], :a, fn _ ->\n"
"    ...>   :pop\n"
"    ...> end)\n"
"    {1, []}\n"
"\n"

#. TRANSLATORS: def Keyword.fetch(keywords, key)
#: lib/keyword.ex:305
msgid ""
"Fetches the value for a specific `key` and returns it in a tuple.\n"
"\n"
"If the `key` does not exist, returns `:error`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.fetch([a: 1], :a)\n"
"    {:ok, 1}\n"
"    iex> Keyword.fetch([a: 1], :b)\n"
"    :error\n"
"\n"
msgstr ""
"指定した`key`の値を取り出し、タプルに入れて返します。\n"
"\n"
"`key`が存在しない場合は`:error`を返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Keyword.fetch([a: 1], :a)\n"
"    {:ok, 1}\n"
"    iex> Keyword.fetch([a: 1], :b)\n"
"    :error\n"
"\n"

#. TRANSLATORS: def Keyword.drop(keywords, keys)
#: lib/keyword.ex:791
msgid ""
"Drops the given keys from the keyword list.\n"
"\n"
"Duplicated keys are preserved in the new keyword list.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.drop([a: 1, b: 2, c: 3], [:b, :d])\n"
"    [a: 1, c: 3]\n"
"    iex> Keyword.drop([a: 1, b: 2, b: 3, c: 3, a: 5], [:b, :d])\n"
"    [a: 1, c: 3, a: 5]\n"
"\n"
msgstr ""
"キーワードリストから指定した複数のキーのエントリを削除します。\n"
"\n"
"重複キーは新しいキーワードリストでも保存されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> Keyword.drop([a: 1, b: 2, c: 3], [:b, :d])\n"
"    [a: 1, c: 3]\n"
"    iex> Keyword.drop([a: 1, b: 2, b: 3, c: 3, a: 5], [:b, :d])\n"
"    [a: 1, c: 3, a: 5]\n"
"\n"

#. TRANSLATORS: def Keyword.get_values(keywords, key)
#: lib/keyword.ex:347
msgid ""
"Gets all values for a specific `key`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.get_values([], :a)\n"
"    []\n"
"    iex> Keyword.get_values([a: 1], :a)\n"
"    [1]\n"
"    iex> Keyword.get_values([a: 1, a: 2], :a)\n"
"    [1, 2]\n"
"\n"
msgstr ""
"指定した`key`のすべての値を取得します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Keyword.get_values([], :a)\n"
"    []\n"
"    iex> Keyword.get_values([a: 1], :a)\n"
"    [1]\n"
"    iex> Keyword.get_values([a: 1, a: 2], :a)\n"
"    [1, 2]\n"
"\n"

#. TRANSLATORS: def Keyword.get_lazy(keywords, key, fun)
#: lib/keyword.ex:157
msgid ""
"Gets the value for a specific `key`.\n"
"\n"
"If `key` does not exist, lazily evaluates `fun` and returns its result.\n"
"\n"
"This is useful if the default value is very expensive to calculate or\n"
"generally difficult to setup and teardown again.\n"
"\n"
"If duplicated entries exist, the first one is returned.\n"
"Use `get_values/2` to retrieve all entries.\n"
"\n"
"## Examples\n"
"\n"
"    iex> keyword = [a: 1]\n"
"    iex> fun = fn ->\n"
"    ...>   # some expensive operation here\n"
"    ...>   13\n"
"    ...> end\n"
"    iex> Keyword.get_lazy(keyword, :a, fun)\n"
"    1\n"
"    iex> Keyword.get_lazy(keyword, :b, fun)\n"
"    13\n"
"\n"
msgstr ""
"指定した`key`の値を取得します。\n"
"\n"
"`key`が存在しない場合は、`fun`を遅延評価してその結果を返します。\n"
"\n"
"これは、デフォルト値の計算コストが非常に高い場合や\n"
"再度設定や解体を行うことが一般に難しい場合に役に立ちます。\n"
"\n"
"重複したエントリが存在する場合は最初のエントリが返ります。\n"
"すべてのエントリを取得するには`get_values/2`を使用してください。\n"
"\n"
"## 例\n"
"\n"
"    iex> keyword = [a: 1]\n"
"    iex> fun = fn ->\n"
"    ...>   # 何らかの高価な操作をここで行う\n"
"    ...>   13\n"
"    ...> end\n"
"    iex> Keyword.get_lazy(keyword, :a, fun)\n"
"    1\n"
"    iex> Keyword.get_lazy(keyword, :b, fun)\n"
"    13\n"
"\n"

#. TRANSLATORS: def Keyword.new(pairs, transform)
#: lib/keyword.ex:98
msgid ""
"Creates a keyword from an enumerable via the transformation function.\n"
"\n"
"Duplicated entries are removed, the latest one prevails.\n"
"Unlike `Enum.into(enumerable, [], fun)`,\n"
"`Keyword.new(enumerable, fun)` guarantees the keys are unique.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.new([:a, :b], fn(x) -> {x, x} end)\n"
"    [a: :a, b: :b]\n"
"\n"
msgstr ""
"変換関数を使ってenumerableからキーワードリストを作成します。\n"
"\n"
"重複したエントリは削除され、最後のエントリが残ります。\n"
"`Enum.into(enumerable, [], fun)`と異なり、`Keyword.new(enumerable, fun)`は\n"
"キーのユニーク性を保証します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Keyword.new([:a, :b], fn (x) -> {x, x} end)\n"
"    [a: :a, b: :b]\n"
"\n"

#. TRANSLATORS: def Keyword.values(keywords)
#: lib/keyword.ex:387
msgid ""
"Returns all values from the keyword list.\n"
"\n"
"Values from duplicated keys will be kept in the final list of values.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.values([a: 1, b: 2])\n"
"    [1, 2]\n"
"    iex> Keyword.values([a: 1, b: 2, a: 3])\n"
"    [1, 2, 3]\n"
"\n"
msgstr ""
"キーワードリストのすべての値を返します。\n"
"\n"
"重複キーの値は、最終的な値のリストに重複して現れます。\n"
"\n"
"## 例\n"
"\n"
"    iex> Keyword.values([a: 1, b: 2])\n"
"    [1, 2]\n"
"    iex> Keyword.values([a: 1, b: 2, a: 3])\n"
"    [1, 2, 3]\n"
"\n"

#. TRANSLATORS: def Keyword.delete_first(keywords, key)
#: lib/keyword.ex:449
msgid ""
"Deletes the first entry in the keyword list for a specific `key`.\n"
"\n"
"If the `key` does not exist, returns the keyword list unchanged.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Keyword.delete_first([a: 1, b: 2, a: 3], :a)\n"
"    [b: 2, a: 3]\n"
"    iex> Keyword.delete_first([b: 2], :a)\n"
"    [b: 2]\n"
"\n"
msgstr ""
"キーワードリストの指定した`key`の最初のエントリを削除します。\n"
"\n"
"`key`が存在しない場合は、変更せずにキーワードリストを返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Keyword.delete_first([a: 1, b: 2, a: 3], :a)\n"
"    [b: 2, a: 3]\n"
"    iex> Keyword.delete_first([b: 2], :a)\n"
"    [b: 2]\n"
"\n"

#~ msgid "Returns an empty keyword list, i.e. an empty list.\n"
#~ msgstr "空のキーワードリスト、すなわち空のリストを返します。\n"

#~ msgid ""
#~ "Returns `true` if `term` is a keyword list; otherwise returns `false`.\n"
#~ msgstr ""
#~ "`term`がキーワードリストなら`true`を返します。\n"
#~ "さもなくば`false`を返します。\n"

#~ msgid ""
#~ "Merges two keyword lists into one.\n"
#~ "\n"
#~ "If they have duplicated keys, the one given in the second argument wins.\n"
#~ "\n"
#~ "## Examples\n"
#~ "\n"
#~ "    iex> Keyword.merge([a: 1, b: 2], [a: 3, d: 4])\n"
#~ "    [a: 3, d: 4, b: 2]\n"
#~ "\n"
#~ msgstr ""
#~ "二つのキーワードリストを一つにマージします。\n"
#~ "\n"
#~ "もし重複したキーがあれば、二つめの引数が勝ちます。\n"
#~ "\n"
#~ "## 例\n"
#~ "\n"
#~ "    iex> Keyword.merge([a: 1, b: 2], [a: 3, d: 4])\n"
#~ "    [a: 3, d: 4, b: 2]\n"
#~ "\n"

#~ msgid ""
#~ "Merges two keyword lists into one.\n"
#~ "\n"
#~ "If they have duplicated keys, the given function is invoked to solve "
#~ "conflicts.\n"
#~ "\n"
#~ "## Examples\n"
#~ "\n"
#~ "    iex> Keyword.merge([a: 1, b: 2], [a: 3, d: 4], fn (_k, v1, v2) ->\n"
#~ "    ...>  v1 + v2\n"
#~ "    ...> end)\n"
#~ "    [a: 4, b: 2, d: 4]\n"
#~ "\n"
#~ msgstr ""
#~ "二つのキーワードリストを一つにマージます。\n"
#~ "\n"
#~ "もし重複したキーがあれば、衝突を解決するため、与えられた関数が\n"
#~ "起動されます。\n"
#~ "\n"
#~ "## 例\n"
#~ "\n"
#~ "    iex> Keyword.merge([a: 1, b: 2], [a: 3, d: 4], fn (_k, v1, v2) ->\n"
#~ "    ...>  v1 + v2\n"
#~ "    ...> end)\n"
#~ "    [a: 4, b: 2, d: 4]\n"
#~ "\n"

#~ msgid "Checks if the given argument is a keyword list or not.\n"
#~ msgstr ""
#~ "与えられた引数がキーワードリストか否かを、\n"
#~ "チェックします。\n"
