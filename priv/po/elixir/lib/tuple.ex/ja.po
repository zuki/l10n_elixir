msgid ""
msgstr ""
"Project-Id-Version: l 10n_elixir\n"
"POT-Creation-Date: \n"
"PO-Revision-Date: 2017-01-29 17:18+0900\n"
"Last-Translator: 小田 照敬 <EMAIL@ADDRESS>\n"
"Language-Team: Japanese\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Poedit 1.8.11\n"

#. TRANSLATORS: def Tuple.delete_at(tuple, index)
#: lib/tuple.ex:111
msgid ""
"Removes an element from a tuple.\n"
"\n"
"Deletes the element at the given `index` from `tuple`.\n"
"Raises an `ArgumentError` if `index` is negative or greater than\n"
"or equal to the length of `tuple`. Index is zero-based.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> tuple = {:foo, :bar, :baz}\n"
"    iex> Tuple.delete_at(tuple, 0)\n"
"    {:bar, :baz}\n"
"\n"
msgstr ""
"タプルから要素を削除します。\n"
"\n"
"`tuple`から指定された`index`の要素を削除します。\n"
"`index`が負、または`tuple`の長さと同じか大きい場合は、\n"
"`ArgumentError`が発生します。インデックスは0始まりです。\n"
"\n"
"コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> tuple = {:foo, :bar, :baz}\n"
"    iex> Tuple.delete_at(tuple, 0)\n"
"    {:bar, :baz}\n"
"\n"

#. TRANSLATORS: def Tuple.to_list(tuple)
#: lib/tuple.ex:132
msgid ""
"Converts a tuple to a list.\n"
"\n"
"Returns a new list with all the tuple elements.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> tuple = {:foo, :bar, :baz}\n"
"    iex> Tuple.to_list(tuple)\n"
"    [:foo, :bar, :baz]\n"
"\n"
msgstr ""
"タプルをリストに変換します。\n"
"\n"
"タプルのすべての要素を持つ新しいリストを返します。\n"
"\n"
"コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> tuple = {:foo, :bar, :baz}\n"
"    iex> Tuple.to_list(tuple)\n"
"    [:foo, :bar, :baz]\n"
"\n"

#. TRANSLATORS: def Tuple.insert_at(tuple, index, value)
#: lib/tuple.ex:69
msgid ""
"Inserts an element into a tuple.\n"
"\n"
"Inserts `value` into `tuple` at the given `index`.\n"
"Raises an `ArgumentError` if `index` is negative or greater than the\n"
"length of `tuple`. Index is zero-based.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> tuple = {:bar, :baz}\n"
"    iex> Tuple.insert_at(tuple, 0, :foo)\n"
"    {:foo, :bar, :baz}\n"
"    iex> Tuple.insert_at(tuple, 2, :bong)\n"
"    {:bar, :baz, :bong}\n"
"\n"
msgstr ""
"タプルに要素を挿入します。\n"
"\n"
"`tuple`の指定された`index`の位置に`value`を挿入します。\n"
"`index`が負、または`tuple`の長さより大きい場合は、\n"
"`ArgumentError`が発生します。インデックスは0始まりです。\n"
"\n"
"コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> tuple = {:bar, :baz}\n"
"    iex> Tuple.insert_at(tuple, 0, :foo)\n"
"    {:foo, :bar, :baz}\n"
"    iex> Tuple.insert_at(tuple, 2, :bong)\n"
"    {:bar, :baz, :bong}\n"
"\n"

#. TRANSLATORS: def Tuple.duplicate(data, size)
#: lib/tuple.ex:50
msgid ""
"Creates a new tuple.\n"
"\n"
"Creates a tuple of `size` containing the\n"
"given `data` at every position.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Tuple.duplicate(:hello, 3)\n"
"    {:hello, :hello, :hello}\n"
"\n"
msgstr ""
"新しいタプルを作成します。\n"
"\n"
"すべての位置に指定された`data`を含んでいる`size`サイズのタプルを\n"
"作成します。\n"
"\n"
"コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> Tuple.duplicate(:hello, 3)\n"
"    {:hello, :hello, :hello}\n"
"\n"

#. TRANSLATORS: def Tuple.append(tuple, value)
#: lib/tuple.ex:92
msgid ""
"Inserts an element at the end of a tuple.\n"
"\n"
"Returns a new tuple with the element appended at the end, and contains\n"
"the elements in `tuple` followed by `value` as the last element.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"    iex> tuple = {:foo, :bar}\n"
"    iex> Tuple.append(tuple, :baz)\n"
"    {:foo, :bar, :baz}\n"
"\n"
msgstr ""
"タプルの最後に要素を挿入します。\n"
"\n"
"最後に追加された要素を持つ新たなタプルを返します。\n"
"これは、`tuple`の要素とそれに続く最後の要素として`value`を含んでいます。\n"
"\n"
"コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"    iex> tuple = {:foo, :bar}\n"
"    iex> Tuple.append(tuple, :baz)\n"
"    {:foo, :bar, :baz}\n"
"\n"

#. TRANSLATORS: Elixir.Tuple Summary
#: lib/tuple.ex:2
msgid ""
"Functions for working with tuples.\n"
"\n"
"Tuples are ordered collection of elements; tuples can contain elements of "
"any\n"
"type, and a tuple can contain elements of different types. Curly braces can "
"be\n"
"used to create tuples:\n"
"\n"
"    iex> {}\n"
"    {}\n"
"    iex> {1, :two, \"three\"}\n"
"    {1, :two, \"three\"}\n"
"\n"
"Tuples store elements contiguously in memory; this means that accessing a\n"
"tuple element by index (which can be done through the `Kernel.elem/2`\n"
"function) is a constant-time operation:\n"
"\n"
"    iex> tuple = {1, :two, \"three\"}\n"
"    iex> elem(tuple, 0)\n"
"    1\n"
"    iex> elem(tuple, 2)\n"
"    \"three\"\n"
"\n"
"Same goes for getting the tuple size (via `Kernel.tuple_size/1`):\n"
"\n"
"    iex> tuple_size({})\n"
"    0\n"
"    iex> tuple_size({1, 2, 3})\n"
"    3\n"
"\n"
"Tuples being stored contiguously in memory also means that updating a tuple\n"
"(for example replacing an element with `Kernel.put_elem/3`) will make a "
"copy\n"
"of the whole tuple.\n"
"\n"
"Tuples are not meant to be used as a \"collection\" type (which is also\n"
"suggested by the absence of an implementation of the `Enumerable` protocol "
"for\n"
"tuples): they're mostly meant to be used as a fixed-size container for\n"
"multiple elements. For example, tuples are often used to have functions "
"return\n"
"\"enriched\" values: a common pattern is for functions to return `{:ok, "
"value}`\n"
"for successful cases and `{:error, reason}` for unsuccessful cases. For\n"
"example, this is exactly what `File.read/1` does: it returns `{:ok, contents}"
"`\n"
"if reading the given file is successful, or `{:error, reason}` otherwise\n"
"(e.g., `{:error, :enoent}` if the file doesn't exist).\n"
"\n"
"This module provides functions to work with tuples; some more functions to\n"
"work with tuples can be found in `Kernel` (`Kernel.tuple_size/1`,\n"
"`Kernel.elem/2`, `Kernel.put_elem/3`, and others).\n"
msgstr ""
"タプルを扱う関数です。\n"
"\n"
"タプルは要素の順序付けられたコレクションです。タプルは任意の型の要素を含め"
"る\n"
"ことができます。また、タプルは異なる型の要素を含めることもできます。\n"
"タプルを作成するには中括弧を使います。\n"
"\n"
"    iex> {}\n"
"    {}\n"
"    iex> {1, :two, \"three\"}\n"
"    {1, :two, \"three\"}\n"
"\n"
"タプルは要素をメモリ上に連続して格納します。これは、タプルの要素を\n"
"インデックスでアクセスする（`Kernel.elem/2`により行われます）\n"
"ことは定数時間の操作であることを意味します。\n"
"\n"
"    iex> tuple = {1, :two, \"three\"}\n"
"    iex> elem(tuple, 0)\n"
"    1\n"
"    iex> elem(tuple, 2)\n"
"    \"three\"\n"
"\n"
"タプルのサイズを得る（`Kernel.tuple_size/1`による）のも同様です。\n"
"\n"
"    iex> tuple_size({})\n"
"    0\n"
"    iex> tuple_size({1, 2, 3})\n"
"    3\n"
"\n"
"タプルがメモリ上に連続して格納されるということは、タプルの更新（たとえば、\n"
"`Kernel.put_elem/3`による要素の置換）はタプル全体のコピーを作成する\n"
"ことになることも意味します。\n"
"\n"
"タプルは「コレクション」型として使用されることは意図されていません（これは\n"
"タプル用の`Enumerable`プロトコルが実装されていないことからも示唆されま"
"す）。\n"
"タプルは主に複数の要素の固定サイズのコンテナとして使用されることを意図され"
"て\n"
"います。たとえば、タプルは関数が「豊かな」値を返すのによく使用されます。\n"
"一般的なパターンは、関数が成功した場合は `{:ok, value}`を返し、成功しなかっ"
"た\n"
"場合は`{:error, reason}`を返すことです。たとえば、これはまさに`File.read/1`"
"が\n"
"行っていることです。この関数は指定されたファイルの読み込みに成功した場合は\n"
"`{:ok, contents}`を返し、そうでない場合は`{:error, reason}` を返します（たと"
"えば、\n"
"ファイルが存在しない場合は`{:error, :enoent}`）。\n"
"\n"
"このモジュールはタプルを扱う関数を提供します。タプルを扱う関数は他に\n"
"`Kernel`にも見つけることができます（`Kernel.tuple_size/1`,\n"
"`Kernel.elem/2`, `Kernel.put_elem/3`など）。\n"
"\n"

#~ msgid ""
#~ "Functions for working with tuples.\n"
#~ "\n"
#~ "See also `Kernel.elem/2`, `Kernel.is_tuple/1`,\n"
#~ "`Kernel.put_elem/3`, and `Kernel.tuple_size/1`.\n"
#~ msgstr ""
#~ "タプルで動く関数です。\n"
#~ "\n"
#~ "`Kernel.elem/2`、 `Kernel.is_tuple/1`、 `Kernel.put_elem/3`、\n"
#~ "そして `Kernel.tuple_size/1` も参照してください。\n"

#~ msgid "Functions for working with tuples.\n"
#~ msgstr "タプルで動く関数です。\n"

#~ msgid ""
#~ "Converts a tuple to a list.\n"
#~ "\n"
#~ "Inlined by the compiler.\n"
#~ msgstr ""
#~ "タプルをリストに変換します。\n"
#~ "\n"
#~ "コンパイラによりインライン化されます。\n"
