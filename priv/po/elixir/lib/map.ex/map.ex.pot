#. TRANSLATORS: def Map.get(map, key, default \\ nil)
#: lib/map.ex:342 
msgid ""
"Gets the value for a specific `key` in `map`.\n"
"\n"
"If `key` is present in `map` with value `value`, then `value` is\n"
"returned. Otherwise, `default` is returned (which is `nil` unless\n"
"specified otherwise).\n"
"\n"
"## Examples\n"
"\n"
"    iex> Map.get(%{}, :a)\n"
"    nil\n"
"    iex> Map.get(%{a: 1}, :a)\n"
"    1\n"
"    iex> Map.get(%{a: 1}, :b)\n"
"    nil\n"
"    iex> Map.get(%{a: 1}, :b, 3)\n"
"    3\n"
"\n"
msgstr ""
#. TRANSLATORS: def Map.merge(map1, map2, callback)
#: lib/map.ex:452 
msgid ""
"Merges two maps into one, resolving conflicts through the given `callback`.\n"
"\n"
"All keys in `map2` will be added to `map1`. The given function will be invoked\n"
"when there are duplicate keys; its arguments are `key` (the duplicate key),\n"
"`value1` (the value of `key` in `map1`), and `value2` (the value of `key` in\n"
"`map2`). The value returned by `callback` is used as the value under `key` in\n"
"the resulting map.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Map.merge(%{a: 1, b: 2}, %{a: 3, d: 4}, fn _k, v1, v2 ->\n"
"    ...>   v1 + v2\n"
"    ...> end)\n"
"    %{a: 4, b: 2, d: 4}\n"
"\n"
msgstr ""
#. TRANSLATORS: def Map.new()
#: lib/map.ex:140 
msgid ""
"Returns a new empty map.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Map.new\n"
"    %{}\n"
"\n"
msgstr ""
#. TRANSLATORS: def Map.new(enumerable)
#: lib/map.ex:152 
msgid ""
"Creates a map from an `enumerable`.\n"
"\n"
"Duplicated keys are removed; the latest one prevails.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Map.new([{:b, 1}, {:a, 2}])\n"
"    %{a: 2, b: 1}\n"
"    iex> Map.new([a: 1, a: 2, a: 3])\n"
"    %{a: 3}\n"
"\n"
msgstr ""
#. TRANSLATORS: def Map.drop(map, keys)
#: lib/map.ex:558 
msgid ""
"Drops the given `keys` from `map`.\n"
"\n"
"If `keys` contains keys that are not in `map`, they're simply ignored.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Map.drop(%{a: 1, b: 2, c: 3}, [:b, :d])\n"
"    %{a: 1, c: 3}\n"
"\n"
msgstr ""
#. TRANSLATORS: def Map.put_new(map, key, value)
#: lib/map.ex:259 
msgid ""
"Puts the given `value` under `key` unless the entry `key`\n"
"already exists in `map`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Map.put_new(%{a: 1}, :b, 2)\n"
"    %{b: 2, a: 1}\n"
"    iex> Map.put_new(%{a: 1, b: 2}, :a, 3)\n"
"    %{a: 1, b: 2}\n"
"\n"
msgstr ""
#. TRANSLATORS: def Map.pop_lazy(map, key, fun)
#: lib/map.ex:526 
msgid ""
"Lazily returns and removes the value associated with `key` in `map`.\n"
"\n"
"If `key` is present in `map` with value `value`, `{value, new_map}` is\n"
"returned where `new_map` is the result of removing `key` from `map`. If `key`\n"
"is not present in `map`, `{fun_result, map}` is returned, where `fun_result`\n"
"is the result of applying `fun`.\n"
"\n"
"This is useful if the default value is very expensive to calculate or\n"
"generally difficult to setup and teardown again.\n"
"\n"
"## Examples\n"
"\n"
"    iex> map = %{a: 1}\n"
"    iex> fun = fn ->\n"
"    ...>   # some expensive operation here\n"
"    ...>   13\n"
"    ...> end\n"
"    iex> Map.pop_lazy(map, :a, fun)\n"
"    {1, %{}}\n"
"    iex> Map.pop_lazy(map, :b, fun)\n"
"    {13, %{a: 1}}\n"
"\n"
msgstr ""
#. TRANSLATORS: def Map.get_and_update(map, key, fun)
#: lib/map.ex:654 
msgid ""
"Gets the value from `key` and updates it, all in one pass.\n"
"\n"
"`fun` is called with the current value under `key` in `map` (or `nil` if `key`\n"
"is not present in `map`) and must return a two-element tuple: the \"get\" value\n"
"(the retrieved value, which can be operated on before being returned) and the\n"
"new value to be stored under `key` in the resulting new map. `fun` may also\n"
"return `:pop`, which means the current value shall be removed from `map` and\n"
"returned (making this function behave like `Map.pop(map, key)`.\n"
"\n"
"The returned value is a tuple with the \"get\" value returned by\n"
"`fun` and a new map with the updated value under `key`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Map.get_and_update(%{a: 1}, :a, fn current_value ->\n"
"    ...>   {current_value, \"new value!\"}\n"
"    ...> end)\n"
"    {1, %{a: \"new value!\"}}\n"
"\n"
"    iex> Map.get_and_update(%{a: 1}, :b, fn current_value ->\n"
"    ...>   {current_value, \"new value!\"}\n"
"    ...> end)\n"
"    {nil, %{b: \"new value!\", a: 1}}\n"
"\n"
"    iex> Map.get_and_update(%{a: 1}, :a, fn _ -> :pop end)\n"
"    {1, %{}}\n"
"\n"
"    iex> Map.get_and_update(%{a: 1}, :b, fn _ -> :pop end)\n"
"    {nil, %{a: 1}}\n"
"\n"
msgstr ""
#. TRANSLATORS: Elixir.Map Summary
#: lib/map.ex:2 
msgid ""
"A set of functions for working with maps.\n"
"\n"
"Maps are the \"go to\" key-value data structure in Elixir. Maps can be created\n"
"with the `%{}` syntax, and key-value pairs can be expressed as `key => value`:\n"
"\n"
"    iex> %{}\n"
"    %{}\n"
"    iex> %{\"one\" => :two, 3 => \"four\"}\n"
"    %{3 => \"four\", \"one\" => :two}\n"
"\n"
"Key-value pairs in a map do not follow any order (that's why the printed map\n"
"in the example above has a different order than the map that was created).\n"
"\n"
"Maps do not impose any restriction on the key type: anything can be a key in a\n"
"map. As a key-value structure, maps do not allow duplicated keys; keys are\n"
"compared using the exact-equality operator (`===`). If colliding keys are defined\n"
"in a map literal, the last one prevails.\n"
"\n"
"When the key in a key-value pair is an atom, the `key: value` shorthand syntax\n"
"can be used (as in many other special forms), provided key-value pairs are put at\n"
"the end:\n"
"\n"
"    iex> %{\"hello\" => \"world\", a: 1, b: 2}\n"
"    %{:a => 1, :b => 2, \"hello\" => \"world\"}\n"
"\n"
"Keys in maps can be accessed through some of the functions in this module\n"
"(such as `Map.get/3` or `Map.fetch/2`) or through the `[]` syntax provided by\n"
"the `Access` module:\n"
"\n"
"    iex> map = %{a: 1, b: 2}\n"
"    iex> Map.fetch(map, :a)\n"
"    {:ok, 1}\n"
"    iex> map[:b]\n"
"    2\n"
"    iex> map[\"non_existing_key\"]\n"
"    nil\n"
"\n"
"The alternative access syntax `map.key` is provided alongside `[]` when the\n"
"map has a `:key` key; note that while `map[key]` will return `nil` if `map`\n"
"doesn't contain the key `key`, `map.key` will raise if `map` doesn't contain\n"
"the key `:key`.\n"
"\n"
"    iex> map = %{foo: \"bar\", baz: \"bong\"}\n"
"    iex> map.foo\n"
"    \"bar\"\n"
"    iex> map.non_existing_key\n"
"    ** (KeyError) key :non_existing_key not found in: %{baz: \"bong\", foo: \"bar\"}\n"
"\n"
"Maps can be pattern matched on; when a map is on the left-hand side of a\n"
"pattern match, it will match if the map on the right-hand side contains the\n"
"keys on the left-hand side and their values match the ones on the left-hand\n"
"side. This means that an empty map matches every map.\n"
"\n"
"    iex> %{} = %{foo: \"bar\"}\n"
"    %{foo: \"bar\"}\n"
"    iex> %{a: a} = %{:a => 1, \"b\" => 2, [:c, :e, :e] => 3}\n"
"    iex> a\n"
"    1\n"
"    iex> %{:c => 3} = %{:a => 1, 2 => :b}\n"
"    ** (MatchError) no match of right hand side value: %{2 => :b, :a => 1}\n"
"\n"
"Variables can be used as map keys both when writing map literals as well as\n"
"when matching:\n"
"\n"
"    iex> n = 1\n"
"    1\n"
"    iex> %{n => :one}\n"
"    %{1 => :one}\n"
"    iex> %{^n => :one} = %{1 => :one, 2 => :two, 3 => :three}\n"
"    %{1 => :one, 2 => :two, 3 => :three}\n"
"\n"
"Maps also support a specific update syntax to update the value stored under\n"
"*existing* atom keys:\n"
"\n"
"    iex> map = %{one: 1, two: 2}\n"
"    iex> %{map | one: \"one\"}\n"
"    %{one: \"one\", two: 2}\n"
"    iex> %{map | three: 3}\n"
"    ** (KeyError) key :three not found\n"
"\n"
"## Modules to work with maps\n"
"\n"
"This module aims to provide functions that perform operations specific to maps\n"
"(like accessing keys, updating values, and so on). For traversing maps as\n"
"collections, developers should use the `Enum` module that works across a\n"
"variety of data types.\n"
"\n"
"The `Kernel` module also provides a few functions to work with maps: for\n"
"example, `Kernel.map_size/1` to know the number of key-value pairs in a map or\n"
"`Kernel.is_map/1` to know if a term is a map.\n"
msgstr ""
#. TRANSLATORS: def Map.has_key?(map, key)
#: lib/map.ex:205 
msgid ""
"Returns whether the given `key` exists in the given `map`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Map.has_key?(%{a: 1}, :a)\n"
"    true\n"
"    iex> Map.has_key?(%{a: 1}, :b)\n"
"    false\n"
"\n"
msgstr ""
#. TRANSLATORS: def Map.merge(map1, map2)
#: lib/map.ex:432 
msgid ""
"Merges two maps into one.\n"
"\n"
"All keys in `map2` will be added to `map1`, overriding any existing one\n"
"(i.e., the keys in `map2` \"have precedence\" over the ones in `map1`).\n"
"\n"
"If you have a struct and you would like to merge a set of keys into the\n"
"struct, do not use this function, as it would merge all keys on the right\n"
"side into the struct, even if the key is not part of the struct. Instead,\n"
"use `Kernel.struct/2`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Map.merge(%{a: 1, b: 2}, %{a: 3, d: 4})\n"
"    %{a: 3, b: 2, d: 4}\n"
"\n"
msgstr ""
#. TRANSLATORS: def Map.to_list(map)
#: lib/map.ex:123 
msgid ""
"Converts `map` to a list.\n"
"\n"
"Each key-value pair in the map is converted to a two-element tuple `{key,\n"
"value}` in the resulting list.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Map.to_list(%{a: 1})\n"
"    [a: 1]\n"
"    iex> Map.to_list(%{1 => 2})\n"
"    [{1, 2}]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Map.delete(map, key)
#: lib/map.ex:416 
msgid ""
"Deletes the entry in `map` for a specific `key`.\n"
"\n"
"If the `key` does not exist, returns `map` unchanged.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Map.delete(%{a: 1, b: 2}, :a)\n"
"    %{b: 2}\n"
"    iex> Map.delete(%{b: 2}, :a)\n"
"    %{b: 2}\n"
"\n"
msgstr ""
#. TRANSLATORS: def Map.split(map, keys)
#: lib/map.ex:587 
msgid ""
"Takes all entries corresponding to the given `keys` in `maps` and extracts\n"
"them into a separate map.\n"
"\n"
"Returns a tuple with the new map and the old map with removed keys.\n"
"\n"
"Keys for which there are no entries in `map` are ignored.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Map.split(%{a: 1, b: 2, c: 3}, [:a, :c, :e])\n"
"    {%{a: 1, c: 3}, %{b: 2}}\n"
"\n"
msgstr ""
#. TRANSLATORS: def Map.keys(map)
#: lib/map.ex:99 
msgid ""
"Returns all keys from `map`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Map.keys(%{a: 1, b: 2})\n"
"    [:a, :b]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Map.from_struct(struct)
#: lib/map.ex:749 
msgid ""
"Converts a `struct` to map.\n"
"\n"
"It accepts the struct module or a struct itself and\n"
"simply removes the `__struct__` field from the given struct\n"
"or from a new struct generated from the given module.\n"
"\n"
"## Example\n"
"\n"
"    defmodule User do\n"
"      defstruct [:name]\n"
"    end\n"
"\n"
"    Map.from_struct(User)\n"
"    #=> %{name: nil}\n"
"\n"
"    Map.from_struct(%User{name: \"john\"})\n"
"    #=> %{name: \"john\"}\n"
"\n"
msgstr ""
#. TRANSLATORS: def Map.equal?(map1, map2)
#: lib/map.ex:778 
msgid ""
"Checks if two maps are equal.\n"
"\n"
"Two maps are considered to be equal if they contain\n"
"the same keys and those keys contain the same values.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Map.equal?(%{a: 1, b: 2}, %{b: 2, a: 1})\n"
"    true\n"
"    iex> Map.equal?(%{a: 1, b: 2}, %{b: 1, a: 2})\n"
"    false\n"
"\n"
msgstr ""
#. TRANSLATORS: def Map.pop(map, key, default \\ nil)
#: lib/map.ex:501 
msgid ""
"Returns and removes the value associated with `key` in `map`.\n"
"\n"
"If `key` is present in `map` with value `value`, `{value, new_map}` is\n"
"returned where `new_map` is the result of removing `key` from `map`. If `key`\n"
"is not present in `map`, `{default, map}` is returned.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Map.pop(%{a: 1}, :a)\n"
"    {1, %{}}\n"
"    iex> Map.pop(%{a: 1}, :b)\n"
"    {nil, %{a: 1}}\n"
"    iex> Map.pop(%{a: 1}, :b, 3)\n"
"    {3, %{a: 1}}\n"
"\n"
msgstr ""
#. TRANSLATORS: def Map.put(map, key, value)
#: lib/map.ex:400 
msgid ""
"Puts the given `value` under `key` in `map`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Map.put(%{a: 1}, :b, 2)\n"
"    %{a: 1, b: 2}\n"
"    iex> Map.put(%{a: 1, b: 2}, :a, 3)\n"
"    %{a: 3, b: 2}\n"
"\n"
msgstr ""
#. TRANSLATORS: def Map.update!(map, key, fun)
#: lib/map.ex:626 
msgid ""
"Updates `key` with the given function.\n"
"\n"
"If `key` is present in `map` with value `value`, `fun` is invoked with\n"
"argument `value` and its result is used as the new value of `key`. If `key` is\n"
"not present in `map`, a `KeyError` exception is raised.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Map.update!(%{a: 1}, :a, &(&1 * 2))\n"
"    %{a: 2}\n"
"\n"
"    iex> Map.update!(%{a: 1}, :b, &(&1 * 2))\n"
"    ** (KeyError) key :b not found in: %{a: 1}\n"
"\n"
msgstr ""
#. TRANSLATORS: def Map.take(map, keys)
#: lib/map.ex:308 
msgid ""
"Returns a new map with all the key-value pairs in `map` where the key\n"
"is in `keys`.\n"
"\n"
"If `keys` contains keys that are not in `map`, they're simply ignored.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Map.take(%{a: 1, b: 2, c: 3}, [:a, :c, :e])\n"
"    %{a: 1, c: 3}\n"
"\n"
msgstr ""
#. TRANSLATORS: def Map.get_and_update!(map, key, fun)
#: lib/map.ex:706 
msgid ""
"Gets the value from `key` and updates it. Raises if there is no `key`.\n"
"\n"
"Behaves exactly like `get_and_update/3`, but raises a `KeyError` exception if\n"
"`key` is not present in `map`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Map.get_and_update!(%{a: 1}, :a, fn current_value ->\n"
"    ...>   {current_value, \"new value!\"}\n"
"    ...> end)\n"
"    {1, %{a: \"new value!\"}}\n"
"\n"
"    iex> Map.get_and_update!(%{a: 1}, :b, fn current_value ->\n"
"    ...>   {current_value, \"new value!\"}\n"
"    ...> end)\n"
"    ** (KeyError) key :b not found in: %{a: 1}\n"
"\n"
"    iex> Map.get_and_update!(%{a: 1}, :a, fn _ ->\n"
"    ...>   :pop\n"
"    ...> end)\n"
"    {1, %{}}\n"
"\n"
msgstr ""
#. TRANSLATORS: def Map.fetch!(map, key)
#: lib/map.ex:236 
msgid ""
"Fetches the value for a specific `key` in the given `map`, erroring out if\n"
"`map` doesn't contain `key`.\n"
"\n"
"If `map` contains the given `key`, the corresponding value is returned. If\n"
"`map` doesn't contain `key`, a `KeyError` exception is raised.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Map.fetch!(%{a: 1}, :a)\n"
"    1\n"
"    iex> Map.fetch!(%{a: 1}, :b)\n"
"    ** (KeyError) key :b not found in: %{a: 1}\n"
"\n"
msgstr ""
#. TRANSLATORS: def Map.new(enumerable, transform)
#: lib/map.ex:177 
msgid ""
"Creates a map from an `enumerable` via the given transformation function.\n"
"\n"
"Duplicated keys are removed; the latest one prevails.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Map.new([:a, :b], fn x -> {x, x} end)\n"
"    %{a: :a, b: :b}\n"
"\n"
msgstr ""
#. TRANSLATORS: def Map.put_new_lazy(map, key, fun)
#: lib/map.ex:279 
msgid ""
"Evaluates `fun` and puts the result under `key`\n"
"in `map` unless `key` is already present.\n"
"\n"
"This function is useful in case you want to compute the value to put under\n"
"`key` only if `key` is not already present (e.g., the value is expensive to\n"
"calculate or generally difficult to setup and teardown again).\n"
"\n"
"## Examples\n"
"\n"
"    iex> map = %{a: 1}\n"
"    iex> fun = fn ->\n"
"    ...>   # some expensive operation here\n"
"    ...>   3\n"
"    ...> end\n"
"    iex> Map.put_new_lazy(map, :a, fun)\n"
"    %{a: 1}\n"
"    iex> Map.put_new_lazy(map, :b, fun)\n"
"    %{a: 1, b: 3}\n"
"\n"
msgstr ""
#. TRANSLATORS: def Map.update(map, key, initial, fun)
#: lib/map.ex:476 
msgid ""
"Updates the `key` in `map` with the given function.\n"
"\n"
"If `key` is present in `map` with value `value`, `fun` is invoked with\n"
"argument `value` and its result is used as the new value of `key`. If `key` is\n"
"not present in `map`, `initial` is inserted as the value of `key`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Map.update(%{a: 1}, :a, 13, &(&1 * 2))\n"
"    %{a: 2}\n"
"    iex> Map.update(%{a: 1}, :b, 11, &(&1 * 2))\n"
"    %{a: 1, b: 11}\n"
"\n"
msgstr ""
#. TRANSLATORS: def Map.fetch(map, key)
#: lib/map.ex:219 
msgid ""
"Fetches the value for a specific `key` in the given `map`.\n"
"\n"
"If `map` contains the given `key` with value `value`, then `{:ok, value}` is\n"
"returned. If `map` doesn't contain `key`, `:error` is returned.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Map.fetch(%{a: 1}, :a)\n"
"    {:ok, 1}\n"
"    iex> Map.fetch(%{a: 1}, :b)\n"
"    :error\n"
"\n"
msgstr ""
#. TRANSLATORS: def Map.get_lazy(map, key, fun)
#: lib/map.ex:370 
msgid ""
"Gets the value for a specific `key` in `map`.\n"
"\n"
"If `key` is present in `map` with value `value`, then `value` is\n"
"returned. Otherwise, `fun` is evaluated and its result is returned.\n"
"\n"
"This is useful if the default value is very expensive to calculate or\n"
"generally difficult to setup and teardown again.\n"
"\n"
"## Examples\n"
"\n"
"    iex> map = %{a: 1}\n"
"    iex> fun = fn ->\n"
"    ...>   # some expensive operation here\n"
"    ...>   13\n"
"    ...> end\n"
"    iex> Map.get_lazy(map, :a, fun)\n"
"    1\n"
"    iex> Map.get_lazy(map, :b, fun)\n"
"    13\n"
"\n"
msgstr ""
#. TRANSLATORS: def Map.values(map)
#: lib/map.ex:111 
msgid ""
"Returns all values from `map`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Map.values(%{a: 1, b: 2})\n"
"    [1, 2]\n"
"\n"
msgstr ""
