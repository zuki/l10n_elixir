msgid ""
msgstr ""
"Project-Id-Version: l 10n_elixir\n"
"PO-Revision-Date: 2016-04-02 19:38+0900\n"
"Last-Translator: 小田 照敬 <EMAIL@ADDRESS>\n"
"Language-Team: Japanese\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#. TRANSLATORS: def Map.get(map, key, default \\ nil)
#: lib/map.ex:342
#, fuzzy
msgid ""
"Gets the value for a specific `key` in `map`.\n"
"\n"
"If `key` is present in `map` with value `value`, then `value` is\n"
"returned. Otherwise, `default` is returned (which is `nil` unless\n"
"specified otherwise).\n"
"\n"
"## Examples\n"
"\n"
"    iex> Map.get(%{}, :a)\n"
"    nil\n"
"    iex> Map.get(%{a: 1}, :a)\n"
"    1\n"
"    iex> Map.get(%{a: 1}, :b)\n"
"    nil\n"
"    iex> Map.get(%{a: 1}, :b, 3)\n"
"    3\n"
"\n"
msgstr ""
"指定された`key`の値を取得します。\n"
"\n"
"`key`が存在しないなら、デフォルト値\n"
"(デフォルト値が無いなら`nil`)を返します\n"
"\n"
"## Examples\n"
"\n"
"    iex> Map.get(%{}, :a)\n"
"    nil\n"
"    iex> Map.get(%{a: 1}, :a)\n"
"    1\n"
"    iex> Map.get(%{a: 1}, :b)\n"
"    nil\n"
"    iex> Map.get(%{a: 1}, :b, 3)\n"
"    3\n"
"\n"

#. TRANSLATORS: def Map.merge(map1, map2, callback)
#: lib/map.ex:452
#, fuzzy
msgid ""
"Merges two maps into one, resolving conflicts through the given `callback`.\n"
"\n"
"All keys in `map2` will be added to `map1`. The given function will be "
"invoked\n"
"when there are duplicate keys; its arguments are `key` (the duplicate key),\n"
"`value1` (the value of `key` in `map1`), and `value2` (the value of `key` "
"in\n"
"`map2`). The value returned by `callback` is used as the value under `key` "
"in\n"
"the resulting map.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Map.merge(%{a: 1, b: 2}, %{a: 3, d: 4}, fn _k, v1, v2 ->\n"
"    ...>   v1 + v2\n"
"    ...> end)\n"
"    %{a: 4, b: 2, d: 4}\n"
"\n"
msgstr ""
"二つのmapを一つにマージします。\n"
"\n"
"`map2`の全てのkeyが`map`に追加されます。\n"
"与えられた関数が、key, value1とvalue2を伴ってコンフリクトを解決するために\n"
"起動されます。\n"
"\n"
"## Examples\n"
"\n"
"    iex> Map.merge(%{a: 1, b: 2}, %{a: 3, d: 4}, fn _k, v1, v2 ->\n"
"    ...>   v1 + v2\n"
"    ...> end)\n"
"    %{a: 4, b: 2, d: 4}\n"
"\n"

#. TRANSLATORS: def Map.new()
#: lib/map.ex:140
msgid ""
"Returns a new empty map.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Map.new\n"
"    %{}\n"
"\n"
msgstr ""
"新しい空のマップを返します。\n"
"\n"
"## Examples\n"
"\n"
"    iex> Map.new\n"
"    %{}\n"
"\n"

#. TRANSLATORS: def Map.new(enumerable)
#: lib/map.ex:152
#, fuzzy
msgid ""
"Creates a map from an `enumerable`.\n"
"\n"
"Duplicated keys are removed; the latest one prevails.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Map.new([{:b, 1}, {:a, 2}])\n"
"    %{a: 2, b: 1}\n"
"    iex> Map.new([a: 1, a: 2, a: 3])\n"
"    %{a: 3}\n"
"\n"
msgstr ""
"enumerableからマップを作成します。\n"
"\n"
"重複したkeyは削除され、最後のものが勝ちます。\n"
"\n"
"## Examples\n"
"\n"
"    iex> Map.new([{:b, 1}, {:a, 2}])\n"
"    %{a: 2, b: 1}\n"
"    iex> Map.new([a: 1, a: 2, a: 3])\n"
"    %{a: 3}\n"
"\n"

#. TRANSLATORS: def Map.drop(map, keys)
#: lib/map.ex:558
#, fuzzy
msgid ""
"Drops the given `keys` from `map`.\n"
"\n"
"If `keys` contains keys that are not in `map`, they're simply ignored.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Map.drop(%{a: 1, b: 2, c: 3}, [:b, :d])\n"
"    %{a: 1, c: 3}\n"
"\n"
msgstr ""
"与えられたkeysをマップから削除します。\n"
"\n"
"## Examples\n"
"\n"
"    iex> Map.drop(%{a: 1, b: 2, c: 3}, [:b, :d])\n"
"    %{a: 1, c: 3}\n"
"\n"

#. TRANSLATORS: def Map.put_new(map, key, value)
#: lib/map.ex:259
#, fuzzy
msgid ""
"Puts the given `value` under `key` unless the entry `key`\n"
"already exists in `map`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Map.put_new(%{a: 1}, :b, 2)\n"
"    %{b: 2, a: 1}\n"
"    iex> Map.put_new(%{a: 1, b: 2}, :a, 3)\n"
"    %{a: 1, b: 2}\n"
"\n"
msgstr ""
"`key`が既に存在していない限り、`key`の下で与えられ\n"
"た`value`をputします。\n"
"\n"
"## Examples\n"
"\n"
"    iex> Map.put_new(%{a: 1}, :b, 2)\n"
"    %{b: 2, a: 1}\n"
"    iex> Map.put_new(%{a: 1, b: 2}, :a, 3)\n"
"    %{a: 1, b: 2}\n"
"\n"

#. TRANSLATORS: def Map.pop_lazy(map, key, fun)
#: lib/map.ex:526
#, fuzzy
msgid ""
"Lazily returns and removes the value associated with `key` in `map`.\n"
"\n"
"If `key` is present in `map` with value `value`, `{value, new_map}` is\n"
"returned where `new_map` is the result of removing `key` from `map`. If "
"`key`\n"
"is not present in `map`, `{fun_result, map}` is returned, where "
"`fun_result`\n"
"is the result of applying `fun`.\n"
"\n"
"This is useful if the default value is very expensive to calculate or\n"
"generally difficult to setup and teardown again.\n"
"\n"
"## Examples\n"
"\n"
"    iex> map = %{a: 1}\n"
"    iex> fun = fn ->\n"
"    ...>   # some expensive operation here\n"
"    ...>   13\n"
"    ...> end\n"
"    iex> Map.pop_lazy(map, :a, fun)\n"
"    {1, %{}}\n"
"    iex> Map.pop_lazy(map, :b, fun)\n"
"    {13, %{a: 1}}\n"
"\n"
msgstr ""
"`map`中の`key`に関連付けられた全ての値を削除して\n"
"返します。ただし、`key`が存在しない時はfunを評価した結果を返します。\n"
"\n"
"これはデフォルト値の計算に非常にコストがかかったり、\n"
"一般的に再びsetupやteardownを行うのが困難だったりする場合に\n"
"便利です。\n"
"\n"
"## Examples\n"
"\n"
"    iex> map = %{a: 1}\n"
"    iex> fun = fn ->\n"
"    ...>   # some expensive operation here\n"
"    ...>   13\n"
"    ...> end\n"
"    iex> Map.pop_lazy(map, :a, fun)\n"
"    {1, %{}}\n"
"    iex> Map.pop_lazy(map, :b, fun)\n"
"    {13, %{a: 1}}\n"
"\n"

#. TRANSLATORS: def Map.get_and_update(map, key, fun)
#: lib/map.ex:654
#, fuzzy
msgid ""
"Gets the value from `key` and updates it, all in one pass.\n"
"\n"
"`fun` is called with the current value under `key` in `map` (or `nil` if "
"`key`\n"
"is not present in `map`) and must return a two-element tuple: the \"get\" "
"value\n"
"(the retrieved value, which can be operated on before being returned) and "
"the\n"
"new value to be stored under `key` in the resulting new map. `fun` may also\n"
"return `:pop`, which means the current value shall be removed from `map` "
"and\n"
"returned (making this function behave like `Map.pop(map, key)`.\n"
"\n"
"The returned value is a tuple with the \"get\" value returned by\n"
"`fun` and a new map with the updated value under `key`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Map.get_and_update(%{a: 1}, :a, fn current_value ->\n"
"    ...>   {current_value, \"new value!\"}\n"
"    ...> end)\n"
"    {1, %{a: \"new value!\"}}\n"
"\n"
"    iex> Map.get_and_update(%{a: 1}, :b, fn current_value ->\n"
"    ...>   {current_value, \"new value!\"}\n"
"    ...> end)\n"
"    {nil, %{b: \"new value!\", a: 1}}\n"
"\n"
"    iex> Map.get_and_update(%{a: 1}, :a, fn _ -> :pop end)\n"
"    {1, %{}}\n"
"\n"
"    iex> Map.get_and_update(%{a: 1}, :b, fn _ -> :pop end)\n"
"    {nil, %{a: 1}}\n"
"\n"
msgstr ""
"`key`から値を取得し更新し、それらを一度のパスで行います。\n"
"\n"
"この`fun`引数は、`key`の値(あるいは`key`が存在しない場合\n"
"は`nil`)を受取り、2要素のタプルを返さなくてはなりません:\n"
"(取り出した値はリターンする前に操作されるかもしれませ\n"
"ん)\"get\" した値と、`key`にストアされる新しい値です。その\n"
"関数はマップから値が削除されることを意味する`:pop`を返す\n"
"こともできます。\n"
"\n"
"戻値は、`fun`により返された\"get\"した値と`key`の値が更新さ\n"
"れた新しいマップです。\n"
"\n"
"## Examples\n"
"\n"
"    iex> Map.get_and_update(%{a: 1}, :a, fn current_value ->\n"
"    ...>   {current_value, \"new value!\"}\n"
"    ...> end)\n"
"    {1, %{a: \"new value!\"}}\n"
"\n"
"    iex> Map.get_and_update(%{a: 1}, :b, fn current_value ->\n"
"    ...>   {current_value, \"new value!\"}\n"
"    ...> end)\n"
"    {nil, %{b: \"new value!\", a: 1}}\n"
"\n"
"    iex> Map.get_and_update(%{a: 1}, :a, fn _ -> :pop end)\n"
"    {1, %{}}\n"
"\n"
"    iex> Map.get_and_update(%{a: 1}, :b, fn _ -> :pop end)\n"
"    {nil, %{a: 1}}\n"
"\n"

#. TRANSLATORS: Elixir.Map Summary
#: lib/map.ex:2
msgid ""
"A set of functions for working with maps.\n"
"\n"
"Maps are the \"go to\" key-value data structure in Elixir. Maps can be "
"created\n"
"with the `%{}` syntax, and key-value pairs can be expressed as `key => "
"value`:\n"
"\n"
"    iex> %{}\n"
"    %{}\n"
"    iex> %{\"one\" => :two, 3 => \"four\"}\n"
"    %{3 => \"four\", \"one\" => :two}\n"
"\n"
"Key-value pairs in a map do not follow any order (that's why the printed "
"map\n"
"in the example above has a different order than the map that was created).\n"
"\n"
"Maps do not impose any restriction on the key type: anything can be a key in "
"a\n"
"map. As a key-value structure, maps do not allow duplicated keys; keys are\n"
"compared using the exact-equality operator (`===`). If colliding keys are "
"defined\n"
"in a map literal, the last one prevails.\n"
"\n"
"When the key in a key-value pair is an atom, the `key: value` shorthand "
"syntax\n"
"can be used (as in many other special forms), provided key-value pairs are "
"put at\n"
"the end:\n"
"\n"
"    iex> %{\"hello\" => \"world\", a: 1, b: 2}\n"
"    %{:a => 1, :b => 2, \"hello\" => \"world\"}\n"
"\n"
"Keys in maps can be accessed through some of the functions in this module\n"
"(such as `Map.get/3` or `Map.fetch/2`) or through the `[]` syntax provided "
"by\n"
"the `Access` module:\n"
"\n"
"    iex> map = %{a: 1, b: 2}\n"
"    iex> Map.fetch(map, :a)\n"
"    {:ok, 1}\n"
"    iex> map[:b]\n"
"    2\n"
"    iex> map[\"non_existing_key\"]\n"
"    nil\n"
"\n"
"The alternative access syntax `map.key` is provided alongside `[]` when the\n"
"map has a `:key` key; note that while `map[key]` will return `nil` if `map`\n"
"doesn't contain the key `key`, `map.key` will raise if `map` doesn't "
"contain\n"
"the key `:key`.\n"
"\n"
"    iex> map = %{foo: \"bar\", baz: \"bong\"}\n"
"    iex> map.foo\n"
"    \"bar\"\n"
"    iex> map.non_existing_key\n"
"    ** (KeyError) key :non_existing_key not found in: %{baz: \"bong\", foo: "
"\"bar\"}\n"
"\n"
"Maps can be pattern matched on; when a map is on the left-hand side of a\n"
"pattern match, it will match if the map on the right-hand side contains the\n"
"keys on the left-hand side and their values match the ones on the left-hand\n"
"side. This means that an empty map matches every map.\n"
"\n"
"    iex> %{} = %{foo: \"bar\"}\n"
"    %{foo: \"bar\"}\n"
"    iex> %{a: a} = %{:a => 1, \"b\" => 2, [:c, :e, :e] => 3}\n"
"    iex> a\n"
"    1\n"
"    iex> %{:c => 3} = %{:a => 1, 2 => :b}\n"
"    ** (MatchError) no match of right hand side value: %{2 => :b, :a => 1}\n"
"\n"
"Variables can be used as map keys both when writing map literals as well as\n"
"when matching:\n"
"\n"
"    iex> n = 1\n"
"    1\n"
"    iex> %{n => :one}\n"
"    %{1 => :one}\n"
"    iex> %{^n => :one} = %{1 => :one, 2 => :two, 3 => :three}\n"
"    %{1 => :one, 2 => :two, 3 => :three}\n"
"\n"
"Maps also support a specific update syntax to update the value stored under\n"
"*existing* atom keys:\n"
"\n"
"    iex> map = %{one: 1, two: 2}\n"
"    iex> %{map | one: \"one\"}\n"
"    %{one: \"one\", two: 2}\n"
"    iex> %{map | three: 3}\n"
"    ** (KeyError) key :three not found\n"
"\n"
"## Modules to work with maps\n"
"\n"
"This module aims to provide functions that perform operations specific to "
"maps\n"
"(like accessing keys, updating values, and so on). For traversing maps as\n"
"collections, developers should use the `Enum` module that works across a\n"
"variety of data types.\n"
"\n"
"The `Kernel` module also provides a few functions to work with maps: for\n"
"example, `Kernel.map_size/1` to know the number of key-value pairs in a map "
"or\n"
"`Kernel.is_map/1` to know if a term is a map.\n"
msgstr ""

#. TRANSLATORS: def Map.has_key?(map, key)
#: lib/map.ex:205
#, fuzzy
msgid ""
"Returns whether the given `key` exists in the given `map`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Map.has_key?(%{a: 1}, :a)\n"
"    true\n"
"    iex> Map.has_key?(%{a: 1}, :b)\n"
"    false\n"
"\n"
msgstr ""
"与えられた`map`に与えられた`key`が存在するかを返します。\n"
"\n"
"## Examples\n"
"\n"
"    iex> Map.has_key?(%{a: 1}, :a)\n"
"    true\n"
"    iex> Map.has_key?(%{a: 1}, :b)\n"
"    false\n"
"\n"

#. TRANSLATORS: def Map.merge(map1, map2)
#: lib/map.ex:432
#, fuzzy
msgid ""
"Merges two maps into one.\n"
"\n"
"All keys in `map2` will be added to `map1`, overriding any existing one\n"
"(i.e., the keys in `map2` \"have precedence\" over the ones in `map1`).\n"
"\n"
"If you have a struct and you would like to merge a set of keys into the\n"
"struct, do not use this function, as it would merge all keys on the right\n"
"side into the struct, even if the key is not part of the struct. Instead,\n"
"use `Kernel.struct/2`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Map.merge(%{a: 1, b: 2}, %{a: 3, d: 4})\n"
"    %{a: 3, b: 2, d: 4}\n"
"\n"
msgstr ""
"二つのマップを一つにマージします。\n"
"\n"
"`map2`の全てのキーが`map1`に追加され、既存のものは上書きされます。\n"
"\n"
"もし構造体とキーの集合を構造体にマージしたいなら、この関数は、\n"
"もしキーが構造体の一部でなくても全てのキーを右辺の構造体にマージする\n"
"ので、使わないでください。代わりに、`Kernel.struct/2`を使ってください。\n"
"\n"
"## Examples\n"
"\n"
"    iex> Map.merge(%{a: 1, b: 2}, %{a: 3, d: 4})\n"
"    %{a: 3, b: 2, d: 4}\n"
"\n"

#. TRANSLATORS: def Map.to_list(map)
#: lib/map.ex:123
#, fuzzy
msgid ""
"Converts `map` to a list.\n"
"\n"
"Each key-value pair in the map is converted to a two-element tuple `{key,\n"
"value}` in the resulting list.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Map.to_list(%{a: 1})\n"
"    [a: 1]\n"
"    iex> Map.to_list(%{1 => 2})\n"
"    [{1, 2}]\n"
"\n"
msgstr ""
"マップをリストに変換します。\n"
"\n"
"## Examples\n"
"\n"
"    iex> Map.to_list(%{a: 1})\n"
"    [a: 1]\n"
"    iex> Map.to_list(%{1 => 2})\n"
"    [{1, 2}]\n"
"\n"

#. TRANSLATORS: def Map.delete(map, key)
#: lib/map.ex:416
#, fuzzy
msgid ""
"Deletes the entry in `map` for a specific `key`.\n"
"\n"
"If the `key` does not exist, returns `map` unchanged.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Map.delete(%{a: 1, b: 2}, :a)\n"
"    %{b: 2}\n"
"    iex> Map.delete(%{b: 2}, :a)\n"
"    %{b: 2}\n"
"\n"
msgstr ""
"指定された`key`をマップのエントリから削除します。\n"
"\n"
"もし`key`が存在しない場合、変更されないマップが返ります。\n"
"\n"
"## Examples\n"
"\n"
"    iex> Map.delete(%{a: 1, b: 2}, :a)\n"
"    %{b: 2}\n"
"    iex> Map.delete(%{b: 2}, :a)\n"
"    %{b: 2}\n"
"\n"

#. TRANSLATORS: def Map.split(map, keys)
#: lib/map.ex:587
#, fuzzy
msgid ""
"Takes all entries corresponding to the given `keys` in `maps` and extracts\n"
"them into a separate map.\n"
"\n"
"Returns a tuple with the new map and the old map with removed keys.\n"
"\n"
"Keys for which there are no entries in `map` are ignored.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Map.split(%{a: 1, b: 2, c: 3}, [:a, :c, :e])\n"
"    {%{a: 1, c: 3}, %{b: 2}}\n"
"\n"
msgstr ""
"与えられたキーに対応する全てのエントリを取り出し、それらを\n"
"別のmapに抽出します。\n"
"\n"
"新しいmapと古いmapからキーを削除されたものの2要素のタプルを\n"
"返します。\n"
"\n"
"mapにエントリが存在しないキーは無視されます。\n"
"\n"
"## Examples\n"
"\n"
"    iex> Map.split(%{a: 1, b: 2, c: 3}, [:a, :c, :e])\n"
"    {%{a: 1, c: 3}, %{b: 2}}\n"
"\n"

#. TRANSLATORS: def Map.keys(map)
#: lib/map.ex:99
#, fuzzy
msgid ""
"Returns all keys from `map`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Map.keys(%{a: 1, b: 2})\n"
"    [:a, :b]\n"
"\n"
msgstr ""
"マップから全てのkeyを返します。\n"
"\n"
"## Examples\n"
"\n"
"    iex> Map.keys(%{a: 1, b: 2})\n"
"    [:a, :b]\n"
"\n"

#. TRANSLATORS: def Map.from_struct(struct)
#: lib/map.ex:749
#, fuzzy
msgid ""
"Converts a `struct` to map.\n"
"\n"
"It accepts the struct module or a struct itself and\n"
"simply removes the `__struct__` field from the given struct\n"
"or from a new struct generated from the given module.\n"
"\n"
"## Example\n"
"\n"
"    defmodule User do\n"
"      defstruct [:name]\n"
"    end\n"
"\n"
"    Map.from_struct(User)\n"
"    #=> %{name: nil}\n"
"\n"
"    Map.from_struct(%User{name: \"john\"})\n"
"    #=> %{name: \"john\"}\n"
"\n"
msgstr ""
"構造体をマップに変換します。\n"
"\n"
"構造体モジュールか構造体自身を受け付け、\n"
"単に、構造体から`__struct__`フィールドを取り除きます。\n"
"\n"
"## 例\n"
"\n"
"    defmodule User do\n"
"      defstruct [:name]\n"
"    end\n"
"\n"
"    Map.from_struct(User)\n"
"    #=> %{name: nil}\n"
"\n"
"    Map.from_struct(%User{name: \"john\"})\n"
"    #=> %{name: \"john\"}\n"
"\n"

#. TRANSLATORS: def Map.equal?(map1, map2)
#: lib/map.ex:778
msgid ""
"Checks if two maps are equal.\n"
"\n"
"Two maps are considered to be equal if they contain\n"
"the same keys and those keys contain the same values.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Map.equal?(%{a: 1, b: 2}, %{b: 2, a: 1})\n"
"    true\n"
"    iex> Map.equal?(%{a: 1, b: 2}, %{b: 1, a: 2})\n"
"    false\n"
"\n"
msgstr ""
"二つのマップが等しいかをチェックします。\n"
"\n"
"二つのマップは、それらが同じキーを持っていて、\n"
"それらのキーが同じ値を持っている場合、等しいと\n"
"考えられます。\n"
"\n"
"## Examples\n"
"\n"
"    iex> Map.equal?(%{a: 1, b: 2}, %{b: 2, a: 1})\n"
"    true\n"
"    iex> Map.equal?(%{a: 1, b: 2}, %{b: 1, a: 2})\n"
"    false\n"
"\n"

#. TRANSLATORS: def Map.pop(map, key, default \\ nil)
#: lib/map.ex:501
#, fuzzy
msgid ""
"Returns and removes the value associated with `key` in `map`.\n"
"\n"
"If `key` is present in `map` with value `value`, `{value, new_map}` is\n"
"returned where `new_map` is the result of removing `key` from `map`. If "
"`key`\n"
"is not present in `map`, `{default, map}` is returned.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Map.pop(%{a: 1}, :a)\n"
"    {1, %{}}\n"
"    iex> Map.pop(%{a: 1}, :b)\n"
"    {nil, %{a: 1}}\n"
"    iex> Map.pop(%{a: 1}, :b, 3)\n"
"    {3, %{a: 1}}\n"
"\n"
msgstr ""
"`map`の中の`key`に関連付けられた全ての値を削除し、削除した\n"
"値と、更新後のmapを返します。\n"
"\n"
"## Examples\n"
"\n"
"    iex> Map.pop(%{a: 1}, :a)\n"
"    {1, %{}}\n"
"    iex> Map.pop(%{a: 1}, :b)\n"
"    {nil, %{a: 1}}\n"
"    iex> Map.pop(%{a: 1}, :b, 3)\n"
"    {3, %{a: 1}}\n"
"\n"

#. TRANSLATORS: def Map.put(map, key, value)
#: lib/map.ex:400
#, fuzzy
msgid ""
"Puts the given `value` under `key` in `map`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Map.put(%{a: 1}, :b, 2)\n"
"    %{a: 1, b: 2}\n"
"    iex> Map.put(%{a: 1, b: 2}, :a, 3)\n"
"    %{a: 3, b: 2}\n"
"\n"
msgstr ""
"`key`に与えられた`value`をプットします。\n"
"\n"
"## Examples\n"
"\n"
"    iex> Map.put(%{a: 1}, :b, 2)\n"
"    %{a: 1, b: 2}\n"
"    iex> Map.put(%{a: 1, b: 2}, :a, 3)\n"
"    %{a: 3, b: 2}\n"
"\n"

#. TRANSLATORS: def Map.update!(map, key, fun)
#: lib/map.ex:626
#, fuzzy
msgid ""
"Updates `key` with the given function.\n"
"\n"
"If `key` is present in `map` with value `value`, `fun` is invoked with\n"
"argument `value` and its result is used as the new value of `key`. If `key` "
"is\n"
"not present in `map`, a `KeyError` exception is raised.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Map.update!(%{a: 1}, :a, &(&1 * 2))\n"
"    %{a: 2}\n"
"\n"
"    iex> Map.update!(%{a: 1}, :b, &(&1 * 2))\n"
"    ** (KeyError) key :b not found in: %{a: 1}\n"
"\n"
msgstr ""
"与えられた関数で`key`を更新します。\n"
"\n"
"もし`key`が存在しないなら、`KeyError`が上ります。\n"
"\n"
"## Examples\n"
"\n"
"    iex> Map.update!(%{a: 1}, :a, &(&1 * 2))\n"
"    %{a: 2}\n"
"\n"
"    iex> Map.update!(%{a: 1}, :b, &(&1 * 2))\n"
"    ** (KeyError) key :b not found\n"
"\n"

#. TRANSLATORS: def Map.take(map, keys)
#: lib/map.ex:308
#, fuzzy
msgid ""
"Returns a new map with all the key-value pairs in `map` where the key\n"
"is in `keys`.\n"
"\n"
"If `keys` contains keys that are not in `map`, they're simply ignored.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Map.take(%{a: 1, b: 2, c: 3}, [:a, :c, :e])\n"
"    %{a: 1, c: 3}\n"
"\n"
msgstr ""
"与えられたkeysを全て含む新しいmapを返します。\n"
"\n"
"## Examples\n"
"\n"
"    iex> Map.take(%{a: 1, b: 2, c: 3}, [:a, :c, :e])\n"
"    %{a: 1, c: 3}\n"
"\n"

#. TRANSLATORS: def Map.get_and_update!(map, key, fun)
#: lib/map.ex:706
#, fuzzy
msgid ""
"Gets the value from `key` and updates it. Raises if there is no `key`.\n"
"\n"
"Behaves exactly like `get_and_update/3`, but raises a `KeyError` exception "
"if\n"
"`key` is not present in `map`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Map.get_and_update!(%{a: 1}, :a, fn current_value ->\n"
"    ...>   {current_value, \"new value!\"}\n"
"    ...> end)\n"
"    {1, %{a: \"new value!\"}}\n"
"\n"
"    iex> Map.get_and_update!(%{a: 1}, :b, fn current_value ->\n"
"    ...>   {current_value, \"new value!\"}\n"
"    ...> end)\n"
"    ** (KeyError) key :b not found in: %{a: 1}\n"
"\n"
"    iex> Map.get_and_update!(%{a: 1}, :a, fn _ ->\n"
"    ...>   :pop\n"
"    ...> end)\n"
"    {1, %{}}\n"
"\n"
msgstr ""
"`key`から値を取得し、更新します。`key`がなければ例外を上げます。\n"
"\n"
"この`fun`引数は、`key`の値(あるいは`key`が存在しない場合は`nil`)を\n"
"受取り、2要素のタプルを返さなくてはなりません: (取り出した値はリ\n"
"ターンする前に操作されるかもしれません)\"get\" した値と、\n"
"`key`にストアされる新しい値です。\n"
"\n"
"戻値は、`fun`により返された\"get\"した値と`key`の値が更新された\n"
"新しいマップです。\n"
"\n"
"## Examples\n"
"\n"
"    iex> Map.get_and_update!(%{a: 1}, :a, fn(current_value) ->\n"
"    ...>   {current_value, \"new value!\"}\n"
"    ...> end)\n"
"    {1, %{a: \"new value!\"}}\n"
"\n"
"    iex> Map.get_and_update!(%{a: 1}, :b, fn current_value ->\n"
"    ...>   {current_value, \"new value!\"}\n"
"    ...> end)\n"
"    ** (KeyError) key :b not found\n"
"\n"

#. TRANSLATORS: def Map.fetch!(map, key)
#: lib/map.ex:236
#, fuzzy
msgid ""
"Fetches the value for a specific `key` in the given `map`, erroring out if\n"
"`map` doesn't contain `key`.\n"
"\n"
"If `map` contains the given `key`, the corresponding value is returned. If\n"
"`map` doesn't contain `key`, a `KeyError` exception is raised.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Map.fetch!(%{a: 1}, :a)\n"
"    1\n"
"    iex> Map.fetch!(%{a: 1}, :b)\n"
"    ** (KeyError) key :b not found in: %{a: 1}\n"
"\n"
msgstr ""
"指定された`key`の値を取得します。\n"
"\n"
"もし`key`が存在しないなら、`KeyError`が上ります。\n"
"\n"
"## Examples\n"
"\n"
"    iex> Map.fetch!(%{a: 1}, :a)\n"
"    1\n"
"    iex> Map.fetch!(%{a: 1}, :b)\n"
"    ** (KeyError) key :b not found in: %{a: 1}\n"
"\n"

#. TRANSLATORS: def Map.new(enumerable, transform)
#: lib/map.ex:177
#, fuzzy
msgid ""
"Creates a map from an `enumerable` via the given transformation function.\n"
"\n"
"Duplicated keys are removed; the latest one prevails.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Map.new([:a, :b], fn x -> {x, x} end)\n"
"    %{a: :a, b: :b}\n"
"\n"
msgstr ""
"enumerableから変換関数を通じてmapを作成します。\n"
"\n"
"重複したエントリは削除されます; 最後のものが優先されます。\n"
"\n"
"## Examples\n"
"\n"
"    iex> Map.new([:a, :b], fn x -> {x, x} end)\n"
"    %{a: :a, b: :b}\n"
"\n"

#. TRANSLATORS: def Map.put_new_lazy(map, key, fun)
#: lib/map.ex:279
#, fuzzy
msgid ""
"Evaluates `fun` and puts the result under `key`\n"
"in `map` unless `key` is already present.\n"
"\n"
"This function is useful in case you want to compute the value to put under\n"
"`key` only if `key` is not already present (e.g., the value is expensive to\n"
"calculate or generally difficult to setup and teardown again).\n"
"\n"
"## Examples\n"
"\n"
"    iex> map = %{a: 1}\n"
"    iex> fun = fn ->\n"
"    ...>   # some expensive operation here\n"
"    ...>   3\n"
"    ...> end\n"
"    iex> Map.put_new_lazy(map, :a, fun)\n"
"    %{a: 1}\n"
"    iex> Map.put_new_lazy(map, :b, fun)\n"
"    %{a: 1, b: 3}\n"
"\n"
msgstr ""
"`key`がmapに既に無いかぎり、`fun`を評価し、その結果を\n"
"`key`の値としてmapにputします。\n"
"\n"
"これは値の計算に非常にコストがかかるとか、setupや\n"
"teardownを再び行うのが困難な場合に一般に便利です。\n"
"\n"
"## Examples\n"
"\n"
"    iex> map = %{a: 1}\n"
"    iex> fun = fn ->\n"
"    ...>   # some expensive operation here\n"
"    ...>   3\n"
"    ...> end\n"
"    iex> Map.put_new_lazy(map, :a, fun)\n"
"    %{a: 1}\n"
"    iex> Map.put_new_lazy(map, :b, fun)\n"
"    %{a: 1, b: 3}\n"
"\n"

#. TRANSLATORS: def Map.update(map, key, initial, fun)
#: lib/map.ex:476
#, fuzzy
msgid ""
"Updates the `key` in `map` with the given function.\n"
"\n"
"If `key` is present in `map` with value `value`, `fun` is invoked with\n"
"argument `value` and its result is used as the new value of `key`. If `key` "
"is\n"
"not present in `map`, `initial` is inserted as the value of `key`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Map.update(%{a: 1}, :a, 13, &(&1 * 2))\n"
"    %{a: 2}\n"
"    iex> Map.update(%{a: 1}, :b, 11, &(&1 * 2))\n"
"    %{a: 1, b: 11}\n"
"\n"
msgstr ""
"与えられた関数で`map`の`key`を更新します。\n"
"\n"
"もし`key`が存在しないなら、与えられた`initial`値が挿入されます。\n"
"\n"
"## Examples\n"
"\n"
"    iex> Map.update(%{a: 1}, :a, 13, &(&1 * 2))\n"
"    %{a: 2}\n"
"    iex> Map.update(%{a: 1}, :b, 11, &(&1 * 2))\n"
"    %{a: 1, b: 11}\n"
"\n"

#. TRANSLATORS: def Map.fetch(map, key)
#: lib/map.ex:219
#, fuzzy
msgid ""
"Fetches the value for a specific `key` in the given `map`.\n"
"\n"
"If `map` contains the given `key` with value `value`, then `{:ok, value}` "
"is\n"
"returned. If `map` doesn't contain `key`, `:error` is returned.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Map.fetch(%{a: 1}, :a)\n"
"    {:ok, 1}\n"
"    iex> Map.fetch(%{a: 1}, :b)\n"
"    :error\n"
"\n"
msgstr ""
"指定された`key`を値を取得し、タプルで返します。\n"
"\n"
"`key`が無い場合、`:error`を返します。\n"
"\n"
"## Examples\n"
"\n"
"    iex> Map.fetch(%{a: 1}, :a)\n"
"    {:ok, 1}\n"
"    iex> Map.fetch(%{a: 1}, :b)\n"
"    :error\n"
"\n"

#. TRANSLATORS: def Map.get_lazy(map, key, fun)
#: lib/map.ex:370
#, fuzzy
msgid ""
"Gets the value for a specific `key` in `map`.\n"
"\n"
"If `key` is present in `map` with value `value`, then `value` is\n"
"returned. Otherwise, `fun` is evaluated and its result is returned.\n"
"\n"
"This is useful if the default value is very expensive to calculate or\n"
"generally difficult to setup and teardown again.\n"
"\n"
"## Examples\n"
"\n"
"    iex> map = %{a: 1}\n"
"    iex> fun = fn ->\n"
"    ...>   # some expensive operation here\n"
"    ...>   13\n"
"    ...> end\n"
"    iex> Map.get_lazy(map, :a, fun)\n"
"    1\n"
"    iex> Map.get_lazy(map, :b, fun)\n"
"    13\n"
"\n"
msgstr ""
"指定された`key`の値を取得します。\n"
"\n"
"`key`が存在しない場合、`fun`が遅延評価され、\n"
"その結果が返ります。\n"
"\n"
"これはデフォルト値の計算に非常にコストがかかったり、\n"
"一般的に再びsetupやteardownを行うのが困難だったりする場合に\n"
"便利です。\n"
"\n"
"## Examples\n"
"\n"
"    iex> map = %{a: 1}\n"
"    iex> fun = fn ->\n"
"    ...>   # some expensive operation here\n"
"    ...>   13\n"
"    ...> end\n"
"    iex> Map.get_lazy(map, :a, fun)\n"
"    1\n"
"    iex> Map.get_lazy(map, :b, fun)\n"
"    13\n"
"\n"

#. TRANSLATORS: def Map.values(map)
#: lib/map.ex:111
#, fuzzy
msgid ""
"Returns all values from `map`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Map.values(%{a: 1, b: 2})\n"
"    [1, 2]\n"
"\n"
msgstr ""
"mapから全ての値を返します。\n"
"\n"
"## Examples\n"
"\n"
"    iex> Map.values(%{a: 1, b: 2})\n"
"    [1, 2]\n"
"\n"

#~ msgid ""
#~ "A set of functions for working with maps.\n"
#~ "\n"
#~ "Maps are key-value stores where keys can be any value and\n"
#~ "are compared using the match operator (`===`). Maps can be\n"
#~ "created with the `%{}` special form defined in the\n"
#~ "`Kernel.SpecialForms` module.\n"
#~ msgstr ""
#~ "マップで動作する一群の関数です。\n"
#~ "\n"
#~ "マップは、キーをマッチオペレータ(`===`)で比較する、\n"
#~ "キーバリューストアです。マップは、\n"
#~ "`Kernel.SpecilForms`で定義された`%{}`スペシャルフォームで、\n"
#~ "作成することができます\n"

#~ msgid "Updates the value in the map with the given function.\n"
#~ msgstr "mapの値を与えられた関数で更新します。\n"

#~ msgid "Returns a new empty map.\n"
#~ msgstr "新しい空のマップを返します。\n"

#~ msgid ""
#~ "Gets a value and updates a map only if the key exists in one operation.\n"
#~ msgstr ""
#~ "一度のオペレーションで存在するkeyの値の取得と\n"
#~ "更新を行います。\n"

#~ msgid "Gets a value and updates a map in one operation.\n"
#~ msgstr "一度のオペレーションで値の取得と更新を行います。\n"
