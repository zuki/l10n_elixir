msgid ""
msgstr ""
"Project-Id-Version: l 10n_elixir\n"
"POT-Creation-Date: \n"
"PO-Revision-Date: 2017-01-29 16:28+0900\n"
"Last-Translator: 小田 照敬 <EMAIL@ADDRESS>\n"
"Language-Team: Japanese\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Poedit 1.8.11\n"

#. TRANSLATORS: def Map.update(map, key, initial, fun)
#: lib/map.ex:476
msgid ""
"Updates the `key` in `map` with the given function.\n"
"\n"
"If `key` is present in `map` with value `value`, `fun` is invoked with\n"
"argument `value` and its result is used as the new value of `key`. If `key` "
"is\n"
"not present in `map`, `initial` is inserted as the value of `key`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Map.update(%{a: 1}, :a, 13, &(&1 * 2))\n"
"    %{a: 2}\n"
"    iex> Map.update(%{a: 1}, :b, 11, &(&1 * 2))\n"
"    %{a: 1, b: 11}\n"
"\n"
msgstr ""
"`map`の`key`を指定された関数で更新します。\n"
"\n"
"`map`で`key`が値`value`で存在する場合、`fun`が`value`を引数に\n"
"呼び出され、その結果が`key`の新たな値として使用されます。\n"
"`key`が`map`に存在しない場合は、`key`の値として`initial`が挿入されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> Map.update(%{a: 1}, :a, 13, &(&1 * 2))\n"
"    %{a: 2}\n"
"    iex> Map.update(%{a: 1}, :b, 11, &(&1 * 2))\n"
"    %{a: 1, b: 11}\n"
"\n"

#. TRANSLATORS: def Map.get_lazy(map, key, fun)
#: lib/map.ex:370
msgid ""
"Gets the value for a specific `key` in `map`.\n"
"\n"
"If `key` is present in `map` with value `value`, then `value` is\n"
"returned. Otherwise, `fun` is evaluated and its result is returned.\n"
"\n"
"This is useful if the default value is very expensive to calculate or\n"
"generally difficult to setup and teardown again.\n"
"\n"
"## Examples\n"
"\n"
"    iex> map = %{a: 1}\n"
"    iex> fun = fn ->\n"
"    ...>   # some expensive operation here\n"
"    ...>   13\n"
"    ...> end\n"
"    iex> Map.get_lazy(map, :a, fun)\n"
"    1\n"
"    iex> Map.get_lazy(map, :b, fun)\n"
"    13\n"
"\n"
msgstr ""
"指定された`map`の`key`の値を取得します。\n"
"\n"
"`key`が`map`で値`value`で存在する場合は、`value`が返されます。\n"
"そうでない場合は、`fun`が評価され、その結果が返されます。\n"
"\n"
"これはデフォルト値が計算するのに非常に高価であるか、または\n"
"構築や解体を再度行うことが一般に難しい場合に役に立ちます。\n"
"\n"
"## 例\n"
"\n"
"    iex> map = %{a: 1}\n"
"    iex> fun = fn ->\n"
"    ...>   # ここで何らかの高価な操作\n"
"    ...>   13\n"
"    ...> end\n"
"    iex> Map.get_lazy(map, :a, fun)\n"
"    1\n"
"    iex> Map.get_lazy(map, :b, fun)\n"
"    13\n"
"\n"

#. TRANSLATORS: def Map.get(map, key, default \\ nil)
#: lib/map.ex:342
msgid ""
"Gets the value for a specific `key` in `map`.\n"
"\n"
"If `key` is present in `map` with value `value`, then `value` is\n"
"returned. Otherwise, `default` is returned (which is `nil` unless\n"
"specified otherwise).\n"
"\n"
"## Examples\n"
"\n"
"    iex> Map.get(%{}, :a)\n"
"    nil\n"
"    iex> Map.get(%{a: 1}, :a)\n"
"    1\n"
"    iex> Map.get(%{a: 1}, :b)\n"
"    nil\n"
"    iex> Map.get(%{a: 1}, :b, 3)\n"
"    3\n"
"\n"
msgstr ""
"指定された`map`の`key`の値を取得します。\n"
"\n"
"`key`が`map`に値`value`で存在した場合は、\n"
"`value`が返されます。そうでない場合は、`default`が\n"
"(指定されていない場合は`nil`）が返されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> Map.get(%{}, :a)\n"
"    nil\n"
"    iex> Map.get(%{a: 1}, :a)\n"
"    1\n"
"    iex> Map.get(%{a: 1}, :b)\n"
"    nil\n"
"    iex> Map.get(%{a: 1}, :b, 3)\n"
"    3\n"
"\n"

#. TRANSLATORS: def Map.merge(map1, map2, callback)
#: lib/map.ex:452
msgid ""
"Merges two maps into one, resolving conflicts through the given `callback`.\n"
"\n"
"All keys in `map2` will be added to `map1`. The given function will be "
"invoked\n"
"when there are duplicate keys; its arguments are `key` (the duplicate key),\n"
"`value1` (the value of `key` in `map1`), and `value2` (the value of `key` "
"in\n"
"`map2`). The value returned by `callback` is used as the value under `key` "
"in\n"
"the resulting map.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Map.merge(%{a: 1, b: 2}, %{a: 3, d: 4}, fn _k, v1, v2 ->\n"
"    ...>   v1 + v2\n"
"    ...> end)\n"
"    %{a: 4, b: 2, d: 4}\n"
"\n"
msgstr ""
"指定された`callback`で衝突を解決しながら、二つのmapを一つにマージします。\n"
"\n"
"`map2`のすべてのキーが`map1`に追加されます。重複キーが存在する場合、\n"
"指定された関数が呼び出されます。引数は、`key`（重複キー）、`value1`\n"
"（`map1`の`key`の値）、`value2`（`map2`の`key`の値）の３つです。\n"
"`callback`により返される値はマージ後のマップの`key`の値として\n"
"使用されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> Map.merge(%{a: 1, b: 2}, %{a: 3, d: 4}, fn _k, v1, v2 ->\n"
"    ...>   v1 + v2\n"
"    ...> end)\n"
"    %{a: 4, b: 2, d: 4}\n"
"\n"

#. TRANSLATORS: def Map.new(enumerable)
#: lib/map.ex:152
msgid ""
"Creates a map from an `enumerable`.\n"
"\n"
"Duplicated keys are removed; the latest one prevails.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Map.new([{:b, 1}, {:a, 2}])\n"
"    %{a: 2, b: 1}\n"
"    iex> Map.new([a: 1, a: 2, a: 3])\n"
"    %{a: 3}\n"
"\n"
msgstr ""
"`enumerable`からマップを作成します。\n"
"\n"
"重複したキーは除去され、最後に指定されたものが優先されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> Map.new([{:b, 1}, {:a, 2}])\n"
"    %{a: 2, b: 1}\n"
"    iex> Map.new([a: 1, a: 2, a: 3])\n"
"    %{a: 3}\n"
"\n"

#. TRANSLATORS: def Map.drop(map, keys)
#: lib/map.ex:558
msgid ""
"Drops the given `keys` from `map`.\n"
"\n"
"If `keys` contains keys that are not in `map`, they're simply ignored.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Map.drop(%{a: 1, b: 2, c: 3}, [:b, :d])\n"
"    %{a: 1, c: 3}\n"
"\n"
msgstr ""
"マップから指定された`keys`を削除します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Map.drop(%{a: 1, b: 2, c: 3}, [:b, :d])\n"
"    %{a: 1, c: 3}\n"
"\n"

#. TRANSLATORS: def Map.put_new(map, key, value)
#: lib/map.ex:259
msgid ""
"Puts the given `value` under `key` unless the entry `key`\n"
"already exists in `map`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Map.put_new(%{a: 1}, :b, 2)\n"
"    %{b: 2, a: 1}\n"
"    iex> Map.put_new(%{a: 1, b: 2}, :a, 3)\n"
"    %{a: 1, b: 2}\n"
"\n"
msgstr ""
"`map`に`key`がまだ存在していない場合、`key`に\n"
"指定された`value`を置きます。\n"
"\n"
"## 例\n"
"\n"
"    iex> Map.put_new(%{a: 1}, :b, 2)\n"
"    %{b: 2, a: 1}\n"
"    iex> Map.put_new(%{a: 1, b: 2}, :a, 3)\n"
"    %{a: 1, b: 2}\n"
"\n"

#. TRANSLATORS: def Map.put_new_lazy(map, key, fun)
#: lib/map.ex:279
msgid ""
"Evaluates `fun` and puts the result under `key`\n"
"in `map` unless `key` is already present.\n"
"\n"
"This function is useful in case you want to compute the value to put under\n"
"`key` only if `key` is not already present (e.g., the value is expensive to\n"
"calculate or generally difficult to setup and teardown again).\n"
"\n"
"## Examples\n"
"\n"
"    iex> map = %{a: 1}\n"
"    iex> fun = fn ->\n"
"    ...>   # some expensive operation here\n"
"    ...>   3\n"
"    ...> end\n"
"    iex> Map.put_new_lazy(map, :a, fun)\n"
"    %{a: 1}\n"
"    iex> Map.put_new_lazy(map, :b, fun)\n"
"    %{a: 1, b: 3}\n"
"\n"
msgstr ""
"`key`が`map`にまだ存在しない場合、`fun`を評価し、その結果を\n"
"`map`の`key`に置きます。\n"
"\n"
"これは`key`がまだ存在しない場合に`key`に置く値を計算したい場合に\n"
"役に立ちます（たとえば、値が計算するのに高価であるか、一般に再度構築や\n"
"廃棄を行うことが難しい場合など）。\n"
"\n"
"## 例\n"
"\n"
"    iex> map = %{a: 1}\n"
"    iex> fun = fn ->\n"
"    ...>   # ここで何か高価な操作\n"
"    ...>   3\n"
"    ...> end\n"
"    iex> Map.put_new_lazy(map, :a, fun)\n"
"    %{a: 1}\n"
"    iex> Map.put_new_lazy(map, :b, fun)\n"
"    %{a: 1, b: 3}\n"
"\n"

#. TRANSLATORS: def Map.new()
#: lib/map.ex:140
msgid ""
"Returns a new empty map.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Map.new\n"
"    %{}\n"
"\n"
msgstr ""
"新しい空のマップを返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Map.new\n"
"    %{}\n"
"\n"

#. TRANSLATORS: def Map.has_key?(map, key)
#: lib/map.ex:205
msgid ""
"Returns whether the given `key` exists in the given `map`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Map.has_key?(%{a: 1}, :a)\n"
"    true\n"
"    iex> Map.has_key?(%{a: 1}, :b)\n"
"    false\n"
"\n"
msgstr ""
"指定の`map`に指定の`key`が存在するか否かを返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Map.has_key?(%{a: 1}, :a)\n"
"    true\n"
"    iex> Map.has_key?(%{a: 1}, :b)\n"
"    false\n"
"\n"

#. TRANSLATORS: def Map.merge(map1, map2)
#: lib/map.ex:432
msgid ""
"Merges two maps into one.\n"
"\n"
"All keys in `map2` will be added to `map1`, overriding any existing one\n"
"(i.e., the keys in `map2` \"have precedence\" over the ones in `map1`).\n"
"\n"
"If you have a struct and you would like to merge a set of keys into the\n"
"struct, do not use this function, as it would merge all keys on the right\n"
"side into the struct, even if the key is not part of the struct. Instead,\n"
"use `Kernel.struct/2`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Map.merge(%{a: 1, b: 2}, %{a: 3, d: 4})\n"
"    %{a: 3, b: 2, d: 4}\n"
"\n"
msgstr ""
"二つのマップを一つにマージします。\n"
"\n"
"`map2`のすべてのキーが`map1`に追加され、既存のものは上書きされます\n"
"（すなわち、`map2`のキーが`map1`のキーより「優先されます」）。\n"
"\n"
"構造体がありこの構造体にキーの集合をマージしたい場合は、この関数を\n"
"使用しないでください。それがたとえ構造体になくても、右辺のすべての\n"
"キーを構造体にマージするからです。その場合は、`Kernel.struct/2`を\n"
"使用してください。\n"
"\n"
"## 例\n"
"\n"
"    iex> Map.merge(%{a: 1, b: 2}, %{a: 3, d: 4})\n"
"    %{a: 3, b: 2, d: 4}\n"
"\n"

#. TRANSLATORS: def Map.pop_lazy(map, key, fun)
#: lib/map.ex:526
msgid ""
"Lazily returns and removes the value associated with `key` in `map`.\n"
"\n"
"If `key` is present in `map` with value `value`, `{value, new_map}` is\n"
"returned where `new_map` is the result of removing `key` from `map`. If "
"`key`\n"
"is not present in `map`, `{fun_result, map}` is returned, where "
"`fun_result`\n"
"is the result of applying `fun`.\n"
"\n"
"This is useful if the default value is very expensive to calculate or\n"
"generally difficult to setup and teardown again.\n"
"\n"
"## Examples\n"
"\n"
"    iex> map = %{a: 1}\n"
"    iex> fun = fn ->\n"
"    ...>   # some expensive operation here\n"
"    ...>   13\n"
"    ...> end\n"
"    iex> Map.pop_lazy(map, :a, fun)\n"
"    {1, %{}}\n"
"    iex> Map.pop_lazy(map, :b, fun)\n"
"    {13, %{a: 1}}\n"
"\n"
msgstr ""
"`map`の`key`に関連付けられた値を遅延して返して、削除します。\n"
"\n"
"`map`に値`value`を持つ`key`が存在する場合、`{value, new_map}`が\n"
"返されます。ここで`new_map`は`map`から`key`を削除した結果です。\n"
"`key`が`map`に存在しない場合は、`{fun_result, map}`が返されます。\n"
"ここで`fun_result`は`fun`を適用した結果です。\n"
"\n"
"これはデフォルト値が計算するのに非常に高価であるか、または\n"
"構築や解体を再度行うことが一般に難しい場合に役に立ちます。\n"
"\n"
"## 例\n"
"\n"
"    iex> map = %{a: 1}\n"
"    iex> fun = fn ->\n"
"    ...>   # ここで何か高価な操作\n"
"    ...>   13\n"
"    ...> end\n"
"    iex> Map.pop_lazy(map, :a, fun)\n"
"    {1, %{}}\n"
"    iex> Map.pop_lazy(map, :b, fun)\n"
"    {13, %{a: 1}}\n"
"\n"

#. TRANSLATORS: def Map.get_and_update(map, key, fun)
#: lib/map.ex:654
msgid ""
"Gets the value from `key` and updates it, all in one pass.\n"
"\n"
"`fun` is called with the current value under `key` in `map` (or `nil` if "
"`key`\n"
"is not present in `map`) and must return a two-element tuple: the \"get\" "
"value\n"
"(the retrieved value, which can be operated on before being returned) and "
"the\n"
"new value to be stored under `key` in the resulting new map. `fun` may also\n"
"return `:pop`, which means the current value shall be removed from `map` "
"and\n"
"returned (making this function behave like `Map.pop(map, key)`.\n"
"\n"
"The returned value is a tuple with the \"get\" value returned by\n"
"`fun` and a new map with the updated value under `key`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Map.get_and_update(%{a: 1}, :a, fn current_value ->\n"
"    ...>   {current_value, \"new value!\"}\n"
"    ...> end)\n"
"    {1, %{a: \"new value!\"}}\n"
"\n"
"    iex> Map.get_and_update(%{a: 1}, :b, fn current_value ->\n"
"    ...>   {current_value, \"new value!\"}\n"
"    ...> end)\n"
"    {nil, %{b: \"new value!\", a: 1}}\n"
"\n"
"    iex> Map.get_and_update(%{a: 1}, :a, fn _ -> :pop end)\n"
"    {1, %{}}\n"
"\n"
"    iex> Map.get_and_update(%{a: 1}, :b, fn _ -> :pop end)\n"
"    {nil, %{a: 1}}\n"
"\n"
msgstr ""
"`key`の値を取得し、更新します。これを一度のパスで行います。\n"
"\n"
"`fun`は、`map`の`key`の現在の値（`key`が`map`に存在しない\n"
"場合は`nil`）を引数に呼び出され、2要素のタプルを返さなくてはなりません: \n"
"第1要素は「取得した」値（取り出した値で、返す前に操作することができます）、\n"
"第2要素は結果である新しいマップの`key`に格納される新しい値です。\n"
"`fun`は`:pot`を返すこともできます。これは現在の値を`map`から削除して\n"
"返すことを意味します（この関数のふるまいを`Map.pop(map, key)`のようにしま"
"す）。\n"
"\n"
"返り値は、`fun`から返される「取得」値と`key`の更新された値を持つ\n"
"新たなマップです。\n"
"\n"
"## 例\n"
"\n"
"    iex> Map.get_and_update(%{a: 1}, :a, fn current_value ->\n"
"    ...>   {current_value, \"new value!\"}\n"
"    ...> end)\n"
"    {1, %{a: \"new value!\"}}\n"
"\n"
"    iex> Map.get_and_update(%{a: 1}, :b, fn current_value ->\n"
"    ...>   {current_value, \"new value!\"}\n"
"    ...> end)\n"
"    {nil, %{b: \"new value!\", a: 1}}\n"
"\n"
"    iex> Map.get_and_update(%{a: 1}, :a, fn _ -> :pop end)\n"
"    {1, %{}}\n"
"\n"
"    iex> Map.get_and_update(%{a: 1}, :b, fn _ -> :pop end)\n"
"    {nil, %{a: 1}}\n"
"\n"

#. TRANSLATORS: Elixir.Map Summary
#: lib/map.ex:2
msgid ""
"A set of functions for working with maps.\n"
"\n"
"Maps are the \"go to\" key-value data structure in Elixir. Maps can be "
"created\n"
"with the `%{}` syntax, and key-value pairs can be expressed as `key => "
"value`:\n"
"\n"
"    iex> %{}\n"
"    %{}\n"
"    iex> %{\"one\" => :two, 3 => \"four\"}\n"
"    %{3 => \"four\", \"one\" => :two}\n"
"\n"
"Key-value pairs in a map do not follow any order (that's why the printed "
"map\n"
"in the example above has a different order than the map that was created).\n"
"\n"
"Maps do not impose any restriction on the key type: anything can be a key in "
"a\n"
"map. As a key-value structure, maps do not allow duplicated keys; keys are\n"
"compared using the exact-equality operator (`===`). If colliding keys are "
"defined\n"
"in a map literal, the last one prevails.\n"
"\n"
"When the key in a key-value pair is an atom, the `key: value` shorthand "
"syntax\n"
"can be used (as in many other special forms), provided key-value pairs are "
"put at\n"
"the end:\n"
"\n"
"    iex> %{\"hello\" => \"world\", a: 1, b: 2}\n"
"    %{:a => 1, :b => 2, \"hello\" => \"world\"}\n"
"\n"
"Keys in maps can be accessed through some of the functions in this module\n"
"(such as `Map.get/3` or `Map.fetch/2`) or through the `[]` syntax provided "
"by\n"
"the `Access` module:\n"
"\n"
"    iex> map = %{a: 1, b: 2}\n"
"    iex> Map.fetch(map, :a)\n"
"    {:ok, 1}\n"
"    iex> map[:b]\n"
"    2\n"
"    iex> map[\"non_existing_key\"]\n"
"    nil\n"
"\n"
"The alternative access syntax `map.key` is provided alongside `[]` when the\n"
"map has a `:key` key; note that while `map[key]` will return `nil` if `map`\n"
"doesn't contain the key `key`, `map.key` will raise if `map` doesn't "
"contain\n"
"the key `:key`.\n"
"\n"
"    iex> map = %{foo: \"bar\", baz: \"bong\"}\n"
"    iex> map.foo\n"
"    \"bar\"\n"
"    iex> map.non_existing_key\n"
"    ** (KeyError) key :non_existing_key not found in: %{baz: \"bong\", foo: "
"\"bar\"}\n"
"\n"
"Maps can be pattern matched on; when a map is on the left-hand side of a\n"
"pattern match, it will match if the map on the right-hand side contains the\n"
"keys on the left-hand side and their values match the ones on the left-hand\n"
"side. This means that an empty map matches every map.\n"
"\n"
"    iex> %{} = %{foo: \"bar\"}\n"
"    %{foo: \"bar\"}\n"
"    iex> %{a: a} = %{:a => 1, \"b\" => 2, [:c, :e, :e] => 3}\n"
"    iex> a\n"
"    1\n"
"    iex> %{:c => 3} = %{:a => 1, 2 => :b}\n"
"    ** (MatchError) no match of right hand side value: %{2 => :b, :a => 1}\n"
"\n"
"Variables can be used as map keys both when writing map literals as well as\n"
"when matching:\n"
"\n"
"    iex> n = 1\n"
"    1\n"
"    iex> %{n => :one}\n"
"    %{1 => :one}\n"
"    iex> %{^n => :one} = %{1 => :one, 2 => :two, 3 => :three}\n"
"    %{1 => :one, 2 => :two, 3 => :three}\n"
"\n"
"Maps also support a specific update syntax to update the value stored under\n"
"*existing* atom keys:\n"
"\n"
"    iex> map = %{one: 1, two: 2}\n"
"    iex> %{map | one: \"one\"}\n"
"    %{one: \"one\", two: 2}\n"
"    iex> %{map | three: 3}\n"
"    ** (KeyError) key :three not found\n"
"\n"
"## Modules to work with maps\n"
"\n"
"This module aims to provide functions that perform operations specific to "
"maps\n"
"(like accessing keys, updating values, and so on). For traversing maps as\n"
"collections, developers should use the `Enum` module that works across a\n"
"variety of data types.\n"
"\n"
"The `Kernel` module also provides a few functions to work with maps: for\n"
"example, `Kernel.map_size/1` to know the number of key-value pairs in a map "
"or\n"
"`Kernel.is_map/1` to know if a term is a map.\n"
msgstr ""
"マップを扱う一連の関数です。\n"
"\n"
"マップはElixirにおける「主力となる」キー・バリュー・データ構造です。\n"
"マップは`%{}`構文で作成でき、キーと値の組は`key => value`で表すことができま"
"す。\n"
"\n"
"    iex> %{}\n"
"    %{}\n"
"    iex> %{\"one\" => :two, 3 => \"four\"}\n"
"    %{3 => \"four\", \"one\" => :two}\n"
"\n"
"マップにおけるキーと値の組は順序を持ちません（上の例で表示されたマップが\n"
"作成したマップとは異なる順になっているのはそのためです）。\n"
"\n"
"マップはキーの型を制限しません。どんな型もマップのキーになれます。\n"
"キー・バリュー構造として、マップは重複キーを認めません。キーは完全一致\n"
"演算子（`===`）を使って比較されます。マップリテラルで衝突するキーが\n"
"定義されている場合は、最後のものが優先されます。\n"
"\n"
"キーと値の組のキーがアトムの場合、キーと値の組が最後に置かれる場合、\n"
"（他の多くの特別な形式と同様に）短縮形の構文`key: value`を使うことが\n"
"できます:\n"
"\n"
"    iex> %{\"hello\" => \"world\", a: 1, b: 2}\n"
"    %{:a => 1, :b => 2, \"hello\" => \"world\"}\n"
"\n"
"マップのキーはこのモジュールの関数（`Map.get/3`や`Map.fetch/2`など）や\n"
"`Access`モジュールが提供する`[]`構文によりアクセスすることが\n"
"できます:\n"
"\n"
"    iex> map = %{a: 1, b: 2}\n"
"    iex> Map.fetch(map, :a)\n"
"    {:ok, 1}\n"
"    iex> map[:b]\n"
"    2\n"
"    iex> map[\"non_existing_key\"]\n"
"    nil\n"
"\n"
"マップがキー`:key`を持っている場合、`[]`構文とともにもう一つのアクセス構文\n"
"`map.key`が提供されています。`map[key]`は`map`がキー`:key`を含んでいない\n"
"場合`nil`を返しますが、`map.key`は`map`がキー`:key`を含んでいない場合\n"
"例外を発生することに注意してください。\n"
"\n"
"    iex> map = %{foo: \"bar\", baz: \"bong\"}\n"
"    iex> map.foo\n"
"    \"bar\"\n"
"    iex> map.non_existing_key\n"
"    ** (KeyError) key :non_existing_key not found in: %{baz: \"bong\", foo: "
"\"bar\"}\n"
"\n"
"マップはパターン照合をすることができます: マップがパターン照合の\n"
"左辺にある場合、右辺のマップが左辺のキーを含んでおり、その値が左辺の\n"
"値とマッチした場合、マッチします。これは空のマップはすべてのマップとマッチ\n"
"することを意味します。\n"
"    iex> %{} = %{foo: \"bar\"}\n"
"    %{foo: \"bar\"}\n"
"    iex> %{a: a} = %{:a => 1, \"b\" => 2, [:c, :e, :e] => 3}\n"
"    iex> a\n"
"    1\n"
"    iex> %{:c => 3} = %{:a => 1, 2 => :b}\n"
"    ** (MatchError) no match of right hand side value: %{2 => :b, :a => 1}\n"
"\n"
"変数は、マップリテラルを書く際にも、照合を行う際にも、マップのキーとして\n"
"使用することができます。\n"
"n\n"
"    iex> n = 1\n"
"    1\n"
"    iex> %{n => :one}\n"
"    %{1 => :one}\n"
"    iex> %{^n => :one} = %{1 => :one, 2 => :two, 3 => :three}\n"
"    %{1 => :one, 2 => :two, 3 => :three}\n"
"\n"
"マップは*既存の*アトムキーに格納されている値を更新するための特別な\n"
"更新構文もサポートしています:\n"
"\n"
"    iex> map = %{one: 1, two: 2}\n"
"    iex> %{map | one: \"one\"}\n"
"    %{one: \"one\", two: 2}\n"
"    iex> %{map | three: 3}\n"
"    ** (KeyError) key :three not found\n"
"\n"
"## マップを扱うモジュール\n"
"\n"
"このモジュールは、マップに特有の操作（キーのアクセス、値の更新など）を実行す"
"る\n"
"関数を提供することを目的としています。 マップをコレクションとしてトラバース\n"
"するには、さまざまなデータ型で動作する`Enum`モジュールを使用する必要が\n"
"あります。\n"
"\n"
"`Kernel`モジュールは、マップで動作するいくつかの関数も提供しています。\n"
"たとえば、マップ内のキーと値の組の数を知るための`Kernel.map_size/1`や\n"
"項がマップであるかどうかを知る`Kernel.is_map/1`などです。\n"

#. TRANSLATORS: def Map.fetch!(map, key)
#: lib/map.ex:236
msgid ""
"Fetches the value for a specific `key` in the given `map`, erroring out if\n"
"`map` doesn't contain `key`.\n"
"\n"
"If `map` contains the given `key`, the corresponding value is returned. If\n"
"`map` doesn't contain `key`, a `KeyError` exception is raised.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Map.fetch!(%{a: 1}, :a)\n"
"    1\n"
"    iex> Map.fetch!(%{a: 1}, :b)\n"
"    ** (KeyError) key :b not found in: %{a: 1}\n"
"\n"
msgstr ""
"指定された`map`の指定された`key`の値を取得します。\n"
"`map`が`key`を含んでいない場合はエラーを発生します。\n"
"\n"
"`map`が`key`を含んでいる場合は、対応する値が返されます。\n"
"`map`が`key`を含んでいない場合は、`KeyError`例外が発生します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Map.fetch!(%{a: 1}, :a)\n"
"    1\n"
"    iex> Map.fetch!(%{a: 1}, :b)\n"
"    ** (KeyError) key :b not found in: %{a: 1}\n"
"\n"

#. TRANSLATORS: def Map.keys(map)
#: lib/map.ex:99
msgid ""
"Returns all keys from `map`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Map.keys(%{a: 1, b: 2})\n"
"    [:a, :b]\n"
"\n"
msgstr ""
"`map`のすべてのkeyを返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Map.keys(%{a: 1, b: 2})\n"
"    [:a, :b]\n"
"\n"

#. TRANSLATORS: def Map.update!(map, key, fun)
#: lib/map.ex:626
msgid ""
"Updates `key` with the given function.\n"
"\n"
"If `key` is present in `map` with value `value`, `fun` is invoked with\n"
"argument `value` and its result is used as the new value of `key`. If `key` "
"is\n"
"not present in `map`, a `KeyError` exception is raised.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Map.update!(%{a: 1}, :a, &(&1 * 2))\n"
"    %{a: 2}\n"
"\n"
"    iex> Map.update!(%{a: 1}, :b, &(&1 * 2))\n"
"    ** (KeyError) key :b not found in: %{a: 1}\n"
"\n"
msgstr ""
"指定された関数で`key`を更新します。\n"
"\n"
"`map`で`key`が値`value`で存在する場合、`fun`が`value`を引数に\n"
"呼び出され、その結果が`key`の新たな値として使用されます。\n"
"`key`が`map`に存在しない場合は、`KeyError`例外が発生します。\n"
"\n"
"もし`key`が存在しないなら、`KeyError`が上ります。\n"
"\n"
"## 例\n"
"\n"
"    iex> Map.update!(%{a: 1}, :a, &(&1 * 2))\n"
"    %{a: 2}\n"
"\n"
"    iex> Map.update!(%{a: 1}, :b, &(&1 * 2))\n"
"    ** (KeyError) key :b not found in: %{a: 1}\n"
"\n"

#. TRANSLATORS: def Map.get_and_update!(map, key, fun)
#: lib/map.ex:706
msgid ""
"Gets the value from `key` and updates it. Raises if there is no `key`.\n"
"\n"
"Behaves exactly like `get_and_update/3`, but raises a `KeyError` exception "
"if\n"
"`key` is not present in `map`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Map.get_and_update!(%{a: 1}, :a, fn current_value ->\n"
"    ...>   {current_value, \"new value!\"}\n"
"    ...> end)\n"
"    {1, %{a: \"new value!\"}}\n"
"\n"
"    iex> Map.get_and_update!(%{a: 1}, :b, fn current_value ->\n"
"    ...>   {current_value, \"new value!\"}\n"
"    ...> end)\n"
"    ** (KeyError) key :b not found in: %{a: 1}\n"
"\n"
"    iex> Map.get_and_update!(%{a: 1}, :a, fn _ ->\n"
"    ...>   :pop\n"
"    ...> end)\n"
"    {1, %{}}\n"
"\n"
msgstr ""
"`key`の値を取得し、更新します。`key`が存在しない場合は例外を発生させます。\n"
"\n"
"`get_and_update/3`とまったく同様にふるまいますが、`key`が`map`に\n"
"存在しない場合、`KeyError`例外を発生させます。\n"
"\n"
"## 例\n"
"\n"
"    iex> Map.get_and_update!(%{a: 1}, :a, fn current_value ->\n"
"    ...>   {current_value, \"new value!\"}\n"
"    ...> end)\n"
"    {1, %{a: \"new value!\"}}\n"
"\n"
"    iex> Map.get_and_update!(%{a: 1}, :b, fn current_value ->\n"
"    ...>   {current_value, \"new value!\"}\n"
"    ...> end)\n"
"    ** (KeyError) key :b not found in: %{a: 1}\n"
"\n"
"    iex> Map.get_and_update!(%{a: 1}, :a, fn _ ->\n"
"    ...>   :pop\n"
"    ...> end)\n"
"    {1, %{}}\n"
"\n"

#. TRANSLATORS: def Map.split(map, keys)
#: lib/map.ex:587
msgid ""
"Takes all entries corresponding to the given `keys` in `maps` and extracts\n"
"them into a separate map.\n"
"\n"
"Returns a tuple with the new map and the old map with removed keys.\n"
"\n"
"Keys for which there are no entries in `map` are ignored.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Map.split(%{a: 1, b: 2, c: 3}, [:a, :c, :e])\n"
"    {%{a: 1, c: 3}, %{b: 2}}\n"
"\n"
msgstr ""
"指定された`map`の`key`に対応するすべてのエントリを取り出し、それらを\n"
"独立したマップに抽出します。\n"
"\n"
"新しいマップおよび削除されたキーを持つ古いマップを持つ2要素のタプルを返しま"
"す。\n"
"\n"
"`map`にエントリが存在しないキーは無視されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> Map.split(%{a: 1, b: 2, c: 3}, [:a, :c, :e])\n"
"    {%{a: 1, c: 3}, %{b: 2}}\n"
"\n"

#. TRANSLATORS: def Map.delete(map, key)
#: lib/map.ex:416
msgid ""
"Deletes the entry in `map` for a specific `key`.\n"
"\n"
"If the `key` does not exist, returns `map` unchanged.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Map.delete(%{a: 1, b: 2}, :a)\n"
"    %{b: 2}\n"
"    iex> Map.delete(%{b: 2}, :a)\n"
"    %{b: 2}\n"
"\n"
msgstr ""
"指定された`key`のマップエントリを削除します。\n"
"\n"
"`key`が存在しない場合、未変更のマップを返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Map.delete(%{a: 1, b: 2}, :a)\n"
"    %{b: 2}\n"
"    iex> Map.delete(%{b: 2}, :a)\n"
"    %{b: 2}\n"
"\n"

#. TRANSLATORS: def Map.to_list(map)
#: lib/map.ex:123
msgid ""
"Converts `map` to a list.\n"
"\n"
"Each key-value pair in the map is converted to a two-element tuple `{key,\n"
"value}` in the resulting list.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Map.to_list(%{a: 1})\n"
"    [a: 1]\n"
"    iex> Map.to_list(%{1 => 2})\n"
"    [{1, 2}]\n"
"\n"
msgstr ""
"`map`をリストに変換します。\n"
"\n"
"マップ中のキーと値の組は結果リスト中では2要素タプル`{key, value}`に\n"
"変換されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> Map.to_list(%{a: 1})\n"
"    [a: 1]\n"
"    iex> Map.to_list(%{1 => 2})\n"
"    [{1, 2}]\n"
"\n"

#. TRANSLATORS: def Map.from_struct(struct)
#: lib/map.ex:749
msgid ""
"Converts a `struct` to map.\n"
"\n"
"It accepts the struct module or a struct itself and\n"
"simply removes the `__struct__` field from the given struct\n"
"or from a new struct generated from the given module.\n"
"\n"
"## Example\n"
"\n"
"    defmodule User do\n"
"      defstruct [:name]\n"
"    end\n"
"\n"
"    Map.from_struct(User)\n"
"    #=> %{name: nil}\n"
"\n"
"    Map.from_struct(%User{name: \"john\"})\n"
"    #=> %{name: \"john\"}\n"
"\n"
msgstr ""
"`struct`をマップに変換します。\n"
"\n"
"構造体モジュールまたは構造体自身を受け付け、\n"
"指定された構造体、または指定されたモジュールから生成した新たな\n"
"構造体から、`__struct__`フィールドを単に取り除きます。\n"
"\n"
"## 例\n"
"\n"
"    defmodule User do\n"
"      defstruct [:name]\n"
"    end\n"
"\n"
"    Map.from_struct(User)\n"
"    #=> %{name: nil}\n"
"\n"
"    Map.from_struct(%User{name: \"john\"})\n"
"    #=> %{name: \"john\"}\n"
"\n"

#. TRANSLATORS: def Map.equal?(map1, map2)
#: lib/map.ex:778
msgid ""
"Checks if two maps are equal.\n"
"\n"
"Two maps are considered to be equal if they contain\n"
"the same keys and those keys contain the same values.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Map.equal?(%{a: 1, b: 2}, %{b: 2, a: 1})\n"
"    true\n"
"    iex> Map.equal?(%{a: 1, b: 2}, %{b: 1, a: 2})\n"
"    false\n"
"\n"
msgstr ""
"二つのマップが等しいかチェックします。\n"
"\n"
"二つのマップは、両者が同じキーを持ち、それらのキーが同じ値を\n"
"持っている場合、等しいとみなされます。\n"
"\n"
"## 例\n"
"\n"
"    iex> Map.equal?(%{a: 1, b: 2}, %{b: 2, a: 1})\n"
"    true\n"
"    iex> Map.equal?(%{a: 1, b: 2}, %{b: 1, a: 2})\n"
"    false\n"
"\n"

#. TRANSLATORS: def Map.pop(map, key, default \\ nil)
#: lib/map.ex:501
msgid ""
"Returns and removes the value associated with `key` in `map`.\n"
"\n"
"If `key` is present in `map` with value `value`, `{value, new_map}` is\n"
"returned where `new_map` is the result of removing `key` from `map`. If "
"`key`\n"
"is not present in `map`, `{default, map}` is returned.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Map.pop(%{a: 1}, :a)\n"
"    {1, %{}}\n"
"    iex> Map.pop(%{a: 1}, :b)\n"
"    {nil, %{a: 1}}\n"
"    iex> Map.pop(%{a: 1}, :b, 3)\n"
"    {3, %{a: 1}}\n"
"\n"
msgstr ""
"`map`の`key`に関連付けられた返して、削除します。\n"
"\n"
"`map`に値`value`を持つ`key`が存在する場合、`{value, new_map}`が\n"
"返されます。ここで`new_map`は`map`から`key`を削除した結果です。\n"
"`key`が`map`に存在しない場合は、`{default, map}`が返されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> Map.pop(%{a: 1}, :a)\n"
"    {1, %{}}\n"
"    iex> Map.pop(%{a: 1}, :b)\n"
"    {nil, %{a: 1}}\n"
"    iex> Map.pop(%{a: 1}, :b, 3)\n"
"    {3, %{a: 1}}\n"
"\n"

#. TRANSLATORS: def Map.put(map, key, value)
#: lib/map.ex:400
msgid ""
"Puts the given `value` under `key` in `map`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Map.put(%{a: 1}, :b, 2)\n"
"    %{a: 1, b: 2}\n"
"    iex> Map.put(%{a: 1, b: 2}, :a, 3)\n"
"    %{a: 3, b: 2}\n"
"\n"
msgstr ""
"`map`の`key`に指定された`value`を置きます。\n"
"\n"
"## 例\n"
"\n"
"    iex> Map.put(%{a: 1}, :b, 2)\n"
"    %{a: 1, b: 2}\n"
"    iex> Map.put(%{a: 1, b: 2}, :a, 3)\n"
"    %{a: 3, b: 2}\n"
"\n"

#. TRANSLATORS: def Map.take(map, keys)
#: lib/map.ex:308
msgid ""
"Returns a new map with all the key-value pairs in `map` where the key\n"
"is in `keys`.\n"
"\n"
"If `keys` contains keys that are not in `map`, they're simply ignored.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Map.take(%{a: 1, b: 2, c: 3}, [:a, :c, :e])\n"
"    %{a: 1, c: 3}\n"
"\n"
msgstr ""
"キーが`keys`に含まれている、`map`のすべてのキーと値の組を持つ\n"
"新たなマップを返します。\n"
"`keys`が`map`にないキーを含んでいる場合、それらは単に無視されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> Map.take(%{a: 1, b: 2, c: 3}, [:a, :c, :e])\n"
"    %{a: 1, c: 3}\n"
"\n"

#. TRANSLATORS: def Map.new(enumerable, transform)
#: lib/map.ex:177
msgid ""
"Creates a map from an `enumerable` via the given transformation function.\n"
"\n"
"Duplicated keys are removed; the latest one prevails.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Map.new([:a, :b], fn x -> {x, x} end)\n"
"    %{a: :a, b: :b}\n"
"\n"
msgstr ""
"指定された変換関数により`enumerable`からマップを作成します。\n"
"\n"
"重複したキーは除去され、 最後のものが優先されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> Map.new([:a, :b], fn x -> {x, x} end)\n"
"    %{a: :a, b: :b}\n"
"\n"

#. TRANSLATORS: def Map.fetch(map, key)
#: lib/map.ex:219
msgid ""
"Fetches the value for a specific `key` in the given `map`.\n"
"\n"
"If `map` contains the given `key` with value `value`, then `{:ok, value}` "
"is\n"
"returned. If `map` doesn't contain `key`, `:error` is returned.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Map.fetch(%{a: 1}, :a)\n"
"    {:ok, 1}\n"
"    iex> Map.fetch(%{a: 1}, :b)\n"
"    :error\n"
"\n"
msgstr ""
"指定された`map`の指定された`key`の値を取得します。\n"
"\n"
"`map`が指定された`key`を含んでいる場合は、 `{:ok, value}`が返されます。\n"
"`map`が`key`を含んでいない場合は、`:error` が返されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> Map.fetch(%{a: 1}, :a)\n"
"    {:ok, 1}\n"
"    iex> Map.fetch(%{a: 1}, :b)\n"
"    :error\n"
"\n"

#. TRANSLATORS: def Map.values(map)
#: lib/map.ex:111
msgid ""
"Returns all values from `map`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Map.values(%{a: 1, b: 2})\n"
"    [1, 2]\n"
"\n"
msgstr ""
"`map`のすべての値を返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Map.values(%{a: 1, b: 2})\n"
"    [1, 2]\n"
"\n"

#~ msgid ""
#~ "A set of functions for working with maps.\n"
#~ "\n"
#~ "Maps are key-value stores where keys can be any value and\n"
#~ "are compared using the match operator (`===`). Maps can be\n"
#~ "created with the `%{}` special form defined in the\n"
#~ "`Kernel.SpecialForms` module.\n"
#~ msgstr ""
#~ "マップで動作する一群の関数です。\n"
#~ "\n"
#~ "マップは、キーをマッチオペレータ(`===`)で比較する、\n"
#~ "キーバリューストアです。マップは、\n"
#~ "`Kernel.SpecilForms`で定義された`%{}`スペシャルフォームで、\n"
#~ "作成することができます\n"

#~ msgid "Updates the value in the map with the given function.\n"
#~ msgstr "mapの値を与えられた関数で更新します。\n"

#~ msgid "Returns a new empty map.\n"
#~ msgstr "新しい空のマップを返します。\n"

#~ msgid ""
#~ "Gets a value and updates a map only if the key exists in one operation.\n"
#~ msgstr ""
#~ "一度のオペレーションで存在するkeyの値の取得と\n"
#~ "更新を行います。\n"

#~ msgid "Gets a value and updates a map in one operation.\n"
#~ msgstr "一度のオペレーションで値の取得と更新を行います。\n"
