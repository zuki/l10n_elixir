msgid ""
msgstr ""
"Project-Id-Version: l 10n_elixir\n"
"PO-Revision-Date: 2017-03-13 19:03+0900\n"
"Last-Translator: 小田 照敬 <EMAIL@ADDRESS>\n"
"Language-Team: Japanese\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"POT-Creation-Date: \n"
"X-Generator: Poedit 1.8.12\n"

#. TRANSLATORS: def Module.defines?(module, tuple, kind)
#: lib/module.ex:731
msgid ""
"Checks if the module defines a function or macro of the\n"
"given `kind`.\n"
"\n"
"`kind` can be any of `:def`, `:defp`, `:defmacro` or `:defmacrop`.\n"
"\n"
"## Examples\n"
"\n"
"    defmodule Example do\n"
"      Module.defines? __MODULE__, {:version, 0}, :defp #=> false\n"
"      def version, do: 1\n"
"      Module.defines? __MODULE__, {:version, 0}, :defp #=> false\n"
"    end\n"
"\n"
msgstr ""
"モジュールが指定した`kind`の関数またはマクロを定義しているかチェックしま"
"す。\n"
"\n"
"`kind`は、`:def`、`:defp`、`:defmacro`、`:defmacrop`のいずれかです。\n"
"\n"
"## 例\n"
"\n"
"    defmodule Example do\n"
"      Module.defines? __MODULE__, {:version, 0}, :defp #=> false\n"
"      def version, do: 1\n"
"      Module.defines? __MODULE__, {:version, 0}, :defp #=> false\n"
"    end\n"
"\n"

#. TRANSLATORS: def Module.safe_concat(list)
#: lib/module.ex:515
msgid ""
"Concatenates a list of aliases and returns a new alias only if the alias\n"
"was already referenced.\n"
"\n"
"If the alias was not referenced yet, fails with `ArgumentError`.\n"
"It handles charlists, binaries and atoms.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Module.safe_concat([Module, Unknown])\n"
"    ** (ArgumentError) argument error\n"
"\n"
"    iex> Module.safe_concat([List, Chars])\n"
"    List.Chars\n"
"\n"
msgstr ""
"エイリアスのリストを連結し、それが既に参照されている場合に限り、新し\n"
"いエイリアスを返します。\n"
"\n"
"エイリアスがまだ参照されていない場合は、`ArgumentError`で\n"
"失敗します。文字のリスト、バイナリ、アトムを指定できます。\n"
"\n"
"## Examples\n"
"\n"
"    iex> Module.safe_concat([Module, Unknown])\n"
"    ** (ArgumentError) argument error\n"
"\n"
"    iex> Module.safe_concat([List, Chars])\n"
"    List.Chars\n"
"\n"

#. TRANSLATORS: def Module.eval_quoted(module_or_env, quoted, binding \\ [], opts \\ [])
#: lib/module.ex:382
msgid ""
"Evaluates the quoted contents in the given module's context.\n"
"\n"
"A list of environment options can also be given as argument.\n"
"See `Code.eval_string/3` for more information.\n"
"\n"
"Raises an error if the module was already compiled.\n"
"\n"
"## Examples\n"
"\n"
"    defmodule Foo do\n"
"      contents = quote do: (def sum(a, b), do: a + b)\n"
"      Module.eval_quoted __MODULE__, contents\n"
"    end\n"
"\n"
"    Foo.sum(1, 2) #=> 3\n"
"\n"
"For convenience, you can pass any `Macro.Env` struct, such\n"
"as  `__ENV__/0`, as the first argument or as options. Both\n"
"the module and all options will be automatically extracted\n"
"from the environment:\n"
"\n"
"    defmodule Foo do\n"
"      contents = quote do: (def sum(a, b), do: a + b)\n"
"      Module.eval_quoted __ENV__, contents\n"
"    end\n"
"\n"
"    Foo.sum(1, 2) #=> 3\n"
"\n"
"Note that if you pass a `Macro.Env` struct as first argument\n"
"while also passing `opts`, they will be merged with `opts`\n"
"having precedence.\n"
msgstr ""
"指定したモジュールのコンテキストでquoteされたコンテンツを評価します。\n"
"\n"
"環境オプションのリストも引数として指定することができます。\n"
"詳細は、`Code.eval_string/3`を参照してください。\n"
"\n"
"モジュールがコンパイル済みの場合はエラーを発生させます。\n"
"\n"
"## 例\n"
"\n"
"    defmodule Foo do\n"
"      contents = quote do: (def sum(a, b), do: a + b)\n"
"      Module.eval_quoted __MODULE__, contents\n"
"    end\n"
"\n"
"    Foo.sum(1, 2) #=> 3\n"
"\n"
"便宜上、`__ENV__/0`などの任意の`Macro.Env`を第1引数またはオプションとして\n"
"渡すことができます。この場合、モジュールとすべてのオプションが環境から自動的"
"に\n"
"抽出されます。\n"
"\n"
"    defmodule Foo do\n"
"      contents = quote do: (def sum(a, b), do: a + b)\n"
"      Module.eval_quoted __MODULE__, contents, [], __ENV__\n"
"    end\n"
"\n"
"    Foo.sum(1, 2) #=> 3\n"
"\n"
"`Macro.Env`構造体を第1引数として渡し、さらに`opts`も渡した場合、\n"
"`opts`が優先されて`opts`にマージされることに注意してください。\n"

#. TRANSLATORS: def Module.definitions_in(module, kind)
#: lib/module.ex:772
msgid ""
"Returns all functions defined in `module`, according\n"
"to its kind.\n"
"\n"
"## Examples\n"
"\n"
"    defmodule Example do\n"
"      def version, do: 1\n"
"      Module.definitions_in __MODULE__, :def  #=> [{:version, 0}]\n"
"      Module.definitions_in __MODULE__, :defp #=> []\n"
"    end\n"
"\n"
msgstr ""
"`module`で定義されている、指定した種別のすべての関数を返します。\n"
"\n"
"## 例\n"
"\n"
"    defmodule Example do\n"
"      def version, do: 1\n"
"      Module.definitions_in __MODULE__, :def  #=> [{:version,0}]\n"
"      Module.definitions_in __MODULE__, :defp #=> []\n"
"    end\n"
"\n"

#. TRANSLATORS: def Module.safe_concat(left, right)
#: lib/module.ex:536
msgid ""
"Concatenates two aliases and returns a new alias only if the alias was\n"
"already referenced.\n"
"\n"
"If the alias was not referenced yet, fails with `ArgumentError`.\n"
"It handles charlists, binaries and atoms.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Module.safe_concat(Module, Unknown)\n"
"    ** (ArgumentError) argument error\n"
"\n"
"    iex> Module.safe_concat(List, Chars)\n"
"    List.Chars\n"
"\n"
msgstr ""
"2つのエイリアスを連結し、それが既に参照されている場合に限り、新し\n"
"いエイリアスを返します。\n"
"\n"
"エイリアスがまだ参照されていない場合は、`ArgumentError`で\n"
"失敗します。文字のリスト、バイナリ、アトムを指定できます。\n"
"\n"
"## 例\n"
"\n"
"    iex> Module.safe_concat(Module, Unknown)\n"
"    ** (ArgumentError) argument error\n"
"\n"
"    iex> Module.safe_concat(List, Chars)\n"
"    List.Chars\n"
"\n"

#. TRANSLATORS: def Module.__info__(kind)
#: lib/module.ex:354
msgid ""
"Provides runtime information about functions and macros defined by the\n"
"module, enables docstring extraction, etc.\n"
"\n"
"Each module gets an `__info__/1` function when it's compiled. The function\n"
"takes one of the following atoms:\n"
"\n"
"  * `:functions`  - keyword list of public functions along with their "
"arities\n"
"\n"
"  * `:macros`     - keyword list of public macros along with their arities\n"
"\n"
"  * `:module`     - module name (`Module == Module.__info__(:module)`)\n"
"\n"
"In addition to the above, you may also pass to `__info__/1` any atom "
"supported\n"
"by `:erlang.module_info/0` which also gets defined for each compiled "
"module.\n"
"\n"
"For a list of supported attributes and more information, see [Modules – "
"Erlang Reference Manual](http://www.erlang.org/doc/reference_manual/modules."
"html#id77056).\n"
msgstr ""
"モジュールで定義された関数とマクロに関する実行時情報を提供し、\n"
"ドキュメント文字列の抽出などを可能にします。\n"
"\n"
"各モジュールはコンパイル時に`__info__/1`関数を取得します。\n"
"この関数は以下のアトムのいずれかを引数として取ります:\n"
"\n"
"  * `:functions`  -  公開関数とそのアリティのキーワードリスト\n"
"\n"
"  * `:macros`     -  公開マクロとそのアリティのキーワードリスト\n"
"\n"
"  * `:module`     -  モジュール名 (`Module == Module.__info__(:module)`)\n"
"\n"
"これらに加えて、これもコンパイルされた各モジュール毎に定義される\n"
"`:erlang.module_info/0`関数でサポートされる任意のアトムを\n"
"`__info__/1`に渡すこともできます。\n"
"\n"
"サポートされる属性やその他の詳細は、\n"
"[モジュール – Erlangレファレンスマニュアル](http://www.erlang.org/doc/"
"reference_manual/modules.html#id77056)\n"
"を参照してください。\n"

#. TRANSLATORS: def Module.get_attribute(module, key)
#: lib/module.ex:858
msgid ""
"Gets the given attribute from a module.\n"
"\n"
"If the attribute was marked with `accumulate` with\n"
"`Module.register_attribute/3`, a list is always returned.\n"
"`nil` is returned if the attribute has not been marked with\n"
"`accumulate` and has not been set to any value.\n"
"\n"
"The `@` macro compiles to a call to this function. For example,\n"
"the following code:\n"
"\n"
"    @foo\n"
"\n"
"Expands to something akin to:\n"
"\n"
"    Module.get_attribute(__MODULE__, :foo)\n"
"\n"
"## Examples\n"
"\n"
"    defmodule Foo do\n"
"      Module.put_attribute __MODULE__, :value, 1\n"
"      Module.get_attribute __MODULE__, :value #=> 1\n"
"\n"
"      Module.register_attribute __MODULE__, :value, accumulate: true\n"
"      Module.put_attribute __MODULE__, :value, 1\n"
"      Module.get_attribute __MODULE__, :value #=> [1]\n"
"    end\n"
"\n"
msgstr ""
"モジュールから指定した属性を取得します。\n"
"\n"
"属性が`Module.register_attribute/3`で`accumulate`とマークされて\n"
"いる場合、リストが常に返されます。属性が`accumulate`とマークされて\n"
"おらず、値がセットされていない場合は`nil`が返ります。\n"
"\n"
"`@`マクロはこの関数の呼び出しにコンパイルします。\n"
"たとえば、以下のコードは:\n"
"\n"
"    @foo\n"
"\n"
"以下のように展開されます:\n"
"\n"
"    Module.get_attribute(__MODULE__, :foo)\n"
"\n"
"## 例\n"
"\n"
"    defmodule Foo do\n"
"      Module.put_attribute __MODULE__, :value, 1\n"
"      Module.get_attribute __MODULE__, :value #=> 1\n"
"\n"
"      Module.register_attribute __MODULE__, :value, accumulate: true\n"
"      Module.put_attribute __MODULE__, :value, 1\n"
"      Module.get_attribute __MODULE__, :value #=> [1]\n"
"    end\n"
"\n"

#. TRANSLATORS: def Module.make_overridable(module, tuples)
#: lib/module.ex:791
msgid ""
"Makes the given functions in `module` overridable.\n"
"\n"
"An overridable function is lazily defined, allowing a\n"
"developer to customize it. See `Kernel.defoverridable/1` for\n"
"more information and documentation.\n"
msgstr ""
"`module`の指定した関数を上書き可能にします。\n"
"\n"
"上書き可能な関数は定義が遅延され、カスタマイズすることが可能になります。\n"
"詳細については、`Kernel.defoverridable/1` を参照してください。\n"

#. TRANSLATORS: def Module.register_attribute(module, new, opts)
#: lib/module.ex:920
msgid ""
"Registers an attribute.\n"
"\n"
"By registering an attribute, a developer is able to customize\n"
"how Elixir will store and accumulate the attribute values.\n"
"\n"
"## Options\n"
"\n"
"When registering an attribute, two options can be given:\n"
"\n"
"  * `:accumulate` - several calls to the same attribute will\n"
"    accumulate instead of override the previous one. New attributes\n"
"    are always added to the top of the accumulated list.\n"
"\n"
"  * `:persist` - the attribute will be persisted in the Erlang\n"
"    Abstract Format. Useful when interfacing with Erlang libraries.\n"
"\n"
"By default, both options are `false`.\n"
"\n"
"## Examples\n"
"\n"
"    defmodule MyModule do\n"
"      Module.register_attribute __MODULE__,\n"
"        :custom_threshold_for_lib,\n"
"        accumulate: true, persist: false\n"
"\n"
"      @custom_threshold_for_lib 10\n"
"      @custom_threshold_for_lib 20\n"
"      @custom_threshold_for_lib #=> [20, 10]\n"
"    end\n"
"\n"
msgstr ""
"属性を登録します。\n"
"\n"
"属性を登録することにより、Elixirが属性の値を格納および蓄積する\n"
"方法をカスタマイズすることができます。\n"
"\n"
"## オプション\n"
"\n"
"属性を登録する際には、次の2つのオプションを指定できます。\n"
"\n"
"  * `:accumulate` - 同じ属性を繰り返し呼び出した場合、\n"
"     以前の値を上書きするのではなく、累積します。新たな属性は\n"
"     常に累積リストの先頭に追加されます。\n"
"\n"
"  * `:persist` - 属性がErlang Abstract Formatで保存されます。\n"
"     Erlangライブラリを使用する際に役立ちます。\n"
"\n"
"デフォルトでは両オプションは`false`です。\n"
"\n"
"## 例\n"
"\n"
"    defmodule MyModule do\n"
"      Module.register_attribute __MODULE__,\n"
"        :custom_threshold_for_lib,\n"
"        accumulate: true, persist: false\n"
"\n"
"      @custom_threshold_for_lib 10\n"
"      @custom_threshold_for_lib 20\n"
"      @custom_threshold_for_lib #=> [20, 10]\n"
"    end\n"
"\n"

#. TRANSLATORS: def Module.concat(left, right)
#: lib/module.ex:498
msgid ""
"Concatenates two aliases and returns a new alias.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Module.concat(Foo, Bar)\n"
"    Foo.Bar\n"
"\n"
"    iex> Module.concat(Foo, \"Bar\")\n"
"    Foo.Bar\n"
"\n"
msgstr ""
"2つのエイリアスを連結し、新しいエイリアスを返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Module.concat(Foo, Bar)\n"
"    Foo.Bar\n"
"\n"
"    iex> Module.concat(Foo, \"Bar\")\n"
"    Foo.Bar\n"
"\n"

#. TRANSLATORS: def Module.definitions_in(module)
#: lib/module.ex:755
msgid ""
"Returns all functions defined in `module`.\n"
"\n"
"## Examples\n"
"\n"
"    defmodule Example do\n"
"      def version, do: 1\n"
"      Module.definitions_in __MODULE__ #=> [{:version, 0}]\n"
"    end\n"
"\n"
msgstr ""
"`module`で定義されているすべての関数を返します。\n"
"\n"
"## 例\n"
"\n"
"    defmodule Example do\n"
"      def version, do: 1\n"
"      Module.definitions_in __MODULE__ #=> [{:version,0}]\n"
"    end\n"
"\n"

#. TRANSLATORS: def Module.delete_attribute(module, key)
#: lib/module.ex:892
msgid ""
"Deletes the module attribute that matches the given key.\n"
"\n"
"It returns the deleted attribute value (or `nil` if nothing was set).\n"
"\n"
"## Examples\n"
"\n"
"    defmodule MyModule do\n"
"      Module.put_attribute __MODULE__, :custom_threshold_for_lib, 10\n"
"      Module.delete_attribute __MODULE__, :custom_threshold_for_lib\n"
"    end\n"
"\n"
msgstr ""
"指定したキーにマッチする属性を削除します。\n"
"\n"
"削除した属性の値（セットされていない場合は`nil`）を返します。\n"
"\n"
"## 例\n"
"\n"
"    defmodule MyModule do\n"
"      Module.put_attribute __MODULE__, :custom_threshold_for_lib, 10\n"
"      Module.delete_attribute __MODULE__, :custom_threshold_for_lib\n"
"    end\n"
"\n"

#. TRANSLATORS: def Module.overridable?(module, tuple)
#: lib/module.ex:836
msgid "Returns `true` if `tuple` in `module` is marked as overridable.\n"
msgstr ""
"`module`の`tuple`が上書き可能であるとマークされている場合、\n"
"`true`を返します。\n"

#. TRANSLATORS: def Module.put_attribute(module, key, value)
#: lib/module.ex:843
msgid ""
"Puts a module attribute with key and value in the given module.\n"
"\n"
"## Examples\n"
"\n"
"    defmodule MyModule do\n"
"      Module.put_attribute __MODULE__, :custom_threshold_for_lib, 10\n"
"    end\n"
"\n"
msgstr ""
"指定したモジュールに指定のキーと値を持つモジュール属性を追加します。\n"
"\n"
"## 例\n"
"\n"
"    defmodule MyModule do\n"
"      Module.put_attribute __MODULE__, :custom_threshold_for_lib, 10\n"
"    end\n"
"\n"

#. TRANSLATORS: def Module.open?(module)
#: lib/module.ex:374
msgid ""
"Checks if a module is open, i.e. it is currently being defined\n"
"and its attributes and functions can be modified.\n"
msgstr ""
"モジュールがオープンされているか、すなわち、モジュールが\n"
"現在定義中であり、その属性や関数が変更可能であるかをチェックします。\n"

#. TRANSLATORS: def Module.create(module, quoted, opts)
#: lib/module.ex:433
msgid ""
"Creates a module with the given name and defined by\n"
"the given quoted expressions.\n"
"\n"
"The line where the module is defined and its file **must**\n"
"be passed as options.\n"
"\n"
"## Examples\n"
"\n"
"    contents =\n"
"      quote do\n"
"        def world, do: true\n"
"      end\n"
"\n"
"    Module.create(Hello, contents, Macro.Env.location(__ENV__))\n"
"\n"
"    Hello.world #=> true\n"
"\n"
"## Differences from `defmodule`\n"
"\n"
"`Module.create/3` works similarly to `defmodule` and\n"
"return the same results. While one could also use\n"
"`defmodule` to define modules dynamically, this\n"
"function is preferred when the module body is given\n"
"by a quoted expression.\n"
"\n"
"Another important distinction is that `Module.create/3`\n"
"allows you to control the environment variables used\n"
"when defining the module, while `defmodule` automatically\n"
"shares the same environment.\n"
msgstr ""
"指定した名前と指定したquoteされた式で定義されるモジュールを\n"
"作成します。\n"
"\n"
"モジュールが定義された行とそのファイル名をオプションとして\n"
"渡さなければ**なりません**。\n"
"\n"
"## 例\n"
"\n"
"    contents =\n"
"      quote do\n"
"        def world, do: true\n"
"      end\n"
"\n"
"    Module.create(Hello, contents, Macro.Env.location(__ENV__))\n"
"\n"
"    Hello.world #=> true\n"
"\n"
"## `defmodule`との相違点\n"
"\n"
"`Module.create/3`は、`defmodule`と似た働きをし、同じ結果を返します。\n"
"モジュールを動的に定義するために`defmodule`を使うこともできますが、\n"
"モジュール本体がquoteされた式により与えられる場合はこの関数が好まれます。\n"
"\n"
"もう一つの重要な違いは、`Module.create/3`はモジュールを定義する際に\n"
"使用される環境変数を制御できますが、`defmodule`は自動的に同じ環境を\n"
"共有します。\n"

#. TRANSLATORS: def Module.add_doc(module, line, kind, tuple, signature \\ [], doc)
#: lib/module.ex:557
msgid ""
"Attaches documentation to a given function or type.\n"
"\n"
"It expects the module the function/type belongs to, the line (a non\n"
"negative integer), the kind (`def` or `defmacro`), a tuple representing\n"
"the function and its arity, the function signature (the signature\n"
"should be omitted for types) and the documentation, which should\n"
"be either a binary or a boolean.\n"
"\n"
"## Examples\n"
"\n"
"    defmodule MyModule do\n"
"      Module.add_doc(__MODULE__, __ENV__.line + 1, :def, {:version, 0}, [], "
"\"Manually added docs\")\n"
"      def version, do: 1\n"
"    end\n"
"\n"
msgstr ""
"指定した関数または型にドキュメントを与えます。\n"
"\n"
"関数/型が属するモジュール、定義行(非負の整数)、種類(`def`または"
"`defmacro`)、\n"
"関数とアリティを表すタプル、関数のシグネチャ（型ではシグネチャは省略）、\n"
"ドキュメント（バイナリまたは論理値）を引数に取ります。\n"
"\n"
"## 例\n"
"\n"
"    defmodule MyModule do\n"
"      Module.add_doc(__MODULE__, __ENV__.line + 1, :def, {:version, 0}, [], "
"\"Manually added docs\")\n"
"      def version, do: 1\n"
"    end\n"
"\n"

#. TRANSLATORS: def Module.concat(list)
#: lib/module.ex:481
msgid ""
"Concatenates a list of aliases and returns a new alias.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Module.concat([Foo, Bar])\n"
"    Foo.Bar\n"
"\n"
"    iex> Module.concat([Foo, \"Bar\"])\n"
"    Foo.Bar\n"
"\n"
msgstr ""
"エイリアスのリストを連結し、新しいエイリアスを返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Module.concat([Foo, Bar])\n"
"    Foo.Bar\n"
"\n"
"    iex> Module.concat([Foo, \"Bar\"])\n"
"    Foo.Bar\n"
"\n"

#. TRANSLATORS: def Module.split(module)
#: lib/module.ex:969
msgid ""
"Splits the given module name into binary parts.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Module.split Very.Long.Module.Name.And.Even.Longer\n"
"    [\"Very\", \"Long\", \"Module\", \"Name\", \"And\", \"Even\", \"Longer"
"\"]\n"
"\n"
msgstr ""
"指定したモジュール名をバイナリパーツに分割します。\n"
"\n"
"## 例\n"
"\n"
"    Module.split Very.Long.Module.Name.And.Even.Longer\n"
"    #=> [\"Very\", \"Long\", \"Module\", \"Name\", \"And\", \"Even\", "
"\"Longer\"]\n"
"\n"

#. TRANSLATORS: def Module.defines?(module, tuple)
#: lib/module.ex:711
msgid ""
"Checks if the module defines the given function or macro.\n"
"\n"
"Use `defines?/3` to assert for a specific type.\n"
"\n"
"## Examples\n"
"\n"
"    defmodule Example do\n"
"      Module.defines? __MODULE__, {:version, 0} #=> false\n"
"      def version, do: 1\n"
"      Module.defines? __MODULE__, {:version, 0} #=> true\n"
"    end\n"
"\n"
msgstr ""
"モジュールが指定した関数またはマクロを定義しているかチェックします。\n"
"\n"
"特定の型のアサートには`defines?/3`を使用してください。\n"
"\n"
"## 例\n"
"\n"
"    defmodule Example do\n"
"      Module.defines? __MODULE__, {:version, 0} #=> false\n"
"      def version, do: 1\n"
"      Module.defines? __MODULE__, {:version, 0} #=> true\n"
"    end\n"
"\n"

#. TRANSLATORS: Elixir.Module Summary
#: lib/module.ex:2
msgid ""
"Provides functions to deal with modules during compilation time.\n"
"\n"
"It allows a developer to dynamically add, delete and register\n"
"attributes, attach documentation and so forth.\n"
"\n"
"After a module is compiled, using many of the functions in\n"
"this module will raise errors, since it is out of their scope\n"
"to inspect runtime data. Most of the runtime data can be inspected\n"
"via the `__info__/1` function attached to each compiled module.\n"
"\n"
"## Module attributes\n"
"\n"
"Each module can be decorated with one or more attributes. The following "
"ones\n"
"are currently defined by Elixir:\n"
"\n"
"### @after_compile\n"
"\n"
"A hook that will be invoked right after the current module is compiled.\n"
"Accepts a module or a tuple `{<module>, <function atom>}`.\n"
"See the \"Compile callbacks\" section below.\n"
"\n"
"### @before_compile\n"
"\n"
"A hook that will be invoked before the module is compiled.\n"
"Accepts a module or a tuple `{<module>, <function/macro atom>}`.\n"
"See the \"Compile callbacks\" section below.\n"
"\n"
"### @behaviour (notice the British spelling)\n"
"\n"
"Behaviours can be referenced by modules to ensure they implement\n"
"required specific function signatures defined by `@callback`.\n"
"\n"
"For example, you can specify the `URI.Parser` behaviour as follows:\n"
"\n"
"    defmodule URI.Parser do\n"
"      @doc \"Defines a default port\"\n"
"      @callback default_port() :: integer\n"
"\n"
"      @doc \"Parses the given URL\"\n"
"      @callback parse(uri_info :: URI.t) :: URI.t\n"
"    end\n"
"\n"
"And then a module may use it as:\n"
"\n"
"    defmodule URI.HTTP do\n"
"      @behaviour URI.Parser\n"
"      def default_port(), do: 80\n"
"      def parse(info), do: info\n"
"    end\n"
"\n"
"If the behaviour changes or `URI.HTTP` does not implement\n"
"one of the callbacks, a warning will be raised.\n"
"\n"
"### @compile\n"
"\n"
"Defines options for module compilation. This is used to configure\n"
"both Elixir and Erlang compilers, as any other compilation pass\n"
"added by external tools. For example:\n"
"\n"
"    defmodule M do\n"
"      @compile {:inline, my_fun: 1}\n"
"\n"
"      def my_fun(arg) do\n"
"        to_string(arg)\n"
"      end\n"
"    end\n"
"\n"
"Multiple uses of `@compile` will accumulate instead of overriding\n"
"previous ones. See the \"Compile options\" section below.\n"
"\n"
"### @doc\n"
"\n"
"Provides documentation for the function or macro that follows the\n"
"attribute.\n"
"\n"
"Accepts a string (often a heredoc) or `false` where `@doc false` will\n"
"make the function/macro invisible to the documentation extraction tools\n"
"like ExDoc. For example:\n"
"\n"
"    defmodule M do\n"
"      @doc \"Hello world\"\n"
"      def hello do\n"
"        \"world\"\n"
"      end\n"
"\n"
"      @doc \"\"\"\n"
"      Sums `a` to `b`.\n"
"      \"\"\"\n"
"      def sum(a, b) do\n"
"        a + b\n"
"      end\n"
"    end\n"
"\n"
"### @dialyzer\n"
"\n"
"Defines warnings to request or suppress when using a version of\n"
"`:dialyzer` that supports module attributes.\n"
"\n"
"Accepts an atom, a tuple, or a list of atoms and tuples. For example:\n"
"\n"
"    defmodule M do\n"
"      @dialyzer {:nowarn_function, my_fun: 1}\n"
"\n"
"      def my_fun(arg) do\n"
"        M.not_a_function(arg)\n"
"      end\n"
"    end\n"
"\n"
"For the list of supported warnings, see\n"
"[`:dialyzer` module](http://www.erlang.org/doc/man/dialyzer.html).\n"
"\n"
"Multiple uses of `@dialyzer` will accumulate instead of overriding\n"
"previous ones.\n"
"\n"
"### @external_resource\n"
"\n"
"Specifies an external resource to the current module.\n"
"\n"
"Many times a module embeds information from an external file. This\n"
"attribute allows the module to annotate which external resources\n"
"have been used.\n"
"\n"
"Tools like Mix may use this information to ensure the module is\n"
"recompiled in case any of the external resources change.\n"
"\n"
"### @file\n"
"\n"
"Changes the filename used in stacktraces for the function or macro that\n"
"follows the attribute, such as:\n"
"\n"
"    defmodule M do\n"
"      @doc \"Hello world\"\n"
"      @file \"hello.ex\"\n"
"      def hello do\n"
"        \"world\"\n"
"      end\n"
"    end\n"
"\n"
"### @moduledoc\n"
"\n"
"Provides documentation for the current module, such as:\n"
"\n"
"    defmodule M do\n"
"      @moduledoc \"\"\"\n"
"      A very useful module\n"
"      \"\"\"\n"
"    end\n"
"\n"
"Accepts a string (which is often a heredoc) or `false` where\n"
"`@moduledoc false` will make the module invisible to the\n"
"documentation extraction tools like ExDoc.\n"
"\n"
"### @on_definition\n"
"\n"
"A hook that will be invoked when each function or macro in the current\n"
"module is defined. Useful when annotating functions.\n"
"\n"
"Accepts a module or a tuple `{<module>, <function atom>}`. See the\n"
"\"Compile callbacks\" section below.\n"
"\n"
"### @on_load\n"
"\n"
"A hook that will be invoked whenever the module is loaded.\n"
"\n"
"Accepts a function atom of a function in the current module. The function\n"
"must have arity 0 (no arguments) and has to return `:ok`, otherwise the\n"
"loading of the module will be aborted. For example:\n"
"\n"
"    defmodule M do\n"
"      @on_load :load_check\n"
"\n"
"      def load_check do\n"
"        if some_condition() do\n"
"          :ok\n"
"        else\n"
"          :abort\n"
"        end\n"
"      end\n"
"\n"
"      def some_condition do\n"
"        false\n"
"      end\n"
"    end\n"
"\n"
"### @vsn\n"
"\n"
"Specify the module version. Accepts any valid Elixir value, for example:\n"
"\n"
"    defmodule M do\n"
"      @vsn \"1.0\"\n"
"    end\n"
"\n"
"### Typespec attributes\n"
"\n"
"The following attributes are part of typespecs and are also reserved by\n"
"Elixir:\n"
"\n"
"  * `@type` - defines a type to be used in `@spec`\n"
"  * `@typep` - defines a private type to be used in `@spec`\n"
"  * `@opaque` - defines an opaque type to be used in `@spec`\n"
"  * `@spec` - provides a specification for a function\n"
"  * `@callback` - provides a specification for a behaviour callback\n"
"  * `@macrocallback` - provides a specification for a macro behaviour "
"callback\n"
"  * `@optional_callbacks` - specifies which behaviour callbacks and macro\n"
"    behaviour callbacks are optional\n"
"\n"
"### Custom attributes\n"
"\n"
"In addition to the built-in attributes outlined above, custom attributes "
"may\n"
"also be added. A custom attribute is any valid identifier prefixed with an\n"
"`@` and followed by a valid Elixir value:\n"
"\n"
"    defmodule M do\n"
"      @custom_attr [some: \"stuff\"]\n"
"    end\n"
"\n"
"For more advanced options available when defining custom attributes, see\n"
"`register_attribute/3`.\n"
"\n"
"## Compile callbacks\n"
"\n"
"There are three callbacks that are invoked when functions are defined,\n"
"as well as before and immediately after the module bytecode is generated.\n"
"\n"
"### @after_compile\n"
"\n"
"A hook that will be invoked right after the current module is compiled.\n"
"\n"
"Accepts a module or a tuple `{<module>, <function atom>}`. The function\n"
"must take two arguments: the module environment and its bytecode.\n"
"When just a module is provided, the function is assumed to be\n"
"`__after_compile__/2`.\n"
"\n"
"#### Example\n"
"\n"
"    defmodule M do\n"
"      @after_compile __MODULE__\n"
"\n"
"      def __after_compile__(env, _bytecode) do\n"
"        IO.inspect env\n"
"      end\n"
"    end\n"
"\n"
"### @before_compile\n"
"\n"
"A hook that will be invoked before the module is compiled.\n"
"\n"
"Accepts a module or a tuple `{<module>, <function/macro atom>}`. The\n"
"function/macro must take one argument: the module environment. If it's a\n"
"macro, its returned value will be injected at the end of the module "
"definition\n"
"before the compilation starts.\n"
"\n"
"When just a module is provided, the function/macro is assumed to be\n"
"`__before_compile__/1`.\n"
"\n"
"Note: unlike `@after_compile`, the callback function/macro must\n"
"be placed in a separate module (because when the callback is invoked,\n"
"the current module does not yet exist).\n"
"\n"
"#### Example\n"
"\n"
"    defmodule A do\n"
"      defmacro __before_compile__(_env) do\n"
"        quote do\n"
"          def hello, do: \"world\"\n"
"        end\n"
"      end\n"
"    end\n"
"\n"
"    defmodule B do\n"
"      @before_compile A\n"
"    end\n"
"\n"
"### @on_definition\n"
"\n"
"A hook that will be invoked when each function or macro in the current\n"
"module is defined. Useful when annotating functions.\n"
"\n"
"Accepts a module or a tuple `{<module>, <function atom>}`. The function\n"
"must take 6 arguments:\n"
"\n"
"  - the module environment\n"
"  - kind: `:def`, `:defp`, `:defmacro`, or `:defmacrop`\n"
"  - function/macro name\n"
"  - list of quoted arguments\n"
"  - list of quoted guards\n"
"  - quoted function body\n"
"\n"
"Note the hook receives the quoted arguments and it is invoked before\n"
"the function is stored in the module. So `Module.defines?/2` will return\n"
"`false` for the first clause of every function.\n"
"\n"
"If the function/macro being defined has multiple clauses, the hook will\n"
"be called for each clause.\n"
"\n"
"Unlike other hooks, `@on_definition` will only invoke functions\n"
"and never macros. This is because the hook is invoked inside the context\n"
"of the function (and nested function definitions are not allowed in\n"
"Elixir).\n"
"\n"
"When just a module is provided, the function is assumed to be\n"
"`__on_definition__/6`.\n"
"\n"
"#### Example\n"
"\n"
"    defmodule H do\n"
"      def on_def(_env, kind, name, args, guards, body) do\n"
"        IO.puts \"Defining #{kind} named #{name} with args:\"\n"
"        IO.inspect args\n"
"        IO.puts \"and guards\"\n"
"        IO.inspect guards\n"
"        IO.puts \"and body\"\n"
"        IO.puts Macro.to_string(body)\n"
"      end\n"
"    end\n"
"\n"
"    defmodule M do\n"
"      @on_definition {H, :on_def}\n"
"\n"
"      def hello(arg) when is_binary(arg) or is_list(arg) do\n"
"        \"Hello\" <> to_string(arg)\n"
"      end\n"
"\n"
"      def hello(_) do\n"
"        :ok\n"
"      end\n"
"    end\n"
"\n"
"## Compile options\n"
"\n"
"The `@compile` attribute accepts diverse options that is used by both\n"
"Elixir and Erlang compilers. Some of the common use cases are documented\n"
"below:\n"
"\n"
"  * `@compile :debug_info` - includes `:debug_info` regardless of the\n"
"    setting in `Code.compiler_options/1`\n"
"\n"
"  * `@compile {:debug_info, false}` - disables `:debug_info` regardless\n"
"    of the setting in `Code.compiler_options/1`\n"
"\n"
"  * `@compile {:inline, some_fun: 2, other_fun: 3}` - inlines the given\n"
"    name/arity pairs\n"
"\n"
"  * `@compile {:autoload, false}` - disables automatic loading of\n"
"    modules after compilation. Instead, the module will be loaded after\n"
"    it is dispatched to\n"
"\n"
"You can see a handful more options used by the Erlang compiler in\n"
"the documentation for the `:compile` module.\n"
msgstr ""
"コンパイル時にモジュールを処理する関数を提供します。\n"
"\n"
"モジュール属性の動的な追加、削除、登録や、ドキュメントの\n"
"添付などを可能にします。\n"
"\n"
"モジュールがコンパイルされた後に、このモジュールの多くの関数を使用すると、\n"
"エラーが発生します。実行時のデータの検査は関数のスコープ外だからです。\n"
"ほとんどの実行時データはコンパイルされた各モジュールに付与される\n"
"`__info__/1`関数を通して検査することができます。\n"
"\n"
"## モジュール属性\n"
"\n"
"各モジュールは1つ以上の属性で装飾することができます。以下はElixirで\n"
"現在、定義されている属性です:\n"
"\n"
"### @after_compile\n"
"\n"
"カレントモジュールがコンパイルされた直後に実行されるフックです。\n"
"モジュール、または、`{<モジュール>, <関数アトム>}`タプルを受け付けます。\n"
"詳細は下の「コンパイルコールバック」セクションを参照してください。\n"
"\n"
"### @before_compile\n"
"\n"
"モジュールがコンパイルされる前に実行されるフックです。\n"
"モジュール、または、`{<モジュール>, <関数またはマクロアトム>}`タプルを\n"
"受け付けます。\n"
"詳細は下の「コンパイルコールバック」セクションを参照してください。\n"
"\n"
"### @behaviour（英国式の綴りであることに注意）\n"
"\n"
"モジュールがビヘイビアを参照することで、@callbackで定義された必須の関数\n"
"シグニチャをモジュールが確実に実装するようにします。\n"
"\n"
"たとえば、URI.Parserビヘイビアを以下のように指定できます。\n"
"\n"
"    defmodule URI.Parser do\n"
"      @doc \"Defines a default port\"\n"
"      @callback default_port() :: integer\n"
"\n"
"      @doc \"Parses the given URL\"\n"
"      @callback parse(uri_info :: URI.t) :: URI.t\n"
"    end\n"
"\n"
"モジュールはこのビヘイビアを次のように使用できます。\n"
"\n"
"    defmodule URI.HTTP do\n"
"      @behaviour URI.Parser\n"
"      def default_port(), do: 80\n"
"      def parse(info), do: info\n"
"    end\n"
"\n"
"ビヘイビアが変更されたり、URI.HTTPがコールバックのすべてを実装していない\n"
"場合は、警告されることになります。\n"
"\n"
"### @compile\n"
"\n"
"モジュールのコンパイルオプションを定義します。これは外部ツールにより\n"
"追加される何らかの他のコンパイルパスとして、ElixirとErlang、双方の\n"
"コンパイラの構成に使用されます。たとえば、\n"
"\n"
"    defmodule M do\n"
"      @compile {:inline, my_fun: 1}\n"
"\n"
"      def my_fun(arg) do\n"
"        to_string(arg)\n"
"      end\n"
"    end\n"
"\n"
"`@compile`を複数回指定した場合は、前の設定を上書きせず\n"
"累積します。下の「コンパイルコールバック」セクションを参照してください。\n"
"\n"
"### @doc\n"
"\n"
"この属性に続く関数またはマクロのドキュメントを提供します。\n"
"\n"
"文字列（通常はヒアドキュメント）または`false`を受け付けます。\n"
"`@doc false`とするとExDocなどのドキュメント抽出ツールから\n"
"関数やマクロを見えなくします。たとえば、\n"
"\n"
"    defmodule M do\n"
"      @doc \"Hello world\"\n"
"      def hello do\n"
"        \"world\"\n"
"      end\n"
"\n"
"      @doc \"\"\"\n"
"      `a` と `b`の合計を求めます。\n"
"      \"\"\"\n"
"      def sum(a, b) do\n"
"        a + b\n"
"      end\n"
"    end\n"
"\n"
"### @dialyzer\n"
"\n"
"モジュール属性をサポートするあるバージョンの`:dialyzer`を使用する際に\n"
"警告の有無を定義します。\n"
"\n"
"アトム、タプル、アトムとタプルのリストを受け付けます。たとえば、\n"
"\n"
"    defmodule M do\n"
"      @dialyzer {:nowarn_function, my_fun: 1}\n"
"\n"
"      def my_fun(arg) do\n"
"        M.not_a_function(arg)\n"
"      end\n"
"    end\n"
"\n"
"サポートされている渓谷のリストは、\n"
"[`:dialyzer`モジュール](http://www.erlang.org/doc/man/dialyzer.html)を\n"
"参照してください。\n"
"\n"
"`@dialyzer`を複数回指定した場合は、前の設定を上書きせず、累積します。\n"
"\n"
"### @external_resource\n"
"\n"
"カレントモジュールに外部リソースを指定します。\n"
"\n"
"多くの場合、モジュールは外部ファイルから情報を取り込みます。\n"
"この属性により、モジュールはどの外部リソースを使ったのか注釈する\n"
"ことができます。\n"
"\n"
"Mixなどのツールは、この情報を使用することで、外部リソースが変更された場合"
"に\n"
"モジュールを確実に再コンパイルすることができます。\n"
"\n"
"### @file\n"
"\n"
"この属性に続く関数またはマクロのスタックトレースで使用されるファイル名を\n"
"変更します。たとえば、\n"
"\n"
"    defmodule M do\n"
"      @doc \"Hello world\"\n"
"      @file \"hello.ex\"\n"
"      def hello do\n"
"        \"world\"\n"
"      end\n"
"    end\n"
"\n"
"### @moduledoc\n"
"\n"
"カレントモジュールのドキュメントを提供します。たとえば、\n"
"\n"
"    defmodule M do\n"
"      @moduledoc \"\"\"\n"
"      非常に便利なモジュール\n"
"      \"\"\"\n"
"    end\n"
"\n"
"文字列（通常はヒアドキュメント）または、`false`を受け付けます。\n"
"`@moduledoc false`とするとExDocなどのドキュメント抽出ツールから\n"
"モジュールを見えなくします。\n"
"\n"
"### @on_definition\n"
"\n"
"カレントモジュールの関数またはマクロが定義される度に実行されるフックです。\n"
"関数を注釈する際に便利です。\n"
"\n"
"モジュール、または、`{<モジュール>, <関数アトム>}`タプルを受け付けます。\n"
"下の「コンパイルコールバック」セクションを参照してください。\n"
"\n"
"### @on_load\n"
"\n"
"モジュールがロードされる度に実行されるフックです。\n"
"\n"
"カレントモジュールの関数の関数アトムを受け付けます。この関数は\n"
"アリティ 0（引数なし）で、`:ok`を返さなければなりません。そうでないと、\n"
"モジュールのローディングは中止されます。たとえば、\n"
"\n"
"    defmodule M do\n"
"      @on_load :load_check\n"
"\n"
"      def load_check do\n"
"        if some_condition() do\n"
"          :ok\n"
"        else\n"
"          :abort\n"
"        end\n"
"      end\n"
"\n"
"      def some_condition do\n"
"        false\n"
"      end\n"
"    end\n"
"\n"
"### @vsn\n"
"\n"
"モジュールのバージョンを指定します。任意の正しいElixirの値を受け付けます。\n"
"たとえば、\n"
"\n"
"    defmodule M do\n"
"      @vsn \"1.0\"\n"
"    end\n"
"\n"
"### 型仕様（Typespec）属性\n"
"\n"
"以下の属性は型仕様の一部であり、Elixirにより予約されています:\n"
"\n"
"  * `@type` - `@spec`で仕様される方を定義する\n"
"  * `@typep` - `@spec`で仕様されるプライベート型を定義する\n"
"  * `@opaque` - `@spec`で仕様されるオパーク型を定義する\n"
"  * `@spec` - 関数の仕様を提供する\n"
"  * `@callback` - ビヘイビアコールバックの仕様を提供する\n"
"  * `@macrocallback` - マクロビヘイビアコールバックの仕様を提供する\n"
"  * `@optional_callbacks` - どのビヘイビアコールバックとマクロビヘイビア\n"
"    コールバックがオプションであるか指定する。\n"
"\n"
"### カスタム属性\n"
"\n"
"上で説明したビルトイン属性に加えて、カスタム属性を追加することもできます。\n"
"カスタム属性は接頭辞`@`を持つ任意の有効な識別子であり、有効なElixir値が続き"
"ます。\n"
"\n"
"    defmodule M do\n"
"      @custom_attr [some: \"stuff\"]\n"
"    end\n"
"\n"
"カスタム属性を停止する際のより高度なオプションについては\n"
"`register_attribute/3`を参照してください。\n"
"\n"
"## コンパイルコールバック\n"
"\n"
"モジュールの定義時、および、モジュールのバイトコードが\n"
"生成される前および生成直後に実行されるコールバックが3つあります。\n"
"\n"
"### @after_compile\n"
"\n"
"現在のモジュールがコンパイルされた直後に実行されるフックです。\n"
"\n"
"モジュール、または、`{<モジュール>, <関数アトム>}`タプルを受け付けます。\n"
"この関数は2つの引数、モジュール環境とモジュールバイトコードを\n"
"とらなければなりません。モジュールのみが提供された場合、この関数は\n"
"`__after_compile__/2`であるとされます。\n"
"\n"
"#### 例\n"
"\n"
"    defmodule M do\n"
"      @after_compile __MODULE__\n"
"\n"
"      def __after_compile__(env, _bytecode) do\n"
"        IO.inspect env\n"
"      end\n"
"    end\n"
"\n"
"### @before_compile\n"
"\n"
"モジュールがコンパイルされる前に実行されるフックです。\n"
"\n"
"モジュール、または、`{<モジュール>, <関数アトムまたはマクロアトム>}`タプル"
"を\n"
"受け付けます。この関数またはマクロは1つの引数、モジュール環境をとらなけれ"
"ば\n"
"なりません。マクロの場合、コンパイルが始まる前にその返り値がモジュール定義"
"の\n"
"最後に注入されます。\n"
"\n"
"モジュールのみが提供された場合、この関数またはマクロは\n"
"`__before_compile__/1`であるとみなされます。\n"
"\n"
"注: `@after_compile`とは異なり、このコールバック関数/マクロは\n"
"別のモジュールに置かれなければなりません（何故なら、このコールバックが\n"
"実行される時には、カレントモジュールはまだ存在していないからです）。\n"
"\n"
"#### 例\n"
"\n"
"    defmodule A do\n"
"      defmacro __before_compile__(_env) do\n"
"        quote do\n"
"          def hello, do: \"world\"\n"
"        end\n"
"      end\n"
"    end\n"
"\n"
"    defmodule B do\n"
"      @before_compile A\n"
"    end\n"
"\n"
"### @on_definition\n"
"\n"
"カレントモジュールの関数またはマクロが定義される度に実行されるフックです。\n"
"関数を注釈する際に便利です。\n"
"\n"
"モジュール、または、`{<モジュール>, <関数アトム>}`タプルを受け付けます。\n"
"この関数は6つの引数を取らなければなりません: \n"
"\n"
"  - モジュール環境\n"
"  - 種類: `:def`, `:defp`, `:defmacro`, または `:defmacrop`\n"
"  - 関数/マクロの名前\n"
"  - quoteされた引数のリスト\n"
"  - quoteされたガードのリスト\n"
"  - quoteされた関数本体\n"
"\n"
"フックは、quoteされた引数を受け取り、関数がモジュールに格納される前に実行\n"
"されることに注意してください。したがって、各関数の最初の節で\n"
"`Module.defines?/2`を実行すると`false`を返します。\n"
"\n"
"定義される関数/マクロが複数の節を保つ場合、フックは各節毎に呼ばれます。\n"
"\n"
"他のフックとは異なり、`@on_definition`は関数のみを実行し、マクロは\n"
"実行しません。これは、フックは関数のコンテキスト内で実行されるからです\n"
"（そして、Elixirではネストした関数定義は許されないからです)。\n"
"\n"
"モジュールのみが提供された場合、、この関数は`__on_definition__/6` であると\n"
"みなされます。\n"
"\n"
"#### 例\n"
"\n"
"    defmodule H do\n"
"      def on_def(_env, kind, name, args, guards, body) do\n"
"        IO.puts \"Defining #{kind} named #{name} with args:\"\n"
"        IO.inspect args\n"
"        IO.puts \"and guards\"\n"
"        IO.inspect guards\n"
"        IO.puts \"and body\"\n"
"        IO.puts Macro.to_string(body)\n"
"      end\n"
"    end\n"
"\n"
"    defmodule M do\n"
"      @on_definition {H, :on_def}\n"
"\n"
"      def hello(arg) when is_binary(arg) or is_list(arg) do\n"
"        \"Hello\" <> to_string(arg)\n"
"      end\n"
"\n"
"      def hello(_) do\n"
"        :ok\n"
"      end\n"
"    end\n"
"\n"
"## コンパイルオプション\n"
"\n"
"`@compile`属性は、ElixirとErlangの両コンパイラで使用される多様な\n"
"オプションを受け付けます。共通で使われるいくつかのオプションを以下に示しま"
"す。\n"
"\n"
"  * `@compile :debug_info` - `Code.compiler_options`の設定に\n"
"    かかわらず、`:debug_info`を含みます\n"
"\n"
"  * `@compile {:debug_info, false}` - `Code.compiler_options`の設定に\n"
"    かかわらず、`:debug_info`を無効にします\n"
"\n"
"  * `@compile {:inline, some_fun: 2, other_fun: 3}` - 指定した\n"
"    関数名/アリティをインライン化します\n"
"\n"
"  * `@compile {:autoload, false}` - コンパイル後の自動ローディングを\n"
"    無効にします。かわりにモジュールは呼ばれたときにロード\n"
"    されます。\n"
"\n"
"Erlangコンパイラで使用される膨大なオプションは`:compile`モジュールの\n"
"ドキュメントで見ることができます。\n"

#~ msgid ""
#~ "Puts an Erlang attribute to the given module with the given\n"
#~ "key and value.\n"
#~ "\n"
#~ "The semantics of putting the attribute depends\n"
#~ "if the attribute was registered or not via `register_attribute/3`.\n"
#~ "\n"
#~ "## Examples\n"
#~ "\n"
#~ "    defmodule MyModule do\n"
#~ "      Module.put_attribute __MODULE__, :custom_threshold_for_lib, 10\n"
#~ "    end\n"
#~ "\n"
#~ msgstr ""
#~ "Erlangアトリビュートを与えられたモジュールに与えられたキーと値でプット\n"
#~ "します。\n"
#~ "\n"
#~ "アトリビュートをプットするセマンティクスは、\n"
#~ "`register_attribute/3`によってアトリビュートが登録されていたか否かに、\n"
#~ "依存します。\n"
#~ "\n"
#~ "## 例\n"
#~ "\n"
#~ "    defmodule MyModule do\n"
#~ "      Module.put_attribute __MODULE__, :custom_threshold_for_lib, 10\n"
#~ "    end\n"
#~ "\n"

#~ msgid ""
#~ "Provides functions to deal with modules during compilation time.\n"
#~ "\n"
#~ "It allows a developer to dynamically add, delete and register\n"
#~ "attributes, attach documentation and so forth.\n"
#~ "\n"
#~ "After a module is compiled, using many of the functions in\n"
#~ "this module will raise errors, since it is out of their scope\n"
#~ "to inspect runtime data. Most of the runtime data can be inspected\n"
#~ "via the `__info__(attr)` function attached to each compiled module.\n"
#~ "\n"
#~ "## Module attributes\n"
#~ "\n"
#~ "Each module can be decorated with one or more attributes. The following "
#~ "ones\n"
#~ "are currently defined by Elixir:\n"
#~ "\n"
#~ "  * `@after_compile`\n"
#~ "\n"
#~ "    A hook that will be invoked right after the current module is "
#~ "compiled.\n"
#~ "\n"
#~ "    Accepts a module or a tuple `{<module>, <function atom>}`. The "
#~ "function\n"
#~ "    must take two arguments: the module environment and its bytecode.\n"
#~ "    When just a module is provided, the function is assumed to be\n"
#~ "    `__after_compile__/2`.\n"
#~ "\n"
#~ "    ### Example\n"
#~ "\n"
#~ "        defmodule M do\n"
#~ "          @after_compile __MODULE__\n"
#~ "\n"
#~ "          def __after_compile__(env, _bytecode) do\n"
#~ "            IO.inspect env\n"
#~ "          end\n"
#~ "        end\n"
#~ "\n"
#~ "  * `@before_compile`\n"
#~ "\n"
#~ "    A hook that will be invoked before the module is compiled.\n"
#~ "\n"
#~ "    Accepts a module or a tuple `{<module>, <function/macro atom>}`. "
#~ "The\n"
#~ "    function/macro must take one argument: the module environment. If "
#~ "it's a\n"
#~ "    macro, its returned value will be injected at the end of the module "
#~ "definition\n"
#~ "    before the compilation starts.\n"
#~ "\n"
#~ "    When just a module is provided, the function/macro is assumed to be\n"
#~ "    `__before_compile__/1`.\n"
#~ "\n"
#~ "    Note: unlike `@after_compile`, the callback function/macro must\n"
#~ "    be placed in a separate module (because when the callback is "
#~ "invoked,\n"
#~ "    the current module does not yet exist).\n"
#~ "\n"
#~ "    ### Example\n"
#~ "\n"
#~ "        defmodule A do\n"
#~ "          defmacro __before_compile__(_env) do\n"
#~ "            quote do\n"
#~ "              def hello, do: \"world\"\n"
#~ "            end\n"
#~ "          end\n"
#~ "        end\n"
#~ "\n"
#~ "        defmodule B do\n"
#~ "          @before_compile A\n"
#~ "        end\n"
#~ "\n"
#~ "  * `@behaviour`   (notice the British spelling)\n"
#~ "\n"
#~ "    Behaviours can be referenced by modules to ensure they implement\n"
#~ "    required specific function signatures defined by `@callback`.\n"
#~ "\n"
#~ "    For example, you can specify the URI.Parser behaviour as follows:\n"
#~ "\n"
#~ "        defmodule URI.Parser do\n"
#~ "          @doc \"Parses the given URL\"\n"
#~ "          @callback parse(uri_info :: URI.t) :: URI.t\n"
#~ "\n"
#~ "          @doc \"Defines a default port\"\n"
#~ "          @callback default_port() :: integer\n"
#~ "        end\n"
#~ "\n"
#~ "        And then a module may use it as:\n"
#~ "\n"
#~ "        defmodule URI.HTTP do\n"
#~ "          @behaviour URI.Parser\n"
#~ "          def default_port(), do: 80\n"
#~ "          def parse(info), do: info\n"
#~ "        end\n"
#~ "\n"
#~ "    If the behaviour changes or URI.HTTP does not implement one of the\n"
#~ "    callbacks, a warning will be raised.\n"
#~ "\n"
#~ "    Specifies an OTP or user-defined behaviour.\n"
#~ "\n"
#~ "    ### Example\n"
#~ "\n"
#~ "        defmodule M do\n"
#~ "          @behaviour gen_event\n"
#~ "\n"
#~ "          # ...\n"
#~ "        end\n"
#~ "\n"
#~ "  * `@compile`\n"
#~ "\n"
#~ "    Defines options for module compilation that are passed to the "
#~ "Erlang\n"
#~ "    compiler.\n"
#~ "\n"
#~ "    Accepts an atom, a tuple, or a list of atoms and tuples.\n"
#~ "\n"
#~ "    For the list of supported options, see Erlang's\n"
#~ "    [`:compile` module](http://www.erlang.org/doc/man/compile.html).\n"
#~ "\n"
#~ "    Multiple uses of `@compile` will accumulate instead of overriding\n"
#~ "    previous ones.\n"
#~ "\n"
#~ "    ### Example\n"
#~ "\n"
#~ "        defmodule M do\n"
#~ "          @compile {:inline, myfun: 1}\n"
#~ "\n"
#~ "          def myfun(arg) do\n"
#~ "            to_string(arg)\n"
#~ "          end\n"
#~ "        end\n"
#~ "\n"
#~ "  * `@doc`\n"
#~ "\n"
#~ "    Provides documentation for the function or macro that follows the\n"
#~ "    attribute.\n"
#~ "\n"
#~ "    Accepts a string (often a heredoc) or `false` where `@doc false` "
#~ "will\n"
#~ "    make the function/macro invisible to the documentation extraction "
#~ "tools\n"
#~ "    like ExDoc.\n"
#~ "\n"
#~ "    Can be invoked more than once.\n"
#~ "\n"
#~ "    ### Example\n"
#~ "\n"
#~ "        defmodule M do\n"
#~ "          @doc \"Hello world\"\n"
#~ "          def hello do\n"
#~ "            \"world\"\n"
#~ "          end\n"
#~ "\n"
#~ "          @doc \"\"\"\n"
#~ "          Sums `a` to `b`.\n"
#~ "          \"\"\"\n"
#~ "          def sum(a, b) do\n"
#~ "            a + b\n"
#~ "          end\n"
#~ "        end\n"
#~ "\n"
#~ "  * `@file`\n"
#~ "\n"
#~ "    Changes the filename used in stacktraces for the function or macro "
#~ "that\n"
#~ "    follows the attribute.\n"
#~ "\n"
#~ "    Accepts a string. Can be used more than once.\n"
#~ "\n"
#~ "    ### Example\n"
#~ "\n"
#~ "        defmodule M do\n"
#~ "          @doc \"Hello world\"\n"
#~ "          @file \"hello.ex\"\n"
#~ "          def hello do\n"
#~ "            \"world\"\n"
#~ "          end\n"
#~ "        end\n"
#~ "\n"
#~ "  * `@moduledoc`\n"
#~ "\n"
#~ "    Provides documentation for the current module.\n"
#~ "\n"
#~ "    Accepts a string (which is often a heredoc) or `false` where\n"
#~ "    `@moduledoc false` will make the module invisible to the\n"
#~ "    documentation extraction tools like ExDoc.\n"
#~ "\n"
#~ "    ### Example\n"
#~ "\n"
#~ "        defmodule M do\n"
#~ "          @moduledoc \"\"\"\n"
#~ "          A very useful module\n"
#~ "          \"\"\"\n"
#~ "        end\n"
#~ "\n"
#~ "\n"
#~ "  * `@on_definition`\n"
#~ "\n"
#~ "    A hook that will be invoked when each function or macro in the "
#~ "current\n"
#~ "    module is defined. Useful when annotating functions.\n"
#~ "\n"
#~ "    Accepts a module or a tuple `{<module>, <function atom>}`. The "
#~ "function\n"
#~ "    must take 6 arguments:\n"
#~ "\n"
#~ "      - the module environment\n"
#~ "      - kind: `:def`, `:defp`, `:defmacro`, or `:defmacrop`\n"
#~ "      - function/macro name\n"
#~ "      - list of quoted arguments\n"
#~ "      - list of quoted guards\n"
#~ "      - quoted function body\n"
#~ "\n"
#~ "    Note the hook receives the quoted arguments and it is invoked "
#~ "before\n"
#~ "    the function is stored in the module. So `Module.defines?/2` will "
#~ "return\n"
#~ "    `false` for the first clause of every function.\n"
#~ "\n"
#~ "    If the function/macro being defined has multiple clauses, the hook "
#~ "will\n"
#~ "    be called for each clause.\n"
#~ "\n"
#~ "    Unlike other hooks, `@on_definition` will only invoke functions\n"
#~ "    and never macros. This is because the hook is invoked inside the "
#~ "context\n"
#~ "    of the function (and nested function definitions are not allowed in\n"
#~ "    Elixir).\n"
#~ "\n"
#~ "    When just a module is provided, the function is assumed to be\n"
#~ "    `__on_definition__/6`.\n"
#~ "\n"
#~ "    ### Example\n"
#~ "\n"
#~ "        defmodule H do\n"
#~ "          def on_def(_env, kind, name, args, guards, body) do\n"
#~ "            IO.puts \"Defining #{kind} named #{name} with args:\"\n"
#~ "            IO.inspect args\n"
#~ "            IO.puts \"and guards\"\n"
#~ "            IO.inspect guards\n"
#~ "            IO.puts \"and body\"\n"
#~ "            IO.puts Macro.to_string(body)\n"
#~ "          end\n"
#~ "        end\n"
#~ "\n"
#~ "        defmodule M do\n"
#~ "          @on_definition {H, :on_def}\n"
#~ "\n"
#~ "          def hello(arg) when is_binary(arg) or is_list(arg) do\n"
#~ "            \"Hello\" <> to_string(arg)\n"
#~ "          end\n"
#~ "\n"
#~ "          def hello(_) do\n"
#~ "            :ok\n"
#~ "          end\n"
#~ "        end\n"
#~ "\n"
#~ "  * `@on_load`\n"
#~ "\n"
#~ "    A hook that will be invoked whenever the module is loaded.\n"
#~ "\n"
#~ "    Accepts a function atom of a function in the current module. The "
#~ "function\n"
#~ "    must have arity 0 (no arguments) and has to return `:ok`, otherwise "
#~ "the\n"
#~ "    loading of the module will be aborted.\n"
#~ "\n"
#~ "    ### Example\n"
#~ "\n"
#~ "        defmodule M do\n"
#~ "          @on_load :load_check\n"
#~ "\n"
#~ "          def load_check do\n"
#~ "            if some_condition() do\n"
#~ "              :ok\n"
#~ "            else\n"
#~ "              nil\n"
#~ "            end\n"
#~ "          end\n"
#~ "\n"
#~ "          def some_condition do\n"
#~ "            false\n"
#~ "          end\n"
#~ "        end\n"
#~ "\n"
#~ "  * `@vsn`\n"
#~ "\n"
#~ "    Specify the module version. Accepts any valid Elixir value.\n"
#~ "\n"
#~ "    ### Example\n"
#~ "\n"
#~ "        defmodule M do\n"
#~ "          @vsn \"1.0\"\n"
#~ "        end\n"
#~ "\n"
#~ "  * `@external_resource`\n"
#~ "\n"
#~ "    Specifies an external resource to the current module.\n"
#~ "\n"
#~ "    Many times a module embeds information from an external file. This\n"
#~ "    attribute allows the module to annotate which external resources\n"
#~ "    have been used.\n"
#~ "\n"
#~ "    Tools like Mix may use this information to ensure the module is\n"
#~ "    recompiled in case any of the external resources change.\n"
#~ "\n"
#~ "  * `@dialyzer`\n"
#~ "\n"
#~ "    Defines warnings to request or suppress when using a version of\n"
#~ "    `:dialyzer` that supports module attributes.\n"
#~ "\n"
#~ "    Accepts an atom, a tuple, or a list of atoms and tuples.\n"
#~ "\n"
#~ "    For the list of supported warnings, see\n"
#~ "    [`:dialyzer` module](http://www.erlang.org/doc/man/dialyzer.html).\n"
#~ "\n"
#~ "    Multiple uses of `@dialyzer` will accumulate instead of overriding\n"
#~ "    previous ones.\n"
#~ "\n"
#~ "    ### Example\n"
#~ "\n"
#~ "        defmodule M do\n"
#~ "          @dialyzer {:nowarn_function, myfun: 1}\n"
#~ "\n"
#~ "          def myfun(arg) do\n"
#~ "            M.not_a_function(arg)\n"
#~ "          end\n"
#~ "        end\n"
#~ "\n"
#~ "The following attributes are part of typespecs and are also reserved by\n"
#~ "Elixir (see `Kernel.Typespec` for more information about typespecs):\n"
#~ "\n"
#~ "  * `@type`          - defines a type to be used in `@spec`\n"
#~ "  * `@typep`         - defines a private type to be used in `@spec`\n"
#~ "  * `@opaque`        - defines an opaque type to be used in `@spec`\n"
#~ "  * `@spec`          - provides a specification for a function\n"
#~ "  * `@callback`      - provides a specification for a behaviour "
#~ "callback\n"
#~ "  * `@macrocallback` - provides a specification for a macro behaviour "
#~ "callback\n"
#~ "\n"
#~ "In addition to the built-in attributes outlined above, custom attributes "
#~ "may\n"
#~ "also be added. A custom attribute is any valid identifier prefixed with "
#~ "an\n"
#~ "`@` and followed by a valid Elixir value:\n"
#~ "\n"
#~ "    defmodule M do\n"
#~ "      @custom_attr [some: \"stuff\"]\n"
#~ "    end\n"
#~ "\n"
#~ "For more advanced options available when defining custom attributes, "
#~ "see\n"
#~ "`register_attribute/3`.\n"
#~ "\n"
#~ "## Runtime information about a module\n"
#~ "\n"
#~ "It is possible to query a module at runtime to find out which functions "
#~ "and\n"
#~ "macros it defines, extract its docstrings, etc. See `__info__/1`.\n"
#~ msgstr ""
#~ "コンパイル時にモジュールを取り扱う多くの関数を提供します。\n"
#~ "\n"
#~ "それらは、開発者に動的にドキュメントを添付したり、アトリビュートや\n"
#~ "その他を追加、削除、登録することを許可します。\n"
#~ "\n"
#~ "モジュールがコンパイルされた後では、実行時データを調べるそれらのスコー\n"
#~ "プの外にあるため、このモジュールの関数の多くは利用すると、エラーを上げ\n"
#~ "ます。多くの実行時データはそれぞれコンパイルされたモジュールにアタッチ\n"
#~ "された`__info__(attr)`関数により調べることができます。\n"
#~ "\n"
#~ "## モジュールアトリビュート\n"
#~ "\n"
#~ "それぞののモジュールは一つ以上のアトリビュートで装飾することができま"
#~ "す。\n"
#~ "以下は現在のElixirで定義されているものです:\n"
#~ "\n"
#~ "  * `@after_compile`\n"
#~ "\n"
#~ "    カレントモジュールがコンパイルされた直後に実行されるフックです。\n"
#~ "\n"
#~ "    モジュールまたは、`{<module>, <function atom>}`タプルを受け付けま"
#~ "す。\n"
#~ "    functionは二つの引数をとらなければなりません: モジュールの環境と\n"
#~ "    バイトコードです。\n"
#~ "    引数としてモジュールのみが提供されたとき、その関数は\n"
#~ "    `__after_compile__/2`であるとされます。\n"
#~ "\n"
#~ "    ### 例\n"
#~ "\n"
#~ "        defmodule M do\n"
#~ "          @after_compile __MODULE__\n"
#~ "\n"
#~ "          def __after_compile__(env, _bytecode) do\n"
#~ "            IO.inspect env\n"
#~ "          end\n"
#~ "        end\n"
#~ "\n"
#~ "  * `@before_compile`\n"
#~ "\n"
#~ "    モジュールがコンパイルされる前に実行されるフックです。\n"
#~ "\n"
#~ "    モジュールまたは、`{<module>, <function/macro atom>}`タプルを受け\n"
#~ "    付けます。そのfunction/macroは一つの引数をとらなければなりません: \n"
#~ "    モジュールの環境です。もしマクロであるならば、その戻値がコンパイル"
#~ "が\n"
#~ "    初まる前にモジュール定義の最後に差し込まれます。\n"
#~ "\n"
#~ "    引数としてモジュールが提供されたとき、その関数/マクロは\n"
#~ "    `__before_compile__/1`であるとされます。\n"
#~ "\n"
#~ "    注: `@after_compile`と異なり、コールバック関数/マクロは\n"
#~ "    別のモジュールに置かれなければなりません(何故なら、\n"
#~ "    コールバックが実行されるとき、カレントモジュールはまだ存在して\n"
#~ "    いないからです)。\n"
#~ "\n"
#~ "    ### 例\n"
#~ "\n"
#~ "        defmodule A do\n"
#~ "          defmacro __before_compile__(_env) do\n"
#~ "            quote do\n"
#~ "              def hello, do: \"world\"\n"
#~ "            end\n"
#~ "          end\n"
#~ "        end\n"
#~ "\n"
#~ "        defmodule B do\n"
#~ "          @before_compile A\n"
#~ "        end\n"
#~ "\n"
#~ "  * `@behaviour`   (英式綴であることに注意してください)\n"
#~ "\n"
#~ "    ビヘイビアはモジュールが要求する`@callback`によって定義された\n"
#~ "    関数を実装することを確実にします。\n"
#~ "\n"
#~ "    例えば、URI.Parserビヘイビアを以下のように指定することができます:\n"
#~ "\n"
#~ "        defmodule URI.Parser do\n"
#~ "          @doc \"Parses the given URL\"\n"
#~ "          @callback parse(uri_info :: URI.t) :: URI.t\n"
#~ "\n"
#~ "          @doc \"Defines a default port\"\n"
#~ "          @callback default_port() :: integer\n"
#~ "        end\n"
#~ "\n"
#~ "        それからモジュールを以下のようにして使います:\n"
#~ "\n"
#~ "        defmodule URI.HTTP d\n"
#~ "          @behaviour URI.Parser\n"
#~ "          def default_port(), do: 80\n"
#~ "          def parse(info), do: info\n"
#~ "        end\n"
#~ "\n"
#~ "    もしビヘイビアが変更したり、URI.HTTPがコールバックを\n"
#~ "    一つでも実装していないなら、警告が上るでしょう。\n"
#~ "\n"
#~ "    OTPあるいはユーザ定義のビヘイビアを指定します。\n"
#~ "\n"
#~ "\n"
#~ "    ### 例\n"
#~ "\n"
#~ "        defmodule M do\n"
#~ "          @behaviour gen_event\n"
#~ "\n"
#~ "          # ...\n"
#~ "        end\n"
#~ "\n"
#~ "  * `@compile`\n"
#~ "\n"
#~ "    モジュールのErlangコンパイラに渡されるコンパイルオプションを定義しま"
#~ "す。\n"
#~ "\n"
#~ "    アトム、タプルあるいはアトムやタプルのリストを受け付けます。\n"
#~ "\n"
#~ "    サポートされるオプションのリストについては、Erlangの\n"
#~ "    [`:compile` モジュール](http://www.erlang.org/doc/man/compile.html)\n"
#~ "    を参照してください。\n"
#~ "\n"
#~ "    '@compile`を何度か使うと、前のものを上書きするかわりに、\n"
#~ "    累積します。\n"
#~ "\n"
#~ "    ### 例\n"
#~ "\n"
#~ "          defmodule M do\n"
#~ "            @compile {:inline, myfun: 1}\n"
#~ "\n"
#~ "            def myfun(arg) do\n"
#~ "              to_string(arg)\n"
#~ "            end\n"
#~ "          end\n"
#~ "\n"
#~ "  * `@doc`\n"
#~ "\n"
#~ "    アトリビュートの後の関数またはマクロへのドキュメントを提供します。\n"
#~ "\n"
#~ "    文字列(しばしばヒアドキュメントです)または、`false`を受け付けます。\n"
#~ "    `@doc false`とした関数/マクロはExDocの様なドキュメント抽出ツールに\n"
#~ "    より非表示にされるでしょう。\n"
#~ "\n"
#~ "    ひとつ以上記述することができます。\n"
#~ "\n"
#~ "    ### 例\n"
#~ "\n"
#~ "          defmodule M do\n"
#~ "            @doc \"Hello world\"\n"
#~ "            def hello do\n"
#~ "              \"world\"\n"
#~ "            end\n"
#~ "\n"
#~ "            @doc \"\"\"\n"
#~ "            Sums `a` to `b`.\n"
#~ "            \"\"\"\n"
#~ "            def sum(a, b) do\n"
#~ "              a + b\n"
#~ "            end\n"
#~ "          end\n"
#~ "\n"
#~ "  * `@file`\n"
#~ "\n"
#~ "    アトリビュートの後の関数またはマクロについてのスタックトレースで\n"
#~ "    使われるファイル名を変更します。\n"
#~ "\n"
#~ "    文字列を受け付けます。ひとつ以上使うことができます。\n"
#~ "\n"
#~ "    ### 例\n"
#~ "\n"
#~ "          defmodule M do\n"
#~ "            @doc \"Hello world\"\n"
#~ "            @file \"hello.ex\"\n"
#~ "            def hello do\n"
#~ "              \"world\"\n"
#~ "            end\n"
#~ "          end\n"
#~ "\n"
#~ "  * `@moduledoc`\n"
#~ "\n"
#~ "    カレントモジュールについてのドキュメントを提供します。\n"
#~ "\n"
#~ "    文字列(しばしばヒアドキュメントです)または、`false`を受け付けます。\n"
#~ "    `@moduledoc false`としたモジュールはExDocの様なドキュメント抽出\n"
#~ "    ツールにより非表示にされるでしょう。\n"
#~ "\n"
#~ "    ### 例\n"
#~ "\n"
#~ "          defmodule M do\n"
#~ "            @moduledoc \"\"\"\n"
#~ "            A very useful module\n"
#~ "            \"\"\"\n"
#~ "          end\n"
#~ "\n"
#~ "\n"
#~ "  * `@on_definition`\n"
#~ "\n"
#~ "    カレントモジュールのそれぞれの関数あるいはマクロが定義されたれた時\n"
#~ "    に実行されるフックです。関数に注をつけるときに役に立ちます。\n"
#~ "\n"
#~ "    モジュールあるいは、`{<module>, <function atom>}`タプルを受け付けま"
#~ "す。\n"
#~ "    関数は6個の引数を取らなければなりません: \n"
#~ "\n"
#~ "      - モジュールの環境\n"
#~ "      - 種類: `:def`, `:defp`, `:defmacro`, あるいは `:defmacrop`\n"
#~ "      - 関数/マクロの名前\n"
#~ "      - quoteされた引数のリスト\n"
#~ "      - quoteされたガードのリスト\n"
#~ "      - quoteされた関数本体\n"
#~ "\n"
#~ "    フックは、関数がモジュールにストアされる前に実行され、\n"
#~ "    quoteされた引数を受信することに注意してください。\n"
#~ "    だから、`Module.defines?/2`はそれぞれの関数について最初の節の\n"
#~ "    ため`false`で返るでしょう。\n"
#~ "\n"
#~ "    もし定義しようとしている関数/マクロが複数の節をもつなら、\n"
#~ "    フックはそれぞれの節毎に呼ばれるでしょう。\n"
#~ "\n"
#~ "    他のフックと異なり、`@on_definition`はマクロでは決してなく、\n"
#~ "    関数だけを実行します。これは、関数のコンテキストの内側で\n"
#~ "    フックが実行されるからです(そしてElixirはネストした関数定義は\n"
#~ "    許されていないのです)。\n"
#~ "\n"
#~ "    引数としてモジュールのみが提供されたとき、その関数は\n"
#~ "    `__on_definition__/6` であるとされます。\n"
#~ "\n"
#~ "    ### 例\n"
#~ "\n"
#~ "          defmodule H do\n"
#~ "            def on_def(_env, kind, name, args, guards, body) do\n"
#~ "              IO.puts \"Defining #{kind} named #{name} with args:\"\n"
#~ "              IO.inspect args\n"
#~ "              IO.puts \"and guards\"\n"
#~ "              IO.inspect guards\n"
#~ "              IO.puts \"and body\"\n"
#~ "              IO.puts Macro.to_string(body)\n"
#~ "            end\n"
#~ "          end\n"
#~ "\n"
#~ "          defmodule M do\n"
#~ "            @on_definition {H, :on_def}\n"
#~ "\n"
#~ "            def hello(arg) when is_binary(arg) or is_list(arg) do\n"
#~ "              \"Hello\" <> to_string(arg)\n"
#~ "            end\n"
#~ "\n"
#~ "            def hello(_) do\n"
#~ "              :ok\n"
#~ "            end\n"
#~ "          end\n"
#~ "\n"
#~ "  * `@on_load`\n"
#~ "\n"
#~ "    モジュールがロードされる時には何時でも実行されるフックです。    \n"
#~ "\n"
#~ "    カレントモジュール内の関数名を示すアトムを\n"
#~ "    受け付けます。関数は、アリティ0(引数なし)で、`:ok`を返さなければ\n"
#~ "    なりません。さもなくば、モジュールのローディングは中止されます。\n"
#~ "\n"
#~ "    ### 例\n"
#~ "\n"
#~ "          defmodule M do\n"
#~ "            @on_load :load_check\n"
#~ "\n"
#~ "            def load_check do\n"
#~ "              if some_condition() do\n"
#~ "                :ok\n"
#~ "              else\n"
#~ "                nil\n"
#~ "              end\n"
#~ "            end\n"
#~ "\n"
#~ "            def some_condition do\n"
#~ "              false\n"
#~ "            end\n"
#~ "          end\n"
#~ "\n"
#~ "  * `@vsn`\n"
#~ "\n"
#~ "    モジュールのバージョンを指定します。任意の正しいElixirの値を\n"
#~ "    受け付けます。\n"
#~ "\n"
#~ "    ### 例\n"
#~ "\n"
#~ "          defmodule M do\n"
#~ "            @vsn \"1.0\"\n"
#~ "          end\n"
#~ "\n"
#~ "  * `@external_resource`\n"
#~ "\n"
#~ "    カレントモジュールに外部リソースを指定します。\n"
#~ "\n"
#~ "    しばしば、モジュールは外部から情報を埋め込みます。\n"
#~ "    このアトリビュートはモジュールにどの外部リソースが使われたかに\n"
#~ "    ついて注釈を付けることを許可します。\n"
#~ "\n"
#~ "    Mixの様なツールはこの情報を、外部リソースが変更された場合に\n"
#~ "    モジュールが再コンパイルされることを確実にするために、使うかも\n"
#~ "    しれません。\n"
#~ "\n"
#~ "  * `@dialyzer`\n"
#~ "\n"
#~ "    モジュールアトリビュートをサポートする\n"
#~ "    `:dialyzer`のバージョンを使用している時に、\n"
#~ "    要求または抑制するwarningを定義します。\n"
#~ "\n"
#~ "    アトム、タプルまたはアトムとタプルのリストを受け付けます。\n"
#~ "\n"
#~ "    サポートしているwarningのリストは\n"
#~ "    [`:dialyzer モジュール](http://www.erlang.org/doc/man/dialyzer."
#~ "html)\n"
#~ "    を参照してください。\n"
#~ "\n"
#~ "    `@dialyzer`を何度か使うと以前の値を上書きするかわりに\n"
#~ "    累積されます。\n"
#~ "\n"
#~ "    ### Example\n"
#~ "\n"
#~ "          defmodule M do\n"
#~ "            @dialyzer {:nowarn_function, myfun: 1}\n"
#~ "\n"
#~ "            def myfun(arg) do\n"
#~ "              M.not_a_function(arg)\n"
#~ "            end\n"
#~ "          end\n"
#~ "\n"
#~ "以下のアトリビュートはtypespecの一部で、Elixirにより予約されています\n"
#~ "(typespecについての詳細は`Kernel.Typespec`を参照してください):\n"
#~ "\n"
#~ "  * `@type`          - `@spec` でタイプの定義に使われます。\n"
#~ "  * `@typep`         - `@spec`でプライベートタイプの定義に使われます。\n"
#~ "  * `@opaque`        - `@spec`不透明なタイプの定義に使われます。\n"
#~ "  * `@spec`          - 関数のspecを提供します。\n"
#~ "  * `@callback`      - ビヘイビアコールバックのspecを提供します。\n"
#~ "  * `@macrocallback` - マクロビヘイビアコールバックのspecを提供します。\n"
#~ "\n"
#~ "上で概説されたビルトインのアトリビュートに加えて、カスタムアトリビュート"
#~ "も\n"
#~ "追加できます。カスタムアトリビュートは`@`が前についた有効な識別子なら\n"
#~ "なんてもよく、後ろにElixirの値がつきます:\n"
#~ "\n"
#~ "      defmodule M do\n"
#~ "        @custom_attr [some: \"stuff\"]\n"
#~ "      end\n"
#~ "\n"
#~ "カスタムアトリビュートの定義時のより進んだオプションについては\n"
#~ "`register_attribute/3`を参照してください。\n"
#~ "\n"
#~ "## モジュールについての実行時情報\n"
#~ "\n"
#~ "どの関数やマクロが定義を見付けるため、あるいはドキュメント\n"
#~ "文字列を抽出するために、実行時にモジュールに問合せることが可能です。\n"
#~ "`__info__/1`を参照してください。\n"
