#. TRANSLATORS: def OptionParser.to_argv(enum, opts \\ [])
#: lib/option_parser.ex:380 
msgid ""
"Receives a key-value enumerable and converts it to `t:argv/0`.\n"
"\n"
"Keys must be atoms. Keys with `nil` value are discarded,\n"
"boolean values are converted to `--key` or `--no-key`\n"
"(if the value is `true` or `false`, respectively),\n"
"and all other values are converted using `Kernel.to_string/1`.\n"
"\n"
"It is advised to pass to `to_argv/2` the same set of `options`\n"
"given to `parse/2`. Some switches can only be reconstructed\n"
"correctly with the `switches` information in hand.\n"
"\n"
"## Examples\n"
"\n"
"    iex>  OptionParser.to_argv([foo_bar: \"baz\"])\n"
"    [\"--foo-bar\", \"baz\"]\n"
"    iex>  OptionParser.to_argv([bool: true, bool: false, discarded: nil])\n"
"    [\"--bool\", \"--no-bool\"]\n"
"\n"
"Some switches will output different values based on the switches\n"
"flag:\n"
"\n"
"    iex> OptionParser.to_argv([number: 2], switches: [])\n"
"    [\"--number\", \"2\"]\n"
"    iex> OptionParser.to_argv([number: 2], switches: [number: :count])\n"
"    [\"--number\", \"--number\"]\n"
"\n"
msgstr ""
#. TRANSLATORS: def OptionParser.parse_head(argv, opts \\ [])
#: lib/option_parser.ex:198 
msgid ""
"Similar to `parse/2` but only parses the head of `argv`;\n"
"as soon as it finds a non-switch, it stops parsing.\n"
"\n"
"See `parse/2` for more information.\n"
"\n"
"## Example\n"
"\n"
"    iex> OptionParser.parse_head([\"--source\", \"lib\", \"test/enum_test.exs\", \"--verbose\"])\n"
"    {[source: \"lib\"], [\"test/enum_test.exs\", \"--verbose\"], []}\n"
"\n"
"    iex> OptionParser.parse_head([\"--verbose\", \"--source\", \"lib\", \"test/enum_test.exs\", \"--unlock\"])\n"
"    {[verbose: true, source: \"lib\"], [\"test/enum_test.exs\", \"--unlock\"], []}\n"
"\n"
msgstr ""
#. TRANSLATORS: def OptionParser.parse(argv, opts \\ [])
#: lib/option_parser.ex:15 
msgid ""
"Parses `argv` into a keyword list.\n"
"\n"
"It returns a three-element tuple with the form `{parsed, args, invalid}`, where:\n"
"\n"
"  * `parsed` is a keyword list of parsed switches with `{switch_name, value}`\n"
"    tuples in it; `switch_name` is the atom representing the switch name while\n"
"    `value` is the value for that switch parsed according to `opts` (see the\n"
"    \"Examples\" section for more information)\n"
"  * `args` is a list of the remaining arguments in `argv` as strings\n"
"  * `invalid` is a list of invalid options as `{option_name, value}` where\n"
"    `option_name` is the raw option and `value` is `nil` if the option wasn't\n"
"    expected or the string value if the value didn't have the expected type for\n"
"    the corresponding option\n"
"\n"
"Elixir converts switches to underscored atoms, so `--source-path` becomes\n"
"`:source_path`. This is done to better suit Elixir conventions. However, this\n"
"means that switches can't contain underscores and switches that do contain\n"
"underscores are always returned in the list of invalid options.\n"
"\n"
"Without any options, this function will try to parse all switches in the `argv`.\n"
"\n"
"    iex> OptionParser.parse([\"--debug\"])\n"
"    {[debug: true], [], []}\n"
"\n"
"    iex> OptionParser.parse([\"--source\", \"lib\"])\n"
"    {[source: \"lib\"], [], []}\n"
"\n"
"    iex> OptionParser.parse([\"--source-path\", \"lib\", \"test/enum_test.exs\", \"--verbose\"])\n"
"    {[source_path: \"lib\", verbose: true], [\"test/enum_test.exs\"], []}\n"
"\n"
"Switches followed by a value will be assigned the value, as a string.\n"
"Switches without an argument, like `--debug` in the examples above, will\n"
"automatically be set to `true`.\n"
"\n"
"## Options\n"
"\n"
"The following options are supported:\n"
"\n"
"  * `:switches` or `:strict` - see the \"Switch definitions\" section below\n"
"  * `:aliases` - see the \"Aliases\" section below\n"
"\n"
"## Switch definitions\n"
"\n"
"Often it is better to explicitly list the known\n"
"switches and their formats. The switches can be specified via one of two\n"
"options:\n"
"\n"
"  * `:switches` - defines some switches and their types. This function\n"
"    still attempts to parse switches that are not in this list.\n"
"  * `:strict` - defines strict switches. Any switch in `argv` that is not\n"
"    specified in the list is returned in the invalid options list.\n"
"\n"
"Both these options accept a keyword list of `{name, type}` tuples where `name`\n"
"is an atom defining the name of the switch and `type` is an atom that\n"
"specifies the type for the value of this switch (see the \"Types\" section below\n"
"for the possible types and more information about type casting).\n"
"\n"
"Note that you should only supply the `:switches` or the`:strict` option.\n"
"If you supply both, an `ArgumentError` exception will be raised.\n"
"\n"
"### Types\n"
"\n"
"Switches parsed by `OptionParser` may take zero or one arguments.\n"
"\n"
"The following switches types take no arguments:\n"
"\n"
"  * `:boolean` - sets the value to `true` when given (see also the\n"
"    \"Negation switches\" section below)\n"
"  * `:count` - counts the number of times the switch is given\n"
"\n"
"The following switches take one argument:\n"
"\n"
"  * `:integer` - parses the value as an integer\n"
"  * `:float` - parses the value as a float\n"
"  * `:string` - parses the value as a string\n"
"\n"
"If a switch can't be parsed according to the given type, it is returned\n"
"in the invalid options list.\n"
"\n"
"### Modifiers\n"
"\n"
"Switches can be specified with modifiers, which change how\n"
"they behave. The following modifiers are supported:\n"
"\n"
"  * `:keep` - keeps duplicated items instead of overriding them; works with\n"
"    all types except `:count`. Specifying `switch_name: :keep` assumes the\n"
"    type of `:switch_name` will be `:string`.\n"
"\n"
"Note that if you want to use `:keep` with a type other than `:string`, use a list\n"
"as the type for the switch. For example: `[foo: [:integer, :keep]]`.\n"
"\n"
"### Negation switches\n"
"\n"
"In case a switch `SWITCH` is specified to have type `:boolean`, it may be\n"
"passed as `--no-SWITCH` as well which will set the option to `false`:\n"
"\n"
"    iex> OptionParser.parse([\"--no-op\", \"path/to/file\"], switches: [op: :boolean])\n"
"    {[op: false], [\"path/to/file\"], []}\n"
"\n"
"## Aliases\n"
"\n"
"A set of aliases can be specified in the `:aliases` option:\n"
"\n"
"    iex> OptionParser.parse([\"-d\"], aliases: [d: :debug])\n"
"    {[debug: true], [], []}\n"
"\n"
"## Examples\n"
"\n"
"Here are some examples of working with different types and modifiers:\n"
"\n"
"    iex> OptionParser.parse([\"--unlock\", \"path/to/file\"], strict: [unlock: :boolean])\n"
"    {[unlock: true], [\"path/to/file\"], []}\n"
"\n"
"    iex> OptionParser.parse([\"--unlock\", \"--limit\", \"0\", \"path/to/file\"],\n"
"    ...>                    strict: [unlock: :boolean, limit: :integer])\n"
"    {[unlock: true, limit: 0], [\"path/to/file\"], []}\n"
"\n"
"    iex> OptionParser.parse([\"--limit\", \"3\"], strict: [limit: :integer])\n"
"    {[limit: 3], [], []}\n"
"\n"
"    iex> OptionParser.parse([\"--limit\", \"xyz\"], strict: [limit: :integer])\n"
"    {[], [], [{\"--limit\", \"xyz\"}]}\n"
"\n"
"    iex> OptionParser.parse([\"--verbose\"], switches: [verbose: :count])\n"
"    {[verbose: 1], [], []}\n"
"\n"
"    iex> OptionParser.parse([\"-v\", \"-v\"], aliases: [v: :verbose], strict: [verbose: :count])\n"
"    {[verbose: 2], [], []}\n"
"\n"
"    iex> OptionParser.parse([\"--unknown\", \"xyz\"], strict: [])\n"
"    {[], [\"xyz\"], [{\"--unknown\", nil}]}\n"
"\n"
"    iex> OptionParser.parse([\"--limit\", \"3\", \"--unknown\", \"xyz\"],\n"
"    ...>                    switches: [limit: :integer])\n"
"    {[limit: 3, unknown: \"xyz\"], [], []}\n"
"\n"
"    iex> OptionParser.parse([\"--unlock\", \"path/to/file\", \"--unlock\", \"path/to/another/file\"], strict: [unlock: :keep])\n"
"    {[unlock: \"path/to/file\", unlock: \"path/to/another/file\"], [], []}\n"
"\n"
msgstr ""
#. TRANSLATORS: def OptionParser.split(string)
#: lib/option_parser.ex:431 
msgid ""
"Splits a string into `t:argv/0` chunks.\n"
"\n"
"This function splits the given `string` into a list of strings in a similar\n"
"way to many shells.\n"
"\n"
"## Examples\n"
"\n"
"    iex> OptionParser.split(\"foo bar\")\n"
"    [\"foo\", \"bar\"]\n"
"\n"
"    iex> OptionParser.split(\"foo \\\"bar baz\\\"\")\n"
"    [\"foo\", \"bar baz\"]\n"
"\n"
msgstr ""
#. TRANSLATORS: def OptionParser.parse!(argv, opts \\ [])
#: lib/option_parser.ex:161 
msgid ""
"The same as `parse/2` but raises an `OptionParser.ParseError`\n"
"exception if any invalid options are given.\n"
"\n"
"If there are no errors, returns a `{parsed, rest}` tuple where:\n"
"\n"
"  * `parsed` is the list of parsed switches (same as in `parse/2`)\n"
"  * `rest` is the list of arguments (same as in `parse/2`)\n"
"\n"
"## Examples\n"
"\n"
"    iex> OptionParser.parse!([\"--debug\", \"path/to/file\"], strict: [debug: :boolean])\n"
"    {[debug: true], [\"path/to/file\"]}\n"
"\n"
"    iex> OptionParser.parse!([\"--limit\", \"xyz\"], strict: [limit: :integer])\n"
"    ** (OptionParser.ParseError) 1 error found!\n"
"    --limit : Expected type integer, got \"xyz\"\n"
"\n"
"    iex> OptionParser.parse!([\"--unknown\", \"xyz\"], strict: [])\n"
"    ** (OptionParser.ParseError) 1 error found!\n"
"    --unknown : Unknown option\n"
"\n"
"    iex> OptionParser.parse!([\"-l\", \"xyz\", \"-f\", \"bar\"],\n"
"    ...>                     switches: [limit: :integer, foo: :integer], aliases: [l: :limit, f: :foo])\n"
"    ** (OptionParser.ParseError) 2 errors found!\n"
"    -l : Expected type integer, got \"xyz\"\n"
"    -f : Expected type integer, got \"bar\"\n"
"\n"
msgstr ""
#. TRANSLATORS: def OptionParser.next(argv, opts \\ [])
#: lib/option_parser.ex:283 
msgid ""
"Low-level function that parses one option.\n"
"\n"
"It accepts the same options as `parse/2` and `parse_head/2`\n"
"as both functions are built on top of this function. This function\n"
"may return:\n"
"\n"
"  * `{:ok, key, value, rest}` - the option `key` with `value` was\n"
"    successfully parsed\n"
"\n"
"  * `{:invalid, key, value, rest}` - the option `key` is invalid with `value`\n"
"    (returned when the value cannot be parsed according to the switch type)\n"
"\n"
"  * `{:undefined, key, value, rest}` - the option `key` is undefined\n"
"    (returned in strict mode when the switch is unknown)\n"
"\n"
"  * `{:error, rest}` - there are no switches at the head of the given `argv`\n"
"\n"
msgstr ""
#. TRANSLATORS: def OptionParser.parse_head!(argv, opts \\ [])
#: lib/option_parser.ex:218 
msgid ""
"The same as `parse_head/2` but raises an `OptionParser.ParseError`\n"
"exception if any invalid options are given.\n"
"\n"
"If there are no errors, returns a `{parsed, rest}` tuple where:\n"
"\n"
"  * `parsed` is the list of parsed switches (same as in `parse_head/2`)\n"
"  * `rest` is the list of arguments (same as in `parse_head/2`)\n"
"\n"
"## Examples\n"
"\n"
"    iex> OptionParser.parse_head!([\"--source\", \"lib\", \"path/to/file\", \"--verbose\"])\n"
"    {[source: \"lib\"], [\"path/to/file\", \"--verbose\"]}\n"
"\n"
"    iex> OptionParser.parse_head!([\"--number\", \"lib\", \"test/enum_test.exs\", \"--verbose\"], strict: [number: :integer])\n"
"    ** (OptionParser.ParseError) 1 error found!\n"
"    --number : Expected type integer, got \"lib\"\n"
"\n"
"    iex> OptionParser.parse_head!([\"--verbose\", \"--source\", \"lib\", \"test/enum_test.exs\", \"--unlock\"],\n"
"    ...>                          strict: [verbose: :integer, source: :integer])\n"
"    ** (OptionParser.ParseError) 2 errors found!\n"
"    --verbose : Missing argument of type integer\n"
"    --source : Expected type integer, got \"lib\"\n"
msgstr ""
#. TRANSLATORS: Elixir.OptionParser Summary
#: lib/option_parser.ex:2 
msgid ""
"This module contains functions to parse command line options.\n"
msgstr ""
