msgid ""
msgstr ""
"Project-Id-Version: l 10n_elixir\n"
"PO-Revision-Date: 2017-02-03 19:06+0900\n"
"Last-Translator: 小田 照敬 <EMAIL@ADDRESS>\n"
"Language-Team: Japanese\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"POT-Creation-Date: \n"
"X-Generator: Poedit 1.8.11\n"

#. TRANSLATORS: def OptionParser.to_argv(enum, opts \\ [])
#: lib/option_parser.ex:380
msgid ""
"Receives a key-value enumerable and converts it to `t:argv/0`.\n"
"\n"
"Keys must be atoms. Keys with `nil` value are discarded,\n"
"boolean values are converted to `--key` or `--no-key`\n"
"(if the value is `true` or `false`, respectively),\n"
"and all other values are converted using `Kernel.to_string/1`.\n"
"\n"
"It is advised to pass to `to_argv/2` the same set of `options`\n"
"given to `parse/2`. Some switches can only be reconstructed\n"
"correctly with the `switches` information in hand.\n"
"\n"
"## Examples\n"
"\n"
"    iex>  OptionParser.to_argv([foo_bar: \"baz\"])\n"
"    [\"--foo-bar\", \"baz\"]\n"
"    iex>  OptionParser.to_argv([bool: true, bool: false, discarded: nil])\n"
"    [\"--bool\", \"--no-bool\"]\n"
"\n"
"Some switches will output different values based on the switches\n"
"flag:\n"
"\n"
"    iex> OptionParser.to_argv([number: 2], switches: [])\n"
"    [\"--number\", \"2\"]\n"
"    iex> OptionParser.to_argv([number: 2], switches: [number: :count])\n"
"    [\"--number\", \"--number\"]\n"
"\n"
msgstr ""
"キー・バリューEnumerableを受け取り、`t:argv/0`に変換します。\n"
"\n"
"キーはアトムでなければなりません。値が`nil`のキーは破棄され、\n"
"真偽値は`--key`または`--no-key`（各々、値が`true`または`false`の\n"
"場合）に変換されます。その他のすべての値は`Kernel.to_string/1`を\n"
"使用して変換されます。\n"
"\n"
"`parse/2`に指定するのと同じセットの`options`を`to_argv/2`に\n"
"渡すことを勧めます。スイッチの中には`switches`情報がなければ\n"
"正しく再構築できないものもあります。\n"
"\n"
"## 例\n"
"\n"
"    iex>  OptionParser.to_argv([foo_bar: \"baz\"])\n"
"    [\"--foo-bar\", \"baz\"]\n"
"    iex>  OptionParser.to_argv([bool: true, bool: false, discarded: nil])\n"
"    [\"--bool\", \"--no-bool\"]\n"
"\n"
"スイッチの中にはスイッチフラグに基いて異なる値を出力するものも\n"
"あります:\n"
"\n"
"    iex> OptionParser.to_argv([number: 2], switches: [])\n"
"    [\"--number\", \"2\"]\n"
"    iex> OptionParser.to_argv([number: 2], switches: [number: :count])\n"
"    [\"--number\", \"--number\"]\n"
"\n"

#. TRANSLATORS: def OptionParser.parse_head(argv, opts \\ [])
#: lib/option_parser.ex:198
msgid ""
"Similar to `parse/2` but only parses the head of `argv`;\n"
"as soon as it finds a non-switch, it stops parsing.\n"
"\n"
"See `parse/2` for more information.\n"
"\n"
"## Example\n"
"\n"
"    iex> OptionParser.parse_head([\"--source\", \"lib\", \"test/enum_test.exs"
"\", \"--verbose\"])\n"
"    {[source: \"lib\"], [\"test/enum_test.exs\", \"--verbose\"], []}\n"
"\n"
"    iex> OptionParser.parse_head([\"--verbose\", \"--source\", \"lib\", "
"\"test/enum_test.exs\", \"--unlock\"])\n"
"    {[verbose: true, source: \"lib\"], [\"test/enum_test.exs\", \"--unlock"
"\"], []}\n"
"\n"
msgstr ""
"`paprser/2`と似ていますが、`argv`の先頭だけパースし、\n"
"スイッチでないものを見付けたらすぐにパースを中止します。\n"
"\n"
"詳細は`parse/2`を参照してください。\n"
"\n"
"## 例\n"
"\n"
"    iex> OptionParser.parse_head([\"--source\", \"lib\", \"test/enum_test.exs"
"\", \"--verbose\"])\n"
"    {[source: \"lib\"], [\"test/enum_test.exs\", \"--verbose\"], []}\n"
"\n"
"    iex> OptionParser.parse_head([\"--verbose\", \"--source\", \"lib\", "
"\"test/enum_test.exs\", \"--unlock\"])\n"
"    {[verbose: true, source: \"lib\"], [\"test/enum_test.exs\", \"--unlock"
"\"], []}\n"
"\n"

#. TRANSLATORS: def OptionParser.parse(argv, opts \\ [])
#: lib/option_parser.ex:15
msgid ""
"Parses `argv` into a keyword list.\n"
"\n"
"It returns a three-element tuple with the form `{parsed, args, invalid}`, "
"where:\n"
"\n"
"  * `parsed` is a keyword list of parsed switches with `{switch_name, value}"
"`\n"
"    tuples in it; `switch_name` is the atom representing the switch name "
"while\n"
"    `value` is the value for that switch parsed according to `opts` (see "
"the\n"
"    \"Examples\" section for more information)\n"
"  * `args` is a list of the remaining arguments in `argv` as strings\n"
"  * `invalid` is a list of invalid options as `{option_name, value}` where\n"
"    `option_name` is the raw option and `value` is `nil` if the option "
"wasn't\n"
"    expected or the string value if the value didn't have the expected type "
"for\n"
"    the corresponding option\n"
"\n"
"Elixir converts switches to underscored atoms, so `--source-path` becomes\n"
"`:source_path`. This is done to better suit Elixir conventions. However, "
"this\n"
"means that switches can't contain underscores and switches that do contain\n"
"underscores are always returned in the list of invalid options.\n"
"\n"
"Without any options, this function will try to parse all switches in the "
"`argv`.\n"
"\n"
"    iex> OptionParser.parse([\"--debug\"])\n"
"    {[debug: true], [], []}\n"
"\n"
"    iex> OptionParser.parse([\"--source\", \"lib\"])\n"
"    {[source: \"lib\"], [], []}\n"
"\n"
"    iex> OptionParser.parse([\"--source-path\", \"lib\", \"test/enum_test.exs"
"\", \"--verbose\"])\n"
"    {[source_path: \"lib\", verbose: true], [\"test/enum_test.exs\"], []}\n"
"\n"
"Switches followed by a value will be assigned the value, as a string.\n"
"Switches without an argument, like `--debug` in the examples above, will\n"
"automatically be set to `true`.\n"
"\n"
"## Options\n"
"\n"
"The following options are supported:\n"
"\n"
"  * `:switches` or `:strict` - see the \"Switch definitions\" section below\n"
"  * `:aliases` - see the \"Aliases\" section below\n"
"\n"
"## Switch definitions\n"
"\n"
"Often it is better to explicitly list the known\n"
"switches and their formats. The switches can be specified via one of two\n"
"options:\n"
"\n"
"  * `:switches` - defines some switches and their types. This function\n"
"    still attempts to parse switches that are not in this list.\n"
"  * `:strict` - defines strict switches. Any switch in `argv` that is not\n"
"    specified in the list is returned in the invalid options list.\n"
"\n"
"Both these options accept a keyword list of `{name, type}` tuples where "
"`name`\n"
"is an atom defining the name of the switch and `type` is an atom that\n"
"specifies the type for the value of this switch (see the \"Types\" section "
"below\n"
"for the possible types and more information about type casting).\n"
"\n"
"Note that you should only supply the `:switches` or the`:strict` option.\n"
"If you supply both, an `ArgumentError` exception will be raised.\n"
"\n"
"### Types\n"
"\n"
"Switches parsed by `OptionParser` may take zero or one arguments.\n"
"\n"
"The following switches types take no arguments:\n"
"\n"
"  * `:boolean` - sets the value to `true` when given (see also the\n"
"    \"Negation switches\" section below)\n"
"  * `:count` - counts the number of times the switch is given\n"
"\n"
"The following switches take one argument:\n"
"\n"
"  * `:integer` - parses the value as an integer\n"
"  * `:float` - parses the value as a float\n"
"  * `:string` - parses the value as a string\n"
"\n"
"If a switch can't be parsed according to the given type, it is returned\n"
"in the invalid options list.\n"
"\n"
"### Modifiers\n"
"\n"
"Switches can be specified with modifiers, which change how\n"
"they behave. The following modifiers are supported:\n"
"\n"
"  * `:keep` - keeps duplicated items instead of overriding them; works with\n"
"    all types except `:count`. Specifying `switch_name: :keep` assumes the\n"
"    type of `:switch_name` will be `:string`.\n"
"\n"
"Note that if you want to use `:keep` with a type other than `:string`, use a "
"list\n"
"as the type for the switch. For example: `[foo: [:integer, :keep]]`.\n"
"\n"
"### Negation switches\n"
"\n"
"In case a switch `SWITCH` is specified to have type `:boolean`, it may be\n"
"passed as `--no-SWITCH` as well which will set the option to `false`:\n"
"\n"
"    iex> OptionParser.parse([\"--no-op\", \"path/to/file\"], switches: [op: :"
"boolean])\n"
"    {[op: false], [\"path/to/file\"], []}\n"
"\n"
"## Aliases\n"
"\n"
"A set of aliases can be specified in the `:aliases` option:\n"
"\n"
"    iex> OptionParser.parse([\"-d\"], aliases: [d: :debug])\n"
"    {[debug: true], [], []}\n"
"\n"
"## Examples\n"
"\n"
"Here are some examples of working with different types and modifiers:\n"
"\n"
"    iex> OptionParser.parse([\"--unlock\", \"path/to/file\"], strict: "
"[unlock: :boolean])\n"
"    {[unlock: true], [\"path/to/file\"], []}\n"
"\n"
"    iex> OptionParser.parse([\"--unlock\", \"--limit\", \"0\", \"path/to/file"
"\"],\n"
"    ...>                    strict: [unlock: :boolean, limit: :integer])\n"
"    {[unlock: true, limit: 0], [\"path/to/file\"], []}\n"
"\n"
"    iex> OptionParser.parse([\"--limit\", \"3\"], strict: [limit: :"
"integer])\n"
"    {[limit: 3], [], []}\n"
"\n"
"    iex> OptionParser.parse([\"--limit\", \"xyz\"], strict: [limit: :"
"integer])\n"
"    {[], [], [{\"--limit\", \"xyz\"}]}\n"
"\n"
"    iex> OptionParser.parse([\"--verbose\"], switches: [verbose: :count])\n"
"    {[verbose: 1], [], []}\n"
"\n"
"    iex> OptionParser.parse([\"-v\", \"-v\"], aliases: [v: :verbose], "
"strict: [verbose: :count])\n"
"    {[verbose: 2], [], []}\n"
"\n"
"    iex> OptionParser.parse([\"--unknown\", \"xyz\"], strict: [])\n"
"    {[], [\"xyz\"], [{\"--unknown\", nil}]}\n"
"\n"
"    iex> OptionParser.parse([\"--limit\", \"3\", \"--unknown\", \"xyz\"],\n"
"    ...>                    switches: [limit: :integer])\n"
"    {[limit: 3, unknown: \"xyz\"], [], []}\n"
"\n"
"    iex> OptionParser.parse([\"--unlock\", \"path/to/file\", \"--unlock\", "
"\"path/to/another/file\"], strict: [unlock: :keep])\n"
"    {[unlock: \"path/to/file\", unlock: \"path/to/another/file\"], [], []}\n"
"\n"
msgstr ""
"`argv`をキーワードリストにパースします。\n"
"\n"
"`{parsed, args, invalid}`形式の3要素のタプルを返します。ここで:\n"
"\n"
"  * `parsed`はパースされたスイッチのキーワードリストで、`{switch_name, value}"
"`\n"
"   タプルを持ちます。ここで、`switch_name`はスイッチ名を表すアトムで、\n"
"   `value`は`opts`に従ってパースされたスイッチの値です（詳細は\n"
"    「例」セクションを参照してください）\n"
"  * `args`は`args`で残りの文字列のリストです。\n"
"  * `invalid`は無効なオプションの`{option_name, value}`の形式のリストです。こ"
"こで、\n"
"    `option_name`は生のオプションで、`value`はオプションが想定されていない場"
"合は\n"
"    `nil`、値が対応するオプションの想定されたタイプを持っていなかった場合は\n"
"    文字列値です。\n"
"\n"
"Elixirはスイッチをアンダースコア付きアトムに変換します。したがって、`--"
"source-path`は\n"
"`:source_path`になります。これはElixirの慣習に合わせるために行われます。\n"
"しかし、これはスイッチにアンダースコアを含めることができず、アンダースコア"
"を\n"
"含むスイッチは杖に無効なオプションのリストとして返されることを意味します。\n"
"\n"
"オプションが指定されない場合、この関数は`args`中のすべてのスイッチをパースし"
"ようとします。\n"
"\n"
"    iex> OptionParser.parse([\"--debug\"])\n"
"    {[debug: true], [], []}\n"
"\n"
"    iex> OptionParser.parse([\"--source\", \"lib\"])\n"
"    {[source: \"lib\"], [], []}\n"
"\n"
"    iex> OptionParser.parse([\"--source-path\", \"lib\", \"test/enum_test.exs"
"\", \"--verbose\"])\n"
"    {[source_path: \"lib\", verbose: true], [\"test/enum_test.exs\"], []}\n"
"\n"
"スイッチに値が続く場合は、その値が文字列として割り当てられます。\n"
"上の例の`—debug`のように引数を持たないスイッチは\n"
"自動的に`true`に設定されます。\n"
"\n"
"## オプション\n"
"\n"
"次のオプションがサポートされています。\n"
"\n"
"  * `:switches` または `:strict` - 以下の「スイッチ定義」セクションを参照して"
"ください\n"
"  * `:aliases` - 以下の「エイリアス」セクションを参照してください\n"
"\n"
"## スイッチ定義\n"
"\n"
"多くの場合、既知のスイッチとその形式を明示的にリストする方が\n"
"よい場合があります。 スイッチは、次の2つのオプションのいずれかを\n"
"使用して指定できます。\n"
"\n"
"  * `:switches` - スイッチとそのタイプを定義します。この関数は\n"
"    このリストに存在しないスイッチもパースしようと試みます。\n"
"  * `:strict` - 厳格にスイッチを定義します。このリストに指定されていない\n"
"    `argv`中のスイッチはすべて無効なオプションリストで返されます。\n"
"\n"
"どちらのオプションも`{name, type}`タプルのキーワードリストを\n"
"受け付けます。ここで、`name`はスイッチの名前を定義するアトムで、\n"
"`type`はこのスイッチの値のタイプを指定するアトムです（指定可能な\n"
"タイプとタイプのキャスティングに関する詳細は、以下の「タイプ」\n"
"セクションを参照してください）。\n"
"\n"
"オプション`:switches`と`:strict`はどちらか1つしか指定できないことに\n"
"注意してください。両方と指定すると`ArgumentError`例外が発生します。\n"
"\n"
"### タイプ\n"
"\n"
"`OptionParser`でパースされるスイッチは0または1つの引数をとることができま"
"す。\n"
"\n"
"次のスイッチタイプは引数を取りません。\n"
"\n"
"  * `:boolean` - 指定されると値に`true`を設定します（以下の「否定スイッチ」\n"
"    セクションも参照してください）\n"
"  * `:count` - スイッチが指定された回数をカウントします\n"
"\n"
"次のスイッチは引数を1つ取ります。\n"
"\n"
"  * `:integer` - 値を整数としてパースします\n"
"  * `:float` - 値を浮動小数点数としてパースします\n"
"  * `:string` - 値を文字列としてパースします\n"
"\n"
"スイッチが指定されたタイプでパースできない場合は、無効なオプション\n"
"リストで返されます。\n"
"\n"
"### 修飾子\n"
"\n"
"スイッチには、動作方法を変更する修飾子を指定することができます。\n"
"次の修飾子がサポートされています。\n"
"\n"
"  * `:keep` - 重複した項目を上書きせずに保持します。`:count`を除く\n"
"    すべてのタイプで使用できます。`switch_name: :keep`と指定すると\n"
"    `:switch_name`のタイプが`:string`だとみなされます。\n"
"\n"
"`:string`以外のタイプで`:keep`を使用したい場合は、スイッチのタイプとして\n"
"リストを使用してください。たとえば、`[foo: [:integer, :keep]]`のように。\n"
"\n"
"### 否定スイッチ\n"
"\n"
"スイッチ`SWITCH`が`boolean`タイプを持つように指定した場合、\n"
"`—no-SWITCH`を渡すこともでき、SWITCHオプションは`false`に設定されます。\n"
"\n"
"    iex> OptionParser.parse([\"--no-op\", \"path/to/file\"], switches: [op: :"
"boolean])\n"
"    {[op: false], [\"path/to/file\"], []}\n"
"\n"
"## エイリアス\n"
"\n"
"`:aliases`オプションでエイリアスの集合を指定することができます。\n"
"\n"
"    iex> OptionParser.parse([\"-d\"], aliases: [d: :debug])\n"
"    {[debug: true], [], []}\n"
"\n"
"\n"
"## 例\n"
"\n"
"    iex> OptionParser.parse([\"--unlock\", \"path/to/file\"], strict: "
"[unlock: :boolean])\n"
"    {[unlock: true], [\"path/to/file\"], []}\n"
"\n"
"    iex> OptionParser.parse([\"--unlock\", \"--limit\", \"0\", \"path/to/file"
"\"],\n"
"    ...>                    strict: [unlock: :boolean, limit: :integer])\n"
"    {[unlock: true, limit: 0], [\"path/to/file\"], []}\n"
"\n"
"    iex> OptionParser.parse([\"--limit\", \"3\"], strict: [limit: :"
"integer])\n"
"    {[limit: 3], [], []}\n"
"\n"
"    iex> OptionParser.parse([\"--limit\", \"xyz\"], strict: [limit: :"
"integer])\n"
"    {[], [], [{\"--limit\", \"xyz\"}]}\n"
"\n"
"    iex> OptionParser.parse([\"--verbose\"], switches: [verbose: :count])\n"
"    {[verbose: 1], [], []}\n"
"\n"
"    iex> OptionParser.parse([\"-v\", \"-v\"], aliases: [v: :verbose], "
"strict: [verbose: :count])\n"
"    {[verbose: 2], [], []}\n"
"\n"
"    iex> OptionParser.parse([\"--unknown\", \"xyz\"], strict: [])\n"
"    {[], [\"xyz\"], [{\"--unknown\", nil}]}\n"
"\n"
"    iex> OptionParser.parse([\"--limit\", \"3\", \"--unknown\", \"xyz\"],\n"
"    ...>                    switches: [limit: :integer])\n"
"    {[limit: 3, unknown: \"xyz\"], [], []}\n"
"\n"
"    iex> OptionParser.parse([\"--unlock\", \"path/to/file\", \"--unlock\", "
"\"path/to/another/file\"], strict: [unlock: :keep])\n"
"    {[unlock: \"path/to/file\", unlock: \"path/to/another/file\"], [], []}\n"
"\n"

#. TRANSLATORS: def OptionParser.split(string)
#: lib/option_parser.ex:431
msgid ""
"Splits a string into `t:argv/0` chunks.\n"
"\n"
"This function splits the given `string` into a list of strings in a similar\n"
"way to many shells.\n"
"\n"
"## Examples\n"
"\n"
"    iex> OptionParser.split(\"foo bar\")\n"
"    [\"foo\", \"bar\"]\n"
"\n"
"    iex> OptionParser.split(\"foo \\\"bar baz\\\"\")\n"
"    [\"foo\", \"bar baz\"]\n"
"\n"
msgstr ""
"文字列を`t:argv/0`チャンクに分割します。\n"
"\n"
"この関数は指定された`string`を多くのシェルと同様な\n"
"方法で文字列のリストに分割します。\n"
"\n"
"## 例\n"
"\n"
"    iex> OptionParser.split(\"foo bar\")\n"
"    [\"foo\", \"bar\"]\n"
"\n"
"    iex> OptionParser.split(\"foo \\\"bar baz\\\"\")\n"
"    [\"foo\", \"bar baz\"]\n"
"\n"

#. TRANSLATORS: def OptionParser.parse!(argv, opts \\ [])
#: lib/option_parser.ex:161
msgid ""
"The same as `parse/2` but raises an `OptionParser.ParseError`\n"
"exception if any invalid options are given.\n"
"\n"
"If there are no errors, returns a `{parsed, rest}` tuple where:\n"
"\n"
"  * `parsed` is the list of parsed switches (same as in `parse/2`)\n"
"  * `rest` is the list of arguments (same as in `parse/2`)\n"
"\n"
"## Examples\n"
"\n"
"    iex> OptionParser.parse!([\"--debug\", \"path/to/file\"], strict: "
"[debug: :boolean])\n"
"    {[debug: true], [\"path/to/file\"]}\n"
"\n"
"    iex> OptionParser.parse!([\"--limit\", \"xyz\"], strict: [limit: :"
"integer])\n"
"    ** (OptionParser.ParseError) 1 error found!\n"
"    --limit : Expected type integer, got \"xyz\"\n"
"\n"
"    iex> OptionParser.parse!([\"--unknown\", \"xyz\"], strict: [])\n"
"    ** (OptionParser.ParseError) 1 error found!\n"
"    --unknown : Unknown option\n"
"\n"
"    iex> OptionParser.parse!([\"-l\", \"xyz\", \"-f\", \"bar\"],\n"
"    ...>                     switches: [limit: :integer, foo: :integer], "
"aliases: [l: :limit, f: :foo])\n"
"    ** (OptionParser.ParseError) 2 errors found!\n"
"    -l : Expected type integer, got \"xyz\"\n"
"    -f : Expected type integer, got \"bar\"\n"
"\n"
msgstr ""
"`parse/2`と同じですが、無効なオプションが指定されると\n"
"`OptionParser.ParseError`例外を発生させます。\n"
"\n"
"エラーがない場合は、`{parsed, rest}`タプルを返します。ここで、\n"
"\n"
"  * `parsed`はパースされたスイッチのリストです（ `parse/2`と同じ）\n"
"  * `rest`は引数のリストです（`parse/2`と同じ）\n"
"\n"
"## 例\n"
"\n"
"    iex> OptionParser.parse!([\"--debug\", \"path/to/file\"], strict: "
"[debug: :boolean])\n"
"    {[debug: true], [\"path/to/file\"]}\n"
"\n"
"    iex> OptionParser.parse!([\"--limit\", \"xyz\"], strict: [limit: :"
"integer])\n"
"    ** (OptionParser.ParseError) 1 error found!\n"
"    --limit : Expected type integer, got \"xyz\"\n"
"\n"
"    iex> OptionParser.parse!([\"--unknown\", \"xyz\"], strict: [])\n"
"    ** (OptionParser.ParseError) 1 error found!\n"
"    --unknown : Unknown option\n"
"\n"
"    iex> OptionParser.parse!([\"-l\", \"xyz\", \"-f\", \"bar\"],\n"
"    ...>                     switches: [limit: :integer, foo: :integer], "
"aliases: [l: :limit, f: :foo])\n"
"    ** (OptionParser.ParseError) 2 errors found!\n"
"    -l : Expected type integer, got \"xyz\"\n"
"    -f : Expected type integer, got \"bar\"\n"
"\n"

#. TRANSLATORS: def OptionParser.next(argv, opts \\ [])
#: lib/option_parser.ex:283
msgid ""
"Low-level function that parses one option.\n"
"\n"
"It accepts the same options as `parse/2` and `parse_head/2`\n"
"as both functions are built on top of this function. This function\n"
"may return:\n"
"\n"
"  * `{:ok, key, value, rest}` - the option `key` with `value` was\n"
"    successfully parsed\n"
"\n"
"  * `{:invalid, key, value, rest}` - the option `key` is invalid with "
"`value`\n"
"    (returned when the value cannot be parsed according to the switch type)\n"
"\n"
"  * `{:undefined, key, value, rest}` - the option `key` is undefined\n"
"    (returned in strict mode when the switch is unknown)\n"
"\n"
"  * `{:error, rest}` - there are no switches at the head of the given "
"`argv`\n"
"\n"
msgstr ""
"1つのオプションをパースする低レベル関数です。\n"
"\n"
"`parse/2`および`parse_head/2`と同じオプションを受け付けます。\n"
"両関数はこの関数を使って構築されているからです。\n"
"この関数は以下を返します:\n"
"\n"
"  * `{:ok, key, value, rest}` - オプション`key`の値は`value`に正常に\n"
"    パースされました。\n"
"\n"
"  * `{:invalid, key, value, rest}` - オプション`key`の値`value`は無効です\n"
"    （スイッチタイプにより値がパースできなかった場合に返されます）\n"
"\n"
"  * `{:undefined, key, value, rest}` - オプション`key`は未定義です\n"
"    （スイッチが不明でstrictモードの場合に返されます）\n"
"\n"
"  * `{:error, rest}` - 指定された`argv`の先頭にスイッチがありません\n"

#. TRANSLATORS: def OptionParser.parse_head!(argv, opts \\ [])
#: lib/option_parser.ex:218
msgid ""
"The same as `parse_head/2` but raises an `OptionParser.ParseError`\n"
"exception if any invalid options are given.\n"
"\n"
"If there are no errors, returns a `{parsed, rest}` tuple where:\n"
"\n"
"  * `parsed` is the list of parsed switches (same as in `parse_head/2`)\n"
"  * `rest` is the list of arguments (same as in `parse_head/2`)\n"
"\n"
"## Examples\n"
"\n"
"    iex> OptionParser.parse_head!([\"--source\", \"lib\", \"path/to/file\", "
"\"--verbose\"])\n"
"    {[source: \"lib\"], [\"path/to/file\", \"--verbose\"]}\n"
"\n"
"    iex> OptionParser.parse_head!([\"--number\", \"lib\", \"test/enum_test."
"exs\", \"--verbose\"], strict: [number: :integer])\n"
"    ** (OptionParser.ParseError) 1 error found!\n"
"    --number : Expected type integer, got \"lib\"\n"
"\n"
"    iex> OptionParser.parse_head!([\"--verbose\", \"--source\", \"lib\", "
"\"test/enum_test.exs\", \"--unlock\"],\n"
"    ...>                          strict: [verbose: :integer, source: :"
"integer])\n"
"    ** (OptionParser.ParseError) 2 errors found!\n"
"    --verbose : Missing argument of type integer\n"
"    --source : Expected type integer, got \"lib\"\n"
msgstr ""
"`parse_head/2`と同じですが、無効なオプションが指定されたら\n"
"`OptionParser.ParseError`例外を発生させます。\n"
"\n"
"エラーがない場合は、`{parsed, rest}`タプルを返します。ここで、\n"
"\n"
"  * `parsed`はパースされたスイッチのリストです（ `parse_head/2`と同じ）\n"
"  * `rest`は引数のリストです（`parse_head/2`と同じ）\n"
"\n"
"## 例\n"
"\n"
"    iex> OptionParser.parse_head!([\"--source\", \"lib\", \"path/to/file\", "
"\"--verbose\"])\n"
"    {[source: \"lib\"], [\"path/to/file\", \"--verbose\"]}\n"
"\n"
"    iex> OptionParser.parse_head!([\"--number\", \"lib\", \"test/enum_test."
"exs\", \"--verbose\"], strict: [number: :integer])\n"
"    ** (OptionParser.ParseError) 1 error found!\n"
"    --number : Expected type integer, got \"lib\"\n"
"\n"
"    iex> OptionParser.parse_head!([\"--verbose\", \"--source\", \"lib\", "
"\"test/enum_test.exs\", \"--unlock\"],\n"
"    ...>                          strict: [verbose: :integer, source: :"
"integer])\n"
"    ** (OptionParser.ParseError) 2 errors found!\n"
"    --verbose : Missing argument of type integer\n"
"    --source : Expected type integer, got \"lib\"\n"
"\n"

#. TRANSLATORS: Elixir.OptionParser Summary
#: lib/option_parser.ex:2
msgid "This module contains functions to parse command line options.\n"
msgstr ""
"このモジュールはコマンドライン引数をパースするための関数を含んでいます。\n"
