msgid ""
msgstr ""
"Project-Id-Version: l 10n_elixir\n"
"POT-Creation-Date: \n"
"PO-Revision-Date: 2017-03-28 09:46+0900\n"
"Last-Translator: 小田 照敬 <EMAIL@ADDRESS>\n"
"Language-Team: Japanese\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Poedit 1.8.12\n"

#. TRANSLATORS: def OptionParser.to_argv(enum, opts \\ [])
#: lib/option_parser.ex:421
msgid ""
"Receives a key-value enumerable and converts it to `t:argv/0`.\n"
"\n"
"Keys must be atoms. Keys with `nil` value are discarded,\n"
"boolean values are converted to `--key` or `--no-key`\n"
"(if the value is `true` or `false`, respectively),\n"
"and all other values are converted using `Kernel.to_string/1`.\n"
"\n"
"It is advised to pass to `to_argv/2` the same set of `options`\n"
"given to `parse/2`. Some switches can only be reconstructed\n"
"correctly with the `switches` information in hand.\n"
"\n"
"## Examples\n"
"\n"
"    iex>  OptionParser.to_argv([foo_bar: \"baz\"])\n"
"    [\"--foo-bar\", \"baz\"]\n"
"    iex>  OptionParser.to_argv([bool: true, bool: false, discarded: nil])\n"
"    [\"--bool\", \"--no-bool\"]\n"
"\n"
"Some switches will output different values based on the switches\n"
"flag:\n"
"\n"
"    iex> OptionParser.to_argv([number: 2], switches: [])\n"
"    [\"--number\", \"2\"]\n"
"    iex> OptionParser.to_argv([number: 2], switches: [number: :count])\n"
"    [\"--number\", \"--number\"]\n"
"\n"
msgstr ""
"キー・バリューEnumerableを受け取り、`t:argv/0`に変換します。\n"
"\n"
"キーはアトムでなければなりません。値が`nil`のキーは破棄され、\n"
"真偽値は`--key`または`--no-key`（各々、値が`true`または`false`の\n"
"場合）に変換されます。その他のすべての値は`Kernel.to_string/1`を\n"
"使用して変換されます。\n"
"\n"
"`parse/2`に指定するのと同じセットの`options`を`to_argv/2`に\n"
"渡すことを勧めます。スイッチの中には`switches`情報がなければ\n"
"正しく再構築できないものもあります。\n"
"\n"
"## 例\n"
"\n"
"    iex>  OptionParser.to_argv([foo_bar: \"baz\"])\n"
"    [\"--foo-bar\", \"baz\"]\n"
"    iex>  OptionParser.to_argv([bool: true, bool: false, discarded: nil])\n"
"    [\"--bool\", \"--no-bool\"]\n"
"\n"
"スイッチの中にはスイッチフラグに基いて異なる値を出力するものも\n"
"あります:\n"
"\n"
"    iex> OptionParser.to_argv([number: 2], switches: [])\n"
"    [\"--number\", \"2\"]\n"
"    iex> OptionParser.to_argv([number: 2], switches: [number: :count])\n"
"    [\"--number\", \"--number\"]\n"
"\n"

#. TRANSLATORS: def OptionParser.parse!(argv, opts \\ [])
#: lib/option_parser.ex:199
msgid ""
"The same as `parse/2` but raises an `OptionParser.ParseError`\n"
"exception if any invalid options are given.\n"
"\n"
"If there are no errors, returns a `{parsed, rest}` tuple where:\n"
"\n"
"  * `parsed` is the list of parsed switches (same as in `parse/2`)\n"
"  * `rest` is the list of arguments (same as in `parse/2`)\n"
"\n"
"## Examples\n"
"\n"
"    iex> OptionParser.parse!([\"--debug\", \"path/to/file\"], strict: "
"[debug: :boolean])\n"
"    {[debug: true], [\"path/to/file\"]}\n"
"\n"
"    iex> OptionParser.parse!([\"--limit\", \"xyz\"], strict: [limit: :"
"integer])\n"
"    ** (OptionParser.ParseError) 1 error found!\n"
"    --limit : Expected type integer, got \"xyz\"\n"
"\n"
"    iex> OptionParser.parse!([\"--unknown\", \"xyz\"], strict: [])\n"
"    ** (OptionParser.ParseError) 1 error found!\n"
"    --unknown : Unknown option\n"
"\n"
"    iex> OptionParser.parse!([\"-l\", \"xyz\", \"-f\", \"bar\"],\n"
"    ...>                     switches: [limit: :integer, foo: :integer], "
"aliases: [l: :limit, f: :foo])\n"
"    ** (OptionParser.ParseError) 2 errors found!\n"
"    -l : Expected type integer, got \"xyz\"\n"
"    -f : Expected type integer, got \"bar\"\n"
"\n"
msgstr ""
"`parse/2`と同じですが、無効なオプションが指定されると\n"
"`OptionParser.ParseError`例外を発生させます。\n"
"\n"
"エラーがない場合は、`{parsed, rest}`タプルを返します。ここで、\n"
"\n"
"  * `parsed`はパースされたスイッチのリストです（ `parse/2`と同じ）\n"
"  * `rest`は引数のリストです（`parse/2`と同じ）\n"
"\n"
"## 例\n"
"\n"
"    iex> OptionParser.parse!([\"--debug\", \"path/to/file\"], strict: "
"[debug: :boolean])\n"
"    {[debug: true], [\"path/to/file\"]}\n"
"\n"
"    iex> OptionParser.parse!([\"--limit\", \"xyz\"], strict: [limit: :"
"integer])\n"
"    ** (OptionParser.ParseError) 1 error found!\n"
"    --limit : Expected type integer, got \"xyz\"\n"
"\n"
"    iex> OptionParser.parse!([\"--unknown\", \"xyz\"], strict: [])\n"
"    ** (OptionParser.ParseError) 1 error found!\n"
"    --unknown : Unknown option\n"
"\n"
"    iex> OptionParser.parse!([\"-l\", \"xyz\", \"-f\", \"bar\"],\n"
"    ...>                     switches: [limit: :integer, foo: :integer], "
"aliases: [l: :limit, f: :foo])\n"
"    ** (OptionParser.ParseError) 2 errors found!\n"
"    -l : Expected type integer, got \"xyz\"\n"
"    -f : Expected type integer, got \"bar\"\n"
"\n"

#. TRANSLATORS: def OptionParser.parse_head!(argv, opts \\ [])
#: lib/option_parser.ex:258
msgid ""
"The same as `parse_head/2` but raises an `OptionParser.ParseError`\n"
"exception if any invalid options are given.\n"
"\n"
"If there are no errors, returns a `{parsed, rest}` tuple where:\n"
"\n"
"  * `parsed` is the list of parsed switches (same as in `parse_head/2`)\n"
"  * `rest` is the list of arguments (same as in `parse_head/2`)\n"
"\n"
"## Examples\n"
"\n"
"    iex> OptionParser.parse_head!([\"--source\", \"lib\", \"path/to/file\", "
"\"--verbose\"],\n"
"    ...>                         switches: [source: :string, verbose: :"
"boolean])\n"
"    {[source: \"lib\"], [\"path/to/file\", \"--verbose\"]}\n"
"\n"
"    iex> OptionParser.parse_head!([\"--number\", \"lib\", \"test/enum_test."
"exs\", \"--verbose\"],\n"
"    ...>                          strict: [number: :integer])\n"
"    ** (OptionParser.ParseError) 1 error found!\n"
"    --number : Expected type integer, got \"lib\"\n"
"\n"
"    iex> OptionParser.parse_head!([\"--verbose\", \"--source\", \"lib\", "
"\"test/enum_test.exs\", \"--unlock\"],\n"
"    ...>                          strict: [verbose: :integer, source: :"
"integer])\n"
"    ** (OptionParser.ParseError) 2 errors found!\n"
"    --verbose : Missing argument of type integer\n"
"    --source : Expected type integer, got \"lib\"\n"
msgstr ""
"`parse_head/2`と同じですが、無効なオプションが指定された場合\n"
"`OptionParser.ParseError`例外を発生させます。\n"
"\n"
"エラーがない場合は、`{parsed, rest}`タプルを返します。ここで、\n"
"\n"
"  * `parsed`はパースされたスイッチのリストです（ `parse_head/2`と同じ）\n"
"  * `rest`は引数のリストです（`parse_head/2`と同じ）\n"
"\n"
"## 例\n"
"\n"
"    iex> OptionParser.parse_head!([\"--source\", \"lib\", \"path/to/file\", "
"\"--verbose\"],\n"
"    ...>                         switches: [source: :string, verbose: :"
"boolean])\n"
"    {[source: \"lib\"], [\"path/to/file\", \"--verbose\"]}\n"
"\n"
"    iex> OptionParser.parse_head!([\"--number\", \"lib\", \"test/enum_test."
"exs\", \"--verbose\"],\n"
"    ...>                          strict: [number: :integer])\n"
"    ** (OptionParser.ParseError) 1 error found!\n"
"    --number : Expected type integer, got \"lib\"\n"
"\n"
"    iex> OptionParser.parse_head!([\"--verbose\", \"--source\", \"lib\", "
"\"test/enum_test.exs\", \"--unlock\"],\n"
"    ...>                          strict: [verbose: :integer, source: :"
"integer])\n"
"    ** (OptionParser.ParseError) 2 errors found!\n"
"    --verbose : Missing argument of type integer\n"
"    --source : Expected type integer, got \"lib\"\n"

#. TRANSLATORS: def OptionParser.parse(argv, opts \\ [])
#: lib/option_parser.ex:15
msgid ""
"Parses `argv` into a keyword list.\n"
"\n"
"It returns a three-element tuple with the form `{parsed, args, invalid}`, "
"where:\n"
"\n"
"  * `parsed` is a keyword list of parsed switches with `{switch_name, value}"
"`\n"
"    tuples in it; `switch_name` is the atom representing the switch name "
"while\n"
"    `value` is the value for that switch parsed according to `opts` (see "
"the\n"
"    \"Examples\" section for more information)\n"
"  * `args` is a list of the remaining arguments in `argv` as strings\n"
"  * `invalid` is a list of invalid options as `{option_name, value}` where\n"
"    `option_name` is the raw option and `value` is `nil` if the option "
"wasn't\n"
"    expected or the string value if the value didn't have the expected type "
"for\n"
"    the corresponding option\n"
"\n"
"Elixir converts switches to underscored atoms, so `--source-path` becomes\n"
"`:source_path`. This is done to better suit Elixir conventions. However, "
"this\n"
"means that switches can't contain underscores and switches that do contain\n"
"underscores are always returned in the list of invalid switches.\n"
"\n"
"When parsing, it is common to list switches and their expected types:\n"
"\n"
"    iex> OptionParser.parse([\"--debug\"], switches: [debug: :boolean])\n"
"    {[debug: true], [], []}\n"
"\n"
"    iex> OptionParser.parse([\"--source\", \"lib\"], switches: [source: :"
"string])\n"
"    {[source: \"lib\"], [], []}\n"
"\n"
"    iex> OptionParser.parse([\"--source-path\", \"lib\", \"test/enum_test.exs"
"\", \"--verbose\"],\n"
"    ...>                    switches: [source_path: :string, verbose: :"
"boolean])\n"
"    {[source_path: \"lib\", verbose: true], [\"test/enum_test.exs\"], []}\n"
"\n"
"We will explore the valid switches and operation modes of option parser "
"below.\n"
"\n"
"## Options\n"
"\n"
"The following options are supported:\n"
"\n"
"  * `:switches` or `:strict` - see the \"Switch definitions\" section below\n"
"  * `:allow_nonexistent_atoms` - see the \"Parsing dynamic switches\" "
"section below\n"
"  * `:aliases` - see the \"Aliases\" section below\n"
"\n"
"## Switch definitions\n"
"\n"
"Switches can be specified via one of two options:\n"
"\n"
"  * `:switches` - defines some switches and their types. This function\n"
"    still attempts to parse switches that are not in this list.\n"
"  * `:strict` - defines strict switches. Any switch in `argv` that is not\n"
"    specified in the list is returned in the invalid options list.\n"
"\n"
"Both these options accept a keyword list of `{name, type}` tuples where "
"`name`\n"
"is an atom defining the name of the switch and `type` is an atom that\n"
"specifies the type for the value of this switch (see the \"Types\" section "
"below\n"
"for the possible types and more information about type casting).\n"
"\n"
"Note that you should only supply the `:switches` or the`:strict` option.\n"
"If you supply both, an `ArgumentError` exception will be raised.\n"
"\n"
"### Types\n"
"\n"
"Switches parsed by `OptionParser` may take zero or one arguments.\n"
"\n"
"The following switches types take no arguments:\n"
"\n"
"  * `:boolean` - sets the value to `true` when given (see also the\n"
"    \"Negation switches\" section below)\n"
"  * `:count` - counts the number of times the switch is given\n"
"\n"
"The following switches take one argument:\n"
"\n"
"  * `:integer` - parses the value as an integer\n"
"  * `:float` - parses the value as a float\n"
"  * `:string` - parses the value as a string\n"
"\n"
"If a switch can't be parsed according to the given type, it is\n"
"returned in the invalid options list.\n"
"\n"
"### Modifiers\n"
"\n"
"Switches can be specified with modifiers, which change how\n"
"they behave. The following modifiers are supported:\n"
"\n"
"  * `:keep` - keeps duplicated items instead of overriding them;\n"
"    works with all types except `:count`. Specifying `switch_name: :keep`\n"
"    assumes the type of `:switch_name` will be `:string`.\n"
"\n"
"To use `:keep` with a type other than `:string`, use a list as the type\n"
"for the switch. For example: `[foo: [:integer, :keep]]`.\n"
"\n"
"### Negation switches\n"
"\n"
"In case a switch `SWITCH` is specified to have type `:boolean`, it may be\n"
"passed as `--no-SWITCH` as well which will set the option to `false`:\n"
"\n"
"    iex> OptionParser.parse([\"--no-op\", \"path/to/file\"], switches: [op: :"
"boolean])\n"
"    {[op: false], [\"path/to/file\"], []}\n"
"\n"
"### Parsing dynamic switches\n"
"\n"
"`OptionParser` also includes a dynamic mode where it will attempt to parse\n"
"switches dynamically. Such can be done by not specifying the `:switches` or\n"
"`:strict` option.\n"
"\n"
"    iex> OptionParser.parse([\"--debug\"])\n"
"    {[debug: true], [], []}\n"
"\n"
"\n"
"Switches followed by a value will be assigned the value, as a string. "
"Switches\n"
"without an argument, like `--debug` in the examples above, will "
"automatically be\n"
"set to `true`.\n"
"\n"
"Since Elixir converts switches to atoms, the dynamic mode will only parse\n"
"switches that translates to atoms used by the runtime. Therefore, the code "
"below\n"
"likely won't parse the given option since the `:option_parser_example` atom "
"is\n"
"never used anywhere:\n"
"\n"
"    OptionParser.parse([\"--option-parser-example\"])\n"
"    # Does nothing more...\n"
"\n"
"However, the code below does since the `:option_parser_example` atom is "
"used\n"
"at some point later (or earlier) on:\n"
"\n"
"    {opts, _, _} = OptionParser.parse([\"--option-parser-example\"])\n"
"    opts[:option_parser_example]\n"
"\n"
"In other words, when using dynamic mode, Elixir will do the correct thing "
"and\n"
"only parse options that are used by the runtime, ignoring all others. If "
"you\n"
"would like to parse all switches, regardless if they exist or not, you can\n"
"force creation of atoms by passing `allow_nonexistent_atoms: true` as "
"option.\n"
"Such option is useful when you are building command-line applications that\n"
"receive dynamically-named arguments but must be used with care on long-"
"running\n"
"systems.\n"
"\n"
"Switches followed by a value will be assigned the value, as a string.\n"
"Switches without an argument, like `--debug` in the examples above, will\n"
"automatically be set to `true`.\n"
"\n"
"## Aliases\n"
"\n"
"A set of aliases can be specified in the `:aliases` option:\n"
"\n"
"    iex> OptionParser.parse([\"-d\"], aliases: [d: :debug])\n"
"    {[debug: true], [], []}\n"
"\n"
"## Examples\n"
"\n"
"Here are some examples of working with different types and modifiers:\n"
"\n"
"    iex> OptionParser.parse([\"--unlock\", \"path/to/file\"], strict: "
"[unlock: :boolean])\n"
"    {[unlock: true], [\"path/to/file\"], []}\n"
"\n"
"    iex> OptionParser.parse([\"--unlock\", \"--limit\", \"0\", \"path/to/file"
"\"],\n"
"    ...>                    strict: [unlock: :boolean, limit: :integer])\n"
"    {[unlock: true, limit: 0], [\"path/to/file\"], []}\n"
"\n"
"    iex> OptionParser.parse([\"--limit\", \"3\"], strict: [limit: :"
"integer])\n"
"    {[limit: 3], [], []}\n"
"\n"
"    iex> OptionParser.parse([\"--limit\", \"xyz\"], strict: [limit: :"
"integer])\n"
"    {[], [], [{\"--limit\", \"xyz\"}]}\n"
"\n"
"    iex> OptionParser.parse([\"--verbose\"], switches: [verbose: :count])\n"
"    {[verbose: 1], [], []}\n"
"\n"
"    iex> OptionParser.parse([\"-v\", \"-v\"], aliases: [v: :verbose], "
"strict: [verbose: :count])\n"
"    {[verbose: 2], [], []}\n"
"\n"
"    iex> OptionParser.parse([\"--unknown\", \"xyz\"], strict: [])\n"
"    {[], [\"xyz\"], [{\"--unknown\", nil}]}\n"
"\n"
"    iex> OptionParser.parse([\"--limit\", \"3\", \"--unknown\", \"xyz\"],\n"
"    ...>                    switches: [limit: :integer])\n"
"    {[limit: 3, unknown: \"xyz\"], [], []}\n"
"\n"
"    iex> OptionParser.parse([\"--unlock\", \"path/to/file\", \"--unlock\", "
"\"path/to/another/file\"], strict: [unlock: :keep])\n"
"    {[unlock: \"path/to/file\", unlock: \"path/to/another/file\"], [], []}\n"
"\n"
msgstr ""
"`argv`をキーワードリストにパースします。\n"
"\n"
"`{parsed, args, invalid}`形式の3要素タプルを返します。ここで:\n"
"\n"
"  * `parsed`はパースされたスイッチのキーワードリストで、`{switch_name, value}"
"`\n"
"   タプルを持ちます。ここで、`switch_name`はスイッチ名を表すアトムで、\n"
"   `value`は`opts`に従ってパースされたスイッチの値です（詳細は\n"
"    「例」セクションを参照してください）\n"
"  * `args`は`args`のパースされずに残った引数の文字列のリストです。\n"
"  * `invalid`は無効なオプションの`{option_name, value}`の形式のリストです。こ"
"こで、\n"
"    `option_name`は生のオプションで、`value`はオプションが想定されていない場"
"合は\n"
"    `nil`、値が対応するオプションの想定されたタイプを持っていなかった場合は\n"
"    文字列値です。\n"
"\n"
"Elixirはスイッチをアンダースコア付きアトムに変換します。したがって、`--"
"source-path`は\n"
"`:source_path`になります。これはElixirの慣習に合わせるために行われます。\n"
"しかし、これはスイッチにアンダースコアを含めることができず、アンダースコア"
"を\n"
"含むスイッチは常に無効なオプションのリストに含まれて返されることを意味しま"
"す。\n"
"\n"
"パースする際、通常、スイッチとその想定される値をリストします。\n"
"\n"
"    iex> OptionParser.parse([\"--debug\"], switches: [debug: :boolean])\n"
"    {[debug: true], [], []}\n"
"\n"
"    iex> OptionParser.parse([\"--source\", \"lib\"], switches: [source: :"
"string])\n"
"    {[source: \"lib\"], [], []}\n"
"\n"
"    iex> OptionParser.parse([\"--source-path\", \"lib\", \"test/enum_test.exs"
"\", \"--verbose\"],\n"
"    ...>                    switches: [source_path: :string, verbose: :"
"boolean])\n"
"    {[source_path: \"lib\", verbose: true], [\"test/enum_test.exs\"], []}\n"
"\n"
"オプションパーサの正しいスイッチと操作モードは以下の通りです。\n"
"\n"
"## オプション\n"
"\n"
"次のオプションがサポートされています。\n"
"\n"
"  * `:switches` または `:strict` - 以下の「スイッチ定義」セクションを参照して"
"ください\n"
"  * `:allow_nonexistent_atoms` - 以下の「動的なスイッチのパース」セクションを"
"参照\n"
"    してください。\n"
"  * `:aliases` - 以下の「エイリアス」セクションを参照してください\n"
"\n"
"## スイッチ定義\n"
"\n"
"スイッチは、次の2つのオプションのいずれかを使用して指定できます。\n"
"\n"
"  * `:switches` - スイッチとその型を定義します。この関数は\n"
"    このリストに存在しないスイッチもパースしようと試みます。\n"
"  * `:strict` - 厳格にスイッチを定義します。このリストに指定されていない\n"
"    `argv`中のスイッチはすべて無効なオプションリストで返されます。\n"
"\n"
"どちらのオプションも`{name, type}`タプルのキーワードリストを\n"
"受け付けます。ここで、`name`はスイッチの名前を定義するアトムで、\n"
"`type`はこのスイッチの値の型を指定するアトムです（指定可能な\n"
"型と型のキャスティングに関する詳細は、以下の「型」\n"
"セクションを参照してください）。\n"
"\n"
"オプション`:switches`と`:strict`はどちらか1つしか指定できないことに\n"
"注意してください。両方と指定すると`ArgumentError`例外が発生します。\n"
"\n"
"### 型\n"
"\n"
"`OptionParser`でパースされるスイッチは0または1つの引数をとることができま"
"す。\n"
"\n"
"次のスイッチ型は引数を取りません。\n"
"\n"
"  * `:boolean` - 指定されると値に`true`を設定します（以下の「否定スイッチ」\n"
"    セクションも参照してください）\n"
"  * `:count` - スイッチが指定された回数をカウントします\n"
"\n"
"次のスイッチは引数を1つ取ります。\n"
"\n"
"  * `:integer` - 値を整数としてパースします\n"
"  * `:float` - 値を浮動小数点数としてパースします\n"
"  * `:string` - 値を文字列としてパースします\n"
"\n"
"スイッチが指定されたタイプでパースできない場合は、無効なオプション\n"
"リストで返されます。\n"
"\n"
"### 修飾子\n"
"\n"
"スイッチには、動作方法を変更する修飾子を指定することができます。\n"
"次の修飾子がサポートされています。\n"
"\n"
"  * `:keep` - 重複した項目を上書きせずに保持します。`:count`を除く\n"
"    すべての型で使用できます。`switch_name: :keep`と指定すると\n"
"    `:switch_name`の型が`:string`だとみなされます。\n"
"\n"
"`:string`以外の型で`:keep`を使用したい場合は、スイッチの型として\n"
"リストを使用してください。たとえば、`[foo: [:integer, :keep]]`のように。\n"
"\n"
"### 否定スイッチ\n"
"\n"
"スイッチ`SWITCH`が`boolean`タイプを持つように指定した場合、\n"
"`—no-SWITCH`を渡すこともでき、SWITCHオプションは`false`に設定されます。\n"
"\n"
"    iex> OptionParser.parse([\"--no-op\", \"path/to/file\"], switches: [op: :"
"boolean])\n"
"    {[op: false], [\"path/to/file\"], []}\n"
"\n"
"### 動的なスイッチのパース\n"
"\n"
"`OptionParser`にはスイッチを動的にパースする動的モードもあります。これは、\n"
"`:switches`オプションまたは`:strict`オプションを指定しないと行われます。\n"
"\n"
"\n"
"    iex> OptionParser.parse([\"--debug\"])\n"
"    {[debug: true], [], []}\n"
"\n"
"値に続くスイッチは文字列として値に割り当てられます。上の例で、`--debug`の\n"
"ような引数を持たないスイッチは自動的に`true`が設定されます。\n"
"\n"
"Elixirはスイッチをアトムに変換するので、動的モードは実行時までに使用される\n"
"アトムに変換するスイッチのみをパースします。そのため、以下のコードは、\n"
"`:option_parser_example`アトムがどこにも使用されていないので、おそらく\n"
"指定したオプションをパースしません。\n"
"\n"
"    OptionParser.parse([\"--option-parser-example\"])\n"
"    # これ以上、何もしない...\n"
"\n"
"しかし、次のコードは`:option_parser_example`アトムが後で使用されるので\n"
"パースされます。\n"
"\n"
"    {opts, _, _} = OptionParser.parse([\"--option-parser-example\"])\n"
"    opts[:option_parser_example]\n"
"\n"
"言い換えると、動的モードを使用する際、Elixirは正しいことを行い、実行時に\n"
"使用されるオプションのみパースし、他はすべて無視します。存在するか否かに\n"
"関わらず、すべてのスイッチをパースしたい場合は、オプションとして\n"
"`allow_nonexistent_atoms: true`を渡すことによりアトムの作成を強制する\n"
"ことができます。そのようなオプションは動的に命名される引数を受け取る\n"
"コマンドラインアプリケーションを構築する場合に役に立ちますが、長期稼働システ"
"ムに\n"
"対しては注意して使用する必要があります。\n"
"\n"
"## エイリアス\n"
"\n"
"`:aliases`オプションでエイリアスを指定することができます。\n"
"\n"
"    iex> OptionParser.parse([\"-d\"], aliases: [d: :debug])\n"
"    {[debug: true], [], []}\n"
"\n"
"\n"
"## 例\n"
"\n"
"以下は様々な型と修飾子を持つ例です。\n"
"\n"
"    iex> OptionParser.parse([\"--unlock\", \"path/to/file\"], strict: "
"[unlock: :boolean])\n"
"    {[unlock: true], [\"path/to/file\"], []}\n"
"\n"
"    iex> OptionParser.parse([\"--unlock\", \"--limit\", \"0\", \"path/to/file"
"\"],\n"
"    ...>                    strict: [unlock: :boolean, limit: :integer])\n"
"    {[unlock: true, limit: 0], [\"path/to/file\"], []}\n"
"\n"
"    iex> OptionParser.parse([\"--limit\", \"3\"], strict: [limit: :"
"integer])\n"
"    {[limit: 3], [], []}\n"
"\n"
"    iex> OptionParser.parse([\"--limit\", \"xyz\"], strict: [limit: :"
"integer])\n"
"    {[], [], [{\"--limit\", \"xyz\"}]}\n"
"\n"
"    iex> OptionParser.parse([\"--verbose\"], switches: [verbose: :count])\n"
"    {[verbose: 1], [], []}\n"
"\n"
"    iex> OptionParser.parse([\"-v\", \"-v\"], aliases: [v: :verbose], "
"strict: [verbose: :count])\n"
"    {[verbose: 2], [], []}\n"
"\n"
"    iex> OptionParser.parse([\"--unknown\", \"xyz\"], strict: [])\n"
"    {[], [\"xyz\"], [{\"--unknown\", nil}]}\n"
"\n"
"    iex> OptionParser.parse([\"--limit\", \"3\", \"--unknown\", \"xyz\"],\n"
"    ...>                    switches: [limit: :integer])\n"
"    {[limit: 3, unknown: \"xyz\"], [], []}\n"
"\n"
"    iex> OptionParser.parse([\"--unlock\", \"path/to/file\", \"--unlock\", "
"\"path/to/another/file\"], strict: [unlock: :keep])\n"
"    {[unlock: \"path/to/file\", unlock: \"path/to/another/file\"], [], []}\n"
"\n"

#. TRANSLATORS: def OptionParser.parse_head(argv, opts \\ [])
#: lib/option_parser.ex:236
msgid ""
"Similar to `parse/2` but only parses the head of `argv`;\n"
"as soon as it finds a non-switch, it stops parsing.\n"
"\n"
"See `parse/2` for more information.\n"
"\n"
"## Example\n"
"\n"
"    iex> OptionParser.parse_head([\"--source\", \"lib\", \"test/enum_test.exs"
"\", \"--verbose\"],\n"
"    ...>                         switches: [source: :string, verbose: :"
"boolean])\n"
"    {[source: \"lib\"], [\"test/enum_test.exs\", \"--verbose\"], []}\n"
"\n"
"    iex> OptionParser.parse_head([\"--verbose\", \"--source\", \"lib\", "
"\"test/enum_test.exs\", \"--unlock\"],\n"
"    ...>                         switches: [source: :string, verbose: :"
"boolean, unlock: :boolean])\n"
"    {[verbose: true, source: \"lib\"], [\"test/enum_test.exs\", \"--unlock"
"\"], []}\n"
"\n"
msgstr ""
"`paprser/2`と似ていますが、`argv`の先頭だけパースし、\n"
"スイッチでないものを発見次弟、直ちにパースを中止します。\n"
"\n"
"詳細は`parse/2`を参照してください。\n"
"\n"
"## 例\n"
"\n"
"    iex> OptionParser.parse_head([\"--source\", \"lib\", \"test/enum_test.exs"
"\", \"--verbose\"],\n"
"    ...>                         switches: [source: :string, verbose: :"
"boolean])\n"
"    {[source: \"lib\"], [\"test/enum_test.exs\", \"--verbose\"], []}\n"
"\n"
"    iex> OptionParser.parse_head([\"--verbose\", \"--source\", \"lib\", "
"\"test/enum_test.exs\", \"--unlock\"],\n"
"    ...>                         switches: [source: :string, verbose: :"
"boolean, unlock: :boolean])\n"
"    {[verbose: true, source: \"lib\"], [\"test/enum_test.exs\", \"--unlock"
"\"], []}\n"
"\n"

#. TRANSLATORS: def OptionParser.split(string)
#: lib/option_parser.ex:472
msgid ""
"Splits a string into `t:argv/0` chunks.\n"
"\n"
"This function splits the given `string` into a list of strings in a similar\n"
"way to many shells.\n"
"\n"
"## Examples\n"
"\n"
"    iex> OptionParser.split(\"foo bar\")\n"
"    [\"foo\", \"bar\"]\n"
"\n"
"    iex> OptionParser.split(\"foo \\\"bar baz\\\"\")\n"
"    [\"foo\", \"bar baz\"]\n"
"\n"
msgstr ""
"文字列を`t:argv/0`チャンクに分割します。\n"
"\n"
"この関数は指定された`string`を多くのシェルと同様な\n"
"方法で文字列のリストに分割します。\n"
"\n"
"## 例\n"
"\n"
"    iex> OptionParser.split(\"foo bar\")\n"
"    [\"foo\", \"bar\"]\n"
"\n"
"    iex> OptionParser.split(\"foo \\\"bar baz\\\"\")\n"
"    [\"foo\", \"bar baz\"]\n"
"\n"

#. TRANSLATORS: def OptionParser.next(argv, opts \\ [])
#: lib/option_parser.ex:325
msgid ""
"Low-level function that parses one option.\n"
"\n"
"It accepts the same options as `parse/2` and `parse_head/2`\n"
"as both functions are built on top of this function. This function\n"
"may return:\n"
"\n"
"  * `{:ok, key, value, rest}` - the option `key` with `value` was\n"
"    successfully parsed\n"
"\n"
"  * `{:invalid, key, value, rest}` - the option `key` is invalid with "
"`value`\n"
"    (returned when the value cannot be parsed according to the switch type)\n"
"\n"
"  * `{:undefined, key, value, rest}` - the option `key` is undefined\n"
"    (returned in strict mode when the switch is unknown)\n"
"\n"
"  * `{:error, rest}` - there are no switches at the head of the given "
"`argv`\n"
"\n"
msgstr ""
"1つのオプションをパースする低レベル関数です。\n"
"\n"
"`parse/2`および`parse_head/2`と同じオプションを受け付けます。\n"
"両関数はこの関数を使って構築されているからです。\n"
"この関数は以下を返します:\n"
"\n"
"  * `{:ok, key, value, rest}` - オプション`key`の値は`value`に正常に\n"
"    パースされました。\n"
"\n"
"  * `{:invalid, key, value, rest}` - オプション`key`の値`value`は無効です\n"
"    （スイッチタイプにより値がパースできなかった場合に返されます）\n"
"\n"
"  * `{:undefined, key, value, rest}` - オプション`key`は未定義です\n"
"    （スイッチが不明でstrictモードの場合に返されます）\n"
"\n"
"  * `{:error, rest}` - 指定された`argv`の先頭にスイッチがありません\n"

#. TRANSLATORS: Elixir.OptionParser Summary
#: lib/option_parser.ex:2
msgid "This module contains functions to parse command line options.\n"
msgstr ""
"このモジュールはコマンドライン引数をパースするための関数を含んでいます。\n"
