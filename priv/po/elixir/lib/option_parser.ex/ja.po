msgid ""
msgstr ""
"Project-Id-Version: l 10n_elixir\n"
"PO-Revision-Date: 2015-12-23 18:15+0900\n"
"Last-Translator: 小田 照敬 <EMAIL@ADDRESS>\n"
"Language-Team: Japanese\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#. TRANSLATORS: def OptionParser.to_argv(enum, opts \\ [])
#: lib/option_parser.ex:380
#, fuzzy
msgid ""
"Receives a key-value enumerable and converts it to `t:argv/0`.\n"
"\n"
"Keys must be atoms. Keys with `nil` value are discarded,\n"
"boolean values are converted to `--key` or `--no-key`\n"
"(if the value is `true` or `false`, respectively),\n"
"and all other values are converted using `Kernel.to_string/1`.\n"
"\n"
"It is advised to pass to `to_argv/2` the same set of `options`\n"
"given to `parse/2`. Some switches can only be reconstructed\n"
"correctly with the `switches` information in hand.\n"
"\n"
"## Examples\n"
"\n"
"    iex>  OptionParser.to_argv([foo_bar: \"baz\"])\n"
"    [\"--foo-bar\", \"baz\"]\n"
"    iex>  OptionParser.to_argv([bool: true, bool: false, discarded: nil])\n"
"    [\"--bool\", \"--no-bool\"]\n"
"\n"
"Some switches will output different values based on the switches\n"
"flag:\n"
"\n"
"    iex> OptionParser.to_argv([number: 2], switches: [])\n"
"    [\"--number\", \"2\"]\n"
"    iex> OptionParser.to_argv([number: 2], switches: [number: :count])\n"
"    [\"--number\", \"--number\"]\n"
"\n"
msgstr ""
"キーバリュー enumerableを受け取り、argvに変換します。\n"
"\n"
"キーはアトムでなくてはなりません。値がnilとなるキーは\n"
"捨てられ、値が真偽値となるキーは`--key`あるいは`--no-key`に\n"
"変換され、他の全ての値は`to_string/1`を用いて変換されます。\n"
"\n"
"## 例\n"
"\n"
"    iex>  OptionParser.to_argv([foo_bar: \"baz\"])\n"
"    [\"--foo-bar\", \"baz\"]\n"
"\n"
"    iex>  OptionParser.to_argv([bool: true, bool: false, discarded: nil])\n"
"    [\"--bool\", \"--no-bool\"]\n"
"\n"

#. TRANSLATORS: def OptionParser.parse_head(argv, opts \\ [])
#: lib/option_parser.ex:198
msgid ""
"Similar to `parse/2` but only parses the head of `argv`;\n"
"as soon as it finds a non-switch, it stops parsing.\n"
"\n"
"See `parse/2` for more information.\n"
"\n"
"## Example\n"
"\n"
"    iex> OptionParser.parse_head([\"--source\", \"lib\", \"test/enum_test.exs"
"\", \"--verbose\"])\n"
"    {[source: \"lib\"], [\"test/enum_test.exs\", \"--verbose\"], []}\n"
"\n"
"    iex> OptionParser.parse_head([\"--verbose\", \"--source\", \"lib\", "
"\"test/enum_test.exs\", \"--unlock\"])\n"
"    {[verbose: true, source: \"lib\"], [\"test/enum_test.exs\", \"--unlock"
"\"], []}\n"
"\n"
msgstr ""
"`paprser/2`と似ていますが、`argv`の先頭までパースし、\n"
"スイッチでないものを見付けたら、パースを停止します。\n"
"\n"
"より詳細は`parse/2`をみてください。\n"
"\n"
"## 例\n"
"\n"
"    iex> OptionParser.parse_head([\"--source\", \"lib\", \"test/enum_test.exs"
"\", \"--verbose\"])\n"
"    {[source: \"lib\"], [\"test/enum_test.exs\", \"--verbose\"], []}\n"
"\n"
"    iex> OptionParser.parse_head([\"--verbose\", \"--source\", \"lib\", "
"\"test/enum_test.exs\", \"--unlock\"])\n"
"    {[verbose: true, source: \"lib\"], [\"test/enum_test.exs\", \"--unlock"
"\"], []}\n"
"\n"

#. TRANSLATORS: def OptionParser.parse(argv, opts \\ [])
#: lib/option_parser.ex:15
#, fuzzy
msgid ""
"Parses `argv` into a keyword list.\n"
"\n"
"It returns a three-element tuple with the form `{parsed, args, invalid}`, "
"where:\n"
"\n"
"  * `parsed` is a keyword list of parsed switches with `{switch_name, value}"
"`\n"
"    tuples in it; `switch_name` is the atom representing the switch name "
"while\n"
"    `value` is the value for that switch parsed according to `opts` (see "
"the\n"
"    \"Examples\" section for more information)\n"
"  * `args` is a list of the remaining arguments in `argv` as strings\n"
"  * `invalid` is a list of invalid options as `{option_name, value}` where\n"
"    `option_name` is the raw option and `value` is `nil` if the option "
"wasn't\n"
"    expected or the string value if the value didn't have the expected type "
"for\n"
"    the corresponding option\n"
"\n"
"Elixir converts switches to underscored atoms, so `--source-path` becomes\n"
"`:source_path`. This is done to better suit Elixir conventions. However, "
"this\n"
"means that switches can't contain underscores and switches that do contain\n"
"underscores are always returned in the list of invalid options.\n"
"\n"
"Without any options, this function will try to parse all switches in the "
"`argv`.\n"
"\n"
"    iex> OptionParser.parse([\"--debug\"])\n"
"    {[debug: true], [], []}\n"
"\n"
"    iex> OptionParser.parse([\"--source\", \"lib\"])\n"
"    {[source: \"lib\"], [], []}\n"
"\n"
"    iex> OptionParser.parse([\"--source-path\", \"lib\", \"test/enum_test.exs"
"\", \"--verbose\"])\n"
"    {[source_path: \"lib\", verbose: true], [\"test/enum_test.exs\"], []}\n"
"\n"
"Switches followed by a value will be assigned the value, as a string.\n"
"Switches without an argument, like `--debug` in the examples above, will\n"
"automatically be set to `true`.\n"
"\n"
"## Options\n"
"\n"
"The following options are supported:\n"
"\n"
"  * `:switches` or `:strict` - see the \"Switch definitions\" section below\n"
"  * `:aliases` - see the \"Aliases\" section below\n"
"\n"
"## Switch definitions\n"
"\n"
"Often it is better to explicitly list the known\n"
"switches and their formats. The switches can be specified via one of two\n"
"options:\n"
"\n"
"  * `:switches` - defines some switches and their types. This function\n"
"    still attempts to parse switches that are not in this list.\n"
"  * `:strict` - defines strict switches. Any switch in `argv` that is not\n"
"    specified in the list is returned in the invalid options list.\n"
"\n"
"Both these options accept a keyword list of `{name, type}` tuples where "
"`name`\n"
"is an atom defining the name of the switch and `type` is an atom that\n"
"specifies the type for the value of this switch (see the \"Types\" section "
"below\n"
"for the possible types and more information about type casting).\n"
"\n"
"Note that you should only supply the `:switches` or the`:strict` option.\n"
"If you supply both, an `ArgumentError` exception will be raised.\n"
"\n"
"### Types\n"
"\n"
"Switches parsed by `OptionParser` may take zero or one arguments.\n"
"\n"
"The following switches types take no arguments:\n"
"\n"
"  * `:boolean` - sets the value to `true` when given (see also the\n"
"    \"Negation switches\" section below)\n"
"  * `:count` - counts the number of times the switch is given\n"
"\n"
"The following switches take one argument:\n"
"\n"
"  * `:integer` - parses the value as an integer\n"
"  * `:float` - parses the value as a float\n"
"  * `:string` - parses the value as a string\n"
"\n"
"If a switch can't be parsed according to the given type, it is returned\n"
"in the invalid options list.\n"
"\n"
"### Modifiers\n"
"\n"
"Switches can be specified with modifiers, which change how\n"
"they behave. The following modifiers are supported:\n"
"\n"
"  * `:keep` - keeps duplicated items instead of overriding them; works with\n"
"    all types except `:count`. Specifying `switch_name: :keep` assumes the\n"
"    type of `:switch_name` will be `:string`.\n"
"\n"
"Note that if you want to use `:keep` with a type other than `:string`, use a "
"list\n"
"as the type for the switch. For example: `[foo: [:integer, :keep]]`.\n"
"\n"
"### Negation switches\n"
"\n"
"In case a switch `SWITCH` is specified to have type `:boolean`, it may be\n"
"passed as `--no-SWITCH` as well which will set the option to `false`:\n"
"\n"
"    iex> OptionParser.parse([\"--no-op\", \"path/to/file\"], switches: [op: :"
"boolean])\n"
"    {[op: false], [\"path/to/file\"], []}\n"
"\n"
"## Aliases\n"
"\n"
"A set of aliases can be specified in the `:aliases` option:\n"
"\n"
"    iex> OptionParser.parse([\"-d\"], aliases: [d: :debug])\n"
"    {[debug: true], [], []}\n"
"\n"
"## Examples\n"
"\n"
"Here are some examples of working with different types and modifiers:\n"
"\n"
"    iex> OptionParser.parse([\"--unlock\", \"path/to/file\"], strict: "
"[unlock: :boolean])\n"
"    {[unlock: true], [\"path/to/file\"], []}\n"
"\n"
"    iex> OptionParser.parse([\"--unlock\", \"--limit\", \"0\", \"path/to/file"
"\"],\n"
"    ...>                    strict: [unlock: :boolean, limit: :integer])\n"
"    {[unlock: true, limit: 0], [\"path/to/file\"], []}\n"
"\n"
"    iex> OptionParser.parse([\"--limit\", \"3\"], strict: [limit: :"
"integer])\n"
"    {[limit: 3], [], []}\n"
"\n"
"    iex> OptionParser.parse([\"--limit\", \"xyz\"], strict: [limit: :"
"integer])\n"
"    {[], [], [{\"--limit\", \"xyz\"}]}\n"
"\n"
"    iex> OptionParser.parse([\"--verbose\"], switches: [verbose: :count])\n"
"    {[verbose: 1], [], []}\n"
"\n"
"    iex> OptionParser.parse([\"-v\", \"-v\"], aliases: [v: :verbose], "
"strict: [verbose: :count])\n"
"    {[verbose: 2], [], []}\n"
"\n"
"    iex> OptionParser.parse([\"--unknown\", \"xyz\"], strict: [])\n"
"    {[], [\"xyz\"], [{\"--unknown\", nil}]}\n"
"\n"
"    iex> OptionParser.parse([\"--limit\", \"3\", \"--unknown\", \"xyz\"],\n"
"    ...>                    switches: [limit: :integer])\n"
"    {[limit: 3, unknown: \"xyz\"], [], []}\n"
"\n"
"    iex> OptionParser.parse([\"--unlock\", \"path/to/file\", \"--unlock\", "
"\"path/to/another/file\"], strict: [unlock: :keep])\n"
"    {[unlock: \"path/to/file\", unlock: \"path/to/another/file\"], [], []}\n"
"\n"
msgstr ""
"`argv`をキーワードリストにパースします。\n"
"\n"
"以下の3要素のタプルを返します:\n"
"\n"
"   1. それはパースされたスイッチ,\n"
"   2. 残りの引数,\n"
"   3. 無効なオプション.\n"
"\n"
"## 例\n"
"\n"
"    iex> OptionParser.parse([\"--debug\"])\n"
"    {[debug: true], [], []}\n"
"\n"
"    iex> OptionParser.parse([\"--source\", \"lib\"])\n"
"    {[source: \"lib\"], [], []}\n"
"\n"
"    iex> OptionParser.parse([\"--source-path\", \"lib\", \"test/enum_test.exs"
"\", \"--verbose\"])\n"
"    {[source_path: \"lib\", verbose: true], [\"test/enum_test.exs\"], []}\n"
"\n"
"デフォルトで、Elixirは自動的にスイッチをパースしようとします。\n"
"値が後ろに続くスイッチは、その値が常に文字列としてセットされます。\n"
"`--debug`のような引数なしのスイッチは、自動的にtrueにセットされます。\n"
"\n"
"Elixirもまた、Elixirの慣習により合うようにするため、\n"
"`--source-path`を`:source_path`として、\n"
"スイッチをアンダースコアアトムに変換することに、\n"
"注意してください。\n"
"これはコマンドラインのオプション名はアンダースコアを含むことができない\n"
"ことを意味します; そのようなオプションは(厳格なモードでは)\n"
"`:undefined`として、あるいは、(ベーシックモードでは)`:invalid`\n"
"として報告されます。\n"
"\n"
"## Switches\n"
"\n"
"しばしば、有効なスイッチとそのフォーマットのリストを明確にすることは\n"
"よりよいです。スイッチは二つの異るオプションで指定できます:\n"
"\n"
"  * `:switches` - いくつかのスイッチを定義します。\n"
"    スイッチリストに存在していないスイッチは、パースされるために\n"
"    まだ試みられます。\n"
"\n"
"  * `:strict` - スイッチは厳格です。\n"
"    スイッチリストに存在していない全てのスイッチは、エラーとして\n"
"    扱われます。\n"
"\n"
"`:strict`または`:switches`は、一度だけ与えられるべきであることに\n"
"注意してください。もし両方を同時に与えるとエラーが上ります。\n"
"\n"
"それぞれのスイッチのために、以下のタイプがサポートされています:\n"
"\n"
"  * `:boolean` - 与えられたスイッチをブーリアンとしてマークします。\n"
"                 ブーリアンスイッチは決して`true`か`false`以外の\n"
"                 値を消費しません。\n"
"  * `:integer` - 整数としてスイッチをパースします。\n"
"  * `:float`   - 浮動小数点数としてスイッチをパースします。\n"
"  * `:string`  - 文字列としてスイッチをパースします。\n"
"\n"
"スイッチがパースできないか、厳格なモードで指定されていないかなら、オプ\n"
"ションは無効なオプションリスト(戻りタプルの三番目の要素)の中に返ります。\n"
"\n"
"以下の特別な\"type\"がサポートされています:\n"
"\n"
"  * `:keep` - 上書きするかわりに、重複したアイテムを保持します\n"
"\n"
"Note: もし文字列以外に`:keep`を使いたいなら、`[foo: [:integer, :keep]]`\n"
"のように、リストにしてください。\n"
"\n"
"Examples:\n"
"\n"
"    iex> OptionParser.parse([\"--unlock\", \"path/to/file\"], strict: "
"[unlock: :boolean])\n"
"    {[unlock: true], [\"path/to/file\"], []}\n"
"\n"
"    iex> OptionParser.parse([\"--unlock\", \"--limit\", \"0\", \"path/to/file"
"\"],\n"
"    ...>                    strict: [unlock: :boolean, limit: :integer])\n"
"    {[unlock: true, limit: 0], [\"path/to/file\"], []}\n"
"\n"
"    iex> OptionParser.parse([\"--limit\", \"3\"], strict: [limit: :"
"integer])\n"
"    {[limit: 3], [], []}\n"
"\n"
"    iex> OptionParser.parse([\"--limit\", \"xyz\"], strict: [limit: :"
"integer])\n"
"    {[], [], [{\"--limit\", \"xyz\"}]}\n"
"\n"
"    iex> OptionParser.parse([\"--unknown\", \"xyz\"], strict: [])\n"
"    {[], [\"xyz\"], [{\"--unknown\", nil}]}\n"
"\n"
"    iex> OptionParser.parse([\"--limit\", \"3\", \"--unknown\", \"xyz\"],\n"
"    ...>                    switches: [limit: :integer])\n"
"    {[limit: 3, unknown: \"xyz\"], [], []}\n"
"\n"
"    iex> OptionParser.parse([\"--unlock\", \"path/to/file\", \"--unlock\", "
"\"path/to/another/file\"], strict: [unlock: :keep])\n"
"    {[unlock: \"path/to/file\", unlock: \"path/to/another/file\"], [], []}\n"
"\n"
"## Negation switches\n"
"\n"
"ブーリアンとして宣言されたスイッチで、`--no-SWITH`として渡されたら、\n"
"そのオプションは`false`とセットされます:\n"
"\n"
"    iex> OptionParser.parse([\"--no-op\", \"path/to/file\"], switches: [op: :"
"boolean])\n"
"    {[op: false], [\"path/to/file\"], []}\n"
"\n"
"## Aliases\n"
"\n"
"一組のアイリアスをオプションに与えることもできます:\n"
"\n"
"    iex> OptionParser.parse([\"-d\"], aliases: [d: :debug])\n"
"    {[debug: true], [], []}\n"
"\n"

#. TRANSLATORS: def OptionParser.split(string)
#: lib/option_parser.ex:431
#, fuzzy
msgid ""
"Splits a string into `t:argv/0` chunks.\n"
"\n"
"This function splits the given `string` into a list of strings in a similar\n"
"way to many shells.\n"
"\n"
"## Examples\n"
"\n"
"    iex> OptionParser.split(\"foo bar\")\n"
"    [\"foo\", \"bar\"]\n"
"\n"
"    iex> OptionParser.split(\"foo \\\"bar baz\\\"\")\n"
"    [\"foo\", \"bar baz\"]\n"
"\n"
msgstr ""
"文字列を引数の塊に分割します。\n"
"\n"
"## 例\n"
"\n"
"    iex> OptionParser.split(\"foo bar\")\n"
"    [\"foo\", \"bar\"]\n"
"\n"
"    iex> OptionParser.split(\"foo \\\"bar baz\\\"\")\n"
"    [\"foo\", \"bar baz\"]\n"

#. TRANSLATORS: def OptionParser.parse!(argv, opts \\ [])
#: lib/option_parser.ex:161
msgid ""
"The same as `parse/2` but raises an `OptionParser.ParseError`\n"
"exception if any invalid options are given.\n"
"\n"
"If there are no errors, returns a `{parsed, rest}` tuple where:\n"
"\n"
"  * `parsed` is the list of parsed switches (same as in `parse/2`)\n"
"  * `rest` is the list of arguments (same as in `parse/2`)\n"
"\n"
"## Examples\n"
"\n"
"    iex> OptionParser.parse!([\"--debug\", \"path/to/file\"], strict: "
"[debug: :boolean])\n"
"    {[debug: true], [\"path/to/file\"]}\n"
"\n"
"    iex> OptionParser.parse!([\"--limit\", \"xyz\"], strict: [limit: :"
"integer])\n"
"    ** (OptionParser.ParseError) 1 error found!\n"
"    --limit : Expected type integer, got \"xyz\"\n"
"\n"
"    iex> OptionParser.parse!([\"--unknown\", \"xyz\"], strict: [])\n"
"    ** (OptionParser.ParseError) 1 error found!\n"
"    --unknown : Unknown option\n"
"\n"
"    iex> OptionParser.parse!([\"-l\", \"xyz\", \"-f\", \"bar\"],\n"
"    ...>                     switches: [limit: :integer, foo: :integer], "
"aliases: [l: :limit, f: :foo])\n"
"    ** (OptionParser.ParseError) 2 errors found!\n"
"    -l : Expected type integer, got \"xyz\"\n"
"    -f : Expected type integer, got \"bar\"\n"
"\n"
msgstr ""

#. TRANSLATORS: def OptionParser.next(argv, opts \\ [])
#: lib/option_parser.ex:283
#, fuzzy
msgid ""
"Low-level function that parses one option.\n"
"\n"
"It accepts the same options as `parse/2` and `parse_head/2`\n"
"as both functions are built on top of this function. This function\n"
"may return:\n"
"\n"
"  * `{:ok, key, value, rest}` - the option `key` with `value` was\n"
"    successfully parsed\n"
"\n"
"  * `{:invalid, key, value, rest}` - the option `key` is invalid with "
"`value`\n"
"    (returned when the value cannot be parsed according to the switch type)\n"
"\n"
"  * `{:undefined, key, value, rest}` - the option `key` is undefined\n"
"    (returned in strict mode when the switch is unknown)\n"
"\n"
"  * `{:error, rest}` - there are no switches at the head of the given "
"`argv`\n"
"\n"
msgstr ""
"一つのオプションをパースする低レベル関数です。\n"
"\n"
"nextの上で構築される`parse/2`や`parse_head/2`といった関数と\n"
"同じオプションを受け付けます。この関数は以下を返します:\n"
"\n"
"  * `{:ok, key, value, rest}` - `value`付きのオプション`key`はパースに\n"
"    成功しました\n"
"\n"
"  * `{:invalid, key, value, rest}` - `value`付きのオプション`key`は無効です\n"
"    (スイッチタイプがコマンドラインにより渡されたものにマッチしないときに\n"
"     返ります)\n"
"\n"
"  * `{:undefined, key, value, rest}` - オプション`key`は未定義です\n"
"    (大文字小文字の違いやスイッチが不明のときに返ります)\n"
"\n"
"  * `{:error, rest}` - 与えられたargvにスイッチがありません\n"

#. TRANSLATORS: def OptionParser.parse_head!(argv, opts \\ [])
#: lib/option_parser.ex:218
msgid ""
"The same as `parse_head/2` but raises an `OptionParser.ParseError`\n"
"exception if any invalid options are given.\n"
"\n"
"If there are no errors, returns a `{parsed, rest}` tuple where:\n"
"\n"
"  * `parsed` is the list of parsed switches (same as in `parse_head/2`)\n"
"  * `rest` is the list of arguments (same as in `parse_head/2`)\n"
"\n"
"## Examples\n"
"\n"
"    iex> OptionParser.parse_head!([\"--source\", \"lib\", \"path/to/file\", "
"\"--verbose\"])\n"
"    {[source: \"lib\"], [\"path/to/file\", \"--verbose\"]}\n"
"\n"
"    iex> OptionParser.parse_head!([\"--number\", \"lib\", \"test/enum_test."
"exs\", \"--verbose\"], strict: [number: :integer])\n"
"    ** (OptionParser.ParseError) 1 error found!\n"
"    --number : Expected type integer, got \"lib\"\n"
"\n"
"    iex> OptionParser.parse_head!([\"--verbose\", \"--source\", \"lib\", "
"\"test/enum_test.exs\", \"--unlock\"],\n"
"    ...>                          strict: [verbose: :integer, source: :"
"integer])\n"
"    ** (OptionParser.ParseError) 2 errors found!\n"
"    --verbose : Missing argument of type integer\n"
"    --source : Expected type integer, got \"lib\"\n"
msgstr ""

#. TRANSLATORS: Elixir.OptionParser Summary
#: lib/option_parser.ex:2
msgid "This module contains functions to parse command line options.\n"
msgstr "このモジュールはコマンドライン引数をパースするための関数を含みます。\n"
