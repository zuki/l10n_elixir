msgid ""
msgstr ""
"Project-Id-Version: l 10n_elixir\n"
"PO-Revision-Date: 2017-03-22 18:01+0900\n"
"Last-Translator: 小田 照敬 <EMAIL@ADDRESS>\n"
"Language-Team: Japanese\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"POT-Creation-Date: \n"
"X-Generator: Poedit 1.8.12\n"

#. TRANSLATORS: defmacro Kernel.SpecialForms.receive(args)
#: lib/kernel/special_forms.ex:1833
msgid ""
"Checks if there is a message matching the given clauses\n"
"in the current process mailbox.\n"
"\n"
"In case there is no such message, the current process hangs\n"
"until a message arrives or waits until a given timeout value.\n"
"\n"
"## Examples\n"
"\n"
"    receive do\n"
"      {:selector, i, value} when is_integer(i) ->\n"
"        value\n"
"      value when is_atom(value) ->\n"
"        value\n"
"      _ ->\n"
"        IO.puts :stderr, \"Unexpected message received\"\n"
"    end\n"
"\n"
"An optional `after` clause can be given in case the message was not\n"
"received after the given timeout period, specified in milliseconds:\n"
"\n"
"    receive do\n"
"      {:selector, i, value} when is_integer(i) ->\n"
"        value\n"
"      value when is_atom(value) ->\n"
"        value\n"
"      _ ->\n"
"        IO.puts :stderr, \"Unexpected message received\"\n"
"    after\n"
"      5000 ->\n"
"        IO.puts :stderr, \"No message in 5 seconds\"\n"
"    end\n"
"\n"
"The `after` clause can be specified even if there are no match clauses.\n"
"The timeout value given to `after` can be a variable; two special\n"
"values are allowed:\n"
"\n"
"  * `:infinity` - the process should wait indefinitely for a matching\n"
"    message, this is the same as not using a timeout\n"
"\n"
"  * `0` - if there is no matching message in the mailbox, the timeout\n"
"    will occur immediately\n"
"\n"
"## Variables handling\n"
"\n"
"The `receive/1` special form handles variables exactly as the `case/2`\n"
"special macro. For more information, check the docs for `case/2`.\n"
msgstr ""
"指定した節にマッチするメッセージが現在のプロセスのメールボックスに\n"
"あるか否かをチェックします。\n"
"\n"
"そのようなメッセージがない場合、現在のプロセスはメッセージが到着するまで\n"
"ハングアップするか、指定したタイムアウト値まで待ちます。\n"
"\n"
"## 例\n"
"\n"
"    receive do\n"
"      {:selector, i, value} when is_integer(i) ->\n"
"        value\n"
"      value when is_atom(value) ->\n"
"        value\n"
"      _ ->\n"
"        IO.puts :stderr, \"Unexpected message received\"\n"
"    end\n"
"\n"
"指定したタイムアウト期間にメッセージが受信されなかった場合に備えて、\n"
"オプションの`after`節をミリ秒単位で指定することができます。\n"
"\n"
"    receive do\n"
"      {:selector, i, value} when is_integer(i) ->\n"
"        value\n"
"      value when is_atom(value) ->\n"
"        value\n"
"      _ ->\n"
"        IO.puts :stderr, \"Unexpected message received\"\n"
"    after\n"
"      5000 ->\n"
"        IO.puts :stderr, \"No message in 5 seconds\"\n"
"    end\n"
"\n"
"`after`節はマッチ節がなくても指定することができます。\n"
"`after`に指定するタイムアウト値は変数でもよく、また、2つの\n"
"特別な値も指定できます。\n"
"\n"
"  * `:infinity` - プロセスは無期限にマッチするメッセージを\n"
"     待ちます。タイムアウトを使わない場合と同じです\n"
"\n"
"  * 0 - メールボックスにマッチするメッセージがない場合、\n"
"    直ちにタイムアウトします。\n"
"\n"
"## 変数の取り扱い\n"
"\n"
"`receive/1`スペシャルフォームは変数を`case/2`スペシャルマクロと\n"
"まったく同じように扱います。詳細は、`case/2`のドキュメントを\n"
"チェックしてください。\n"

#. TRANSLATORS: defmacro Kernel.SpecialForms.<<>>(args)
#: lib/kernel/special_forms.ex:119
msgid ""
"Defines a new bitstring.\n"
"\n"
"## Examples\n"
"\n"
"    iex> <<1, 2, 3>>\n"
"    <<1, 2, 3>>\n"
"\n"
"## Types\n"
"\n"
"A bitstring is made of many segments and each segment has a\n"
"type. There are 9 types used in bitstrings:\n"
"\n"
"- `integer`\n"
"- `float`\n"
"- `bits` (alias for `bitstring`)\n"
"- `bitstring`\n"
"- `binary`\n"
"- `bytes` (alias for `binary`)\n"
"- `utf8`\n"
"- `utf16`\n"
"- `utf32`\n"
"\n"
"When no type is specified, the default is `integer`:\n"
"\n"
"    iex> <<1, 2, 3>>\n"
"    <<1, 2, 3>>\n"
"\n"
"Elixir also accepts by default the segment to be a literal\n"
"string or a literal charlist, which are by default expanded to integers:\n"
"\n"
"    iex> <<0, \"foo\">>\n"
"    <<0, 102, 111, 111>>\n"
"\n"
"Variables or any other type need to be explicitly tagged:\n"
"\n"
"    iex> rest = \"oo\"\n"
"    iex> <<102, rest>>\n"
"    ** (ArgumentError) argument error\n"
"\n"
"We can solve this by explicitly tagging it as `binary`:\n"
"\n"
"    iex> rest = \"oo\"\n"
"    iex> <<102, rest::binary>>\n"
"    \"foo\"\n"
"\n"
"The `utf8`, `utf16`, and `utf32` types are for Unicode codepoints. They\n"
"can also be applied to literal strings and charlists:\n"
"\n"
"    iex> <<\"foo\"::utf16>>\n"
"    <<0, 102, 0, 111, 0, 111>>\n"
"    iex> <<\"foo\"::utf32>>\n"
"    <<0, 0, 0, 102, 0, 0, 0, 111, 0, 0, 0, 111>>\n"
"\n"
"## Options\n"
"\n"
"Many options can be given by using `-` as separator. Order is\n"
"arbitrary, so the following are all equivalent:\n"
"\n"
"    <<102::integer-native, rest::binary>>\n"
"    <<102::native-integer, rest::binary>>\n"
"    <<102::unsigned-big-integer, rest::binary>>\n"
"    <<102::unsigned-big-integer-size(8), rest::binary>>\n"
"    <<102::unsigned-big-integer-8, rest::binary>>\n"
"    <<102::8-integer-big-unsigned, rest::binary>>\n"
"    <<102, rest::binary>>\n"
"\n"
"### Unit and Size\n"
"\n"
"The length of the match is equal to the `unit` (a number of bits) times the\n"
"`size` (the number of repeated segments of length `unit`).\n"
"\n"
"Type      | Default Unit\n"
"--------- | ------------\n"
"`integer` | 1 bit\n"
"`float`   | 1 bit\n"
"`binary`  | 8 bits\n"
"\n"
"Sizes for types are a bit more nuanced. The default size for integers is 8.\n"
"\n"
"For floats, it is 64. For floats, `size * unit` must result in 32 or 64,\n"
"corresponding to [IEEE 754](https://en.wikipedia.org/wiki/"
"IEEE_floating_point)\n"
"binary32 and binary64, respectively.\n"
"\n"
"For binaries, the default is the size of the binary. Only the last binary in "
"a\n"
"match can use the default size. All others must have their size specified\n"
"explicitly, even if the match is unambiguous. For example:\n"
"\n"
"    iex> <<name::binary-size(5), \" the \", species::binary>> = <<\"Frank "
"the Walrus\">>\n"
"    \"Frank the Walrus\"\n"
"    iex> {name, species}\n"
"    {\"Frank\", \"Walrus\"}\n"
"\n"
"Failing to specify the size for the non-last causes compilation to fail:\n"
"\n"
"    <<name::binary, \" the \", species::binary>> = <<\"Frank the Walrus\">>\n"
"    ** (CompileError): a binary field without size is only allowed at the "
"end of a binary pattern\n"
"\n"
"#### Shortcut Syntax\n"
"\n"
"Size and unit can also be specified using a syntax shortcut\n"
"when passing integer values:\n"
"\n"
"    iex> x = 1\n"
"    iex> <<x::8>> == <<x::size(8)>>\n"
"    true\n"
"    iex> <<x::8*4>> == <<x::size(8)-unit(4)>>\n"
"    true\n"
"\n"
"This syntax reflects the fact the effective size is given by\n"
"multiplying the size by the unit.\n"
"\n"
"### Modifiers\n"
"\n"
"Some types have associated modifiers to clear up ambiguity in byte\n"
"representation.\n"
"\n"
"Modifier             | Relevant Type(s)\n"
"-------------------- | ----------------\n"
"`signed`             | `integer`\n"
"`unsigned` (default) | `integer`\n"
"`little`             | `integer`, `float`, `utf16`, `utf32`\n"
"`big` (default)      | `integer`, `float`, `utf16`, `utf32`\n"
"`native`             | `integer`, `utf16`, `utf32`\n"
"\n"
"### Sign\n"
"\n"
"Integers can be `signed` or `unsigned`, defaulting to `unsigned`.\n"
"\n"
"    iex> <<int::integer>> = <<-100>>\n"
"    <<156>>\n"
"    iex> int\n"
"    156\n"
"    iex> <<int::integer-signed>> = <<-100>>\n"
"    <<156>>\n"
"    iex> int\n"
"    -100\n"
"\n"
"`signed` and `unsigned` are only used for matching binaries (see below) and\n"
"are only used for integers.\n"
"\n"
"    iex> <<-100::signed, _rest::binary>> = <<-100, \"foo\">>\n"
"    <<156, 102, 111, 111>>\n"
"\n"
"### Endianness\n"
"\n"
"Elixir has three options for endianness: `big`, `little`, and `native`.\n"
"The default is `big`:\n"
"\n"
"    iex> <<number::little-integer-size(16)>> = <<0, 1>>\n"
"    <<0, 1>>\n"
"    iex> number\n"
"    256\n"
"    iex> <<number::big-integer-size(16)>> = <<0, 1>>\n"
"    <<0, 1>>\n"
"    iex> number\n"
"    1\n"
"\n"
"`native` is determined by the VM at startup and will depend on the\n"
"host operating system.\n"
"\n"
"## Binary/Bitstring Matching\n"
"\n"
"Binary matching is a powerful feature in Elixir that is useful for "
"extracting\n"
"information from binaries as well as pattern matching.\n"
"\n"
"Binary matching can be used by itself to extract information from binaries:\n"
"\n"
"    iex> <<\"Hello, \", place::binary>> = \"Hello, World\"\n"
"    \"Hello, World\"\n"
"    iex> place\n"
"    \"World\"\n"
"\n"
"Or as a part of function definitions to pattern match:\n"
"\n"
"    defmodule ImageTyper\n"
"      @png_signature <<137::size(8), 80::size(8), 78::size(8), 71::size(8),\n"
"                       13::size(8), 10::size(8), 26::size(8), 10::size(8)>>\n"
"      @jpg_signature <<255::size(8), 216::size(8)>>\n"
"\n"
"      def type(<<@png_signature, rest::binary>>), do: :png\n"
"      def type(<<@jpg_signature, rest::binary>>), do: :jpg\n"
"      def type(_), do :unknown\n"
"    end\n"
"\n"
"### Performance & Optimizations\n"
"\n"
"The Erlang compiler can provide a number of optimizations on binary "
"creation\n"
"and matching. To see optimization output, set the `bin_opt_info` compiler\n"
"option:\n"
"\n"
"    ERL_COMPILER_OPTIONS=bin_opt_info mix compile\n"
"\n"
"To learn more about specific optimizations and performance considerations,\n"
"check out\n"
"[Erlang's Efficiency Guide on handling binaries](http://www.erlang.org/doc/"
"efficiency_guide/binaryhandling.html).\n"
msgstr ""
"新しいbitstringを定義します。\n"
"\n"
"## 例\n"
"\n"
"    iex> << 1, 2, 3 >>\n"
"    << 1, 2, 3 >>\n"
"\n"
"## 型\n"
"\n"
"bitstringは多くのセグメントで出来ています。各セグメントは型を持ちます。\n"
"bitstringで使用される型には次の9種類があります。\n"
"\n"
"- `integer`\n"
"- `float`\n"
"- `bits`（bitstringの別名）\n"
"- `bitstring`\n"
"- `binary`\n"
"- `bytes`（binaryの別名）\n"
"- `utf8`\n"
"- `utf16`\n"
"- `utf32`\n"
"\n"
"型が指定されない場合のデフォルトは`integer`です。\n"
"\n"
"    iex> <<1, 2, 3>>\n"
"    <<1, 2, 3>>\n"
"\n"
"Elixirはリテラル文字列またはリテラル文字リストのセグメントも\n"
"デフォルトで受け付けます。これらはデフォルトで整数に展開されます。\n"
"\n"
"    iex> <<0, \"foo\">>\n"
"    <<0, 102, 111, 111>>\n"
"\n"
"変数やその他の型は明示的にタグ付けされる必要があります。\n"
"\n"
"    iex> rest = \"oo\"\n"
"    iex> <<102, rest>>\n"
"    ** (ArgumentError) argument error\n"
"\n"
"これは明示的に`binary`とタグ付けすることで解決できます:\n"
"\n"
"    iex> rest = \"oo\"\n"
"    iex> <<102, rest::binary>>\n"
"    \"foo\"\n"
"\n"
"utf8型、utf16型、utf32型はUnicodeのコードポイントです。\n"
"これらはリテラル文字列とリテラル文字リストにも適用できます。\n"
"\n"
"    iex> <<\"foo\"::utf16>>\n"
"    <<0, 102, 0, 111, 0, 111>>\n"
"    iex> <<\"foo\"::utf32>>\n"
"    <<0, 0, 0, 102, 0, 0, 0, 111, 0, 0, 0, 111>>\n"
"\n"
"## オプション\n"
"\n"
"多くのオプションを`-`で区切って指定することができます。\n"
"指定順は任意ですので以下は全て同等です。\n"
"\n"
"    <<102::integer-native, rest::binary>>\n"
"    <<102::native-integer, rest::binary>>\n"
"    <<102::unsigned-big-integer, rest::binary>>\n"
"    <<102::unsigned-big-integer-size(8), rest::binary>>\n"
"    <<102::unsigned-big-integer-8, rest::binary>>\n"
"    <<102::8-integer-big-unsigned, rest::binary>>\n"
"    <<102, rest::binary>>\n"
"\n"
"### ユニットとサイズ\n"
"\n"
"マッチの長さは、`unit`（bitの数） × `size`（`unit`の長さのセグメント\n"
"の繰り返しの数）に等しいです。\n"
"\n"
"型      | デフォルトユニット\n"
"--------- | ------------\n"
"`integer` | 1 bit\n"
"`float`   | 1 bit\n"
"`binary`  | 8 bits\n"
"\n"
"型のサイズはもう少し微妙です。integerのデフォルトサイズは8です。\n"
"\n"
"floatのデフォルトは64です。floatは`size * unit`は 32 か 64でなければなりませ"
"ん。\n"
"各々[IEEE 754](https://en.wikipedia.org/wiki/IEEE_floating_point)の\n"
"binary32とbinary64に対応します。\n"
"\n"
"binaryでは、デフォルトはバイナリのサイズです。\n"
"マッチの最後のbinaryのみ、デフォルトサイズを使うことができます。\n"
"他のすべてのマッチは、たとえマッチが明白でも、明示的にサイズを指定\n"
"しなければなりません。たとえば、\n"
"\n"
"    iex> <<name::binary-size(5), \" the \", species::binary>> = <<\"Frank "
"the Walrus\">>\n"
"    \"Frank the Walrus\"\n"
"    iex> {name, species}\n"
"    {\"Frank\", \"Walrus\"}\n"
"\n"
"最後でないbinaryにサイズを指定しないとコンパイルが失敗します。\n"
"\n"
"    <<name::binary, \" the \", species::binary>> = <<\"Frank the Walrus\">>\n"
"    ** (CompileError): a binary field without size is only allowed at the "
"end of a binary pattern\n"
"\n"
"#### 短縮構文\n"
"\n"
"サイズとユニットは整数値を渡す場合は短縮構文で指定することもできます。\n"
"\n"
"    iex> x = 1\n"
"    iex> <<x::8>> == <<x::size(8)>>\n"
"    true\n"
"    iex> <<x::8 * 4>> == <<x::size(8)-unit(4)>>\n"
"    true\n"
"\n"
"この構文は、有効サイズはユニットにサイズをかけることにより得られるという\n"
"事実を反映しています。\n"
"\n"
"### モディファイア\n"
"\n"
"バイト表現の曖昧さをなくすために関連する修飾子を持つ型もあります。\n"
"\n"
"モディファイア  | 関連する型\n"
"-------------------- | ----------------\n"
"`signed`             | `integer`\n"
"`unsigned`（デフォルト） | `integer`\n"
"`little`             | `integer`, `utf16`, `utf32`\n"
"`big`（デフォルト） | `integer`, `utf16`, `utf32`\n"
"`native`             | `integer`, `utf16`, `utf32`\n"
"\n"
"### 符号\n"
"\n"
"integerには、`signed`または`unsigned`を指定できます。デフォルトは\n"
"`unsigned`です。\n"
"\n"
"    iex> <<int::integer>> =  <<-100>>\n"
"    <<156>>\n"
"    iex> int\n"
"    156\n"
"    iex> <<int::integer-signed>> =  <<-100>>\n"
"    <<156>>\n"
"    iex> int\n"
"    -100\n"
"\n"
"`signed`と`unsigned`はバイナリのマッチング（以下参照）においてのみ使用さ"
"れ、\n"
"また、integerにのみ使用されます。\n"
"\n"
"    iex> <<-100::signed, _rest::binary>> = <<-100, \"foo\">>\n"
"    <<156, 102, 111, 111>>\n"
"\n"
"### エンディアン\n"
"\n"
"Elixirはエンディアンに対して、`bit`、`little`、`native`の3つのオプションを\n"
"持ちます。デフォルトは`bit`です:\n"
"\n"
"    iex> <<number::little-integer-size(16)>> = <<0, 1>>\n"
"    <<0, 1>>\n"
"    iex> number\n"
"    256\n"
"    iex> <<number::big-integer-size(16)>> = <<0, 1>>\n"
"    <<0, 1>>\n"
"    iex> number\n"
"    1\n"
"\n"
"`native`は起動時にVMにより決定され、ホストオペレーティングシステムに\n"
"依存します。\n"
"\n"
"## Binary/Bitstringのマッチング\n"
"\n"
"バイナリマッチングはElixirの強力な機能であり、パターンマッチングと\n"
"同じようにバイナリから情報を抽出するのに便利です。\n"
"\n"
"バイナリマッチングはバイナリから情報を抽出するために自分自身を\n"
"使うこともできます。\n"
"\n"
"    iex> <<\"Hello, \", place::binary>> = \"Hello, World\"\n"
"    \"Hello, World\"\n"
"    iex> place\n"
"    \"World\"\n"
"\n"
"また、パターンマッチを行う関数定義の一部分としても\n"
"使うことができます。\n"
"\n"
"    defmodule ImageTyper\n"
"      @png_signature <<137::size(8), 80::size(8), 78::size(8), 71::size(8),\n"
"                    13::size(8), 10::size(8), 26::size(8), 10::size(8)>>\n"
"      @jpg_signature <<255::size(8), 216::size(8)>>\n"
"\n"
"      def type(<<@png_signature, rest::binary>>), do: :png\n"
"      def type(<<@jpg_signature, rest::binary>>), do: :jpg\n"
"      def type(_), do :unknown\n"
"    end\n"
"\n"
"### パフォーマンスと最適化\n"
"\n"
"Erlangコンパイラは、バイナリの作成とマッチングのために数多くの最適化を\n"
"提供しています。最適化出力は、`bin_opt_info`コンパイラ\n"
"オプションで見ることができます。\n"
"\n"
"    ERL_COMPILER_OPTIONS=bin_opt_info mix compile\n"
"\n"
"最適化の指定やパフォーマンスの考慮点に関する詳細は、\n"
"[Erlangのバイナリ処理に関する効率性ガイド](http://www.erlang.org/doc/"
"efficiency_guide/binaryhandling.html)\n"
"を参照してください。\n"

#. TRANSLATORS: defmacro Kernel.SpecialForms.__ENV__()
#: lib/kernel/special_forms.ex:614
msgid ""
"Returns the current environment information as a `Macro.Env` struct.\n"
"\n"
"In the environment you can access the current filename,\n"
"line numbers, set up aliases, the current function and others.\n"
msgstr ""
"現在の環境の情報を`Macro.Env`構造体で返します。\n"
"\n"
"この環境の現在のファイル名、行番号、セットアップされた別名や\n"
"現在の関数などにアクセスできます。\n"

#. TRANSLATORS: defmacro Kernel.SpecialForms.fn(clauses)
#: lib/kernel/special_forms.ex:1354
msgid ""
"Defines an anonymous function.\n"
"\n"
"## Examples\n"
"\n"
"    iex> add = fn a, b -> a + b end\n"
"    iex> add.(1, 2)\n"
"    3\n"
"\n"
msgstr ""
"無名関数を定義します。\n"
"\n"
"## 例\n"
"\n"
"    iex> add = fn a, b -> a + b end\n"
"    iex> add.(1, 2)\n"
"    3\n"
"\n"

#. TRANSLATORS: defmacro Kernel.SpecialForms.with(args)
#: lib/kernel/special_forms.ex:1296
msgid ""
"Used to combine matching clauses.\n"
"\n"
"Let's start with an example:\n"
"\n"
"    iex> opts = %{width: 10, height: 15}\n"
"    iex> with {:ok, width} <- Map.fetch(opts, :width),\n"
"    ...>      {:ok, height} <- Map.fetch(opts, :height),\n"
"    ...>      do: {:ok, width * height}\n"
"    {:ok, 150}\n"
"\n"
"If all clauses match, the `do` block is executed, returning its result.\n"
"Otherwise the chain is aborted and the non-matched value is returned:\n"
"\n"
"    iex> opts = %{width: 10}\n"
"    iex> with {:ok, width} <- Map.fetch(opts, :width),\n"
"    ...>      {:ok, height} <- Map.fetch(opts, :height),\n"
"    ...>      do: {:ok, width * height}\n"
"    :error\n"
"\n"
"Guards can be used in patterns as well:\n"
"\n"
"    iex> users = %{\"melany\" => \"guest\", \"bob\" => :admin}\n"
"    iex> with {:ok, role} when not is_binary(role) <- Map.fetch(users, \"bob"
"\"),\n"
"    ...>      do: {:ok, to_string(role)}\n"
"    {:ok, \"admin\"}\n"
"\n"
"As in `for/1`, variables bound inside `with/1` won't leak;\n"
"\"bare expressions\" may also be inserted between the clauses:\n"
"\n"
"    iex> width = nil\n"
"    iex> opts = %{width: 10, height: 15}\n"
"    iex> with {:ok, width} <- Map.fetch(opts, :width),\n"
"    ...>      double_width = width * 2,\n"
"    ...>      {:ok, height} <- Map.fetch(opts, :height),\n"
"    ...>      do: {:ok, double_width * height}\n"
"    {:ok, 300}\n"
"    iex> width\n"
"    nil\n"
"\n"
"An `else` option can be given to modify what is being returned from\n"
"`with` in the case of a failed match:\n"
"\n"
"    iex> opts = %{width: 10}\n"
"    iex> with {:ok, width} <- Map.fetch(opts, :width),\n"
"    ...>      {:ok, height} <- Map.fetch(opts, :height) do\n"
"    ...>   {:ok, width * height}\n"
"    ...> else\n"
"    ...>   :error ->\n"
"    ...>     {:error, :wrong_data}\n"
"    ...> end\n"
"    {:error, :wrong_data}\n"
"\n"
"If there is no matching `else` condition, then a `WithClauseError` exception "
"is raised.\n"
"\n"
msgstr ""
"マッチ節を結合するために使います。\n"
"\n"
"まず例から始めましょう。\n"
"\n"
"    iex> opts = %{width: 10, height: 15}\n"
"    iex> with {:ok, width} <- Map.fetch(opts, :width),\n"
"    ...>      {:ok, height} <- Map.fetch(opts, :height),\n"
"    ...>   do: {:ok, width * height}\n"
"    {:ok, 150}\n"
"\n"
"すべての節がマッチしたら、`do`ブロックが実行され、その結果が返されます。\n"
"そうでなければ、マッチは中止され、non-matched値が返ります:\n"
"\n"
"    iex> opts = %{width: 10}\n"
"    iex> with {:ok, width} <- Map.fetch(opts, :width),\n"
"    ...>      {:ok, height} <- Map.fetch(opts, :height),\n"
"    ...>   do: {:ok, width * height}\n"
"    :error\n"
"\n"
"パターンマッチにガードを使うことも可能です。\n"
"\n"
"    iex> users = %{\"melany\" => \"guest\", \"bob\" => :admin}\n"
"    iex> with {:ok, role} when not is_binary(role) <- Map.fetch(users, \"bob"
"\"),\n"
"    ...>   do: {:ok, to_string(role)}\n"
"    {:ok, \"admin\"}\n"
"\n"
"`for/1`と同じように`with/1`内で束縛された変数は外に漏れません。\n"
"節の間に「はだかの式（bare expression）」を挿入することもできます。\n"
"\n"
"    iex> width = nil\n"
"    iex> opts = %{width: 10, height: 15}\n"
"    iex> with {:ok, width} <- Map.fetch(opts, :width),\n"
"    ...>      double_width = width * 2,\n"
"    ...>      {:ok, height} <- Map.fetch(opts, :height),\n"
"    ...>   do: {:ok, double_width * height}\n"
"    {:ok, 300}\n"
"    iex> width\n"
"    nil\n"
"\n"
"マッチが失敗した場合に`with`が返す値を変更するためにelseオプションを\n"
"指定することができます。\n"
"\n"
"    iex> opts = %{width: 10}\n"
"    iex> with {:ok, width} <- Map.fetch(opts, :width),\n"
"    ...>      {:ok, height} <- Map.fetch(opts, :height) do\n"
"    ...>   {:ok, width * height}\n"
"    ...> else\n"
"    ...>   :error ->\n"
"    ...>     {:error, :wrong_data}\n"
"    ...> end\n"
"    {:error, :wrong_data}\n"
"\n"
"`else`条件にマッチするものがない場合は、`WithClauseError`例外が\n"
"発生します。\n"
"\n"

#. TRANSLATORS: defmacro Kernel.SpecialForms.try(args)
#: lib/kernel/special_forms.ex:1595
msgid ""
"Evaluates the given expressions and handles any error, exit\n"
"or throw that may have happened.\n"
"\n"
"## Examples\n"
"\n"
"    try do\n"
"      do_something_that_may_fail(some_arg)\n"
"    rescue\n"
"      ArgumentError ->\n"
"        IO.puts \"Invalid argument given\"\n"
"    catch\n"
"      value ->\n"
"        IO.puts \"caught #{value}\"\n"
"    else\n"
"      value ->\n"
"        IO.puts \"Success! The result was #{value}\"\n"
"    after\n"
"      IO.puts \"This is printed regardless if it failed or succeed\"\n"
"    end\n"
"\n"
"The rescue clause is used to handle exceptions, while the catch\n"
"clause can be used to catch thrown values. The else clause can\n"
"be used to control flow based on the result of the expression.\n"
"Catch, rescue and else clauses work based on pattern matching.\n"
"\n"
"Note that calls inside `try/1` are not tail recursive since the VM\n"
"needs to keep the stacktrace in case an exception happens.\n"
"\n"
"## Rescue clauses\n"
"\n"
"Besides relying on pattern matching, rescue clauses provides some\n"
"conveniences around exceptions that allows one to rescue an\n"
"exception by its name. All the following formats are valid rescue\n"
"expressions:\n"
"\n"
"    try do\n"
"      UndefinedModule.undefined_function\n"
"    rescue\n"
"      UndefinedFunctionError -> nil\n"
"    end\n"
"\n"
"    try do\n"
"      UndefinedModule.undefined_function\n"
"    rescue\n"
"      [UndefinedFunctionError] -> nil\n"
"    end\n"
"\n"
"    # rescue and bind to x\n"
"    try do\n"
"      UndefinedModule.undefined_function\n"
"    rescue\n"
"      x in [UndefinedFunctionError] -> nil\n"
"    end\n"
"\n"
"    # rescue all and bind to x\n"
"    try do\n"
"      UndefinedModule.undefined_function\n"
"    rescue\n"
"      x -> nil\n"
"    end\n"
"\n"
"## Erlang errors\n"
"\n"
"Erlang errors are transformed into Elixir ones during rescue:\n"
"\n"
"    try do\n"
"      :erlang.error(:badarg)\n"
"    rescue\n"
"      ArgumentError -> :ok\n"
"    end\n"
"\n"
"The most common Erlang errors will be transformed into their\n"
"Elixir counter-part. Those which are not will be transformed\n"
"into `ErlangError`:\n"
"\n"
"    try do\n"
"      :erlang.error(:unknown)\n"
"    rescue\n"
"      ErlangError -> :ok\n"
"    end\n"
"\n"
"In fact, `ErlangError` can be used to rescue any error that is\n"
"not an Elixir error proper. For example, it can be used to rescue\n"
"the earlier `:badarg` error too, prior to transformation:\n"
"\n"
"    try do\n"
"      :erlang.error(:badarg)\n"
"    rescue\n"
"      ErlangError -> :ok\n"
"    end\n"
"\n"
"## Catching throws and exits\n"
"\n"
"The catch clause can be used to catch throws values and exits.\n"
"\n"
"    try do\n"
"      exit(:shutdown)\n"
"    catch\n"
"      :exit, :shutdown -> IO.puts \"Exited with shutdown reason\"\n"
"    end\n"
"\n"
"    try do\n"
"      throw(:sample)\n"
"    catch\n"
"      :throw, :sample ->\n"
"        IO.puts \"sample thrown\"\n"
"    end\n"
"\n"
"catch values also support `:error`, as in Erlang, although it is\n"
"commonly avoided in favor of raise/rescue control mechanisms.\n"
"\n"
"## After clauses\n"
"\n"
"An `after` clause allows you to define cleanup logic that will be invoked "
"both\n"
"when the tried block of code succeeds and also when an error is raised. "
"Note\n"
"that the process will exit as usually when receiving an exit signal that "
"causes\n"
"it to exit abruptly and so the `after` clause is not guaranteed to be "
"executed.\n"
"Luckily, most resources in Elixir (such as open files, ETS tables, ports, "
"sockets,\n"
"etc.) are linked to or monitor the owning process and will automatically "
"clean\n"
"themselves up if that process exits.\n"
"\n"
"    File.write!(\"tmp/story.txt\", \"Hello, World\")\n"
"    try do\n"
"      do_something_with(\"tmp/story.txt\")\n"
"    after\n"
"      File.rm(\"tmp/story.txt\")\n"
"    end\n"
"\n"
"## Else clauses\n"
"\n"
"Else clauses allow the result of the expression to be pattern\n"
"matched on:\n"
"\n"
"    x = 2\n"
"    try do\n"
"      1 / x\n"
"    rescue\n"
"      ArithmeticError ->\n"
"        :infinity\n"
"    else\n"
"      y when y < 1 and y > -1 ->\n"
"        :small\n"
"      _ ->\n"
"        :large\n"
"    end\n"
"\n"
"If an else clause is not present and no exceptions are raised,\n"
"the result of the expression will be returned:\n"
"\n"
"    x = 1\n"
"    ^x =\n"
"      try do\n"
"        1 / x\n"
"      rescue\n"
"        ArithmeticError ->\n"
"          :infinity\n"
"      end\n"
"\n"
"However, when an else clause is present but the result of the expression\n"
"does not match any of the patterns an exception will be raised. This\n"
"exception will not be caught by a catch or rescue in the same try:\n"
"\n"
"    x = 1\n"
"    try do\n"
"      try do\n"
"        1 / x\n"
"      rescue\n"
"        # The TryClauseError can not be rescued here:\n"
"        TryClauseError ->\n"
"          :error_a\n"
"      else\n"
"        0 ->\n"
"          :small\n"
"      end\n"
"    rescue\n"
"      # The TryClauseError is rescued here:\n"
"      TryClauseError ->\n"
"        :error_b\n"
"    end\n"
"\n"
"Similarly, an exception inside an else clause is not caught or rescued\n"
"inside the same try:\n"
"\n"
"    try do\n"
"      try do\n"
"        nil\n"
"      catch\n"
"        # The exit(1) call below can not be caught here:\n"
"        :exit, _ ->\n"
"          :exit_a\n"
"      else\n"
"        _ ->\n"
"          exit(1)\n"
"      end\n"
"    catch\n"
"      # The exit is caught here:\n"
"      :exit, _ ->\n"
"        :exit_b\n"
"    end\n"
"\n"
"This means the VM no longer needs to keep the stacktrace once inside\n"
"an else clause and so tail recursion is possible when using a `try`\n"
"with a tail call as the final call inside an else clause. The same\n"
"is true for `rescue` and `catch` clauses.\n"
"\n"
"## Variable handling\n"
"\n"
"Since an expression inside `try` may not have been evaluated\n"
"due to an exception, any variable created inside `try` cannot\n"
"be accessed externally. For instance:\n"
"\n"
"    try do\n"
"      x = 1\n"
"      do_something_that_may_fail(same_arg)\n"
"      :ok\n"
"    catch\n"
"      _, _ -> :failed\n"
"    end\n"
"\n"
"    x #=> unbound variable \"x\"\n"
"\n"
"In the example above, `x` cannot be accessed since it was defined\n"
"inside the `try` clause. A common practice to address this issue\n"
"is to return the variables defined inside `try`:\n"
"\n"
"    x =\n"
"      try do\n"
"        x = 1\n"
"        do_something_that_may_fail(same_arg)\n"
"        x\n"
"      catch\n"
"        _, _ -> :failed\n"
"      end\n"
"\n"
msgstr ""
"指定した式を評価し、発生する可能性のある任意のerror、exit,、throwを\n"
"処理します。\n"
"\n"
"## 例\n"
"\n"
"    try do\n"
"      do_something_that_may_fail(some_arg)\n"
"    rescue\n"
"      ArgumentError ->\n"
"        IO.puts \"Invalid argument given\"\n"
"    catch\n"
"      value ->\n"
"        IO.puts \"caught #{value}\"\n"
"    else\n"
"      value ->\n"
"        IO.puts \"Success! The result was #{value}\"\n"
"    after\n"
"      IO.puts \"This is printed regardless if it failed or succeed\"\n"
"    end\n"
"\n"
"rescue節は例外を処理するために使われ、catch節はthrowされた値を\n"
"捕捉するために使われます。else節は式の結果に基いたフロー制御のために\n"
"使われます。catch、rescue、elseの各節はパターンマッチングに基いて\n"
"動作します。\n"
"\n"
"`try/1`内の呼び出しは、末尾再帰ではないことに注意してください。\n"
"例外発生に備えて、VMがスタックトレースを保持する必要があるからです。\n"
"\n"
"## Rescue節\n"
"\n"
"パターンマッチングに頼る他に、rescue節はその名前によって例外をrescue\n"
"できる例外関連のいくつかの利便性を提供します。\n"
"以下のフォーマットはすべて正しいrescue式です。\n"
"\n"
"    try do\n"
"      UndefinedModule.undefined_function\n"
"    rescue\n"
"      UndefinedFunctionError -> nil\n"
"    end\n"
"\n"
"    try do\n"
"      UndefinedModule.undefined_function\n"
"    rescue\n"
"      [UndefinedFunctionError] -> nil\n"
"    end\n"
"\n"
"    # rescueして、xに束縛\n"
"    try do\n"
"      UndefinedModule.undefined_function\n"
"    rescue\n"
"      x in [UndefinedFunctionError] -> nil\n"
"    end\n"
"\n"
"    # すべてをrescueして、xに束縛\n"
"    try do\n"
"      UndefinedModule.undefined_function\n"
"    rescue\n"
"      x -> nil\n"
"    end\n"
"\n"
"## Erlangエラー\n"
"\n"
"Erlangエラーはrescueされる際にElixirのエラーに変換されます。\n"
"\n"
"    try do\n"
"      :erlang.error(:badarg)\n"
"    rescue\n"
"      ArgumentError -> :ok\n"
"    end\n"
"\n"
"一般的なErlangエラーのほとんどは対応するElixirのエラーに変換されます。\n"
"変換できないエラーは`ErlangError`に変換されます。\n"
"\n"
"    try do\n"
"      :erlang.error(:unknown)\n"
"    rescue\n"
"      ErlangError -> :ok\n"
"    end\n"
"\n"
"実際、`ErlangError`は、本来Elixirのエラーではないすべてのエラーを\n"
"rescueするために使うことができます。たとえば、先の`:badarg`エラーを\n"
"変換する前にrescueするために使うことができます:\n"
"\n"
"    try do\n"
"      :erlang.error(:badarg)\n"
"    rescue\n"
"      ErlangError -> :ok\n"
"    end\n"
"\n"
"## throwとexitの捕捉\n"
"\n"
"throwされた値とexitを捕捉するためにcatch節を使うことができます。\n"
"\n"
"    try do\n"
"      exit(:shutdown)\n"
"    catch\n"
"      :exit, :shutdown -> IO.puts \"Exited with shutdown reason\"\n"
"    end\n"
"\n"
"    try do\n"
"      throw(:sample)\n"
"    catch\n"
"      :throw, :sample ->\n"
"        IO.puts \"sample thrown\"\n"
"    end\n"
"\n"
"捕捉する値には、Erlangのように`:error`もサポートしますが、\n"
"raise/rescue制御機構の方が好まれ、一般的には使用が避けられます。\n"
"\n"
"## After節\n"
"\n"
"`after`節を使って、tryしたコードブロックが成功した場合、および、エラーが\n"
"発生した場合の両者で呼び出されるクリーンアップロジックを定義することができま"
"す。\n"
"プロセスは、突然終了を引き起こす終了シグナルを受信すると通常は終了するの"
"で、\n"
"`after`節が実行されることは保証されないことに注意が必要です。幸運なことに、\n"
"Elixirのほとんどのリソース（オープンしたファイル、ETSテーブル、ポート、\n"
"ソケットなど）は、所有プロセスにリンクされているか、所有プロセスを監視してお"
"り、\n"
"プロセスが終了すると自分自身を自動的にクリーンアップします。\n"
"\n"
"\n"
"    File.write!(\"tmp/story.txt\", \"Hello, World\")\n"
"    try do\n"
"      do_something_with(\"tmp/story.txt\")\n"
"    after\n"
"      File.rm(\"tmp/story.txt\")\n"
"    end\n"
"\n"
"## Else節\n"
"\n"
"else節は式の結果をパターンマッチすることができます。\n"
"\n"
"    x = 2\n"
"    try do\n"
"      1 / x\n"
"    rescue\n"
"      ArithmeticError ->\n"
"        :infinity\n"
"    else\n"
"      y when y < 1 and y > -1 ->\n"
"        :small\n"
"      _ ->\n"
"        :large\n"
"    end\n"
"\n"
"else節がなく、例外が発生しない場合、式の結果が返されます。\n"
"\n"
"    x = 1\n"
"    ^x =\n"
"      try do\n"
"        1 / x\n"
"      rescue\n"
"        ArithmeticError ->\n"
"          :infinity\n"
"      end\n"
"\n"
"しかし、else節はあるが式の結果がどのパターンにもマッチしない場合は、\n"
"例外が発生します。この例外は、同じtryのcatchやrescueでは捕捉されません:\n"
"\n"
"    x = 1\n"
"    try do\n"
"      try do\n"
"        1 / x\n"
"      rescue\n"
"        # TryClauseErrorはここではrescueできない\n"
"        TryClauseError ->\n"
"          :error_a\n"
"      else\n"
"        0 ->\n"
"          :small\n"
"      end\n"
"    rescue\n"
"      # TryClauseErrorはここでrescueされる\n"
"      TryClauseError ->\n"
"        :error_b\n"
"    end\n"
"\n"
"同様に、else節内の例外は、同じtryの中ではcatchもrescueも\n"
"されません。\n"
"\n"
"    try do\n"
"      try do\n"
"        nil\n"
"      catch\n"
"        # 下のexit(1)呼び出しはここでは捕捉できない\n"
"        :exit, _ ->\n"
"          :exit_a\n"
"      else\n"
"        _ ->\n"
"          exit(1)\n"
"      end\n"
"    catch\n"
"      # exitはここで補足される\n"
"      :exit, _ ->\n"
"        :exit_b\n"
"    end\n"
"\n"
"これは、else節の内側になるとVMは最早スタックトレースを保持する必要がなく、\n"
"そのため、else節の内側の最後の呼び出しとして末尾再帰呼び出しを持つ`try`を\n"
"使うと末尾再帰が可能になることを意味します。`rescue`節と`catch`節に\n"
"ついても同じです。\n"
"\n"
"## 変数の取り扱い\n"
"\n"
"`try`の内側の式は、例外のために評価されない可能性があるので、\n"
"`try`の内側で作成されたすべての変数は外部からアクセスできません。\n"
"たとえば、\n"
"\n"
"    try do\n"
"      x = 1\n"
"      do_something_that_may_fail(same_arg)\n"
"      :ok\n"
"    catch\n"
"      _, _ -> :failed\n"
"    end\n"
"\n"
"    x #=> unbound variable \"x\"\n"
"\n"
"この例では、`x`は`try`節の内側で定義されたのでアクセスできません。\n"
"この問題に対処する一般的な方法は、`try`の内側で定義された変数を\n"
"返すことです。\n"
"\n"
"    x =\n"
"      try do\n"
"        x = 1\n"
"        do_something_that_may_fail(same_arg)\n"
"        x\n"
"      catch\n"
"        _, _ -> :failed\n"
"      end\n"
"\n"

#. TRANSLATORS: defmacro Kernel.SpecialForms.%(struct, map)
#: lib/kernel/special_forms.ex:74
msgid ""
"Creates a struct.\n"
"\n"
"A struct is a tagged map that allows developers to provide\n"
"default values for keys, tags to be used in polymorphic\n"
"dispatches and compile time assertions.\n"
"\n"
"Structs are usually defined with the `Kernel.defstruct/1` macro:\n"
"\n"
"    defmodule User do\n"
"      defstruct name: \"john\", age: 27\n"
"    end\n"
"\n"
"Now a struct can be created as follows:\n"
"\n"
"    %User{}\n"
"\n"
"Underneath a struct is just a map with a `:__struct__` key\n"
"pointing to the `User` module:\n"
"\n"
"    %User{} == %{__struct__: User, name: \"john\", age: 27}\n"
"\n"
"A struct also validates that the given keys are part of the defined\n"
"struct. The example below will fail because there is no key\n"
"`:full_name` in the `User` struct:\n"
"\n"
"    %User{full_name: \"john doe\"}\n"
"\n"
"An update operation specific for structs is also available:\n"
"\n"
"    %User{user | age: 28}\n"
"\n"
"The syntax above will guarantee the given keys are valid at\n"
"compilation time and it will guarantee at runtime the given\n"
"argument is a struct, failing with `BadStructError` otherwise.\n"
"\n"
"Although structs are maps, by default structs do not implement\n"
"any of the protocols implemented for maps. Check\n"
"`Kernel.defprotocol/2` for more information on how structs\n"
"can be used with protocols for polymorphic dispatch. Also\n"
"see `Kernel.struct/2` and `Kernel.struct!/2` for examples on\n"
"how to create and update structs dynamically.\n"
msgstr ""
"構造体を作成します。\n"
"\n"
"構造体は、タグ付きマップであり、キーのデフォルト値やポリモーフィックな\n"
"ディスパッチに使用されるタグ、コンパイル時アサーションを提供可能にします。\n"
"\n"
"構造体は通常、`Kernel.defstruct/1`マクロを使って定義されます。\n"
"\n"
"    defmodule User do\n"
"      defstruct name: \"john\", age: 27\n"
"    end\n"
"\n"
"これで、構造体を次のように作成できます。\n"
"\n"
"    %User{}\n"
"\n"
"内部的には、構造体は`User`モジュールを指す`__struct__`キーを持つ\n"
"単なるマップです。\n"
"\n"
"    %User{} == %{__struct__: User, name: \"john\", age: 27}\n"
"\n"
"構造体は、指定したキーが構造体定義に含まれているかの検証も行います。\n"
"下の例は失敗します。`User`構造体には`:full_name`キーがないからです。\n"
"\n"
"    %User{full_name: \"john doe\"}\n"
"\n"
"構造体特有の更新操作も利用できます。\n"
"\n"
"    %User{user | age: 28}\n"
"\n"
"この構文はコンパイル時に指定したキーが有効であることを保証し、かつ、\n"
"実行時には指定した引数が構造体であることを保証します。そうでない場合は、\n"
"`BadStructError`で失敗します。\n"
"\n"
"構造体はマップですが、デフォルトではマップで実装されているプロトコルを\n"
"1つも実装していません。ポリモーフィックなディスパッチのために\n"
"構造体がプロトコルを使う方法に関する詳細は`Kernel.defprotocol/2`を\n"
"チェックしてください。また、構造体を動的に作成・更新する方法に関する例は\n"

#. TRANSLATORS: defmacro Kernel.SpecialForms.=(left, right)
#: lib/kernel/special_forms.ex:678
msgid "Matches the value on the right against the pattern on the left.\n"
msgstr "左辺のパターンに対して右辺の値をマッチさせます。\n"

#. TRANSLATORS: defmacro Kernel.SpecialForms.super(args)
#: lib/kernel/special_forms.ex:1486
msgid ""
"Calls the overridden function when overriding it with `Kernel."
"defoverridable/1`.\n"
"\n"
"See `Kernel.defoverridable/1` for more information and documentation.\n"
msgstr ""
"`Kernel.defoverridable/1`で関数をオーバライドした場合に、\n"
"オーバライドされた関数を呼び出します。\n"
"\n"
"詳細とトキュメントは`Kernel.defoverridable/1`を参照してください。\n"

#. TRANSLATORS: defmacro Kernel.SpecialForms.__MODULE__()
#: lib/kernel/special_forms.ex:622
msgid ""
"Returns the current module name as an atom or `nil` otherwise.\n"
"\n"
"Although the module can be accessed in the `__ENV__/0`, this macro\n"
"is a convenient shortcut.\n"
msgstr ""
"現在のモジュール名をアトムで返します。そうでなければ、`nil`を返します。\n"
"\n"
"モジュールは`__ENV__`でアクセスできますが、このマクロは\n"
"その便利なショートカットです。\n"

#. TRANSLATORS: defmacro Kernel.SpecialForms.__DIR__()
#: lib/kernel/special_forms.ex:630
msgid ""
"Returns the absolute path of the directory of the current file as a binary.\n"
"\n"
"Although the directory can be accessed as `Path.dirname(__ENV__.file)`,\n"
"this macro is a convenient shortcut.\n"
msgstr ""
"現在のファイルのディレクトリの完全パスをバイナリで返します。\n"
"\n"
"ディレクトリは`Path.dirname(__ENV__.file)`でアクセスできますが、\n"
"このマクロはその便利なショートカットです。\n"

#. TRANSLATORS: defmacro Kernel.SpecialForms.&(expr)
#: lib/kernel/special_forms.ex:1383
msgid ""
"Captures or creates an anonymous function.\n"
"\n"
"## Capture\n"
"\n"
"The capture operator is most commonly used to capture a\n"
"function with given name and arity from a module:\n"
"\n"
"    iex> fun = &Kernel.is_atom/1\n"
"    iex> fun.(:atom)\n"
"    true\n"
"    iex> fun.(\"string\")\n"
"    false\n"
"\n"
"In the example above, we captured `Kernel.is_atom/1` as an\n"
"anonymous function and then invoked it.\n"
"\n"
"The capture operator can also be used to capture local functions,\n"
"including private ones, and imported functions by omitting the\n"
"module name:\n"
"\n"
"    &local_function/1\n"
"\n"
"## Anonymous functions\n"
"\n"
"The capture operator can also be used to partially apply\n"
"functions, where `&1`, `&2` and so on can be used as value\n"
"placeholders. For example:\n"
"\n"
"    iex> double = &(&1 * 2)\n"
"    iex> double.(2)\n"
"    4\n"
"\n"
"In other words, `&(&1 * 2)` is equivalent to `fn x -> x * 2 end`.\n"
"Another example using a local function:\n"
"\n"
"    iex> fun = &is_atom(&1)\n"
"    iex> fun.(:atom)\n"
"    true\n"
"\n"
"The `&` operator can be used with more complex expressions:\n"
"\n"
"    iex> fun = &(&1 + &2 + &3)\n"
"    iex> fun.(1, 2, 3)\n"
"    6\n"
"\n"
"As well as with lists and tuples:\n"
"\n"
"    iex> fun = &{&1, &2}\n"
"    iex> fun.(1, 2)\n"
"    {1, 2}\n"
"\n"
"    iex> fun = &[&1 | &2]\n"
"    iex> fun.(1, 2)\n"
"    [1 | 2]\n"
"\n"
"The only restrictions when creating anonymous functions is that at\n"
"least one placeholder must be present, i.e. it must contain at least\n"
"`&1`, and that block expressions are not supported:\n"
"\n"
"    # No placeholder, fails to compile.\n"
"    &(:foo)\n"
"\n"
"    # Block expression, fails to compile.\n"
"    &(&1; &2)\n"
"\n"
msgstr ""
"無名関数を捕捉あるいは作成します。\n"
"\n"
"## 捕捉\n"
"\n"
"捕捉オペレータは、モジュールから指定した名前とアリティを持つ\n"
"関数を捕捉するために最もよく使われます。\n"
"\n"
"    iex> fun = &Kernel.is_atom/1\n"
"    iex> fun.(:atom)\n"
"    true\n"
"    iex> fun.(\"string\")\n"
"    false\n"
"\n"
"この例では、`Kernel.is_atom/1`を無名関数として捕捉して、\n"
"呼び出しています。\n"
"\n"
"捕捉オペレータは、プライベート関数を含むローカル関数の捕捉にも\n"
"使用することができ、モジュール名を省略して関数をインポートできます:\n"
"\n"
"    &local_function/1\n"
"\n"
"## 無名関数\n"
"\n"
"捕捉オペレータは、関数の部分適用にも使うことができ、\n"
"`&1`, `&2`などを値のプレースホルダとして使うことができます。\n"
"たとえば:\n"
"\n"
"    iex> double = &(&1 * 2)\n"
"    iex> double.(2)\n"
"    4\n"
"\n"
"言い替えると、`&(&1 * 2)`は`fn x -> x * 2 end`に等しいです。\n"
"ローカル関数を使用した別の例です。\n"
"\n"
"    iex> fun = &is_atom(&1)\n"
"    iex> fun.(:atom)\n"
"    true\n"
"\n"
"`&`オペレータはもっと複雑な式に使うことができます:\n"
"\n"
"    iex> fun = &(&1 + &2 + &3)\n"
"    iex> fun.(1, 2, 3)\n"
"    6\n"
"\n"
"リストやタプルにも同じように使えます:\n"
"\n"
"    iex> fun = &{&1, &2}\n"
"    iex> fun.(1, 2)\n"
"    {1, 2}\n"
"\n"
"    iex> fun = &[&1|&2]\n"
"    iex> fun.(1, 2)\n"
"    [1|2]\n"
"\n"
"無名関数を作成する際の唯一の制限は、少なくとも1つはプレースホルダが\n"
"なければならないことです。すなわち、少なくとも`&1`は含まなければなりませ"
"ん。\n"
"また、ブロック式はサポートされていません。\n"
"\n"
"    # プレースホルダがないのでコンパイルに失敗します\n"
"    &(:foo)\n"
"\n"
"    # ブロック式もコンパイルに失敗します\n"
"    &(&1; &2)\n"
"\n"

#. TRANSLATORS: defmacro Kernel.SpecialForms.case(condition, clauses)
#: lib/kernel/special_forms.ex:1493
msgid ""
"Matches the given expression against the given clauses.\n"
"\n"
"## Examples\n"
"\n"
"    case thing do\n"
"      {:selector, i, value} when is_integer(i) ->\n"
"        value\n"
"      value ->\n"
"        value\n"
"    end\n"
"\n"
"In the example above, we match `thing` against each clause \"head\"\n"
"and execute the clause \"body\" corresponding to the first clause\n"
"that matches.\n"
"\n"
"If no clause matches, an error is raised.\n"
"For this reason, it may be necessary to add a final catch-all clause (like "
"`_`)\n"
"which will always match.\n"
"\n"
"    x = 10\n"
"\n"
"    case x do\n"
"      0 ->\n"
"        \"This clause won't match\"\n"
"      _ ->\n"
"        \"This clause would match any value (x = #{x})\"\n"
"    end\n"
"    #=> \"This clause would match any value (x = 10)\"\n"
"\n"
"## Variables handling\n"
"\n"
"Notice that variables bound in a clause \"head\" do not leak to the\n"
"outer context:\n"
"\n"
"    case data do\n"
"      {:ok, value} -> value\n"
"      :error -> nil\n"
"    end\n"
"\n"
"    value #=> unbound variable value\n"
"\n"
"However, variables explicitly bound in the clause \"body\" are\n"
"accessible from the outer context:\n"
"\n"
"    value = 7\n"
"\n"
"    case lucky? do\n"
"      false -> value = 13\n"
"      true  -> true\n"
"    end\n"
"\n"
"    value #=> 7 or 13\n"
"\n"
"In the example above, value is going to be `7` or `13` depending on\n"
"the value of `lucky?`. In case `value` has no previous value before\n"
"case, clauses that do not explicitly bind a value have the variable\n"
"bound to `nil`.\n"
"\n"
"If you want to pattern match against an existing variable,\n"
"you need to use the `^/1` operator:\n"
"\n"
"    x = 1\n"
"\n"
"    case 10 do\n"
"      ^x -> \"Won't match\"\n"
"      _  -> \"Will match\"\n"
"    end\n"
"    #=> \"Will match\"\n"
"\n"
msgstr ""
"指定した節に対して指定した式をマッチさせます。\n"
"\n"
"## 例\n"
"\n"
"    case thing do\n"
"      {:selector, i, value} when is_integer(i) ->\n"
"        value\n"
"      value ->\n"
"        value\n"
"    end\n"
"\n"
"上の例では、各節の”head”に対して`thing`をマッチさせ、マッチした\n"
"最初の節の”body”を実行します。\n"
"\n"
"マッチする節がない場合は、エラーが発生します。そのため、最後に\n"
"常にマッチする（`_`のような）catch-all節を追加する必要があるでしょう。\n"
"\n"
"\n"
"    x = 10\n"
"\n"
"    case x do\n"
"      0 ->\n"
"        \"This clause won't match\"\n"
"      _ ->\n"
"        \"This clause would match any value (x = #{x})\"\n"
"    end\n"
"    #=> \"This clause would match any value (x = 10)\"\n"
"\n"
"## 変数の取り扱い\n"
"\n"
"節の”head”で束縛された変数は、外部コンテキストには漏れないことに\n"
"注意してください:\n"
"\n"
"    case data do\n"
"      {:ok, value} -> value\n"
"      :error -> nil\n"
"    end\n"
"\n"
"    value #=> unbound variable value\n"
"\n"
"しかし、節の\"body\"で明示的に束縛された変数は、外部コンテキスト\n"
"からアクセスできます。\n"
"\n"
"    value = 7\n"
"\n"
"    case lucky? do\n"
"      false -> value = 13\n"
"      true  -> true\n"
"    end\n"
"\n"
"    value #=> 7 or 13\n"
"\n"
"上の例では、valueは`lucky?`の値により`7`か`13`になります。\n"
"`value`がcase以前に値を持っていなかった場合は、明示的に値を\n"
"束縛しない節の`variable`は`nil`に束縛されます。\n"
"\n"
"既存の変数に対してパターンマッチさせたい場合は、\n"
"`^/1`オペレータを使う必要があります。\n"
"\n"
"    x = 1\n"
"\n"
"    case 10 do\n"
"      ^x -> \"Won't match\"\n"
"      _  -> \"Will match\"\n"
"    end\n"
"    #=> \"Will match\"\n"
"\n"

#. TRANSLATORS: defmacro Kernel.SpecialForms.unquote_splicing(expr)
#: lib/kernel/special_forms.ex:1212
msgid ""
"Unquotes the given list expanding its arguments. Similar\n"
"to `unquote/1`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> values = [2, 3, 4]\n"
"    iex> quote do\n"
"    ...>   sum(1, unquote_splicing(values), 5)\n"
"    ...> end\n"
"    {:sum, [], [1, 2, 3, 4, 5]}\n"
"\n"
msgstr ""
"指定したリストの引数を展開してunquoteします。\n"
"`unquote/1`と同じです。\n"
"\n"
"## 例\n"
"\n"
"    iex> values = [2, 3, 4]\n"
"    iex> quote do\n"
"    ...>   sum(1, unquote_splicing(values), 5)\n"
"    ...> end\n"
"    {:sum, [], [1, 2, 3, 4, 5]}\n"
"\n"

#. TRANSLATORS: defmacro Kernel.SpecialForms.alias(module, opts)
#: lib/kernel/special_forms.ex:427
msgid ""
"`alias/2` is used to setup aliases, often useful with modules names.\n"
"\n"
"## Examples\n"
"\n"
"`alias/2` can be used to setup an alias for any module:\n"
"\n"
"    defmodule Math do\n"
"      alias MyKeyword, as: Keyword\n"
"    end\n"
"\n"
"In the example above, we have set up `MyKeyword` to be aliased\n"
"as `Keyword`. So now, any reference to `Keyword` will be\n"
"automatically replaced by `MyKeyword`.\n"
"\n"
"In case one wants to access the original `Keyword`, it can be done\n"
"by accessing `Elixir`:\n"
"\n"
"    Keyword.values   #=> uses MyKeyword.values\n"
"    Elixir.Keyword.values #=> uses Keyword.values\n"
"\n"
"Notice that calling `alias` without the `as:` option automatically\n"
"sets an alias based on the last part of the module. For example:\n"
"\n"
"    alias Foo.Bar.Baz\n"
"\n"
"Is the same as:\n"
"\n"
"    alias Foo.Bar.Baz, as: Baz\n"
"\n"
"We can also alias multiple modules in one line:\n"
"\n"
"    alias Foo.{Bar, Baz, Biz}\n"
"\n"
"Is the same as:\n"
"\n"
"    alias Foo.Bar\n"
"    alias Foo.Baz\n"
"    alias Foo.Biz\n"
"\n"
"## Lexical scope\n"
"\n"
"`import/2`, `require/2` and `alias/2` are called directives and all\n"
"have lexical scope. This means you can set up aliases inside\n"
"specific functions and it won't affect the overall scope.\n"
"\n"
"## Warnings\n"
"\n"
"If you alias a module and you don't use the alias, Elixir is\n"
"going to issue a warning implying the alias is not being used.\n"
"\n"
"In case the alias is generated automatically by a macro,\n"
"Elixir won't emit any warnings though, since the alias\n"
"was not explicitly defined.\n"
"\n"
"Both warning behaviours could be changed by explicitly\n"
"setting the `:warn` option to `true` or `false`.\n"
msgstr ""
"`alias/2`は、多くの場合、モジュール名の別名の設定に使用されます。\n"
"\n"
"## 例\n"
"\n"
"`alias/2`は任意のモジュールの別名の設定に使用できます:\n"
"\n"
"    defmodule Math do\n"
"      alias MyKeyword, as: Keyword\n"
"    end\n"
"\n"
"上の例では、`MyKeyword`の別名に`Keyword`を設定しました。そのため、\n"
"これ以後は`Keyword`へのすべての参照は`MyKeyword`に自動的に置き換えられま"
"す。\n"
"\n"
"オリジナルの`Keyword`にアクセスしたい場合は、`Elixir`を付ければ\n"
"可能です。\n"
"\n"
"    Keyword.values   #=> MyKeyword.values を使う\n"
"    Elixir.Keyword.values #=> Keyword.values を使う\n"
"\n"
"`as:`オプションなしで`alias`を呼び出すと、自動的にモジュールの最後の\n"
"パートを元に別名を設定することに注意してください。たとえば\n"
"\n"
"    alias Foo.Bar.Baz\n"
"\n"
"これは以下と同じです。\n"
"\n"
"    alias Foo.Bar.Baz, as: Baz\n"
"\n"
"複数のモジュールの別名を1行で行うこともできます。\n"
"\n"
"    alias Foo.{Bar, Baz, Biz}\n"
"\n"
"これは以下と同じです。\n"
"\n"
"    alias Foo.Bar\n"
"    alias Foo.Baz\n"
"    alias Foo.Biz\n"
"\n"
"## レキシカルスコープ\n"
"\n"
"`import/2`、`require/2`、`alias/2`はディレクティブと呼ばれ、すべて\n"
"レキシカルスコープを持ちます。これは、別名は特定の関数内で\n"
"設定でき、全体のスコープに影響を及ぼさないことを意味します。\n"
"\n"
"## 警告\n"
"\n"
"モジュールの別名を設定して、その別名を使わないと、Elixirは、別名\n"
"が使われていないことを意味する警告を発します。\n"
"\n"
"別名がマクロにより自動的に生成された場合は、Elixirは警告を発しません。\n"
"別名が明示的に定義されていないからです。\n"
"\n"
"これら2つの警告のふるまいは、`:warn`オプションを`true`または`false`に\n"
"明示的に設定することにより変更できます。\n"

#. TRANSLATORS: defmacro Kernel.SpecialForms.quote(opts, block)
#: lib/kernel/special_forms.ex:704
msgid ""
"Gets the representation of any expression.\n"
"\n"
"## Examples\n"
"\n"
"    iex> quote do\n"
"    ...>   sum(1, 2, 3)\n"
"    ...> end\n"
"    {:sum, [], [1, 2, 3]}\n"
"\n"
"## Explanation\n"
"\n"
"Any Elixir code can be represented using Elixir data structures.\n"
"The building block of Elixir macros is a tuple with three elements,\n"
"for example:\n"
"\n"
"    {:sum, [], [1, 2, 3]}\n"
"\n"
"The tuple above represents a function call to `sum` passing 1, 2 and\n"
"3 as arguments. The tuple elements are:\n"
"\n"
"  * The first element of the tuple is always an atom or\n"
"    another tuple in the same representation.\n"
"\n"
"  * The second element of the tuple represents metadata.\n"
"\n"
"  * The third element of the tuple are the arguments for the\n"
"    function call. The third argument may be an atom, which is\n"
"    usually a variable (or a local call).\n"
"\n"
"## Options\n"
"\n"
"  * `:unquote` - when `false`, disables unquoting. Useful when you have a "
"quote\n"
"    inside another quote and want to control what quote is able to unquote.\n"
"\n"
"  * `:location` - when set to `:keep`, keeps the current line and file from\n"
"    quote. Read the Stacktrace information section below for more\n"
"    information.\n"
"\n"
"  * `:generated` - marks the given chunk as generated so it does not emit "
"warnings.\n"
"    Currently it only works on special forms (for example, you can annotate "
"a `case`\n"
"    but not an `if`).\n"
"\n"
"  * `:context` - sets the resolution context.\n"
"\n"
"  * `:bind_quoted` - passes a binding to the macro. Whenever a binding is\n"
"    given, `unquote/1` is automatically disabled.\n"
"\n"
"## Quote literals\n"
"\n"
"Besides the tuple described above, Elixir has a few literals that\n"
"when quoted return themselves. They are:\n"
"\n"
"    :sum         #=> Atoms\n"
"    1            #=> Integers\n"
"    2.0          #=> Floats\n"
"    [1, 2]       #=> Lists\n"
"    \"strings\"    #=> Strings\n"
"    {key, value} #=> Tuples with two elements\n"
"\n"
"## Quote and macros\n"
"\n"
"`quote/2` is commonly used with macros for code generation. As an exercise,\n"
"let's define a macro that multiplies a number by itself (squared). Note\n"
"there is no reason to define such as a macro (and it would actually be\n"
"seen as a bad practice), but it is simple enough that it allows us to focus\n"
"on the important aspects of quotes and macros:\n"
"\n"
"    defmodule Math do\n"
"      defmacro squared(x) do\n"
"        quote do\n"
"          unquote(x) * unquote(x)\n"
"        end\n"
"      end\n"
"    end\n"
"\n"
"We can invoke it as:\n"
"\n"
"    import Math\n"
"    IO.puts \"Got #{squared(5)}\"\n"
"\n"
"At first, there is nothing in this example that actually reveals it is a\n"
"macro. But what is happening is that, at compilation time, `squared(5)`\n"
"becomes `5 * 5`. The argument `5` is duplicated in the produced code, we\n"
"can see this behaviour in practice though because our macro actually has\n"
"a bug:\n"
"\n"
"    import Math\n"
"    my_number = fn ->\n"
"      IO.puts \"Returning 5\"\n"
"      5\n"
"    end\n"
"    IO.puts \"Got #{squared(my_number.())}\"\n"
"\n"
"The example above will print:\n"
"\n"
"    Returning 5\n"
"    Returning 5\n"
"    Got 25\n"
"\n"
"Notice how \"Returning 5\" was printed twice, instead of just once. This is\n"
"because a macro receives an expression and not a value (which is what we\n"
"would expect in a regular function). This means that:\n"
"\n"
"    squared(my_number.())\n"
"\n"
"Actually expands to:\n"
"\n"
"    my_number.() * my_number.()\n"
"\n"
"Which invokes the function twice, explaining why we get the printed value\n"
"twice! In the majority of the cases, this is actually unexpected behaviour,\n"
"and that's why one of the first things you need to keep in mind when it\n"
"comes to macros is to **not unquote the same value more than once**.\n"
"\n"
"Let's fix our macro:\n"
"\n"
"    defmodule Math do\n"
"      defmacro squared(x) do\n"
"        quote do\n"
"          x = unquote(x)\n"
"          x * x\n"
"        end\n"
"      end\n"
"    end\n"
"\n"
"Now invoking `square(my_number.())` as before will print the value just\n"
"once.\n"
"\n"
"In fact, this pattern is so common that most of the times you will want\n"
"to use the `bind_quoted` option with `quote/2`:\n"
"\n"
"    defmodule Math do\n"
"      defmacro squared(x) do\n"
"        quote bind_quoted: [x: x] do\n"
"          x * x\n"
"        end\n"
"      end\n"
"    end\n"
"\n"
"`:bind_quoted` will translate to the same code as the example above.\n"
"`:bind_quoted` can be used in many cases and is seen as good practice,\n"
"not only because it helps us from running into common mistakes but also\n"
"because it allows us to leverage other tools exposed by macros, such as\n"
"unquote fragments discussed in some sections below.\n"
"\n"
"Before we finish this brief introduction, you will notice that, even though\n"
"we defined a variable `x` inside our quote:\n"
"\n"
"    quote do\n"
"      x = unquote(x)\n"
"      x * x\n"
"    end\n"
"\n"
"When we call:\n"
"\n"
"    import Math\n"
"    squared(5)\n"
"    x #=> ** (CompileError) undefined variable x or undefined function x/0\n"
"\n"
"We can see that `x` did not leak to the user context. This happens\n"
"because Elixir macros are hygienic, a topic we will discuss at length\n"
"in the next sections as well.\n"
"\n"
"## Hygiene in variables\n"
"\n"
"Consider the following example:\n"
"\n"
"    defmodule Hygiene do\n"
"      defmacro no_interference do\n"
"        quote do\n"
"          a = 1\n"
"        end\n"
"      end\n"
"    end\n"
"\n"
"    require Hygiene\n"
"\n"
"    a = 10\n"
"    Hygiene.no_interference\n"
"    a #=> 10\n"
"\n"
"In the example above, `a` returns 10 even if the macro\n"
"is apparently setting it to 1 because variables defined\n"
"in the macro do not affect the context the macro is executed in.\n"
"If you want to set or get a variable in the caller's context, you\n"
"can do it with the help of the `var!` macro:\n"
"\n"
"    defmodule NoHygiene do\n"
"      defmacro interference do\n"
"        quote do\n"
"          var!(a) = 1\n"
"        end\n"
"      end\n"
"    end\n"
"\n"
"    require NoHygiene\n"
"\n"
"    a = 10\n"
"    NoHygiene.interference\n"
"    a #=> 1\n"
"\n"
"Note that you cannot even access variables defined in the same\n"
"module unless you explicitly give it a context:\n"
"\n"
"    defmodule Hygiene do\n"
"      defmacro write do\n"
"        quote do\n"
"          a = 1\n"
"        end\n"
"      end\n"
"\n"
"      defmacro read do\n"
"        quote do\n"
"          a\n"
"        end\n"
"      end\n"
"    end\n"
"\n"
"    Hygiene.write\n"
"    Hygiene.read\n"
"    #=> ** (RuntimeError) undefined variable a or undefined function a/0\n"
"\n"
"For such, you can explicitly pass the current module scope as\n"
"argument:\n"
"\n"
"    defmodule ContextHygiene do\n"
"      defmacro write do\n"
"        quote do\n"
"          var!(a, ContextHygiene) = 1\n"
"        end\n"
"      end\n"
"\n"
"      defmacro read do\n"
"        quote do\n"
"          var!(a, ContextHygiene)\n"
"        end\n"
"      end\n"
"    end\n"
"\n"
"    ContextHygiene.write\n"
"    ContextHygiene.read\n"
"    #=> 1\n"
"\n"
"## Hygiene in aliases\n"
"\n"
"Aliases inside quote are hygienic by default.\n"
"Consider the following example:\n"
"\n"
"    defmodule Hygiene do\n"
"      alias Map, as: M\n"
"\n"
"      defmacro no_interference do\n"
"        quote do\n"
"          M.new\n"
"        end\n"
"      end\n"
"    end\n"
"\n"
"    require Hygiene\n"
"    Hygiene.no_interference #=> %{}\n"
"\n"
"Notice that, even though the alias `M` is not available\n"
"in the context the macro is expanded, the code above works\n"
"because `M` still expands to `Map`.\n"
"\n"
"Similarly, even if we defined an alias with the same name\n"
"before invoking a macro, it won't affect the macro's result:\n"
"\n"
"    defmodule Hygiene do\n"
"      alias Map, as: M\n"
"\n"
"      defmacro no_interference do\n"
"        quote do\n"
"          M.new\n"
"        end\n"
"      end\n"
"    end\n"
"\n"
"    require Hygiene\n"
"    alias SomethingElse, as: M\n"
"    Hygiene.no_interference #=> %{}\n"
"\n"
"In some cases, you want to access an alias or a module defined\n"
"in the caller. For such, you can use the `alias!` macro:\n"
"\n"
"    defmodule Hygiene do\n"
"      # This will expand to Elixir.Nested.hello\n"
"      defmacro no_interference do\n"
"        quote do\n"
"          Nested.hello\n"
"        end\n"
"      end\n"
"\n"
"      # This will expand to Nested.hello for\n"
"      # whatever is Nested in the caller\n"
"      defmacro interference do\n"
"        quote do\n"
"          alias!(Nested).hello\n"
"        end\n"
"      end\n"
"    end\n"
"\n"
"    defmodule Parent do\n"
"      defmodule Nested do\n"
"        def hello, do: \"world\"\n"
"      end\n"
"\n"
"      require Hygiene\n"
"      Hygiene.no_interference\n"
"      #=> ** (UndefinedFunctionError) ...\n"
"\n"
"      Hygiene.interference\n"
"      #=> \"world\"\n"
"    end\n"
"\n"
"## Hygiene in imports\n"
"\n"
"Similar to aliases, imports in Elixir are hygienic. Consider the\n"
"following code:\n"
"\n"
"    defmodule Hygiene do\n"
"      defmacrop get_length do\n"
"        quote do\n"
"          length([1, 2, 3])\n"
"        end\n"
"      end\n"
"\n"
"      def return_length do\n"
"        import Kernel, except: [length: 1]\n"
"        get_length\n"
"      end\n"
"    end\n"
"\n"
"    Hygiene.return_length #=> 3\n"
"\n"
"Notice how `Hygiene.return_length/0` returns `3` even though the `Kernel."
"length/1`\n"
"function is not imported. In fact, even if `return_length/0`\n"
"imported a function with the same name and arity from another\n"
"module, it wouldn't affect the function result:\n"
"\n"
"    def return_length do\n"
"      import String, only: [length: 1]\n"
"      get_length\n"
"    end\n"
"\n"
"Calling this new `return_length/0` will still return `3` as result.\n"
"\n"
"Elixir is smart enough to delay the resolution to the latest\n"
"possible moment. So, if you call `length([1, 2, 3])` inside quote,\n"
"but no `length/1` function is available, it is then expanded in\n"
"the caller:\n"
"\n"
"    defmodule Lazy do\n"
"      defmacrop get_length do\n"
"        import Kernel, except: [length: 1]\n"
"\n"
"        quote do\n"
"          length(\"hello\")\n"
"        end\n"
"      end\n"
"\n"
"      def return_length do\n"
"        import Kernel, except: [length: 1]\n"
"        import String, only: [length: 1]\n"
"        get_length\n"
"      end\n"
"    end\n"
"\n"
"    Lazy.return_length #=> 5\n"
"\n"
"## Stacktrace information\n"
"\n"
"When defining functions via macros, developers have the option of\n"
"choosing if runtime errors will be reported from the caller or from\n"
"inside the quote. Let's see an example:\n"
"\n"
"    # adder.ex\n"
"    defmodule Adder do\n"
"      @doc \"Defines a function that adds two numbers\"\n"
"      defmacro defadd do\n"
"        quote location: :keep do\n"
"          def add(a, b), do: a + b\n"
"        end\n"
"      end\n"
"    end\n"
"\n"
"    # sample.ex\n"
"    defmodule Sample do\n"
"      import Adder\n"
"      defadd\n"
"    end\n"
"\n"
"    require Sample\n"
"    Sample.add(:one, :two)\n"
"    #=> ** (ArithmeticError) bad argument in arithmetic expression\n"
"    #=>     adder.ex:5: Sample.add/2\n"
"\n"
"When using `location: :keep` and invalid arguments are given to\n"
"`Sample.add/2`, the stacktrace information will point to the file\n"
"and line inside the quote. Without `location: :keep`, the error is\n"
"reported to where `defadd` was invoked. Note `location: :keep` affects\n"
"only definitions inside the quote.\n"
"\n"
"## Binding and unquote fragments\n"
"\n"
"Elixir quote/unquote mechanisms provides a functionality called\n"
"unquote fragments. Unquote fragments provide an easy way to generate\n"
"functions on the fly. Consider this example:\n"
"\n"
"    kv = [foo: 1, bar: 2]\n"
"    Enum.each kv, fn {k, v} ->\n"
"      def unquote(k)(), do: unquote(v)\n"
"    end\n"
"\n"
"In the example above, we have generated the functions `foo/0` and\n"
"`bar/0` dynamically. Now, imagine that, we want to convert this\n"
"functionality into a macro:\n"
"\n"
"    defmacro defkv(kv) do\n"
"      Enum.map kv, fn {k, v} ->\n"
"        quote do\n"
"          def unquote(k)(), do: unquote(v)\n"
"        end\n"
"      end\n"
"    end\n"
"\n"
"We can invoke this macro as:\n"
"\n"
"    defkv [foo: 1, bar: 2]\n"
"\n"
"However, we can't invoke it as follows:\n"
"\n"
"    kv = [foo: 1, bar: 2]\n"
"    defkv kv\n"
"\n"
"This is because the macro is expecting its arguments to be a\n"
"keyword list at **compilation** time. Since in the example above\n"
"we are passing the representation of the variable `kv`, our\n"
"code fails.\n"
"\n"
"This is actually a common pitfall when developing macros. We are\n"
"assuming a particular shape in the macro. We can work around it\n"
"by unquoting the variable inside the quoted expression:\n"
"\n"
"    defmacro defkv(kv) do\n"
"      quote do\n"
"        Enum.each unquote(kv), fn {k, v} ->\n"
"          def unquote(k)(), do: unquote(v)\n"
"        end\n"
"      end\n"
"    end\n"
"\n"
"If you try to run our new macro, you will notice it won't\n"
"even compile, complaining that the variables `k` and `v`\n"
"do not exist. This is because of the ambiguity: `unquote(k)`\n"
"can either be an unquote fragment, as previously, or a regular\n"
"unquote as in `unquote(kv)`.\n"
"\n"
"One solution to this problem is to disable unquoting in the\n"
"macro, however, doing that would make it impossible to inject the\n"
"`kv` representation into the tree. That's when the `:bind_quoted`\n"
"option comes to the rescue (again!). By using `:bind_quoted`, we\n"
"can automatically disable unquoting while still injecting the\n"
"desired variables into the tree:\n"
"\n"
"    defmacro defkv(kv) do\n"
"      quote bind_quoted: [kv: kv] do\n"
"        Enum.each kv, fn {k, v} ->\n"
"          def unquote(k)(), do: unquote(v)\n"
"        end\n"
"      end\n"
"    end\n"
"\n"
"In fact, the `:bind_quoted` option is recommended every time\n"
"one desires to inject a value into the quote.\n"
msgstr ""
"任意の式の表現を取得します。\n"
"\n"
"## 例\n"
"\n"
"    iex> quote do\n"
"    ...>   sum(1, 2, 3)\n"
"    ...> end\n"
"    {:sum, [], [1, 2, 3]}\n"
"\n"
"## 説明\n"
"\n"
"任意のElixirコードは、Elixirのデータ構造を使って表現することができます。\n"
"Elixirマクロの構成要素は3要素タプルです。たとえば\n"
"\n"
"    {:sum, [], [1, 2, 3]}\n"
"\n"
"上のタプルは、引数1, 2, 3を渡した`sum`の関数呼び出しを表しています。\n"
"タプルの各要素は以下の通りです。\n"
"\n"
"  * タプルの第1要素は常にアトムか、同じ表現の別のタプルです。\n"
"\n"
"  * タプルの第2要素は、メタデータを表します。\n"
"\n"
"  * タプルの第3要素は、関数呼び出しの引数です。\n"
"    第3引数はアトムの場合もあります。これは通常、\n"
"    変数（またはローカル呼び出し）です。\n"
"\n"
"## オプション\n"
"\n"
"  * `:unquote` - `false`の場合、unquoteを無効にします。\n"
"    quoteの内側に別のquoteがあり、どのquoteでunquoteできるかを\n"
"    制御したい場合に便利です。\n"
"\n"
"  * `:location` -  `:keep`を設定した場合、quoteされた現在の行とファイルを\n"
"    保存します。詳細は、以下のスタックトレース情報セクションを参照してくださ"
"い。\n"
"\n"
"  * `:generated` - 指定したチャンクに生成済みのマークを付け、警告を発しないよ"
"うに\n"
"    します。現在のところ、これはスペシャルフォームに対してのみ機能します\n"
"    （たとえば、`case`には付けられますが、`if`には付けられません）。\n"
"\n"
"  * `:context` -  解決コンテキストをセットします。\n"
"\n"
"  * `:bind_quoted` - マクロにバインディングを渡します。\n"
"    バインディングが渡されると常に`unquote/1`が自動的に無効になります。\n"
"\n"
"## quoteリテラル\n"
"\n"
"上で説明したタプルの他に、Elixirにはquoteされると自分自身を返す\n"
"リテラルがいくつかあります。次のリテラルです。\n"
"\n"
"    :sum         #=> アトム\n"
"    1            #=> 整数\n"
"    2.0          #=> 浮動小数点数\n"
"    [1, 2]       #=> リスト\n"
"    \"strings\"    #=> 文字列\n"
"    {key, value} #=> 2要素タプル\n"
"\n"
"## quoteとマクロ\n"
"\n"
"`quote/2`はコード生成のためのマクロで一般的に用いられます。\n"
"演習として、数にそれ自身を乗算(2乗)するマクロを定義してみましょう。\n"
"このようなマクロを定義する理由はない（しかも、これは実際には悪い実践だと\n"
"思われます）ことに気を付けてください。\n"
"しかし、quoteとマクロの重要な側面に焦点をあてることができる簡単な例です。\n"
"\n"
"    defmodule Math do\n"
"      defmacro squared(x) do\n"
"        quote do\n"
"          unquote(x) * unquote(x)\n"
"        end\n"
"      end\n"
"    end\n"
"\n"
"これは以下のように実行できます。\n"
"\n"
"    import Math\n"
"    IO.puts \"Got #{squared(5)}\"\n"
"\n"
"最初は、この例では実際にそれがマクロであることを明かにするものは何も\n"
"ありません。しかし、コンパイル時に起こっていることは`squared(5)`が\n"
"`5 * 5`になるということです。引数`5`は生成されたコードに複製されます。\n"
"実はこのマクロにはバグがありますが、実際にこの振る舞いを見ることができます:\n"
"\n"
"    import Math\n"
"    my_number = fn ->\n"
"      IO.puts \"Returning 5\"\n"
"      5\n"
"    end\n"
"    IO.puts \"Got #{squared(my_number.())}\"\n"
"\n"
"上の例は次のように表示されます。\n"
"\n"
"    Returning 5\n"
"    Returning 5\n"
"    25\n"
"\n"
"”Returning 5\"が何故か1回ではなく2回表示されたことに注目してください。\n"
"これは、マクロは（通常の関数で期待する）値ではなく、式を受け取るためです。\n"
"この意味は\n"
"\n"
"    squared(my_number.())\n"
"\n"
"が、実際には次のように展開されるということです。\n"
"\n"
"    my_number.() * my_number.()\n"
"\n"
"マクロは関数を2回実行します。これが何故2回値が表示されたかの説明です。\n"
"実際、ほとんどの場合、これは想定外の振る舞いです。これが、マクロに関する\n"
"留意点の最初の1つが、**同じ値を何度もunquoteしない**ことである\n"
"理由です。\n"
"\n"
"マクロを修正しましょう:\n"
"\n"
"    defmodule Math do\n"
"      defmacro squared(x) do\n"
"        quote do\n"
"          x = unquote(x)\n"
"          x * x\n"
"        end\n"
"      end\n"
"    end\n"
"\n"
"今や前と同じように`square(my_number.())`を実行しても、値が表示されるのは\n"
"1回だけです。\n"
"\n"
"実際、このパターンはごく一般的なので、ほとんどの場合、\n"
"`quote/2`では`bind_quote`オプションを使うことになるでしょう。\n"
"\n"
"    defmodule Math do\n"
"      defmacro squared(x) do\n"
"        quote bind_quoted: [x: x] do\n"
"          x * x\n"
"        end\n"
"      end\n"
"    end\n"
"\n"
"`:bind_quoted`は上の例と同じコードに翻訳します。`:bind_quoted`は多くの\n"
"場合に使うことができ、良い実践だと考えられています。なぜなら、よくある\n"
"間違いを避けることができるだけでなく、後で説明されるunquoteフラグメントなど"
"の\n"
"マクロが提供するその他のツールを使うことができるからです。\n"
"\n"
"この短かい入門編を終える前に、次のことに気がつくでしょう。\n"
"変数`x`をquoteの内側で定義して\n"
"\n"
"    quote do\n"
"      x = unquote(x)\n"
"      x * x\n"
"    end\n"
"\n"
"以下を呼び出すと\n"
"\n"
"    import Math\n"
"    squared(5)\n"
"    x #=> ** (CompileError) undefined variable x or undefined function x/0\n"
"\n"
"`x`はユーザコンテキストに漏れないことが分ります。これは\n"
"Elixirマクロは健全（hygienic）だからです。これが次のセクションで\n"
"詳細に説明するトピックです。\n"
"\n"
"## 変数の健全性\n"
"\n"
"以下の例を考えてください:\n"
"\n"
"    defmodule Hygiene do\n"
"      defmacro no_interference do\n"
"        quote do: a = 1\n"
"      end\n"
"    end\n"
"\n"
"    require Hygiene\n"
"\n"
"    a = 10\n"
"    Hygiene.no_interference\n"
"    a #=> 10\n"
"\n"
"上の例で`a`は10を返します。明かにマクロはそれを1に設定していますが、\n"
"マクロの中で定義された変数はマクロが実行されているコンテキストには影響を\n"
"及ぼしません。呼び出し側のコンテキストで変数を設定あるいは取得したい\n"
"場合は、`var!`マクロを使って行うことができます。\n"
"\n"
"    defmodule NoHygiene do\n"
"      defmacro interference do\n"
"        quote do: var!(a) = 1\n"
"      end\n"
"    end\n"
"\n"
"    require NoHygiene\n"
"\n"
"    a = 10\n"
"    NoHygiene.interference\n"
"    a #=> 1\n"
"\n"
"明示的にコンテキストを与えない限り、同じモジュールで定義された変数にさえ\n"
"アクセスできないことに注意してください。\n"
"\n"
"    defmodule Hygiene do\n"
"      defmacro write do\n"
"        quote do\n"
"          a = 1\n"
"        end\n"
"      end\n"
"\n"
"      defmacro read do\n"
"        quote do\n"
"          a\n"
"        end\n"
"      end\n"
"    end\n"
"\n"
"    Hygiene.write\n"
"    Hygiene.read\n"
"    #=> ** (RuntimeError) undefined variable a or undefined function a/0\n"
"\n"
"この場合、引数として現在のモジュールのスコープを明示的に渡す\n"
"ことができます。\n"
"\n"
"    defmodule ContextHygiene do\n"
"      defmacro write do\n"
"        quote do\n"
"          var!(a, ContextHygiene) = 1\n"
"        end\n"
"      end\n"
"\n"
"      defmacro read do\n"
"        quote do\n"
"          var!(a, ContextHygiene)\n"
"        end\n"
"      end\n"
"    end\n"
"\n"
"    ContextHygiene.write\n"
"    ContextHygiene.read\n"
"    #=> 1\n"
"\n"
"## エイリアスの健全性\n"
"\n"
"quote内のエイリアスはデフォルトで健全です。\n"
"下の例を考えてください:\n"
"\n"
"    defmodule Hygiene do\n"
"      alias Map, as: M\n"
"\n"
"      defmacro no_interference do\n"
"        quote do\n"
"          M.new\n"
"        end\n"
"      end\n"
"    end\n"
"\n"
"    require Hygiene\n"
"    Hygiene.no_interference #=> %{}\n"
"\n"
"たとえマクロが展開されるコンテキストでエイリアス`M`が利用できなくても、\n"
"以前として`M`は`Map`に展開されるので、上のコードは動くことに注意して\n"
"ください。\n"
"\n"
"同様に、たとえマクロを起動する前に同じ名前でエイリアスを定義しても、\n"
"マクロの結果には影響を与えません。\n"
"\n"
"    defmodule Hygiene do\n"
"      alias Map, as: M\n"
"\n"
"      defmacro no_interference do\n"
"        quote do: M.new\n"
"      end\n"
"    end\n"
"\n"
"    require Hygiene\n"
"    alias SomethingElse, as: M\n"
"    Hygiene.no_interference #=> %{}\n"
"\n"
"呼び出し側で定義したエイリアスやモジュールにアクセスしたい場合もあるでしょ"
"う。\n"
"その場合は、`alias!`マクロを使うことができます。\n"
"\n"
"    defmodule Hygiene do\n"
"      # これは、Elixir.Nested.helloに展開される\n"
"      defmacro no_interference do\n"
"        quote do: Nested.hello\n"
"      end\n"
"\n"
"      # 呼び出し側のNestedがなんであろうと\n"
"      # これはNested.helloに展開される\n"
"      defmacro interference do\n"
"        quote do: alias!(Nested).hello\n"
"      end\n"
"    end\n"
"\n"
"    defmodule Parent do\n"
"      defmodule Nested do\n"
"        def hello, do: \"world\"\n"
"      end\n"
"\n"
"      require Hygiene\n"
"      Hygiene.no_interference\n"
"      #=> ** (UndefinedFunctionError) ...\n"
"\n"
"      Hygiene.interference\n"
"      #=> \"world\"\n"
"    end\n"
"\n"
"## importの健全性\n"
"\n"
"エイリアス同様、Elixirのimportは健全です。以下のコードを\n"
"考えてください。\n"
"\n"
"    defmodule Hygiene do\n"
"      defmacrop get_length do\n"
"        quote do\n"
"          length([1,2,3])\n"
"        end\n"
"      end\n"
"\n"
"      def return_length do\n"
"        import Kernel, except: [length: 1]\n"
"        get_length\n"
"      end\n"
"    end\n"
"\n"
"    Hygiene.return_length #=> 3\n"
"\n"
"`Kernel.length/1`関数がインポートされていないのに、何故\n"
"`Hygiene.return_length/0`が`3`を返すかに注目してください。\n"
"実際、`return_length/0`が他のモジュールから名前とアリティが同じ\n"
"関数をインポートしたとしても、関数の結果には影響を与えません。\n"
"\n"
"    def return_length do\n"
"      import String, only: [length: 1]\n"
"      get_length\n"
"    end\n"
"\n"
"この新しい`return_length/0`を呼び出しても、依然として結果は`3`を返します。\n"
"\n"
"Elixirは賢いので、可能な限り最新の瞬間まで解決を遅らせます。\n"
"それで、quoteの内部で`length([1, 2, 3])`を呼び出したが\n"
"利用できる`length/1`関数がない場合、呼び出し側で展開されます。\n"
"\n"
"    defmodule Lazy do\n"
"      defmacrop get_length do\n"
"        import Kernel, except: [length: 1]\n"
"\n"
"        quote do\n"
"          length(\"hello\")\n"
"        end\n"
"      end\n"
"\n"
"      def return_length do\n"
"        import Kernel, except: [length: 1]\n"
"        import String, only: [length: 1]\n"
"        get_length\n"
"      end\n"
"    end\n"
"\n"
"    Lazy.return_size #=> 5\n"
"\n"
"## スタックトレース情報\n"
"\n"
"マクロによって関数を定義する際、実行時エラーを呼び出し側でレポートするか、\n"
"quoteの内部でレポートするかを選択するオプションがあります。例をみましょう。\n"
"\n"
"    # adder.ex\n"
"    defmodule Adder do\n"
"      @doc \"Defines a function that adds two numbers\"\n"
"      defmacro defadd do\n"
"        quote location: :keep do\n"
"          def add(a, b), do: a + b\n"
"        end\n"
"      end\n"
"    end\n"
"\n"
"    # sample.ex\n"
"    defmodule Sample do\n"
"      import Adder\n"
"      defadd\n"
"    end\n"
"\n"
"    require Sample\n"
"    Sample.add(:one, :two)\n"
"    #=> ** (ArithmeticError) bad argument in arithmetic expression\n"
"    #=>     adder.ex:5: Sample.add/2\n"
"\n"
"`location: :keep`を指定すると、`Sample.add/2`に無効な引数を与えた場合、\n"
"スタックトレース情報はquoteの内部のファイルと行を示します。 \n"
"`location: :keep`を指定しないと、エラーは`defadd`が起動された場所に\n"
"報告されます。`location: keep`は、quote内の定義にのみ影響を及ぼすことに\n"
"注意してください。\n"
"\n"
"## 束縛とunquoteフラグメント\n"
"\n"
"Elixirのquote/unquote機構はunquoteフラグメントと呼ばれる機能を提供します。\n"
"unquoteフラグメントはその場で関数を生成する簡単な方法を提供します。\n"
"この例を考えてください。\n"
"\n"
"    kv = [foo: 1, bar: 2]\n"
"    Enum.each kv, fn {k, v} ->\n"
"      def unquote(k)(), do: unquote(v)\n"
"    end\n"
"\n"
"上の例では、関数`foo/0`と`bar/0`を動的に生成しました。\n"
"今、この機能をマクロに変換したい場合を想像してください。\n"
"\n"
"    defmacro defkv(kv) do\n"
"      Enum.map kv, fn {k, v} ->\n"
"        quote do\n"
"          def unquote(k)(), do: unquote(v)\n"
"        end\n"
"      end\n"
"    end\n"
"\n"
"このマクロは次のように呼び出すことができます。\n"
"\n"
"    defkv [foo: 1, bar: 2]\n"
"\n"
"しかし、次のようには呼び出すことができません:\n"
"\n"
"    kv = [foo: 1, bar: 2]\n"
"    defkv kv\n"
"\n"
"これは、マクロは引数がコンパイル時にキーワードリストであることを\n"
"想定しているからです。上の例では変数`kv`の表現を渡しているので、\n"
"コードは失敗します。\n"
"\n"
"これは実際、マクロを開発する際のよくある落とし穴です。マクロには\n"
"特定の形を想定します。quoteされた式の中では変数をunquoteすることで\n"
"この問題を避けることができます。\n"
"\n"
"    defmacro defkv(kv) do\n"
"      quote do\n"
"        Enum.each unquote(kv), fn {k, v} ->\n"
"          def unquote(k)(), do: unquote(v)\n"
"        end\n"
"      end\n"
"    end\n"
"\n"
"この新しいマクロを実行しようとすると、変数`k`と`v`が存在しない旨のエラーにな"
"り、\n"
"コンパイルさえできないことに気付くでしょう。これは曖昧さのためです。すなわ"
"ち、\n"
"`unquote(k)`は、以前のようなunquoteフラグメントの可能性と、`unquote(kv)`の\n"
"ような標準的なunquoteの可能性があるからです。\n"
"\n"
"この問題の一つの解決法は、マクロでのunquoteを無効にすることですが、\n"
"これではツリーの中に`kv`表現を注入することができません。ここは、\n"
"`:bind_quote`オプションが（再び）救出に現れる時です。\n"
"`:bind_quoted`を使うことにより、自動的にunquoteを無効にする一方で、\n"
"ツリーに望み通りの変数を注入することができます。\n"
"\n"
"    defmacro defkv(kv) do\n"
"      quote bind_quoted: [kv: kv] do\n"
"        Enum.each kv, fn {k, v} ->\n"
"          def unquote(k)(), do: unquote(v)\n"
"        end\n"
"      end\n"
"    end\n"
"\n"
"実際のところ、quoteに値を注入したい場合は常に`:bind_quoted`オプションを\n"
"使用することを推奨します。\n"

#. TRANSLATORS: defmacro Kernel.SpecialForms.import(module, opts)
#: lib/kernel/special_forms.ex:515
msgid ""
"Imports functions and macros from other modules.\n"
"\n"
"`import/2` allows one to easily access functions or macros from\n"
"others modules without using the qualified name.\n"
"\n"
"## Examples\n"
"\n"
"If you are using several functions from a given module, you can\n"
"import those functions and reference them as local functions,\n"
"for example:\n"
"\n"
"    iex> import List\n"
"    iex> flatten([1, [2], 3])\n"
"    [1, 2, 3]\n"
"\n"
"## Selector\n"
"\n"
"By default, Elixir imports functions and macros from the given\n"
"module, except the ones starting with underscore (which are\n"
"usually callbacks):\n"
"\n"
"    import List\n"
"\n"
"A developer can filter to import only macros or functions via\n"
"the only option:\n"
"\n"
"    import List, only: :functions\n"
"    import List, only: :macros\n"
"\n"
"Alternatively, Elixir allows a developer to pass pairs of\n"
"name/arities to `:only` or `:except` as a fine grained control\n"
"on what to import (or not):\n"
"\n"
"    import List, only: [flatten: 1]\n"
"    import String, except: [split: 2]\n"
"\n"
"Notice that calling `except` for a previously declared `import/2`\n"
"simply filters the previously imported elements. For example:\n"
"\n"
"    import List, only: [flatten: 1, keyfind: 4]\n"
"    import List, except: [flatten: 1]\n"
"\n"
"After the two import calls above, only `List.keyfind/4` will be\n"
"imported.\n"
"\n"
"## Underscore functions\n"
"\n"
"By default functions starting with `_` are not imported. If you really want\n"
"to import a function starting with `_` you must explicitly include it in "
"the\n"
"`:only` selector.\n"
"\n"
"    import File.Stream, only: [__build__: 3]\n"
"\n"
"## Lexical scope\n"
"\n"
"It is important to notice that `import/2` is lexical. This means you\n"
"can import specific macros inside specific functions:\n"
"\n"
"    defmodule Math do\n"
"      def some_function do\n"
"        # 1) Disable \"if/2\" from Kernel\n"
"        import Kernel, except: [if: 2]\n"
"\n"
"        # 2) Require the new \"if/2\" macro from MyMacros\n"
"        import MyMacros\n"
"\n"
"        # 3) Use the new macro\n"
"        if do_something, it_works\n"
"      end\n"
"    end\n"
"\n"
"In the example above, we imported macros from `MyMacros`,\n"
"replacing the original `if/2` implementation by our own\n"
"within that specific function. All other functions in that\n"
"module will still be able to use the original one.\n"
"\n"
"## Warnings\n"
"\n"
"If you import a module and you don't use any of the imported\n"
"functions or macros from this module, Elixir is going to issue\n"
"a warning implying the import is not being used.\n"
"\n"
"In case the import is generated automatically by a macro,\n"
"Elixir won't emit any warnings though, since the import\n"
"was not explicitly defined.\n"
"\n"
"Both warning behaviours could be changed by explicitly\n"
"setting the `:warn` option to `true` or `false`.\n"
"\n"
"## Ambiguous function/macro names\n"
"\n"
"If two modules `A` and `B` are imported and they both contain\n"
"a `foo` function with an arity of `1`, an error is only emitted\n"
"if an ambiguous call to `foo/1` is actually made; that is, the\n"
"errors are emitted lazily, not eagerly.\n"
msgstr ""
"他のモジュールから関数とマクロをインポートします。\n"
"\n"
"`import/2`を使うことで、完全修飾名を使わずに、他のモジュールの\n"
"関数やマクロに容易にアクセスできます。\n"
"\n"
"## 例\n"
"\n"
"指定したモジュールの関数をいくつか使う場合、それらの関数を\n"
"インポートしてローカル関数として参照することができます。たとえば、\n"
"\n"
"    iex> import List\n"
"    iex> flatten([1, [2], 3])\n"
"    [1,2,3]\n"
"\n"
"## セレクタ\n"
"\n"
"デフォルトでは、Elixirは指定したモジュールの、アンダースコアで始まるもの\n"
"（これは通常コールバックです）を除く、すべての関数とマクロをインポートしま"
"す。\n"
"\n"
"    import List\n"
"\n"
"onlyオプションを使うことにより、マクロだけ、あるいは関数だけを\n"
"インポートすることができます。\n"
"\n"
"    import List, only: :functions\n"
"    import List, only: :macros\n"
"\n"
"さらに、`:only`または`:except`オプションに名前とアリティのペアを\n"
"渡すことにより、何をインポートするか（または、しないか）を\n"
"きめ細かく制御できます。\n"
"\n"
"    import List, only: [flatten: 1]\n"
"    import String, except: [split: 2]\n"
"\n"
"先に`import`宣言された要素に対して`except`を呼ぶと、先にインポートされた\n"
"要素がフィルタリングされることに注意してください。たとえば\n"
"\n"
"    import List, only: [flatten: 1, keyfind: 3]\n"
"    import List, except: [flatten: 1]\n"
"\n"
"上のように2つのimportを呼び出すと、`List.keyfind/3`だけがインポートされま"
"す。\n"
"\n"
"## アンダースコア関数\n"
"\n"
"デフォルトでは`_`で始まる関数はインポートされません。\n"
"実際に`_`で始まる関数をインポートしたい場合は、`:only`セレクタで\n"
"明示的に指定する必要があります。\n"
"\n"
"    import File.Stream, only: [__build__: 3]\n"
"\n"
"## レキシカルスコープ\n"
"\n"
"`import/2`はレキシカルスコープであることに注意が必要です。\n"
"これは特定の関数の中に特定のマクロをインポートできることを\n"
"意味します。\n"
"\n"
"    defmodule Math do\n"
"      def some_function do\n"
"        # 1) Kernelモジュールの”if/2”を無効化\n"
"        import Kernel, except: [if: 2]\n"
"\n"
"        # 2) MyMacrosの新しい”if/2”マクロをインポート\n"
"        import MyMacros\n"
"\n"
"        # 3) 新しいマクロを使用\n"
"        if do_something, it_works\n"
"      end\n"
"    end\n"
"\n"
"上の例では、`MyMacros`からマクロをインポートし、\n"
"特定の関数の範囲内で、オリジナルの`if/2`実装を`MyMacros`の実装で\n"
"置き換えました。このモジュールの他のすべての関数は依然として\n"
"オリジナルの`if/2`実装を使うことができます。\n"
"\n"
"## 警告\n"
"\n"
"モジュールをインポートして、このモジュールからインポートした\n"
"関数またはマクロを1つも使わないと、Elixirは、インポートが\n"
"使われていないことを意味する警告を発します。\n"
"\n"
"インポートがマクロにより自動的に生成された場合は、Elixirは警告を\n"
"発しません。インポートが明示的に定義されていないからです。\n"
"\n"
"これら2つの警告のふるまいは、`:warn`オプションを`true`\n"
"または`false`に明示的に設定することにより変更できます。\n"
"\n"
"## 曖昧な関数名/マクロ名\n"
"\n"
"2つのモジュール`A`と`B`がインポートされ、両モジュールとも\n"
"アリティ1の`foo`関数を含んでいる場合は、曖昧な`foo/1`への\n"
"呼び出しが実際に行われた場合にのみエラーが発生します。\n"
"すなわち、エラーは先行評価ではなく遅延評価で発生されます。\n"

#. TRANSLATORS: defmacro Kernel.SpecialForms.unquote(expr)
#: lib/kernel/special_forms.ex:1183
msgid ""
"Unquotes the given expression from inside a macro.\n"
"\n"
"## Examples\n"
"\n"
"Imagine the situation you have a variable `value` and\n"
"you want to inject it inside some quote. The first attempt\n"
"would be:\n"
"\n"
"    value = 13\n"
"    quote do\n"
"      sum(1, value, 3)\n"
"    end\n"
"\n"
"Which would then return:\n"
"\n"
"    {:sum, [], [1, {:value, [], quoted}, 3]}\n"
"\n"
"Which is not the expected result. For this, we use unquote:\n"
"\n"
"    iex> value = 13\n"
"    iex> quote do\n"
"    ...>   sum(1, unquote(value), 3)\n"
"    ...> end\n"
"    {:sum, [], [1, 13, 3]}\n"
"\n"
msgstr ""
"マクロの内側で指定した式をunquoteします。\n"
"\n"
"## 例\n"
"\n"
"変数`value`があり、それをquoteの内側に注入したいとします。\n"
"最初の試みは以下のようになるでしょう。\n"
"\n"
"    value = 13\n"
"    quote do\n"
"      sum(1, value, 3)\n"
"    end\n"
"\n"
"これは以下を返します。\n"
"\n"
"    {:sum, [], [1, {:value, [], quoted}, 3]}\n"
"\n"
"これは期待した結果ではありません。そのため、unquoteを使います。\n"
"\n"
"    iex> value = 13\n"
"    iex> quote do\n"
"    ...>   sum(1, unquote(value), 3)\n"
"    ...> end\n"
"    {:sum, [], [1, 13, 3]}\n"
"\n"

#. TRANSLATORS: defmacro Kernel.SpecialForms.for(args)
#: lib/kernel/special_forms.ex:1227
msgid ""
"Comprehensions allow you to quickly build a data structure from\n"
"an enumerable or a bitstring.\n"
"\n"
"Let's start with an example:\n"
"\n"
"    iex> for n <- [1, 2, 3, 4], do: n * 2\n"
"    [2, 4, 6, 8]\n"
"\n"
"A comprehension accepts many generators and filters. Enumerable\n"
"generators are defined using `<-`:\n"
"\n"
"    # A list generator:\n"
"    iex> for n <- [1, 2, 3, 4], do: n * 2\n"
"    [2, 4, 6, 8]\n"
"\n"
"    # A comprehension with two generators\n"
"    iex> for x <- [1, 2], y <- [2, 3], do: x * y\n"
"    [2, 3, 4, 6]\n"
"\n"
"Filters can also be given:\n"
"\n"
"    # A comprehension with a generator and a filter\n"
"    iex> for n <- [1, 2, 3, 4, 5, 6], rem(n, 2) == 0, do: n\n"
"    [2, 4, 6]\n"
"\n"
"Note generators can also be used to filter as it removes any value\n"
"that doesn't match the pattern on the left side of `<-`:\n"
"\n"
"    iex> users = [user: \"john\", admin: \"meg\", guest: \"barbara\"]\n"
"    iex> for {type, name} when type != :guest <- users do\n"
"    ...>   String.upcase(name)\n"
"    ...> end\n"
"    [\"JOHN\", \"MEG\"]\n"
"\n"
"Bitstring generators are also supported and are very useful when you\n"
"need to organize bitstring streams:\n"
"\n"
"    iex> pixels = <<213, 45, 132, 64, 76, 32, 76, 0, 0, 234, 32, 15>>\n"
"    iex> for <<r::8, g::8, b::8 <- pixels>>, do: {r, g, b}\n"
"    [{213, 45, 132}, {64, 76, 32}, {76, 0, 0}, {234, 32, 15}]\n"
"\n"
"Variable assignments inside the comprehension, be it in generators,\n"
"filters or inside the block, are not reflected outside of the\n"
"comprehension.\n"
"\n"
"## Into\n"
"\n"
"In the examples above, the result returned by the comprehension was\n"
"always a list. The returned result can be configured by passing an\n"
"`:into` option, that accepts any structure as long as it implements\n"
"the `Collectable` protocol.\n"
"\n"
"For example, we can use bitstring generators with the `:into` option\n"
"to easily remove all spaces in a string:\n"
"\n"
"    iex> for <<c <- \" hello world \">>, c != ?\\s, into: \"\", do: <<c>>\n"
"    \"helloworld\"\n"
"\n"
"The `IO` module provides streams, that are both `Enumerable` and\n"
"`Collectable`, here is an upcase echo server using comprehensions:\n"
"\n"
"    for line <- IO.stream(:stdio, :line), into: IO.stream(:stdio, :line) do\n"
"      String.upcase(line)\n"
"    end\n"
"\n"
msgstr ""
"内包表記を使うと、enumerableやbitstringから素早くデータ構造を\n"
"構築することができます。\n"
"\n"
"例から始めてみましょう。\n"
"\n"
"    iex> for n <- [1, 2, 3, 4], do: n * 2\n"
"    [2, 4, 6, 8]\n"
"\n"
"内包表記は多くのジェネレータとフィルタを受け付けます。\n"
"enumerableジェネレータは`<-`を使って定義されます。\n"
"\n"
"    # リストジェネレータ:\n"
"    iex> for n <- [1, 2, 3, 4], do: n * 2\n"
"    [2, 4, 6, 8]\n"
"\n"
"    # 2つのジェネレータを持つ内包表記\n"
"    iex> for x <- [1, 2], y <- [2, 3], do: x*y\n"
"    [2, 3, 4, 6]\n"
"\n"
"フィルタを与えることもできます。\n"
"\n"
"    # ジェネレータとフィルタを持つ内包表記\n"
"    iex> for n <- [1, 2, 3, 4, 5, 6], rem(n, 2) == 0, do: n\n"
"    [2, 4, 6]\n"
"\n"
"ジェネレータは、`<-`の左辺のパターンにマッチしない値をすべて削除するので、\n"
"フィルタとしても使えることに注意してください。\n"
"\n"
"    iex> users = [user: \"john\", admin: \"meg\", guest: \"barbara\"]\n"
"    iex> for {type, name} when type != :guest <- users do\n"
"    ...>   String.upcase(name)\n"
"    ...> end\n"
"    [\"JOHN\", \"MEG\"]\n"
"\n"
"bitstringジェネレータもサポートされており、bitstringストリームを\n"
"組織化する必要がある場合に非常に便利です。\n"
"\n"
"    iex> pixels = <<213, 45, 132, 64, 76, 32, 76, 0, 0, 234, 32, 15>>\n"
"    iex> for <<r::8, g::8, b::8 <- pixels >>, do: {r, g, b}\n"
"    [{213, 45, 132}, {64, 76, 32}, {76, 0, 0}, {234, 32, 15}]\n"
"\n"
"内包表記の内側の変数代入は、ジェネレータ、フィルタとブロックの内側では\n"
"有効ですが、内包表記の外側には反映されません。\n"
"\n"
"## Into\n"
"\n"
"上の例では、内包表記が返す結果は常にリストでした。返り値は\n"
"`:into`オプションを渡すことにより構成することができます。\n"
"`:into`オプションは、`Collectable`プロトコルを実装する任意の\n"
"構造を受け付けます。\n"
"\n"
"たとえば、`:into`オプション付きのbitstringジェネレータを使うこにより、\n"
"文字列からすべての空白を簡単に削除できます。\n"
"\n"
"    iex> for <<c <- \" hello world \">>, c != ?\\s, into: \"\", do: <<c>>\n"
"    \"helloworld\"\n"
"\n"
"`IO`モジュールは`Enumerable`と`Collectable`の両プロトコルを実装する\n"
"ストリームを提供します。以下は、内包表記を使った大文字化エコーサーバです:\n"
"\n"
"    for line <- IO.stream(:stdio, :line), into: IO.stream(:stdio, :line) do\n"
"      String.upcase(line)\n"
"    end\n"
"\n"

#. TRANSLATORS: defmacro Kernel.SpecialForms.{}(args)
#: lib/kernel/special_forms.ex:27
msgid ""
"Creates a tuple.\n"
"\n"
"More information about the tuple data type and about functions to "
"manipulate\n"
"tuples can be found in the `Tuple` module; some functions for working with\n"
"tuples are also available in `Kernel` (such as `Kernel.elem/2` or\n"
"`Kernel.tuple_size/1`).\n"
"\n"
"## AST representation\n"
"\n"
"Only two-item tuples are considered literals in Elixir and return "
"themselves\n"
"when quoted. Therefore, all other tuples are represented in the AST as calls "
"to\n"
"the `:{}` special form.\n"
"\n"
"    iex> quote do\n"
"    ...>   {1, 2}\n"
"    ...> end\n"
"    {1, 2}\n"
"\n"
"    iex> quote do\n"
"    ...>   {1, 2, 3}\n"
"    ...> end\n"
"    {:{}, [], [1, 2, 3]}\n"
"\n"
msgstr ""
"タプルを作成します。\n"
"\n"
"タブルデータ型とタプルを操作する関数に関する情報は`Tuple`モジュールを\n"
"参照してください。`Kernel`モジュールにもタプルを扱う関数があります\n"
"（`Kernel.elem/2`や`Kernel.tuple_size/1`など）\n"
"\n"
"## AST表現\n"
"\n"
"Elixirでは2要素タプルだけがリテラルだとみなされ、quoteした際に、\n"
"それ自身が返されます。それゆえ、その他のすべてのタプルは、ASTでは\n"
"スペシャルフォーム`:{}`への呼び出しとして表現されます。\n"
"\n"
"    iex> quote do\n"
"    ...>   {1, 2}\n"
"    ...> end\n"
"    {1, 2}\n"
"\n"
"    iex> quote do\n"
"    ...>   {1, 2, 3}\n"
"    ...> end\n"
"    {:{}, [], [1, 2, 3]}\n"
"\n"

#. TRANSLATORS: defmacro Kernel.SpecialForms.__aliases__(args)
#: lib/kernel/special_forms.ex:1452
msgid ""
"Internal special form to hold aliases information.\n"
"\n"
"It is usually compiled to an atom:\n"
"\n"
"    iex> quote do\n"
"    ...>   Foo.Bar\n"
"    ...> end\n"
"    {:__aliases__, [alias: false], [:Foo, :Bar]}\n"
"\n"
"Elixir represents `Foo.Bar` as `__aliases__` so calls can be\n"
"unambiguously identified by the operator `:.`. For example:\n"
"\n"
"    iex> quote do\n"
"    ...>   Foo.bar\n"
"    ...> end\n"
"    {{:., [], [{:__aliases__, [alias: false], [:Foo]}, :bar]}, [], []}\n"
"\n"
"Whenever an expression iterator sees a `:.` as the tuple key,\n"
"it can be sure that it represents a call and the second argument\n"
"in the list is an atom.\n"
"\n"
"On the other hand, aliases holds some properties:\n"
"\n"
"  1. The head element of aliases can be any term that must expand to\n"
"     an atom at compilation time.\n"
"\n"
"  2. The tail elements of aliases are guaranteed to always be atoms.\n"
"\n"
"  3. When the head element of aliases is the atom `:Elixir`, no expansion "
"happens.\n"
"\n"
msgstr ""
"エイリアス情報を保持する内部スペシャルフォームです。\n"
"\n"
"通常、アトムにコンパイルされます。\n"
"\n"
"    iex> quote do\n"
"    ...>   Foo.Bar\n"
"    ...> end\n"
"    {:__aliases__, [alias: false], [:Foo, :Bar]}\n"
"\n"
"Eilxirは`Foo.Bar`を`__aliases__`で表現します。そのため、呼び出しを\n"
"`:.`オペレータで明確に識別することができます。たとえば、\n"
"\n"
"    iex> quote do\n"
"    ...>   Foo.bar\n"
"    ...> end\n"
"    {{:., [], [{:__aliases__, [alias: false], [:Foo]}, :bar]}, [], []}\n"
"\n"
"式イテレータがタプルのキーとして`:.`を見付けた時は常に、\n"
"それが呼び出しを表しており、リストの第2引数がアトムであることを\n"
"確信できます。\n"
"\n"
"一方、aliasはいくつかのプロパティを保持します。\n"
"\n"
"  1. aliasのhead要素はコンパイル時にアトムに展開される任意の項です。￥\n"
"\n"
"  2. aliasのtail要素は常にアトムであることが保証されます。\n"
"\n"
"  3. aliasのhead要素がアトム`:Elixir`である場合は、展開はされません。\n"
"\n"

#. TRANSLATORS: defmacro Kernel.SpecialForms..(left, right)
#: lib/kernel/special_forms.ex:318
msgid ""
"Defines a remote call or an alias.\n"
"\n"
"The dot (`.`) in Elixir can be used for remote calls:\n"
"\n"
"    iex> String.downcase(\"FOO\")\n"
"    \"foo\"\n"
"\n"
"In this example above, we have used `.` to invoke `downcase` in the\n"
"`String` alias, passing \"FOO\" as argument. We can also use the dot\n"
"for creating aliases:\n"
"\n"
"    iex> Hello.World\n"
"    Hello.World\n"
"\n"
"This time, we have joined two aliases, defining the final alias\n"
"`Hello.World`.\n"
"\n"
"## Syntax\n"
"\n"
"The right side of `.` may be a word starting in upcase, which represents\n"
"an alias, a word starting with lowercase or underscore, any valid language\n"
"operator or any name wrapped in single- or double-quotes. Those are all "
"valid\n"
"examples:\n"
"\n"
"    iex> Kernel.Sample\n"
"    Kernel.Sample\n"
"\n"
"    iex> Kernel.length([1, 2, 3])\n"
"    3\n"
"\n"
"    iex> Kernel.+(1, 2)\n"
"    3\n"
"\n"
"    iex> Kernel.\"length\"([1, 2, 3])\n"
"    3\n"
"\n"
"    iex> Kernel.'+'(1, 2)\n"
"    3\n"
"\n"
"Note that `Kernel.\"FUNCTION_NAME\"` will be treated as a remote call and "
"not an alias.\n"
"This choice was done so every time single- or double-quotes are used, we "
"have\n"
"a remote call regardless of the quote contents. This decision is also "
"reflected\n"
"in the quoted expressions discussed below.\n"
"\n"
"## Quoted expression\n"
"\n"
"When `.` is used, the quoted expression may take two distinct\n"
"forms. When the right side starts with a lowercase letter (or\n"
"underscore):\n"
"\n"
"    iex> quote do\n"
"    ...>   String.downcase(\"FOO\")\n"
"    ...> end\n"
"    {{:., [], [{:__aliases__, [alias: false], [:String]}, :downcase]}, [], "
"[\"FOO\"]}\n"
"\n"
"Notice we have an inner tuple, containing the atom `:.` representing\n"
"the dot as first element:\n"
"\n"
"    {:., [], [{:__aliases__, [alias: false], [:String]}, :downcase]}\n"
"\n"
"This tuple follows the general quoted expression structure in Elixir,\n"
"with the name as first argument, some keyword list as metadata as second,\n"
"and the number of arguments as third. In this case, the arguments is the\n"
"alias `String` and the atom `:downcase`. The second argument is **always**\n"
"an atom:\n"
"\n"
"    iex> quote do\n"
"    ...>   String.\"downcase\"(\"FOO\")\n"
"    ...> end\n"
"    {{:., [], [{:__aliases__, [alias: false], [:String]}, :downcase]}, [], "
"[\"FOO\"]}\n"
"\n"
"The tuple containing `:.` is wrapped in another tuple, which actually\n"
"represents the function call, and has `\"FOO\"` as argument.\n"
"\n"
"When the right side is an alias (i.e. starts with uppercase), we get "
"instead:\n"
"\n"
"    iex> quote do\n"
"    ...>   Hello.World\n"
"    ...> end\n"
"    {:__aliases__, [alias: false], [:Hello, :World]}\n"
"\n"
"We go into more details about aliases in the `__aliases__/1` special form\n"
"documentation.\n"
"\n"
"## Unquoting\n"
"\n"
"We can also use unquote to generate a remote call in a quoted expression:\n"
"\n"
"    iex> x = :downcase\n"
"    iex> quote do\n"
"    ...>   String.unquote(x)(\"FOO\")\n"
"    ...> end\n"
"    {{:., [], [{:__aliases__, [alias: false], [:String]}, :downcase]}, [], "
"[\"FOO\"]}\n"
"\n"
"Similar to `Kernel.\"FUNCTION_NAME\"`, `unquote(x)` will always generate a "
"remote call,\n"
"independent of the value of `x`. To generate an alias via the quoted "
"expression,\n"
"one needs to rely on `Module.concat/2`:\n"
"\n"
"    iex> x = Sample\n"
"    iex> quote do\n"
"    ...>   Module.concat(String, unquote(x))\n"
"    ...> end\n"
"    {{:., [], [{:__aliases__, [alias: false], [:Module]}, :concat]}, [],\n"
"     [{:__aliases__, [alias: false], [:String]}, Sample]}\n"
"\n"
msgstr ""
"リモート呼び出し、または、エイリアスを定義します。\n"
"\n"
"Elixirでは、ドット(`.`)はリモート呼び出しに使うことができます。\n"
"\n"
"    iex> String.downcase(\"FOO\")\n"
"    \"foo\"\n"
"\n"
"上の例では、`String`エイリアスの`downcase`に引数\"FOO\"を渡して起動するため"
"に\n"
"`.`を使用しました。ドットはエイリアスの作成にも使うことができます。\n"
"\n"
"    iex> Hello.World\n"
"    Hello.World\n"
"\n"
"今回は、2つのエイリアスを結合して、最終的にエイリアス`Hello.World`を\n"
"定義しました。\n"
"\n"
"## 構文\n"
"\n"
"`.`の右辺には、大文字で始まる単語（これはエイリアスを表します）、小文字\n"
"またはアンダースコアで始まる小文字の単語、任意の有効なこの言語の演算子、\n"
"一重または二重引用符に囲まれた任意の名前を指定できます。以下はすべて\n"
"有効な例です。\n"
"\n"
"    iex> Kernel.Sample\n"
"    Kernel.Sample\n"
"\n"
"    iex> Kernel.length([1, 2, 3])\n"
"    3\n"
"\n"
"    iex> Kernel.+(1, 2)\n"
"    3\n"
"\n"
"    iex> Kernel.\"length\"([1, 2, 3])\n"
"    3\n"
"\n"
"    iex> Kernel.'+'(1, 2)\n"
"    3\n"
"\n"
"`Kernel.\"FUNCTION_NAME\"`は、エイリアスではなく、リモート呼び出しとして\n"
"扱われることに注意してください。この選択をしたので、一重または二重引用符が\n"
"使われた時は、引用された内容に関係なく、常にリモート呼び出しをします。\n"
"この決定は、以下で考察するquoteされた式についても反映されます。\n"
"\n"
"## quoteされた式\n"
"\n"
"`.`が使われた場合、quoteされた式は2つの異なるフォームをとる可能性がありま"
"す。\n"
"右辺が小文字(またはアンダースコア)で始まる場合、\n"
"\n"
"    iex> quote do\n"
"    ...>   String.downcase(\"FOO\")\n"
"    ...> end\n"
"    {{:., [], [{:__aliases__, [alias: false], [:String]}, :downcase]}, [], "
"[\"FOO\"]}\n"
"\n"
"最初の要素としてドットを表すアトム`:.`を含む内部のタプルを持つことに、\n"
"注目してください:\n"
"\n"
"    {:., [], [{:__aliases__, [alias: false], [:String]}, :downcase]}\n"
"\n"
"このタプルは、Elixirの一般的なquoteされた式の構造に従っています。\n"
"すなわち、第1要素が名前、第2要素がメタデータであるキーワードリスト、\n"
"第3要素が引数です。この例では、引数はエイリアス`String`と\n"
"アトム`:downcase`です。2番目の引数は **常に** アトムです:\n"
"\n"
"    iex> quote do\n"
"    ...>   String.\"downcase\"(\"FOO\")\n"
"    ...> end\n"
"    {{:., [], [{:__aliases__, [alias: false], [:String]}, :downcase]}, [], "
"[\"FOO\"]}\n"
"\n"
"`:.`を含むタプルはもう一つのタプルに囲まれます。実は、これは関数呼びだしを\n"
"意味しており、引数`\"FOO\"`を持ちます。\n"
"\n"
"右辺がエイリアス（すなわち、大文字で初まる）場合は、違う結果が得られます。\n"
"\n"
"    iex> quote do\n"
"    ...>   Hello.World\n"
"    ...> end\n"
"    {:__aliases__, [alias: false], [:Hello, :World]}\n"
"\n"
"aliasに関する詳細は`__alias__/1`スペシャルフォームのドキュメントで\n"
"説明します。\n"
"\n"
"## Unquoting\n"
"\n"
"quoteされた式の中でunquoteを使用してリモート呼び出しを生成することもできま"
"す:\n"
"\n"
"    iex> x = :downcase\n"
"    iex> quote do\n"
"    ...>   String.unquote(x)(\"FOO\")\n"
"    ...> end\n"
"    {{:., [], [{:__aliases__, [alias: false], [:String]}, :downcase]}, [], "
"[\"FOO\"]}\n"
"\n"
"`Kernel.\"FUNCTION_NAME\"`と同じく、`unquote(x)`は、`x`の値にかかわらず、\n"
"常にリモート呼び出しを生成します。quoteされた式でエイリアスを生成するには、\n"
"`Module.concat/2`に頼る必要があります。\n"
"\n"
"    iex> x = Sample\n"
"    iex> quote do\n"
"    ...>   Module.concat(String, unquote(x))\n"
"    ...> end\n"
"    {{:., [], [{:__aliases__, [alias: false], [:Module]}, :concat]}, [],\n"
"     [{:__aliases__, [alias: false], [:String]}, Sample]}\n"
"\n"

#. TRANSLATORS: Elixir.Kernel.SpecialForms Summary
#: lib/kernel/special_forms.ex:2
msgid ""
"Special forms are the basic building blocks of Elixir, and therefore\n"
"cannot be overridden by the developer.\n"
"\n"
"We define them in this module. Some of these forms are lexical (like\n"
"`alias/2`, `case/2`, etc). The macros `{}` and `<<>>` are also special\n"
"forms used to define tuple and binary data structures respectively.\n"
"\n"
"This module also documents macros that return information about Elixir's\n"
"compilation environment, such as (`__ENV__/0`, `__MODULE__/0`, `__DIR__/0` "
"and `__CALLER__/0`).\n"
"\n"
"Finally, it also documents two special forms, `__block__/1` and\n"
"`__aliases__/1`, which are not intended to be called directly by the\n"
"developer but they appear in quoted contents since they are essential\n"
"in Elixir's constructs.\n"
msgstr ""
"スペシャルフォームは、Elixirコードの基本的な構成要素であり、\n"
"それゆえ、開発者が上書きすることはできません。\n"
"\n"
"スペシャルフォームはこのモジュールで定義しました。これらの中には\n"
"（`alias/2` や`case/2`などの）字句もあります。`{}`や`<<>>`のマクロも\n"
"スペシャルフォームであり、各々タプルとバイナリデータ構造の定義に使われま"
"す。\n"
"\n"
"このモジュールでは、Elixirのコンパイル環境に関する情報を返すマクロ\n"
"（`__ENV__/0`、`__MODULE__/0`、`__DIR__/0`、`__CALLER__/0`など）\n"
"についても記述します。\n"
"\n"
"また、2つのスペシャルフォーム、`__block__/1`と`__aliases__/1`についても\n"
"記述します。これらは開発者から直接呼び出されることは意図されていませんが、\n"
"Elixirの構成に不可欠なものなのでquoteされたコンテンツに現れます。\n"

#. TRANSLATORS: defmacro Kernel.SpecialForms.__CALLER__()
#: lib/kernel/special_forms.ex:638
msgid ""
"Returns the current calling environment as a `Macro.Env` struct.\n"
"\n"
"In the environment you can access the filename, line numbers,\n"
"set up aliases, the function and others.\n"
msgstr ""
"現在の呼び出し側の環境を`Macro.Env`構造体で返します。\n"
"\n"
"この環境の現在のファイル名、行番号、セットアップされた別名や\n"
"関数などにアクセスできます。\n"

#. TRANSLATORS: defmacro Kernel.SpecialForms.%{}(args)
#: lib/kernel/special_forms.ex:54
msgid ""
"Creates a map.\n"
"\n"
"See the `Map` module for more information about maps, their syntax, and ways "
"to\n"
"access and manipulate them.\n"
"\n"
"## AST representation\n"
"\n"
"Regardless of whether `=>` or the keyword syntax is used, key-value pairs "
"in\n"
"maps are always represented internally as a list of two-element tuples for\n"
"simplicity:\n"
"\n"
"    iex> quote do\n"
"    ...>   %{\"a\" => :b, c: :d}\n"
"    ...> end\n"
"    {:%{}, [], [{\"a\", :b}, {:c, :d}]}\n"
"\n"
msgstr ""
"マップを作成します。\n"
"\n"
"マップとその構文、アクセス方法と操作方法の詳細に関しては、`Map`モジュールを\n"
"参照してください。\n"
"\n"
"## AST表現\n"
"\n"
"`=>`構文、またはキーワード構文のいずれが使用されても、マップの\n"
"キー・バリューペアは、単純化のために内部では常に2要素タプルのリストで\n"
"表現されます。\n"
"\n"
"    iex> quote do\n"
"    ...>   %{\"a\" => :b, c: :d}\n"
"    ...> end\n"
"    {:%{}, [], [{\"a\", :b}, {:c, :d}]}\n"
"\n"

#. TRANSLATORS: defmacro Kernel.SpecialForms.__block__(args)
#: lib/kernel/special_forms.ex:1366
msgid ""
"Internal special form for block expressions.\n"
"\n"
"This is the special form used whenever we have a block\n"
"of expressions in Elixir. This special form is private\n"
"and should not be invoked directly:\n"
"\n"
"    iex> quote do\n"
"    ...>   1\n"
"    ...>   2\n"
"    ...>   3\n"
"    ...> end\n"
"    {:__block__, [], [1, 2, 3]}\n"
"\n"
msgstr ""
"ブロック式のための内部スペシャルフォームです。\n"
"\n"
"これは、Elixirで式のブロックがある場合に常に使用されるスペシャルフォームで"
"す。\n"
"このスペシャルフォームはプライベートであり、直接起動するべきではありませ"
"ん。\n"
"\n"
"    iex> quote do\n"
"    ...>   1\n"
"    ...>   2\n"
"    ...>   3\n"
"    ...> end\n"
"    {:__block__, [], [1, 2, 3]}\n"
"\n"

#. TRANSLATORS: defmacro Kernel.SpecialForms.::(left, right)
#: lib/kernel/special_forms.ex:683
msgid ""
"Used by types and bitstrings to specify types.\n"
"\n"
"This operator is used in two distinct occasions in Elixir.\n"
"It is used in typespecs to specify the type of a variable,\n"
"function or of a type itself:\n"
"\n"
"    @type number :: integer | float\n"
"    @spec add(number, number) :: number\n"
"\n"
"It may also be used in bit strings to specify the type\n"
"of a given bit segment:\n"
"\n"
"    <<int::integer-little, rest::bits>> = bits\n"
"\n"
"Read the documentation on the `Typespec` page and\n"
"`<<>>/1` for more information on typespecs and\n"
"bitstrings respectively.\n"
msgstr ""
"型とbitstringで型を指定するために使用されます。\n"
"\n"
"Elixirではこのオペレータは2つの異なる状況で使用されます。\n"
"typespecでは、変数、関数、または型自身の型を指定するために\n"
"使用されます。\n"
"\n"
"    @type number :: integer | float\n"
"    @spec add(number, number) :: number\n"
"\n"
"bitstringでは、指定したbitセグメントの型を指定するために使用されます。\n"
"\n"
"    <<int::integer-little, rest::bits>> = bits\n"
"\n"
"typespecとbitstringの詳細は、各々、`Typespec`と`<<>>/1`の\n"
"ドキュメントを参照してください。\n"

#. TRANSLATORS: defmacro Kernel.SpecialForms.^(var)
#: lib/kernel/special_forms.ex:646
msgid ""
"Accesses an already bound variable in match clauses. Also known as the pin "
"operator.\n"
"\n"
"## Examples\n"
"\n"
"Elixir allows variables to be rebound via static single assignment:\n"
"\n"
"    iex> x = 1\n"
"    iex> x = x + 1\n"
"    iex> x\n"
"    2\n"
"\n"
"However, in some situations, it is useful to match against an existing\n"
"value, instead of rebinding. This can be done with the `^` special form,\n"
"colloquially known as the pin operator:\n"
"\n"
"    iex> x = 1\n"
"    iex> ^x = List.first([1])\n"
"    iex> ^x = List.first([2])\n"
"    ** (MatchError) no match of right hand side value: 2\n"
"\n"
"Note that `^x` always refers to the value of `x` prior to the match. The\n"
"following example will match:\n"
"\n"
"    iex> x = 0\n"
"    iex> {x, ^x} = {1, 0}\n"
"    iex> x\n"
"    1\n"
"\n"
msgstr ""
"マッチ節の中で既に束縛された変数へアクセスします。pin オペレータ\n"
"としても知られています。\n"
"\n"
"## 例\n"
"\n"
"Elixirでは静的な単一代入による変数の再束縛ができます。\n"
"\n"
"    iex> x = 1\n"
"    iex> x = x + 1\n"
"    iex> x\n"
"    2\n"
"\n"
"しかし、状況によっては、再束縛ではなく、既存の値にマッチした方が便利です。\n"
"これは、pinオペレータと呼ばれている、`^`スペシャルフォームで\n"
"行うことができます。\n"
"\n"
"    iex> x = 1\n"
"    iex> ^x = List.first([1])\n"
"    iex> ^x = List.first([2])\n"
"    ** (MatchError) no match of right hand side value: 2\n"
"\n"
"`^`は、常にマッチ以前の`x`の値を参照することに注意してください。\n"
"下の例は、マッチします:\n"
"\n"
"    iex> x = 0\n"
"    iex> {x, ^x} = {1, 0}\n"
"    iex> x\n"
"    1\n"
"\n"

#. TRANSLATORS: defmacro Kernel.SpecialForms.require(module, opts)
#: lib/kernel/special_forms.ex:487
msgid ""
"Requires a given module to be compiled and loaded.\n"
"\n"
"## Examples\n"
"\n"
"Notice that usually modules should not be required before usage,\n"
"the only exception is if you want to use the macros from a module.\n"
"In such cases, you need to explicitly require them.\n"
"\n"
"Let's suppose you created your own `if/2` implementation in the module\n"
"`MyMacros`. If you want to invoke it, you need to first explicitly\n"
"require the `MyMacros`:\n"
"\n"
"    defmodule Math do\n"
"      require MyMacros\n"
"      MyMacros.if do_something, it_works\n"
"    end\n"
"\n"
"An attempt to call a macro that was not loaded will raise an error.\n"
"\n"
"## Alias shortcut\n"
"\n"
"`require/2` also accepts `as:` as an option so it automatically sets\n"
"up an alias. Please check `alias/2` for more information.\n"
"\n"
msgstr ""
"指定したモジュールがコンパイルされてロードされていることを\n"
"要求します。\n"
"\n"
"## 例\n"
"\n"
"通常、モジュールを使用する前にrequireする必要はないことに注意してください。\n"
"唯一の例外はモジュールのマクロを利用したい場合です。そのような場合は、\n"
"モジュールを明示的にrequireする必要があります。\n"
"\n"
"モジュール`MyMacros`で独自の`if/2`実装を作成したと仮定します。\n"
"それを実行したい場合は、まず明示的に`MyMacros`をrequireする\n"
"必要があります。\n"
"\n"
"    defmodule Math do\n"
"      require MyMacros\n"
"      MyMacros.if do_something, it_works\n"
"    end\n"
"\n"
"ロードされていないマクロを呼び出そうとするとエラーが発生します。\n"
"\n"
"## Alias ショートカット\n"
"\n"
"`require/2`は、エイリアスを自動的に設定するオプションとして、\n"
"`as:`も受け付けます。詳細は、`alias/2`をチェックしてください。\n"
"\n"

#. TRANSLATORS: defmacro Kernel.SpecialForms.cond(clauses)
#: lib/kernel/special_forms.ex:1566
msgid ""
"Evaluates the expression corresponding to the first clause that\n"
"evaluates to a truthy value.\n"
"\n"
"    cond do\n"
"      hd([1, 2, 3]) ->\n"
"        \"1 is considered as true\"\n"
"    end\n"
"    #=> \"1 is considered as true\"\n"
"\n"
"Raises an error if all conditions evaluate to `nil` or `false`.\n"
"For this reason, it may be necessary to add a final always-truthy condition\n"
"(anything non-`false` and non-`nil`), which will always match.\n"
"\n"
"## Examples\n"
"\n"
"    cond do\n"
"      1 + 1 == 1 ->\n"
"        \"This will never match\"\n"
"      2 * 2 != 4 ->\n"
"        \"Nor this\"\n"
"      true ->\n"
"        \"This will\"\n"
"    end\n"
"    #=> \"This will\"\n"
"\n"
msgstr ""
"truthy値と評価された最初の節の式を評価します。\n"
"\n"
"    cond do\n"
"      hd([1,2,3]) ->\n"
"        \"1 is considered as true\"\n"
"    end\n"
"    #=> \"1 is considered as true\"\n"
"\n"
"すべての条件が`nil`または`false`と評価された場合は、エラーを発生させます。\n"
"そのため、常にマッチする、常にtruthyとなる（非`false`かつ非`nil`の何か）\n"
"最終的な条件を追加する必要があるかもしれません。\n"
"\n"
"## 例\n"
"\n"
"    cond do\n"
"      1 + 1 == 1 ->\n"
"        \"This will never match\"\n"
"      2 * 2 != 4 ->\n"
"        \"Nor this\"\n"
"      true ->\n"
"        \"This will\"\n"
"    end\n"
"    #=> \"This will\"\n"
"\n"

#~ msgid ""
#~ "Creates a map.\n"
#~ "\n"
#~ "Maps are key-value stores where keys are compared\n"
#~ "using the match operator (`===`). Maps can be created with\n"
#~ "the `%{}` special form where keys are associated via `=>`:\n"
#~ "\n"
#~ "    %{1 => 2}\n"
#~ "\n"
#~ "Maps also support the keyword notation, as other special forms,\n"
#~ "as long as they are at the end of the argument list:\n"
#~ "\n"
#~ "    %{hello: :world, with: :keywords}\n"
#~ "    %{:hello => :world, with: :keywords}\n"
#~ "\n"
#~ "If a map has duplicated keys, the last key will always have\n"
#~ "higher precedence:\n"
#~ "\n"
#~ "    iex> %{a: :b, a: :c}\n"
#~ "    %{a: :c}\n"
#~ "\n"
#~ "Conveniences for manipulating maps can be found in the\n"
#~ "`Map` module.\n"
#~ "\n"
#~ "## Access syntax\n"
#~ "\n"
#~ "Besides the access functions available in the `Map` module,\n"
#~ "like `Map.get/3` and `Map.fetch/2`, a map can be accessed using the\n"
#~ "`.` operator:\n"
#~ "\n"
#~ "    iex> map = %{a: :b}\n"
#~ "    iex> map.a\n"
#~ "    :b\n"
#~ "\n"
#~ "Note that the `.` operator expects the field to exist in the map.\n"
#~ "If not, an `ArgumentError` is raised.\n"
#~ "\n"
#~ "## Update syntax\n"
#~ "\n"
#~ "Maps also support an update syntax:\n"
#~ "\n"
#~ "    iex> map = %{:a => :b}\n"
#~ "    iex> %{map | :a => :c}\n"
#~ "    %{:a => :c}\n"
#~ "\n"
#~ "Notice the update syntax requires the given keys to exist.\n"
#~ "Trying to update a key that does not exist will raise an `KeyError`.\n"
#~ "\n"
#~ "## AST representation\n"
#~ "\n"
#~ "Regardless if `=>` or the keywords syntax is used, Maps are\n"
#~ "always represented internally as a list of two-element tuples\n"
#~ "for simplicity:\n"
#~ "\n"
#~ "    iex> quote do\n"
#~ "    ...>   %{\"a\" => :b, c: :d}\n"
#~ "    ...> end\n"
#~ "    {:%{}, [], [{\"a\", :b}, {:c, :d}]}\n"
#~ "\n"
#~ msgstr ""
#~ "マップを作成します。\n"
#~ "\n"
#~ "マップは、キーをマッチオペレータ(`===`)で比較する、\n"
#~ "キーバリューストアです。マップは、キーを`=>`で関連付けた\n"
#~ "`%{}`スペシャルフォームで、作成することができます:\n"
#~ "\n"
#~ "    %{1 => 2}\n"
#~ "\n"
#~ "引数リストの終わりにいる限り、マップは、他のスペシャルフォーム\n"
#~ "として、キーワード記法もサポートします:\n"
#~ "\n"
#~ "    %{hello: :world, with: :keywords}\n"
#~ "    %{:hello => :world, with: :keywords}\n"
#~ "\n"
#~ "もしマップが重複したキーをもったら、最後のキーが常に高い優先度を持ちま\n"
#~ "す:\n"
#~ "\n"
#~ "    iex> %{a: :b, a: :c}\n"
#~ "    %{a: :c}\n"
#~ "\n"
#~ "マップ操作のための便利さは`Map`モジュールで見付けることができます。\n"
#~ "\n"
#~ "## Access syntax\n"
#~ "\n"
#~ "`Map.get/3`や`Map.fetch/2`のような、`Map`モジュールで有効なアクセス関数\n"
#~ "の他に、マップは`.`オペレータを使ってアクセスすることが出来ます:\n"
#~ "\n"
#~ "    iex> map = %{a: :b}\n"
#~ "    iex> map.a\n"
#~ "    :b\n"
#~ "\n"
#~ "なお、`.`オペレータはマップの中にフィールドが存在することを期待してま"
#~ "す。\n"
#~ "もしないなら、`ArgumentError`が上ります。\n"
#~ "\n"
#~ "## Update syntax\n"
#~ "\n"
#~ "マップは更新構文もサポートします:\n"
#~ "\n"
#~ "    iex> map = %{:a => :b}\n"
#~ "    iex> %{map | :a => :c}\n"
#~ "    %{:a => :c}\n"
#~ "\n"
#~ "更新構文は、与えられたキーが存在することを要求することに、\n"
#~ "注意してください。\n"
#~ "存在しないキーを更新しようとすると、`ArgumentError`が上ります。\n"
#~ "\n"
#~ "## AST representation\n"
#~ "\n"
#~ "`=>`またはキーワード構文が使われたかを気にせずに、マップは、\n"
#~ "常に内部的には単純さの為に2要素のタプルのリストとして表現されます:\n"
#~ "\n"
#~ "    iex> quote do\n"
#~ "    ...>   %{\"a\" => :b, c: :d}\n"
#~ "    ...> end\n"
#~ "    {:%{}, [], [{:a, :b}, {:c, :d}]}\n"
#~ "\n"

#~ msgid ""
#~ "Defines a new bitstring.\n"
#~ "\n"
#~ "## Examples\n"
#~ "\n"
#~ "    iex> << 1, 2, 3 >>\n"
#~ "    << 1, 2, 3 >>\n"
#~ "\n"
#~ "## Bitstring types\n"
#~ "\n"
#~ "A bitstring is made of many segments. Each segment has a\n"
#~ "type, which defaults to integer:\n"
#~ "\n"
#~ "    iex> <<1, 2, 3>>\n"
#~ "    <<1, 2, 3>>\n"
#~ "\n"
#~ "Elixir also accepts by default the segment to be a literal\n"
#~ "string or a literal char list, which are by expanded to integers:\n"
#~ "\n"
#~ "    iex> <<0, \"foo\">>\n"
#~ "    <<0, 102, 111, 111>>\n"
#~ "\n"
#~ "Any other type needs to be explicitly tagged. For example,\n"
#~ "in order to store a float type in the binary, one has to do:\n"
#~ "\n"
#~ "    iex> <<3.14 :: float>>\n"
#~ "    <<64, 9, 30, 184, 81, 235, 133, 31>>\n"
#~ "\n"
#~ "This also means that variables need to be explicitly tagged,\n"
#~ "otherwise Elixir defaults to integer:\n"
#~ "\n"
#~ "    iex> rest = \"oo\"\n"
#~ "    iex> <<102, rest>>\n"
#~ "    ** (ArgumentError) argument error\n"
#~ "\n"
#~ "We can solve this by explicitly tagging it as a binary:\n"
#~ "\n"
#~ "    <<102, rest :: binary>>\n"
#~ "\n"
#~ "The type can be integer, float, bitstring/bits, binary/bytes,\n"
#~ "utf8, utf16 or utf32, e.g.:\n"
#~ "\n"
#~ "    <<102 :: float, rest :: binary>>\n"
#~ "\n"
#~ "An integer can be any arbitrary precision integer. A float is an\n"
#~ "IEEE 754 binary32 or binary64 floating point number. A bitstring\n"
#~ "is an arbitrary series of bits. A binary is a special case of\n"
#~ "bitstring that has a total size divisible by 8.\n"
#~ "\n"
#~ "The utf8, utf16, and utf32 types are for unicode codepoints. They\n"
#~ "can also be applied to literal strings and char lists:\n"
#~ "\n"
#~ "    iex> <<\"foo\" :: utf16>>\n"
#~ "    <<0,102,0,111,0,111>>\n"
#~ "\n"
#~ "The bits type is an alias for bitstring. The bytes type is an\n"
#~ "alias for binary.\n"
#~ "\n"
#~ "The signedness can also be given as signed or unsigned. The\n"
#~ "signedness only matters for matching and relevant only for\n"
#~ "integers. If unspecified, it defaults to unsigned. Example:\n"
#~ "\n"
#~ "    iex> <<-100 :: signed, _rest :: binary>> = <<-100, \"foo\">>\n"
#~ "    <<156,102,111,111>>\n"
#~ "\n"
#~ "This match would have failed if we did not specify that the\n"
#~ "value -100 is signed. If we're matching into a variable instead\n"
#~ "of a value, the signedness won't be checked; rather, the number\n"
#~ "will simply be interpreted as having the given (or implied)\n"
#~ "signedness, e.g.:\n"
#~ "\n"
#~ "    iex> <<val, _rest :: binary>> = <<-100, \"foo\">>\n"
#~ "    iex> val\n"
#~ "    156\n"
#~ "\n"
#~ "Here, `val` is interpreted as unsigned.\n"
#~ "\n"
#~ "The endianness of a segment can be big, little or native (the\n"
#~ "latter meaning it will be resolved at VM load time).\n"
#~ "\n"
#~ "Many options can be given by using `-` as separator, order is\n"
#~ "arbitrary. The following are all the same:\n"
#~ "\n"
#~ "    <<102 :: integer-native, rest :: binary>>\n"
#~ "    <<102 :: native-integer, rest :: binary>>  \n"
#~ "    <<102 :: unsigned-big-integer, rest :: binary>>\n"
#~ "    <<102 :: unsigned-big-integer-size(8), rest :: binary>>\n"
#~ "    <<102 :: unsigned-big-integer-8, rest :: binary>>\n"
#~ "    <<102 :: 8-integer-big-unsigned, rest :: binary>>\n"
#~ "    <<102, rest :: binary>>\n"
#~ "\n"
#~ "And so on.\n"
#~ "\n"
#~ "Endianness only makes sense for integers and some UTF code\n"
#~ "point types (utf16 and utf32).\n"
#~ "\n"
#~ "Finally, we can also specify size and unit for each segment. The\n"
#~ "unit is multiplied by the size to give the effective size of\n"
#~ "the segment in bits. The default unit for integers, floats,\n"
#~ "and bitstrings is 1. For binaries, it is 8.\n"
#~ "\n"
#~ "Since integers are default, the default unit is 1. The example below\n"
#~ "matches because the string \"foo\" takes 24 bits and we match it\n"
#~ "against a segment of 24 bits, 8 of which are taken by the integer\n"
#~ "102 and the remaining 16 bits are specified on the rest.\n"
#~ "\n"
#~ "    iex> <<102, _rest :: size(16)>> = \"foo\"\n"
#~ "    \"foo\"\n"
#~ "\n"
#~ "We can also match by specifying size and unit explicitly:\n"
#~ "\n"
#~ "    iex> <<102, _rest :: size(2)-unit(8)>> = \"foo\"\n"
#~ "    \"foo\"\n"
#~ "\n"
#~ "However, if we expect a size of 32, it won't match:\n"
#~ "\n"
#~ "    iex> <<102, _rest :: size(32)>> = \"foo\"\n"
#~ "    ** (MatchError) no match of right hand side value: \"foo\"\n"
#~ "\n"
#~ "Size and unit are not applicable to utf8, utf16, and utf32.\n"
#~ "\n"
#~ "The default size for integers is 8. For floats, it is 64. For\n"
#~ "binaries, it is the size of the binary. Only the last binary\n"
#~ "in a binary match can use the default size (all others must\n"
#~ "have their size specified explicitly).\n"
#~ "\n"
#~ "    iex> <<3.14 :: float>>\n"
#~ "    <<64, 9, 30, 184, 81, 235, 133, 31>>\n"
#~ "    iex> <<3.14 :: float-32>>\n"
#~ "    <<64, 72, 245, 195>>\n"
#~ "\n"
#~ "Size and unit can also be specified using a syntax shortcut\n"
#~ "when passing integer values:\n"
#~ "\n"
#~ "    << x :: 8 >> == << x :: size(8) >>\n"
#~ "    << x :: 8 * 4 >> == << x :: size(8)-unit(4) >>\n"
#~ "    << x :: _ * 4 >> == << x :: unit(4) >>\n"
#~ "\n"
#~ "This syntax reflects the fact the effective size is given by\n"
#~ "multiplying the size by the unit.\n"
#~ "\n"
#~ "For floats, `size * unit` must result in 32 or 64, corresponding\n"
#~ "to binary32 and binary64, respectively.\n"
#~ msgstr ""
#~ "新しいbitstringを定義します。\n"
#~ "\n"
#~ "## 例\n"
#~ "\n"
#~ "    iex> << 1, 2, 3 >>\n"
#~ "    << 1, 2, 3 >>\n"
#~ "\n"
#~ "## Bitstringタイプ\n"
#~ "\n"
#~ "bitstringは多くのセグメントで出来ています。それぞれのセグメントは\n"
#~ "デフォルトは整数のタイプを持っています:\n"
#~ "\n"
#~ "    iex> <<1, 2, 3>>\n"
#~ "    <<1, 2, 3>>\n"
#~ "\n"
#~ "Elixirはリテラル文字列あるいはリテラル文字のリストのセグメントも\n"
#~ "デフォルトで受け付け、整数に展開されます:\n"
#~ "\n"
#~ "    iex> <<0, \"foo\">>\n"
#~ "    <<0, 102, 111, 111>>\n"
#~ "\n"
#~ "他の任意のタイプは明示的にタグづけされる必要があります。例えば、\n"
#~ "バイナリでfloatタイプをストアするために、下のようにします:\n"
#~ "\n"
#~ "    iex> <<3.14 :: float>>\n"
#~ "    <<64, 9, 30, 184, 81, 235, 133, 31>>\n"
#~ "\n"
#~ "これは、変数は明示的にタグづけされる必要があることも意味します。\n"
#~ "さもないと、Elixirはデフォルトの整数として扱おうとします:\n"
#~ "\n"
#~ "    iex> rest = \"oo\"\n"
#~ "    iex> <<102, rest>>\n"
#~ "    ** (ArgumentError) argument error\n"
#~ "\n"
#~ "明示的にバイナリとタグづけすることによって、この問題を解決できます:\n"
#~ "\n"
#~ "    <<102, rest :: binary>>\n"
#~ "\n"
#~ "タイプはinteger, float, bitstring/bits, binary/types, utf8, utf16, \n"
#~ "utf32が可能です。例えば:\n"
#~ "\n"
#~ "    <<102 :: float, rest :: binary>>\n"
#~ "\n"
#~ "integerは任意の精度の整数が可能です。floatはIEEE754 binary32か\n"
#~ "binary64浮動小数点数です。bitstringは任意のbit列です。binaryは\n"
#~ "bitstringの特別な場合で合計の大きさが8の倍数です。\n"
#~ "\n"
#~ "utf8, utf16, utf32タイプはunicodeコードポイントです。\n"
#~ "それらはリテラルの文字列と文字リストにも適用できます:\n"
#~ "\n"
#~ "    iex> <<\"foo\" :: utf16>>\n"
#~ "    <<0,102,0,111,0,111>>\n"
#~ "\n"
#~ "bitsタイプはbitstringの別名です。bytesタイプはbinaryの\n"
#~ "別名です。\n"
#~ "符号の有無はsignedかunsignedとして与えることも出来ます。\n"
#~ "符号の有無は、整数の為だけにあって、マッチングに重要なだけです。\n"
#~ "もし指定されなければ、デフォルトはunsignedです。例は:\n"
#~ "\n"
#~ "    iex> <<-100 :: signed, _rest :: binary>> = <<-100, \"foo\">>\n"
#~ "    <<156,102,111,111>>\n"
#~ "\n"
#~ "もし値-100がsignedと指定しなかったら、このマッチは失敗したでしょう。\n"
#~ "もし値の代りに変数にマッチングさせたら、符号の有無はチェックされません;\n"
#~ "むしろ、与えられた(または意味される)符号の有無を持つとして、\n"
#~ "単に解釈されます。例えば:\n"
#~ "\n"
#~ "    iex> <<val, _rest :: binary>> = <<-100, \"foo\">>\n"
#~ "    iex> val\n"
#~ "    156\n"
#~ "\n"
#~ "ここで、`val`はunsignedとして解釈されています。\n"
#~ "\n"
#~ "セグメントのエンディアンはbig、little, native(その意味は\n"
#~ "VMのロード時に解決されます)が可能です。\n"
#~ "\n"
#~ "セパレータとして`-`を使うことにより、多くのオプションを指定すること\n"
#~ "ができます。以下は全て同じです:\n"
#~ "\n"
#~ "    <<102 :: integer-native, rest :: binary>>\n"
#~ "    <<102 :: native-integer, rest :: binary>>\n"
#~ "    <<102 :: unsigned-big-integer, rest :: binary>>\n"
#~ "    <<102 :: unsigned-big-integer-size(8), rest :: binary>>\n"
#~ "    <<102 :: unsigned-big-integer-8, rest :: binary>>\n"
#~ "    <<102 :: 8-integer-big-unsigned, rest :: binary>>\n"
#~ "    <<102, rest :: binary>>\n"
#~ "\n"
#~ "そしてその他。\n"
#~ "\n"
#~ "エンディアンはintegerといくつかのUTFコードポイントタイプ\n"
#~ "(utf16とutf32)でのみ意味をなすだけです。\n"
#~ "\n"
#~ "最後に、それぞれのセグメントにsizeとunitを指定することもできます。\n"
#~ "unitはbitでセグメントの実質的なサイズを与えるために、\n"
#~ "sizeによって掛け算されます。\n"
#~ "デフォルトunitは、integer, float, bitstringでは1です。binaryでは8です。\n"
#~ "\n"
#~ "integerがデフォルトなので、デフォルトunitは1です。\n"
#~ "下の例では、文字列\"foo\"が24ビットをとります。その24ビットのセグメント\n"
#~ "に対して、整数102により8ビットと、のこり16bitは_restにより指定さ\n"
#~ "れているので、マッチします。\n"
#~ "\n"
#~ "    iex> <<102, _rest :: size(16)>> = \"foo\"\n"
#~ "    \"foo\"\n"
#~ "\n"
#~ "sizeとunitを明示的に指定することによってマッチさせることもできます:\n"
#~ "\n"
#~ "    iex> <<102, _rest :: size(2)-unit(8)>> = \"foo\"\n"
#~ "    \"foo\"\n"
#~ "\n"
#~ "しかしながら、この例でsizeを32にすると、マッチしません:\n"
#~ "\n"
#~ "    iex> <<102, _rest :: size(32)>> = \"foo\"\n"
#~ "    ** (MatchError) no match of right hand side value: \"foo\"\n"
#~ "\n"
#~ "sizeとunitはutf8, utf16, utf32には適用されません。\n"
#~ "\n"
#~ "integerのデフォルトのsizeは8です。floatは64です。binaryはbinaryの大きさ\n"
#~ "です。最後のbinaryのマッチにだけは、デフォルトsizeを使うことができます\n"
#~ "(他の全てはsizeを明示的に指定されていなければなりません)。\n"
#~ "\n"
#~ "    iex> <<3.14 :: float>>\n"
#~ "    <<64, 9, 30, 184, 81, 235, 133, 31>>\n"
#~ "    iex> <<3.14 :: float-32>>\n"
#~ "    <<64, 72, 245, 195>>\n"
#~ "\n"
#~ "\n"
#~ "sizeとunitは、構文上のショートカットを使って指定することも\n"
#~ "できます:\n"
#~ "\n"
#~ "    << x :: 8 >> == << x :: size(8) >>\n"
#~ "    << x :: 8 * 4 >> == << x :: size(8)-unit(4) >>\n"
#~ "    << x :: _ * 4 >> == << x :: unit(4) >>\n"
#~ "\n"
#~ "実際の大きさがsizeとunitの掛け算によって与えられるという事実を、\n"
#~ "この構文は反映しています。\n"
#~ "\n"
#~ "floatでは、`size * unit`は、binary32とbinary64にそれぞれ一致する、\n"
#~ "32か64でなければなりません。\n"
