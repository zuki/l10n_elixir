msgid ""
msgstr ""
"Project-Id-Version: l 10n_elixir\n"
"PO-Revision-Date: 2017-03-20 17:11+0900\n"
"Last-Translator: 小田 照敬 <EMAIL@ADDRESS>\n"
"Language-Team: Japanese\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"POT-Creation-Date: \n"
"X-Generator: Poedit 1.8.12\n"

#. TRANSLATORS: Elixir.Task Summary
#: lib/task.ex:2
msgid ""
"Conveniences for spawning and awaiting tasks.\n"
"\n"
"Tasks are processes meant to execute one particular\n"
"action throughout their lifetime, often with little or no\n"
"communication with other processes. The most common use case\n"
"for tasks is to convert sequential code into concurrent code\n"
"by computing a value asynchronously:\n"
"\n"
"    task = Task.async(fn -> do_some_work() end)\n"
"    res  = do_some_other_work()\n"
"    res + Task.await(task)\n"
"\n"
"Tasks spawned with `async` can be awaited on by their caller\n"
"process (and only their caller) as shown in the example above.\n"
"They are implemented by spawning a process that sends a message\n"
"to the caller once the given computation is performed.\n"
"\n"
"Besides `async/1` and `await/2`, tasks can also be\n"
"started as part of a supervision tree and dynamically spawned\n"
"on remote nodes. We will explore all three scenarios next.\n"
"\n"
"## async and await\n"
"\n"
"One of the common uses of tasks is to convert sequential code\n"
"into concurrent code with `Task.async/1` while keeping its semantics.\n"
"When invoked, a new process will be created, linked and monitored\n"
"by the caller. Once the task action finishes, a message will be sent\n"
"to the caller with the result.\n"
"\n"
"`Task.await/2` is used to read the message sent by the task.\n"
"\n"
"There are two important things to consider when using `async`:\n"
"\n"
"  1. If you are using async tasks, you **must await** a reply\n"
"     as they are *always* sent. If you are not expecting a reply,\n"
"     consider using `Task.start_link/1` detailed below.\n"
"\n"
"  2. async tasks link the caller and the spawned process. This\n"
"     means that, if the caller crashes, the task will crash\n"
"     too and vice-versa. This is on purpose: if the process\n"
"     meant to receive the result no longer exists, there is\n"
"     no purpose in completing the computation.\n"
"\n"
"     If this is not desired, use `Task.start/1` or consider starting\n"
"     the task under a `Task.Supervisor` using `async_nolink` or\n"
"     `start_child`.\n"
"\n"
"`Task.yield/2` is an alternative to `await/2` where the caller will\n"
"temporarily block, waiting until the task replies or crashes. If the\n"
"result does not arrive within the timeout, it can be called again at a\n"
"later moment. This allows checking for the result of a task multiple\n"
"times. If a reply does not arrive within the desired time,\n"
"`Task.shutdown/2` can be used to stop the task.\n"
"\n"
"## Supervised tasks\n"
"\n"
"It is also possible to spawn a task under a supervisor\n"
"with `start_link/1` and `start_link/3`:\n"
"\n"
"    Task.start_link(fn -> IO.puts \"ok\" end)\n"
"\n"
"Such tasks can be mounted in your supervision tree as:\n"
"\n"
"    import Supervisor.Spec\n"
"\n"
"    children = [\n"
"      worker(Task, [fn -> IO.puts \"ok\" end])\n"
"    ]\n"
"\n"
"Since these tasks are supervised and not directly linked to\n"
"the caller, they cannot be awaited on. Note `start_link/1`,\n"
"unlike `async/1`, returns `{:ok, pid}` (which is\n"
"the result expected by supervision trees).\n"
"\n"
"By default, most supervision strategies will try to restart\n"
"a worker after it exits regardless of the reason. If you design the\n"
"task to terminate normally (as in the example with `IO.puts/2` above),\n"
"consider passing `restart: :transient` in the options to `Supervisor.Spec."
"worker/3`.\n"
"\n"
"## Dynamically supervised tasks\n"
"\n"
"The `Task.Supervisor` module allows developers to dynamically\n"
"create multiple supervised tasks.\n"
"\n"
"A short example is:\n"
"\n"
"    {:ok, pid} = Task.Supervisor.start_link()\n"
"    task = Task.Supervisor.async(pid, fn ->\n"
"      # Do something\n"
"    end)\n"
"    Task.await(task)\n"
"\n"
"However, in the majority of cases, you want to add the task supervisor\n"
"to your supervision tree:\n"
"\n"
"    import Supervisor.Spec\n"
"\n"
"    children = [\n"
"      supervisor(Task.Supervisor, [[name: MyApp.TaskSupervisor]])\n"
"    ]\n"
"\n"
"Now you can dynamically start supervised tasks:\n"
"\n"
"    Task.Supervisor.start_child(MyApp.TaskSupervisor, fn ->\n"
"      # Do something\n"
"    end)\n"
"\n"
"Or even use the async/await pattern:\n"
"\n"
"    Task.Supervisor.async(MyApp.TaskSupervisor, fn ->\n"
"      # Do something\n"
"    end) |> Task.await()\n"
"\n"
"Finally, check `Task.Supervisor` for other supported operations.\n"
"\n"
"## Distributed tasks\n"
"\n"
"Since Elixir provides a Task supervisor, it is easy to use one\n"
"to dynamically spawn tasks across nodes:\n"
"\n"
"    # On the remote node\n"
"    Task.Supervisor.start_link(name: MyApp.DistSupervisor)\n"
"\n"
"    # On the client\n"
"    Task.Supervisor.async({MyApp.DistSupervisor, :remote@local},\n"
"                          MyMod, :my_fun, [arg1, arg2, arg3])\n"
"\n"
"Note that, when working with distributed tasks, one should use the `Task."
"Supervisor.async/4` function\n"
"that expects explicit module, function and arguments, instead of `Task."
"Supervisor.async/2` that\n"
"works with anonymous functions. That's because anonymous functions expect\n"
"the same module version to exist on all involved nodes. Check the `Agent` "
"module\n"
"documentation for more information on distributed processes as the "
"limitations\n"
"described there apply to the whole ecosystem.\n"
msgstr ""
"タスクの生成と処理待ちに便利ツールです。\n"
"\n"
"タスクとは、そのライフサイクルを通じて特定のアクションを\n"
"実行するプロセスであり、多くの場合、他のプロセスとはほとんど\n"
"通信しません。タスクの最も一般的なユースケースは、値を非同期的に\n"
"計算することにより、逐次コードを並行コードに変換することです。\n"
"\n"
"    task = Task.async(fn -> do_some_work() end)\n"
"    res  = do_some_other_work()\n"
"    res + Task.await(task)\n"
"\n"
"`async`で生成されたタスクは、上の例が示すように、呼び出し元\n"
"プロセスで(そして呼び出し元だけで)待つことができます。 タスクは\n"
"指定された計算が実行されると、呼び出し元にメッセージを送信する\n"
"プロセスを生成することによって実装されます。\n"
"\n"
"`async/1`と`await/2`以外にも、タスクは、監視ツリーの一部として\n"
"起動されたり、リモートノードで動的に起動されたりすることも\n"
"できます。\n"
"\n"
"## asyncとawait\n"
"\n"
"タスクの一般的な用途の1つは、セマンティクスを保ったまま\n"
"`Task.async/1`を使用して逐次コードを並行コードに変換する\n"
"ことです。起動されると、新しいプロセスが作成され、呼び出し元に\n"
"リンクされ監視されます。タスクアクションが終了すると結果と共に\n"
"呼び出し元にメッセージが送信されます。\n"
"\n"
"`Task.await/2`はタスクから送信されたメッセージを読むために使\n"
"われます。\n"
"\n"
"`async`を使用する際には、次の2点を考慮する必要があります。\n"
"\n"
"  1. asyncタスクを使用する場合、 応答が*常に* 送信されるので、\n"
"     それを*待たなければなりません*。応答を期待しない場合は、\n"
"     以下で説明する`Task.start_link/1` の使用を検討してください。\n"
"\n"
"  2. asyncタスクは呼び出し元と生成されたプロセスをリンクします。\n"
"     これは、呼び出し元がクラッシュしたらタスクもクラッシュし、\n"
"     逆もまた同じであることを意味します。これは意図的なものです。\n"
"     結果を受信するはずのプロセスがもはや存在しないなら、\n"
"     計算を完了する意味がないからです。\n"
"\n"
"     これを望まない場合は、`Task.start/1`を使用するか、`async_nolink`\n"
"     または`start_child`を使用して`Task.Supervisor`の下でタスクを起動\n"
"     することを考慮してください。\n"
"\n"
"`Task.yield/2`は`await/2`の代替関数で、呼び出し元が一時的に\n"
"ブロックし、タスクが応答またはクラッシュするまで待機します。\n"
"結果がタイムアウト時間内に到着しない場合は、後で再度呼び出す\n"
"ことができます。これにより、タスクの結果を何度も確認することが\n"
"できます。応答が望み通りの時間内に到着しない場合は、\n"
"`Task.shutdown/2`を使用してタスクを停止できます。\n"
"\n"
"## 監視されるタスク\n"
"\n"
"`start_link/1`と`start_link/3`を使用することで、\n"
"スーパバイザ配下でタスクを起動することもできます。\n"
"\n"
"    Task.start_link(fn -> IO.puts \"ok\" end)\n"
"\n"
"そのようなタスクは次のように監視ツリーにマウントできます:\n"
"\n"
"    import Supervisor.Spec\n"
"\n"
"    children = [\n"
"      worker(Task, [fn -> IO.puts \"ok\" end])\n"
"    ]\n"
"\n"
"これらのタスクは監視され、呼び出し元には直接リンクされませんので\n"
"待つことはできません。。`start_link/1`は`async/1`と違って、\n"
"`{:ok, pid}`(これは監視ツリーにより期待される結果です)を返す\n"
"ことに注意してください。\n"
"\n"
"デフォルトでは、ほとんどの監視戦略は理由に関わらず、終了後に\n"
"ワーカーの再起動を試みます。タスクを正常に終了するに設計する\n"
"場合は、(上の`IO.puts/2`の例のように)、`Supervisor.Spec.worker/3`への\n"
"オプションに`restart: :transient`を渡すことを検討してください。\n"
"\n"
"## 動的に監視されるタスク\n"
"\n"
"`Task.Supervisor`モジュールは、監視されるタスクを動的に複数\n"
"作成することを可能にしてます。\n"
"\n"
"短かい例は次の通りです:\n"
"\n"
"    {:ok, pid} = Task.Supervisor.start_link()\n"
"    task = Task.Supervisor.async(pid, fn ->\n"
"      # 何か行う\n"
"    end)\n"
"    Task.await(task)\n"
"\n"
"しかし、ほとんどの場合、監視ツリーにタスクスーパバイザを追加\n"
"したいと思うでしょう。\n"
"\n"
"    import Supervisor.Spec\n"
"\n"
"    children = [\n"
"      supervisor(Task.Supervisor, [[name: MyApp.TaskSupervisor]])\n"
"    ]\n"
"\n"
"これで監視されたタスクを動的に開始できます:\n"
"\n"
"    Task.Supervisor.start_child(MyApp.TaskSupervisor, fn ->\n"
"      # 何かをする\n"
"    end)\n"
"\n"
"または、async/awaitパターンを使うこともできます:\n"
"\n"
"    Task.Supervisor.async(MyApp.TaskSupervisor, fn ->\n"
"      # 何かする\n"
"    end) |> Task.await()\n"
"\n"
"最後に、サポートされている他のオペレーションは`Task.Supervisor`で\n"
"チェックしてください。\n"
"\n"
"## 分散タスク\n"
"\n"
"ElixirはTaskスーパバイザを提供していますので、それを使用することで\n"
"ノードを越えてタスクを動的に生成することは簡単です。:\n"
"\n"
"    # リモートノードにおいて\n"
"    Task.Supervisor.start_link(name: MyApp.DistSupervisor)\n"
"\n"
"    # クライアントにおいて\n"
"    Task.Supervisor.async({MyApp.DistSupervisor, :remote@local},\n"
"                          MyMod, :my_fun, [arg1, arg2, arg3])\n"
"\n"
"分散タスクを扱う場合は、匿名関数で動作する`Task.Supervisor.async/2`\n"
"ではなく、明示的なモジュール、関数、引数を期待する関数\n"
"`Task.Supervisor.async/4` を使用する必要があることに注意\n"
"してください。これは、匿名関数は関連するすべてのノードに同一の\n"
"モジュールバージョンが存在することを期待するためです。 分散プロセスに\n"
"関する情報は`Agent`モジュールのドキュメントをチェックしてください。\n"
"そこで説明されている制限はエコシステム全体に適用される\n"
"からです。\n"

#. TRANSLATORS: def Task.yield(task, timeout \\ 5000)
#: lib/task.ex:448
msgid ""
"Temporarily blocks the current process waiting for a task reply.\n"
"\n"
"Returns `{:ok, reply}` if the reply is received, `nil` if\n"
"no reply has arrived, or `{:exit, reason}` if the task has already\n"
"exited. Keep in mind that normally a task failure also causes\n"
"the process owning the task to exit. Therefore this function can\n"
"return `{:exit, reason}` only if\n"
"\n"
"  * the task process exited with the reason `:normal`\n"
"  * it isn't linked to the caller\n"
"  * the caller is trapping exits\n"
"\n"
"A timeout, in milliseconds, can be given with default value\n"
"of `5000`. If the time runs out before a message from\n"
"the task is received, this function will return `nil`\n"
"and the monitor will remain active. Therefore `yield/2` can be\n"
"called multiple times on the same task.\n"
"\n"
"This function assumes the task's monitor is still active or the\n"
"monitor's `:DOWN` message is in the message queue. If it has been\n"
"demonitored or the message already received, this function will wait\n"
"for the duration of the timeout awaiting the message.\n"
"\n"
"If you intend to shut the task down if it has not responded within "
"`timeout`\n"
"milliseconds, you should chain this together with `shutdown/1`, like so:\n"
"\n"
"    case Task.yield(task, timeout) || Task.shutdown(task) do\n"
"      {:ok, result} ->\n"
"        result\n"
"      nil ->\n"
"        Logger.warn \"Failed to get a result in #{timeout}ms\"\n"
"        nil\n"
"    end\n"
"\n"
"That ensures that if the task completes after the `timeout` but before "
"`shutdown/1`\n"
"has been called, you will still get the result, since `shutdown/1` is "
"designed to\n"
"handle this case and return the result.\n"
msgstr ""
"タスクの応答を待ために現在のプロセスを一時的にブロックします。\n"
"\n"
"応答を受信した場合は`{:ok, reply}` 、応答が届かなかった場合は`nil`、\n"
"タスクがすでに終了していた場合は`{:exit, reason}`を返します。\n"
"通常、タスクの失敗は、タスクを所有するプロセスを終了させる原因にも\n"
"なることに留意してください。そのため、この関数が`{:exit, reason}`を\n"
"返すのは次の場合だけです。\n"
"\n"
"  * タスクプロセスが理由`:normal`で終了した\n"
"  * 呼び出し元にリンクされていない\n"
"  * 呼び出し元が終了をトラップしている\n"
"\n"
"ミリ秒単位のタイムアウトを指定することができ、デフォルト値は\n"
"`5000`です。タスクからのメッセージを受信する前にタイムアウトの\n"
"時間を過ぎた場合、この関数は`nil`を返し、モニタはアクティブの\n"
"ままです。したがって、`yield/2`は同じタスクに対して複数回\n"
"呼び出すことができます。\n"
"\n"
"この関数は、タスクのモニタがまだ有効であるか、またはモニタの\n"
"`:DOWN`メッセージがメッセージキューにあることを前提としています。\n"
"モニタから外された、またはメッセージが既に受信されている場合、この\n"
"関数はメッセージ待ちのタイムアウト時間まで待機します。\n"
"\n"
"`timeout`ミリ秒内に応答がない場合にタスクをシャットダウンさせたい場合は、\n"
"次のようにこの関数と`shutdown/1`を続けて実行する必要があります。\n"
"\n"
"    case Task.yield(task, timeout) || Task.shutdown(task) do\n"
"      {:ok, result} ->\n"
"        result\n"
"      nil ->\n"
"        Logger.warn \"Failed to get a result in #{timeout}ms\"\n"
"        nil\n"
"    end\n"
"\n"
"これにより、タスクが`timeout`の後だが、`shutdown/1`が呼び出される前に\n"
"完了した場合、結果が得られます。なぜなら、`shutdown/1`はこのようなケースを\n"
"処理して結果を返すように設計されているからです。\n"

#. TRANSLATORS: def Task.async_stream(enumerable, module, function, args, options \\ [])
#: lib/task.ex:285
msgid ""
"Returns a stream that runs the given `module`, `function` and `args`\n"
"concurrently on each item in `enumerable`.\n"
"\n"
"Each item will be appended to the given `args` and processed by its\n"
"own task. The tasks will be linked to an intermediate process that is\n"
"then linked to the current process. This means a failure in a task\n"
"terminates the current process and a failure in the current process\n"
"terminates all tasks.\n"
"\n"
"When streamed, each task will emit `{:ok, val}` upon successful\n"
"completion or `{:exit, val}` if the caller is trapping exits. Results\n"
"are emitted in the same order as the original `enumerable`.\n"
"\n"
"The level of concurrency can be controlled via the `:max_concurrency`\n"
"option and defaults to `System.schedulers_online/1`. The timeout\n"
"can also be given as option and defaults to 5000 and it defaults to\n"
"the maximum amount of time to wait without a task reply.\n"
"\n"
"Finally, consider using `Task.Supervisor.async_stream/6` to start tasks\n"
"under a supervisor. If you find yourself trapping exits to handle exits\n"
"inside the async stream, consider using `Task.Supervisor."
"async_stream_nolink/6`\n"
"to start tasks that are not linked to the current process.\n"
"\n"
"## Options\n"
"\n"
"  * `:max_concurrency` - sets the maximum number of tasks to run\n"
"    at the same time. Defaults to `System.schedulers_online/1`.\n"
"  * `:timeout` - the maximum amount of time to wait without\n"
"    receiving a task reply (across all running tasks).\n"
"\n"
"## Example\n"
"\n"
"Let's build a stream and then enumerate it:\n"
"\n"
"    stream = Task.async_stream(collection, Mod, :expensive_fun, [])\n"
"    Enum.to_list(stream)\n"
"\n"
"The concurrency can be increased or decreased using the `:max_concurrency`\n"
"option. For example, if the tasks are IO heavy, the value can be increased:\n"
"\n"
"    max_concurrency = System.schedulers_online * 2\n"
"    stream = Task.async_stream(collection, Mod, :expensive_fun, [], "
"max_concurrency: max_concurrency)\n"
"    Enum.to_list(stream)\n"
"\n"
msgstr ""
"`enumerable`の各項目について、指定された`module`,\n"
"`function`, `args`を並行に実行するストリームを返します。\n"
"\n"
"各項目は指定された`args`に追加され、各自のタスクで\n"
"処理されます。タスクは現在のプロセスにリンクされている\n"
"中間プロセスにリンクされます。これは1つのタスクの失敗が\n"
"現在のプロセスを終了させ、現在のプロセスの失敗が\n"
"すべてのタスクを終了させることを意味します。\n"
"\n"
"ストリーム化されている場合、各タスクは処理が成功すると`{:ok, val}`、\n"
"または呼び出し元がexitをトラップしている場合は`{:exit, val}`を出力します。\n"
"結果は元の`enumerable`と同じ順で出力されます。\n"
"\n"
"並行性のレベルは`:max_concurrency`オプションで調整でき、\n"
"デフォルトは`System.schedulers_online/0`です。タイムアウトも\n"
"オプションで指定することができ、デフォルトは5000です。これは\n"
"タスク応答なしで待機する最大時間のデフォルトです。\n"
"\n"
"最後に、`Task.Supervisor.async_stream/6`を使用して、スーパバイザ配下で\n"
"タスクを開始することを検討してください。非同期ストリーム内のexitを処理する\n"
"ためにexitのトラップを思いついた場合は、`Task.Supervisor."
"async_stream_nolink/6`を\n"
"使用して、現在のプロセスにリンクしないプロセスを開始することを検討してくださ"
"い。\n"
"\n"
"## オプション\n"
"\n"
"  * `:max_concurrency` - 同時に実行するタスクの最大値を\n"
"    設定します。デフォルトは`System.schedulers_online/0`です。\n"
"  * `:timeout` - タスク応答を受信することなく待機する\n"
"    最大の時間（実行中のすべてのタスクにわたる）\n"
"\n"
"## 例\n"
"\n"
"ストリームを作成して、列挙しよう:\n"
"\n"
"    stream = Task.async_stream(collection, Mod, :expensive_fun, [])\n"
"    Enum.to_list(stream)\n"
"\n"
"平行度は`:max_concurrency`オプションで増減できます。\n"
"たとえば、タスクIOが重い場合は値を増加することができます:\n"
"\n"
"    max_concurrency = System.schedulers_online * 2\n"
"    stream = Task.async_stream(collection, Mod, :expensive_fun, [], "
"max_concurrency: max_concurrency)\n"
"    Enum.to_list(stream)\n"
"\n"

#. TRANSLATORS: def Task.start_link(mod, fun, args)
#: lib/task.ex:163
msgid "Starts a task as part of a supervision tree.\n"
msgstr "監視ツリーの一部としてタスクを開始します。\n"

#. TRANSLATORS: def Task.async(fun)
#: lib/task.ex:195
msgid ""
"Starts a task that must be awaited on.\n"
"\n"
"This function spawns a process that is linked to and monitored\n"
"by the caller process. A `Task` struct is returned containing\n"
"the relevant information.\n"
"\n"
"Read the `Task` module documentation for more info on general\n"
"usage of `async/1` and `async/3`.\n"
"\n"
"See also `async/3`.\n"
msgstr ""
"待機が必要なタスクを開始します。\n"
"\n"
"この関数は、呼び出し元プロセスによりリンクされ、モニタされる、\n"
"プロセスを生成します。関連情報を含む`Task`構造体が\n"
"返されます。\n"
"\n"
"`async/1` と `async/3` の一斑的な使用法については、\n"
" `Task`モジュールのドキュメントを参照してください。\n"
"\n"
"`async/3`も参照してください。\n"

#. TRANSLATORS: def Task.async(mod, fun, args)
#: lib/task.ex:212
msgid ""
"Starts a task that must be awaited on.\n"
"\n"
"A `Task` struct is returned containing the relevant information.\n"
"Developers must eventually call `Task.await/2` or `Task.yield/2`\n"
"followed by `Task.shutdown/2` on the returned task.\n"
"\n"
"Read the `Task` module documentation for more info on general\n"
"usage of `async/1` and `async/3`.\n"
"\n"
"## Linking\n"
"\n"
"This function spawns a process that is linked to and monitored\n"
"by the caller process. The linking part is important because it\n"
"aborts the task if the parent process dies. It also guarantees\n"
"the code before async/await has the same properties after you\n"
"add the async call. For example, imagine you have this:\n"
"\n"
"    x = heavy_fun()\n"
"    y = some_fun()\n"
"    x + y\n"
"\n"
"Now you want to make the `heavy_fun()` async:\n"
"\n"
"    x = Task.async(&heavy_fun/0)\n"
"    y = some_fun()\n"
"    Task.await(x) + y\n"
"\n"
"As before, if `heavy_fun/0` fails, the whole computation will\n"
"fail, including the parent process. If you don't want the task\n"
"to fail then you must change the `heavy_fun/0` code in the\n"
"same way you would achieve it if you didn't have the async call.\n"
"For example, to either return `{:ok, val} | :error` results or,\n"
"in more extreme cases, by using `try/rescue`. In other words,\n"
"an asynchronous task should be thought of as an extension of a\n"
"process rather than a mechanism to isolate it from all errors.\n"
"\n"
"If you don't want to link the caller to the task, then you\n"
"must use a supervised task with `Task.Supervisor` and call\n"
"`Task.Supervisor.async_nolink/2`.\n"
"\n"
"In any case, avoid any of the following:\n"
"\n"
"  * Setting `:trap_exit` to `true` - trapping exits should be\n"
"    used only in special circumstances as it would make your\n"
"    process immune to not only exits from the task but from\n"
"    any other processes.\n"
"\n"
"    Moreover, even when trapping exits, calling `await` will\n"
"    still exit if the task has terminated without sending its\n"
"    result back.\n"
"\n"
"  * Unlinking the task process started with `async`/`await`.\n"
"    If you unlink the processes and the task does not belong\n"
"    to any supervisor, you may leave dangling tasks in case\n"
"    the parent dies.\n"
"\n"
"## Message format\n"
"\n"
"The reply sent by the task will be in the format `{ref, result}`,\n"
"where `ref` is the monitor reference held by the task struct\n"
"and `result` is the return value of the task function.\n"
msgstr ""
"待機が必要なタスクを起動します。\n"
"\n"
"関連情報を含む`Task`構造体が返されます。開発者は最終的には\n"
"返されたタスクに対して、`Task.await/2`か`Task.yield/2`を、\n"
"続けて`Task.shutdown/2`を呼び出さなければなりません。\n"
"\n"
"`async/1`と`async/3`の一般的な使用法については`Task`モジュールの\n"
"ドキュメントを読んでください。\n"
"\n"
"## リンク付け\n"
"\n"
"この関数は、呼び出し元プロセスによりリンクされ、モニタされる\n"
"プロセスを生成します。リンク部分は、親プロセスが\n"
"死んだ場合にタスクを停止させるので重要です。また、\n"
"非同期呼出しを追加した後にasync/awaitが同じ属性を持つ前に\n"
"コードを保証します。たとえば、これがあると想像してください:\n"
"\n"
"    x = heavy_fun()\n"
"    y = some_fun()\n"
"    x + y\n"
"\n"
"今、`heavy_fun()`を非同期にしたいとします:\n"
"\n"
"    x = Task.async(&heavy_fun/0)\n"
"    y = some_fun()\n"
"    Task.await(x) + y\n"
"\n"
"すでに述べたように、`heavy_fun/0`が失敗した場合、親プロセスを含む\n"
"計算全体が失敗します。 タスクを失敗させたくない場合は、非同期\n"
"呼び出しがない場合と同じ方法で`heavy_fun/0`を変更する必要が\n"
"あります。 たとえば、`{:ok, val} | :error`のいずれかの結果を返すか、\n"
"さらに極端な場合は`try/rescue`を使用します。言い替えると、\n"
"非同期タスクは、すべてのエラーからプロセスを分離するメカニズム\n"
"ではなく、プロセスの拡張として考える必要が\n"
"あります。\n"
"\n"
"呼び出し元をタスクにリンクしたくない場合は、`Task.Supervisor`で\n"
"監視タスクを使用して、`Task.Supervisor.async_nolink/2`を呼ぶ\n"
"必要があります。\n"
"\n"
"いずれにしても、次の方法はいずれも避けてください:\n"
"\n"
"  * `:trap_exit` を true にセットすること - exitのトラップは\n"
"    特別な状況でのみ使用するべきです。なぜなら、プロセスが\n"
"    タスクだけでなく、すべてのプロセスからexitしなくなるから\n"
"    です。\n"
"\n"
"    さらに、exitをトラップしても、結果を送り返すことなく\n"
"    タスクが終了した場合は、`await`の呼出しは終了します。\n"
"\n"
"  * `async`/`await`で起動したタスクプロセスのリンクの解除。\n"
"    プロセスをリンクを解除し、タスクがどのスーパバイザもにも\n"
"    属さなくなるああと、親が死んだ場合でもタスクが残ってしまう\n"
"    場合があります。\n"
"\n"
"## メッセージ形式\n"
"\n"
"タスクから送信される応答は`{ref, result}`の形式です。\n"
"ここで、`ref`はタスク構造体に保持されたモニタリファレンスで、\n"
"`result`はタスク関数の返り値です。\n"

#. TRANSLATORS: def Task.await(task, timeout \\ 5000)
#: lib/task.ex:366
msgid ""
"Awaits a task reply and returns it.\n"
"\n"
"A timeout, in milliseconds, can be given with default value\n"
"of `5000`. In case the task process dies, this function will\n"
"exit with the same reason as the task.\n"
"\n"
"If the timeout is exceeded, `await` will exit; however,\n"
"the task will continue to run. When the calling process exits, its\n"
"exit signal will terminate the task if it is not trapping exits.\n"
"\n"
"This function assumes the task's monitor is still active or the monitor's\n"
"`:DOWN` message is in the message queue. If it has been demonitored, or the\n"
"message already received, this function will wait for the duration of the\n"
"timeout awaiting the message.\n"
"\n"
"This function can only be called once for any given task. If you want\n"
"to be able to check multiple times if a long-running task has finished\n"
"its computation, use `yield/2` instead.\n"
"\n"
"## Compatibility with OTP behaviours\n"
"\n"
"It is not recommended to `await` a long-running task inside an OTP\n"
"behaviour such as `GenServer`. Instead, you should match on the message\n"
"coming from a task inside your `GenServer.handle_info/2` callback.\n"
"\n"
"## Examples\n"
"\n"
"    iex> task = Task.async(fn -> 1 + 1 end)\n"
"    iex> Task.await(task)\n"
"    2\n"
"\n"
msgstr ""
"タスクの応答を待ち、それを返します。\n"
"\n"
"ミリ秒単位のタイムアウトを指定できます。デフォルト値は`5000`です。\n"
"タスクプロセスが死んだ場合、この関数はタスクと同じ理由で\n"
"で終了します。\n"
"\n"
"タイムアウトを超えると、`await`は終了しますが、タスクは引き続き\n"
"実行されます。呼び出しプロセスが終了すると、終了シグナルを\n"
"トラップしていない限り、終了シグナルがタスクを終了させます。\n"
"\n"
"この関数は、タスクのモニタがまだ有効であるか、またはモニタの\n"
"`:DOWN`メッセージがメッセージキューにあることを前提としています。\n"
"モニタから外された、またはメッセージが既に受信されている場合、この\n"
"関数はメッセージ待ちのタイムアウト時間まで待機します。\n"
"\n"
"この関数は指定されたタスクに対して1回だけ呼び出すことができます。\n"
"長時間実行しているタスクの計算が終了したか否かを複数回チェックできる\n"
"ようにしたい場合は、代わりに`yield/2`を使ってください。\n"
"\n"
"\n"
"## OTPビヘイビアとの互換性\n"
"\n"
"`GenServer`などのOTPビヘイビアで長時間実行されるタスクを`await`する\n"
"ことは推奨しません。代わりに`GenServer.handle_info/2`コールバックの\n"
"中でタスクから来るメッセージを照合するべきです。\n"
"\n"
"## 例\n"
"\n"
"    iex> task = Task.async(fn -> 1 + 1 end)\n"
"    iex> Task.await(task)\n"
"    2\n"
"\n"
"\n"

#. TRANSLATORS: def Task.async_stream(enumerable, fun, options \\ [])
#: lib/task.ex:337
msgid ""
"Returns a stream that runs the given `function` concurrently on each\n"
"item in `enumerable`.\n"
"\n"
"Each `enumerable` item is passed as argument to the `function` and\n"
"processed by its own task. The tasks will be linked to the current\n"
"process, similar to `async/1`.\n"
"\n"
"See `async_stream/5` for discussion and examples.\n"
msgstr ""
"`enumerable`の各項目について、指定された`function`を\n"
"並行に実行するストリームを返します。\n"
"\n"
"`enumerable`の各項目は`function`に引数として渡され、\n"
"各自のタスクで処理されます。タスクは`async/1`と同様に\n"
"現在のプロセスにリンクされます。\n"
"\n"
"解説と例は`async_stream/5`を参照してください。\n"

#. TRANSLATORS: def Task.start(mod, fun, args)
#: lib/task.ex:183
msgid ""
"Starts a task.\n"
"\n"
"This is only used when the task is used for side-effects\n"
"(i.e. no interest in the returned result) and it should not\n"
"be linked to the current process.\n"
msgstr ""
"タスクを開始します。\n"
"\n"
"これはタスクを副作用のために使用する（すわわち、\n"
"返される結果には興味がない）場合にのみ使用します。\n"
"また、現在のプロセスにリンクするべきではありません。\n"

#. TRANSLATORS: def Task.__struct__()
#: lib/task.ex:138
msgid ""
"The Task struct.\n"
"\n"
"It contains these fields:\n"
"\n"
"  * `:pid` - the PID of the task process; `nil` if the task does\n"
"    not use a task process\n"
"\n"
"  * `:ref` - the task monitor reference\n"
"\n"
"  * `:owner` - the PID of the process that started the task\n"
"\n"
msgstr ""
"タスク構造体。\n"
"\n"
"次の3つのフィールドを含みます:\n"
"\n"
"  * `:pid` - タスクプロセスのPID; タスクがタスクプロセスを使用して\n"
"    いない場合は`nil`。\n"
"\n"
"  * `:ref` - タスクモニタのリファレンス\n"
"\n"
"  * `:owner` - タスクを開始したプロセスのPID\n"
"\n"

#. TRANSLATORS: def Task.yield_many(tasks, timeout \\ 5000)
#: lib/task.ex:509
msgid ""
"Yields to multiple tasks in the given time interval.\n"
"\n"
"This function receives a list of tasks and waits for their\n"
"replies in the given time interval. It returns a list\n"
"of tuples of two elements, with the task as the first element\n"
"and the yielded result as the second.\n"
"\n"
"Similarly to `yield/2`, each task's result will be\n"
"\n"
"  * `{:ok, term}` if the task has successfully reported its\n"
"    result back in the given time interval\n"
"  * `{:exit, reason}` if the task has died\n"
"  * `nil` if the task keeps running past the timeout\n"
"\n"
"Check `yield/2` for more information.\n"
"\n"
"## Example\n"
"\n"
"`Task.yield_many/2` allows developers to spawn multiple tasks\n"
"and retrieve the results received in a given timeframe.\n"
"If we combine it with `Task.shutdown/2`, it allows us to gather\n"
"those results and cancel the tasks that have not replied in time.\n"
"\n"
"Let's see an example.\n"
"\n"
"    tasks =\n"
"      for i <- 1..10 do\n"
"        Task.async(fn ->\n"
"          Process.sleep(i * 1000)\n"
"          i\n"
"        end)\n"
"      end\n"
"\n"
"    tasks_with_results = Task.yield_many(tasks, 5000)\n"
"\n"
"    results = Enum.map(tasks_with_results, fn {task, res} ->\n"
"      # Shutdown the tasks that did not reply nor exit\n"
"      res || Task.shutdown(task, :brutal_kill)\n"
"    end)\n"
"\n"
"    # Here we are matching only on {:ok, value} and\n"
"    # ignoring {:exit, _} (crashed tasks) and `nil` (no replies)\n"
"    for {:ok, value} <- results do\n"
"      IO.inspect value\n"
"    end\n"
"\n"
"In the example above, we create tasks that sleep from 1\n"
"up to 10 seconds and return the amount of seconds they slept.\n"
"If you execute the code all at once, you should see 1 up to 5\n"
"printed, as those were the tasks that have replied in the\n"
"given time. All other tasks will have been shut down using\n"
"the `Task.shutdown/2` call.\n"
msgstr ""
"指定された時間間隔で複数回タスクを呼び出します。\n"
"\n"
"この関数はタスクのリストを受取り、指定された\n"
"時間感覚でタスクからの応答を待ちます。2要素の\n"
"タプルを返します。その第1要素はタスクで、第2要素は\n"
"実行結果です。\n"
"\n"
"`yield/2`同様、各タスクの結果は次のようになります:\n"
"\n"
"  * `{:ok, term}` 指定された時間間隔内に結果を正常に\n"
"    報告した場合\n"
"  * `{:exit, reason}` タスクが死んだ場合\n"
"  * `nil` タイムアウトを過ぎても実行中の場合\n"
"\n"
"詳細は`yield/2`をチェックしてください。\n"
"\n"
"## 例\n"
"\n"
"`Task.yield_many/2`により、複数のタスクを生成し、指定された\n"
"時間間隔内に受信された結果を取得することができます。\n"
"`Task.shutdown/2`と組み合わせることで、結果を収集して\n"
"時間内に応答しなかったタスクを取り消すことができます。\n"
"\n"
"例を見てみましょう。\n"
"\n"
"    tasks =\n"
"      for i <- 1..10 do\n"
"        Task.async(fn ->\n"
"          Process.sleep(i * 1000)\n"
"          i\n"
"        end)\n"
"      end\n"
"\n"
"    tasks_with_results = Task.yield_many(tasks, 5000)\n"
"\n"
"    results = Enum.map(tasks_with_results, fn {task, res} ->\n"
"      # 応答を返さず、終了もしていないタスクをシャットダウンする\n"
"      res || Task.shutdown(task, :brutal_kill)\n"
"    end)\n"
"\n"
"    # ここでは {:ok, value} とだけ照合を行い\n"
"    # {:exit, _}（クラッシュしたタスク）と`nil`（応答なし）は無視する\n"
"    for {:ok, value} <- results do\n"
"      IO.inspect value\n"
"    end\n"
"\n"
"上の例では、1秒から10秒スリープして、スリープした秒数を\n"
"返すタスクを作成しています。\n"
"上のコードを一度にすべて実行すると、1から5までを見ることになります。\n"
"それらが指定した時間内に応答したタスクだからです。その他の\n"
"タスクは`Task.shutdown/2` を呼び出すことでシャットダウン\n"
"させられています。\n"

#. TRANSLATORS: def Task.shutdown(task, shutdown \\ 5000)
#: lib/task.ex:608
msgid ""
"Unlinks and shuts down the task, and then checks for a reply.\n"
"\n"
"Returns `{:ok, reply}` if the reply is received while shutting down the "
"task,\n"
"`{:exit, reason}` if the task died, otherwise `nil`.\n"
"\n"
"The shutdown method is either a timeout or `:brutal_kill`. In case\n"
"of a `timeout`, a `:shutdown` exit signal is sent to the task process\n"
"and if it does not exit within the timeout, it is killed. With `:"
"brutal_kill`\n"
"the task is killed straight away. In case the task terminates abnormally\n"
"(possibly killed by another process), this function will exit with the same "
"reason.\n"
"\n"
"It is not required to call this function when terminating the caller, "
"unless\n"
"exiting with reason `:normal` or if the task is trapping exits. If the "
"caller is\n"
"exiting with a reason other than `:normal` and the task is not trapping "
"exits, the\n"
"caller's exit signal will stop the task. The caller can exit with reason\n"
"`:shutdown` to shutdown all of its linked processes, including tasks, that\n"
"are not trapping exits without generating any log messages.\n"
"\n"
"If a task's monitor has already been demonitored or received  and there is "
"not\n"
"a response waiting in the message queue this function will return\n"
"`{:exit, :noproc}` as the result or exit reason can not be determined.\n"
msgstr ""
"タスクのリンクを解除してシャットダウンし、応答をチェックします。\n"
"\n"
"タスクのシャットダウン中に応答があった場合は`{:ok, reply}`を、\n"
"タスクが死んだ場合は`{:exit, reason}`を、そうでない場合は`nil`を返します。\n"
"\n"
"シャットダウンさせる方法はタイムアウトか`:brutal_kill`のいずれかです。\n"
"`timeout`の場合、`:shutdown`終了シグナルがタスクプロセスに送信され、\n"
"タイムアウト時間内に終了しない場合は、強制終了させられます。`:brutal_kill`"
"の\n"
"場合は、直ちに強制終了させられます。タスクが異常終了した（おそらく別のプロ\n"
"セスにより強制終了させられた）場合は、この関数は同じ理由で終了します。\n"
"\n"
"理由`:normal`で終了する場合を除いて、またはタスクが終了をトラップしている場合"
"は\n"
"呼び出し元を終了するときにこの関数を呼び出す必要はありません。\n"
"呼び出し元が`:normal`以外の理由で終了し、タスクが終了をトラップして\n"
"いない場合は、呼び出し元の終了シグナルはタスクを停止します。\n"
"呼び出し元は、終了をトラップしていない、タスクを含むリンクされて\n"
"いるすべてのプロセスをログメッセージを生成することなくシャットダウン\n"
"するために、理由`:shutdown`でシャットダウンすることができます。\n"
"\n"
"タスクのモニタがすでに外されている場合、または応答を受信済みで\n"
"メッセージキューに応答が存在しない場合、この関数は`{:exit, :noproc}`を\n"
"返します。結果あるいは終了理由を決めることができないからです。\n"

#~ msgid ""
#~ "Receives a group of tasks and a message and finds\n"
#~ "a task that matches the given message.\n"
#~ "\n"
#~ "This function returns a tuple with the returned value\n"
#~ "in case the message matches a task that exited with\n"
#~ "success alongside the matching task. It returns `nil`\n"
#~ "if no task was found. It exits if the task has failed.\n"
#~ "\n"
#~ "This function is useful in situations where multiple\n"
#~ "tasks are spawned and their results are collected\n"
#~ "later on. For example, a `GenServer` can spawn tasks,\n"
#~ "store the tasks in a list and later use `Task.find/2`\n"
#~ "to see if incoming messages are from any of the tasks.\n"
#~ msgstr ""
#~ "タスクとメッセージのグループを受け取り、与えられたメッセージ\n"
#~ "にマッチするタスクを見付けます。\n"
#~ "\n"
#~ "この関数は、タスク付のタプルを返し、返された値は成功して終了\n"
#~ "したタスクにマッチするメッセージです。タスクが見付けられない\n"
#~ "時は、`nil`を返します。タスクが失敗したときは、exitします。\n"
#~ "\n"
#~ "この関数は、複数のタスクが生成され、それらの結果をあとで集め\n"
#~ "るというシチュエーションで、便利です。例えば、`GenServer`はタ\n"
#~ "スクを生成することができ、タスクをリストに格納して、他のタス\n"
#~ "クからのメッセージが来たかどうかを知るために、後で\n"
#~ "`Task.find/2`を使うことが出来ます。\n"

#~ msgid ""
#~ "Receives a group of tasks and a message and finds\n"
#~ "a task that matches the given message.\n"
#~ "\n"
#~ "This function returns a tuple with the returned value\n"
#~ "in case the message matches a task that exited with\n"
#~ "success alongside the matching task. It raises in case\n"
#~ "the found task failed or `nil` if no task was found.\n"
#~ "\n"
#~ "This function is useful in situations where multiple\n"
#~ "tasks are spawned and their results are collected\n"
#~ "later on. For example, a `GenServer` can spawn tasks,\n"
#~ "store the tasks in a list and later use `Task.find/2`\n"
#~ "to see if incoming messages are from any of the tasks.\n"
#~ "\n"
#~ "## Examples\n"
#~ "\n"
#~ "    defmodule TaskFinder do\n"
#~ "      def run do\n"
#~ "        task1 = Task.async fn -> :timer.sleep(1000); 1 end\n"
#~ "        task2 = Task.async fn -> :timer.sleep(5000); 2 end\n"
#~ "        await [task1, task2]\n"
#~ "      end\n"
#~ "\n"
#~ "      # Be careful, this will receive all messages sent\n"
#~ "      # to this process. It will return the first task\n"
#~ "      # reply and the list of tasks that came second.\n"
#~ "      def await(tasks) do\n"
#~ "        receive do\n"
#~ "          message ->\n"
#~ "            case Task.find(tasks, message) do\n"
#~ "              {reply, task} ->\n"
#~ "                {reply, List.delete(tasks, task)}\n"
#~ "              nil ->\n"
#~ "                await(tasks)\n"
#~ "            end\n"
#~ "        end\n"
#~ "      end\n"
#~ "    end\n"
#~ "\n"
#~ "    TaskFinder.run\n"
#~ msgstr ""
#~ "一群のタスクとメッセージを受けて、そのメッセージ\n"
#~ "にマッチするタスクを見付けます。\n"
#~ "\n"
#~ "この関数は、\n"
#~ "マッチしたタスクが処理に成功して終了した場合に\n"
#~ "備えて、そのタスクが返した値とタスクのタプルを返します。\n"
#~ "タスクが失敗を見付けたら、例外を上げ、タスクが見付\n"
#~ "からない場合、`nil`を返します。\n"
#~ "\n"
#~ "この関数は複数のタスクを生成し、それらの結果を後で\n"
#~ "集めるときに便利です。例えば、`GenServer`が\n"
#~ "タスクを生成し、リストにタスクを保存しておき、\n"
#~ "後で、そららのタスクからメッセージを受信したとき\n"
#~ "`Task.find/2`を使います。\n"
#~ "\n"
#~ "## Examples\n"
#~ "\n"
#~ "    defmodule TaskFinder do\n"
#~ "      def run do\n"
#~ "        task1 = Task.async fn -> :timer.sleep(1000); 1 end\n"
#~ "        task2 = Task.async fn -> :timer.sleep(5000); 2 end\n"
#~ "        await [task1, task2]\n"
#~ "      end\n"
#~ "\n"
#~ "      # Be careful, this will receive all messages sent\n"
#~ "      # to this process. It will return the first task\n"
#~ "      # reply and the list of tasks that came second.\n"
#~ "      def await(tasks) do\n"
#~ "        receive do\n"
#~ "          message ->\n"
#~ "            case Task.find(tasks, message) do\n"
#~ "              {reply, task} ->\n"
#~ "                {reply, List.delete(tasks, task)}\n"
#~ "              nil ->\n"
#~ "                await(tasks)\n"
#~ "            end\n"
#~ "        end\n"
#~ "      end\n"
#~ "    end\n"
#~ "\n"
#~ "    TaskFinder.run\n"

#~ msgid ""
#~ "Starts a task that can be awaited on.\n"
#~ "\n"
#~ "Similar to `async/1`, but the task is specified by the given\n"
#~ "module, function and arguments.\n"
#~ msgstr ""
#~ "待機することができるタスクを開始します。\n"
#~ "\n"
#~ "`async/1`と似ていますが、タスクは与えられたモジュール、関数\n"
#~ "および引数により指定されます。\n"

#~ msgid ""
#~ "Awaits a task reply.\n"
#~ "\n"
#~ "A timeout, in milliseconds, can be given with default value\n"
#~ "of `5000`. In case the task process dies, this function will\n"
#~ "exit with the same reason as the task.\n"
#~ msgstr ""
#~ "タスクの応答を待ちます。\n"
#~ "\n"
#~ "タイムアウト(ミリ秒)を与えることができ、デフォルト値は`5000`です。\n"
#~ "タスクプロセスが死んだ場合、この関数は、\n"
#~ "そのタスクと同じreasonでexitします。\n"

#~ msgid ""
#~ "Conveniences for spawning and awaiting for tasks.\n"
#~ "\n"
#~ "Tasks are processes meant to execute one particular\n"
#~ "action throughout their life-cycle, often with little or no\n"
#~ "communication with other processes. The most common use case\n"
#~ "for tasks is to compute a value asynchronously:\n"
#~ "\n"
#~ "    task = Task.async(fn -> do_some_work() end)\n"
#~ "    res  = do_some_other_work()\n"
#~ "    res + Task.await(task)\n"
#~ "\n"
#~ "Tasks spawned with `async` can be awaited on by its caller\n"
#~ "process (and only its caller) as shown in the example above.\n"
#~ "They are implemented by spawning a process that sends a message\n"
#~ "to the caller once the given computation is performed.\n"
#~ "\n"
#~ "Besides `async/1` and `await/2`, tasks can also be\n"
#~ "started as part of supervision trees and dynamically spawned\n"
#~ "in remote nodes. We will explore all three scenarios next.\n"
#~ "\n"
#~ "## async and await\n"
#~ "\n"
#~ "The most common way to spawn a task is with `Task.async/1`. A new\n"
#~ "process will be created, linked and monitored by the caller. Once\n"
#~ "the task action finishes, a message will be sent to the caller\n"
#~ "with the result.\n"
#~ "\n"
#~ "`Task.await/2` is used to read the message sent by the task. On\n"
#~ "`await`, Elixir will also setup a monitor to verify if the process\n"
#~ "exited for any abnormal reason (or in case exits are being\n"
#~ "trapped by the caller).\n"
#~ "\n"
#~ "## Supervised tasks\n"
#~ "\n"
#~ "It is also possible to spawn a task inside a supervision tree\n"
#~ "with `start_link/1` and `start_link/3`:\n"
#~ "\n"
#~ "    Task.start_link(fn -> IO.puts \"ok\" end)\n"
#~ "\n"
#~ "Such tasks can be mounted in your supervision tree as:\n"
#~ "\n"
#~ "    import Supervisor.Spec\n"
#~ "\n"
#~ "    children = [\n"
#~ "      worker(Task, [fn -> IO.puts \"ok\" end])\n"
#~ "    ]\n"
#~ "\n"
#~ "Since these tasks are supervised and not directly linked to\n"
#~ "the caller, they cannot be awaited on. Note `start_link/1`,\n"
#~ "unlike `async/1`, returns `{:ok, pid}` (which is\n"
#~ "the result expected by supervision trees).\n"
#~ "\n"
#~ "## Supervision trees\n"
#~ "\n"
#~ "The `Task.Supervisor` module allows developers to start supervisors\n"
#~ "that dynamically supervise tasks:\n"
#~ "\n"
#~ "    {:ok, pid} = Task.Supervisor.start_link()\n"
#~ "    Task.Supervisor.async(pid, MyMod, :my_fun, [arg1, arg2, arg3])\n"
#~ "\n"
#~ "`Task.Supervisor` also makes it possible to spawn tasks in remote nodes "
#~ "as\n"
#~ "long as the supervisor is registered locally or globally:\n"
#~ "\n"
#~ "    # In the remote node\n"
#~ "    Task.Supervisor.start_link(name: :tasks_sup)\n"
#~ "\n"
#~ "    # In the client\n"
#~ "    Task.Supervisor.async({:tasks_sup, :remote@local}, MyMod, :my_fun, "
#~ "[arg1, arg2, arg3])\n"
#~ "\n"
#~ "`Task.Supervisor` is more often started in your supervision tree as:\n"
#~ "\n"
#~ "    import Supervisor.Spec\n"
#~ "\n"
#~ "    children = [\n"
#~ "      supervisor(Task.Supervisor, [[name: :tasks_sup]])\n"
#~ "    ]\n"
#~ "\n"
#~ "Note that, when working with distributed tasks, one should use the "
#~ "`async/3` API,\n"
#~ "that expects explicit module, function and arguments, instead of "
#~ "`async/1` that\n"
#~ "works with anonymous functions. That's because the anonymous function API "
#~ "expects\n"
#~ "the same module version to exist on all involved nodes. Check the `Agent` "
#~ "module\n"
#~ "documentation for more information on distributed processes, as the "
#~ "limitations\n"
#~ "described in the agents documentation apply to the whole ecosystem.\n"
#~ "\n"
#~ "Finally, check `Task.Supervisor` for other operations supported by the "
#~ "Task\n"
#~ "supervisor.\n"
#~ msgstr ""
#~ "タスクの生成と、待ち受けに便利なものです。\n"
#~ "\n"
#~ "タスクは、そのライフサイクルを通して、一つの特定の活動を実行するはずの\n"
#~ "プロセスです。そのプロセスは、しばしば、少しだけ、または全く他のプロセ\n"
#~ "スとコミュニケーションをとりません。\n"
#~ "タスクのための最も一般的なユースケースは、\n"
#~ "非同期的に値を計算することです:\n"
#~ "\n"
#~ "    task = Task.async(fn -> do_some_work() end)\n"
#~ "    res  = do_some_other_work()\n"
#~ "    res + Task.await(task)\n"
#~ "\n"
#~ "`async`により生み出されたタスクは、上の例で見られるように、\n"
#~ "呼び出しプロセス(そしてその呼び出し側だけに)により待たれます。\n"
#~ "一度与えられた計算が実行されるなら、呼び出し側に\n"
#~ "メッセージを送信するプロセスを生み出すことによって、それらは\n"
#~ "実装されます。\n"
#~ "\n"
#~ "`async/1`と`await/2`の他に、タスクはスーパビジョンツリー\n"
#~ "の一部として開始したり、リモートノードで動的に生み出すことも\n"
#~ "出来ます。次に、全3つのシナリオを調査します。\n"
#~ "\n"
#~ "## async and await\n"
#~ "\n"
#~ "タスクを生む最も一般的な方法は`Task.async/1`です。新しい\n"
#~ "プロセスが作成され、呼び出し側によりリンクされ、モニタされます。\n"
#~ "一度タスクのアクションが終了したら、結果として呼び出し側に\n"
#~ "メッセージが送信されます。\n"
#~ "\n"
#~ "`Task.await/2`はタスクにより送信されたメッセージを読み出すために使われ\n"
#~ "ます。`await`で、Elixirは、プロセスが異常な理由でexitしているかどうか\n"
#~ "(または、呼び出し側によりトラップされるexitしているかどうか)、検証する\n"
#~ "ためのモニタをセットアップします。\n"
#~ "\n"
#~ "## Supervised tasks\n"
#~ "\n"
#~ "`start_link/2`と`start_link/3`でスーパビジョンツリーの内でタスクを\n"
#~ "生み出すこともできます:\n"
#~ "\n"
#~ "    Task.start_link(fn -> IO.puts \"ok\" end)\n"
#~ "\n"
#~ "そのようなタスクは以下のようにして、スーパビジョンツリーに\n"
#~ "取り付けることもできます:\n"
#~ "\n"
#~ "    import Supervisor.Spec\n"
#~ "\n"
#~ "    children = [\n"
#~ "      worker(Task, [fn -> IO.puts \"ok\" end])\n"
#~ "    ]\n"
#~ "\n"
#~ "これらのタスクはスーパバイズされ、直接呼び出し側にリンクされて\n"
#~ "いないので、awaitで待つことが出来ません。\n"
#~ "`start_link/1`(`async/1`と違って)は、`{:ok, pid}`\n"
#~ "(スーバビジョンツリーにより期待される結果です)を返すことに\n"
#~ "注意してください。\n"
#~ "\n"
#~ "## Supervision trees\n"
#~ "\n"
#~ "`Task.Supervisor`モジュールは、開発者に、\n"
#~ "動的にタスクをスーパバイズするスーパバイザを開始することを許します:\n"
#~ "\n"
#~ "    {:ok, pid} = Task.Supervisor.start_link()\n"
#~ "    Task.Supervisor.async(pid, MyMod, :my_fun, [arg1, arg2, arg3])\n"
#~ "\n"
#~ "スーパバイザがローカルまたは、グローバルに登録される限り、\n"
#~ "`Task.Supervisor`もまた、リモートノードでタスクを生むことを可能にします:\n"
#~ "\n"
#~ "    # In the remote node\n"
#~ "    Task.Supervisor.start_link(name: :tasks_sup)\n"
#~ "\n"
#~ "    # In the client\n"
#~ "    Task.Supervisor.async({:tasks_sup, :remote@local}, MyMod, :my_fun, "
#~ "[arg1, arg2, arg3])\n"
#~ "\n"
#~ "`Task.Supervisor`は、スーバビジョンツリーでよりしばしば開始されます:\n"
#~ "\n"
#~ "    import Supervisor.Spec\n"
#~ "\n"
#~ "    children = [\n"
#~ "      supervisor(Task.Supervisor, [[name: :tasks_sup]])\n"
#~ "    ]\n"
#~ "\n"
#~ "なお、分散されたタスクで動くとき、無名関数を動かす`async/1`のかわりに、\n"
#~ "モジュール、関数、引数を明示的に期待する、`async/3`APIを使うべきです。\n"
#~ "これは、無名関数APIは全ての起動されたノードで同じモジュールバージョンが\n"
#~ "存在することを期待するためです。\n"
#~ "全エコシステムに適用される、エージェントドキュメントで記述される制限として"
#~ "の、\n"
#~ "分散プロセスの詳細は、`Agent`モジュールドキュメントをチェックしてくださ"
#~ "い。\n"
#~ "\n"
#~ "最後に、他のタスクスーパバイザによりサポートされるオペレーションについて\n"
#~ "の詳細は、 `Task.Supervisor` をチェックしてください。\n"
