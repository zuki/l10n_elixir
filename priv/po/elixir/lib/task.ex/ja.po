msgid ""
msgstr ""
"Project-Id-Version: l 10n_elixir\n"
"PO-Revision-Date: 2017-01-31 16:14+0900\n"
"Last-Translator: 小田 照敬 <EMAIL@ADDRESS>\n"
"Language-Team: Japanese\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"POT-Creation-Date: \n"
"X-Generator: Poedit 1.8.11\n"

#. TRANSLATORS: Elixir.Task Summary
#: lib/task.ex:2
msgid ""
"Conveniences for spawning and awaiting tasks.\n"
"\n"
"Tasks are processes meant to execute one particular\n"
"action throughout their lifetime, often with little or no\n"
"communication with other processes. The most common use case\n"
"for tasks is to convert sequential code into concurrent code\n"
"by computing a value asynchronously:\n"
"\n"
"    task = Task.async(fn -> do_some_work() end)\n"
"    res  = do_some_other_work()\n"
"    res + Task.await(task)\n"
"\n"
"Tasks spawned with `async` can be awaited on by their caller\n"
"process (and only their caller) as shown in the example above.\n"
"They are implemented by spawning a process that sends a message\n"
"to the caller once the given computation is performed.\n"
"\n"
"Besides `async/1` and `await/2`, tasks can also be\n"
"started as part of a supervision tree and dynamically spawned\n"
"on remote nodes. We will explore all three scenarios next.\n"
"\n"
"## async and await\n"
"\n"
"One of the common uses of tasks is to convert sequential code\n"
"into concurrent code with `Task.async/1` while keeping its semantics.\n"
"When invoked, a new process will be created, linked and monitored\n"
"by the caller. Once the task action finishes, a message will be sent\n"
"to the caller with the result.\n"
"\n"
"`Task.await/2` is used to read the message sent by the task.\n"
"\n"
"There are two important things to consider when using `async`:\n"
"\n"
"  1. If you are using async tasks, you **must await** a reply\n"
"     as they are *always* sent. If you are not expecting a reply,\n"
"     consider using `Task.start_link/1` detailed below.\n"
"\n"
"  2. async tasks link the caller and the spawned process. This\n"
"     means that, if the caller crashes, the task will crash\n"
"     too and vice-versa. This is on purpose: if the process\n"
"     meant to receive the result no longer exists, there is\n"
"     no purpose in completing the computation.\n"
"\n"
"     If this is not desired, use `Task.start/1` or consider starting\n"
"     the task under a `Task.Supervisor` using `async_nolink` or\n"
"     `start_child`.\n"
"\n"
"`Task.yield/2` is an alternative to `await/2` where the caller will\n"
"temporarily block, waiting until the task replies or crashes. If the\n"
"result does not arrive within the timeout, it can be called again at a\n"
"later moment. This allows checking for the result of a task multiple\n"
"times. If a reply does not arrive within the desired time,\n"
"`Task.shutdown/2` can be used to stop the task.\n"
"\n"
"## Supervised tasks\n"
"\n"
"It is also possible to spawn a task under a supervisor\n"
"with `start_link/1` and `start_link/3`:\n"
"\n"
"    Task.start_link(fn -> IO.puts \"ok\" end)\n"
"\n"
"Such tasks can be mounted in your supervision tree as:\n"
"\n"
"    import Supervisor.Spec\n"
"\n"
"    children = [\n"
"      worker(Task, [fn -> IO.puts \"ok\" end])\n"
"    ]\n"
"\n"
"Since these tasks are supervised and not directly linked to\n"
"the caller, they cannot be awaited on. Note `start_link/1`,\n"
"unlike `async/1`, returns `{:ok, pid}` (which is\n"
"the result expected by supervision trees).\n"
"\n"
"By default, most supervision strategies will try to restart\n"
"a worker after it exits regardless of the reason. If you design the\n"
"task to terminate normally (as in the example with `IO.puts/2` above),\n"
"consider passing `restart: :transient` in the options to `Supervisor.Spec."
"worker/3`.\n"
"\n"
"## Dynamically supervised tasks\n"
"\n"
"The `Task.Supervisor` module allows developers to dynamically\n"
"create multiple supervised tasks.\n"
"\n"
"A short example is:\n"
"\n"
"    {:ok, pid} = Task.Supervisor.start_link()\n"
"    task = Task.Supervisor.async(pid, fn ->\n"
"      # Do something\n"
"    end)\n"
"    Task.await(task)\n"
"\n"
"However, in the majority of cases, you want to add the task supervisor\n"
"to your supervision tree:\n"
"\n"
"    import Supervisor.Spec\n"
"\n"
"    children = [\n"
"      supervisor(Task.Supervisor, [[name: MyApp.TaskSupervisor]])\n"
"    ]\n"
"\n"
"Now you can dynamically start supervised tasks:\n"
"\n"
"    Task.Supervisor.start_child(MyApp.TaskSupervisor, fn ->\n"
"      # Do something\n"
"    end)\n"
"\n"
"Or even use the async/await pattern:\n"
"\n"
"    Task.Supervisor.async(MyApp.TaskSupervisor, fn ->\n"
"      # Do something\n"
"    end) |> Task.await()\n"
"\n"
"Finally, check `Task.Supervisor` for other supported operations.\n"
"\n"
"## Distributed tasks\n"
"\n"
"Since Elixir provides a Task supervisor, it is easy to use one\n"
"to dynamically spawn tasks across nodes:\n"
"\n"
"    # On the remote node\n"
"    Task.Supervisor.start_link(name: MyApp.DistSupervisor)\n"
"\n"
"    # On the client\n"
"    Task.Supervisor.async({MyApp.DistSupervisor, :remote@local},\n"
"                          MyMod, :my_fun, [arg1, arg2, arg3])\n"
"\n"
"Note that, when working with distributed tasks, one should use the `Task."
"Supervisor.async/4` function\n"
"that expects explicit module, function and arguments, instead of `Task."
"Supervisor.async/2` that\n"
"works with anonymous functions. That's because anonymous functions expect\n"
"the same module version to exist on all involved nodes. Check the `Agent` "
"module\n"
"documentation for more information on distributed processes as the "
"limitations\n"
"described there apply to the whole ecosystem.\n"
msgstr ""
"タスクの生成と処理待ちに便利ツールです。\n"
"\n"
"タスクとは、そのライフサイクルを通じて特定のアクションを\n"
"実行するプロセスであり、多くの場合、他のプロセスとはほとんど\n"
"通信しません。タスクの最も一般的なユースケースは、値を非同期的に\n"
"計算することによる、逐次コードを並行コードに変換することです。\n"
"\n"
"    task = Task.async(fn -> do_some_work() end)\n"
"    res  = do_some_other_work()\n"
"    res + Task.await(task)\n"
"\n"
"`async`で生成されたタスクは、上の例が示すように、呼び出し元\n"
"プロセスで(そして呼び出し元だけで)待つことができます。 タスクは\n"
"指定された計算が実行されると、呼び出し元にメッセージを送信する\n"
"プロセスを生成することによって実装されます。\n"
"\n"
"`async/1`と`await/2`以外にも、タスクは、監視ツリーの一部として\n"
"起動されたり、リモートノードで動的に起動されたりすることも\n"
"できます。\n"
"\n"
"## asyncとawait\n"
"\n"
"タスクの一般的な用途の1つは、セマンティクスを保ったまま\n"
"`Task.async/1`を使用して逐次コードを並行コードに変換する\n"
"ことです。起動されると、新しいプロセスが作成され、呼び出し元に\n"
"リンクされ監視されます。タスクアクションが終了すると結果と共に\n"
"呼び出し元にメッセージが送信されます。\n"
"\n"
"`Task.await/2`はタスクから送信されたメッセージを読むために使\n"
"われます。\n"
"\n"
"`async`を使用する際には、次の2点を考慮する必要があります。\n"
"\n"
"  1. asyncタスクを使用する場合、 応答が*常に* 送信されるので、\n"
"     それを*待たなければなりません*。応答を期待しない場合は、\n"
"     以下で説明する`Task.start_link/1` の使用を検討してください。\n"
"\n"
"  2. asyncタスクは呼び出し元と生成されたプロセスをリンクします。\n"
"     これは、呼び出し元がクラッシュしたらタスクもクラッシュし、\n"
"     逆もまた同じであることを意味します。これは意図的なものです。\n"
"     結果を受信するはずのプロセスがもはや存在しないなら、\n"
"     計算を完了する意味がないからです。\n"
"\n"
"     これを望まない場合は、`Task.start/1`を使用するか、`async_nolink`\n"
"     または`start_child`を使用して`Task.Supervisor`の下でタスクを起動\n"
"     することを考慮してください。\n"
"\n"
"`Task.yield/2`は`await/2`の代替関数で、呼び出し元が一時的に\n"
"ブロックし、タスクが応答またはクラッシュするまで待機します。\n"
"結果がタイムアウト時間内に到着しない場合は、後で再度呼び出す\n"
"ことができます。これにより、タスクの結果を何度も確認することが\n"
"できます。応答が望み通りの時間内に到着しない場合は、\n"
"`Task.shutdown/2`を使用してタスクを停止できます。\n"
"\n"
"## 監視されるタスク\n"
"\n"
"`start_link/1`と`start_link/3`を使用することで、\n"
"スーパーバイザ配下でタスクを起動することもできます。\n"
"\n"
"    Task.start_link(fn -> IO.puts \"ok\" end)\n"
"\n"
"そのようなタスクは次のように監視ツリーにマウントできます:\n"
"\n"
"    import Supervisor.Spec\n"
"\n"
"    children = [\n"
"      worker(Task, [fn -> IO.puts \"ok\" end])\n"
"    ]\n"
"\n"
"これらのタスクは監視され、呼び出し元には直接リンクされませんので\n"
"待つことはできません。。`start_link/1`は`async/1`と違って、\n"
"`{:ok, pid}`(これは監視ツリーにより期待される結果です)を返す\n"
"ことに注意してください。\n"
"\n"
"デフォルトでは、ほとんどの監視戦略は理由に関わらず、終了後に\n"
"ワーカーの再起動を試みます。タスクを正常に終了するに設計する\n"
"場合は、(上の`IO.puts/2`の例のように)、`Supervisor.Spec.worker/3`への\n"
"オプションに`restart: :transient`を渡すことを検討してください。\n"
"\n"
"## 動的に監視されるタスク\n"
"\n"
"`Task.Supervisor`モジュールは、監視されるタスクを動的に複数\n"
"作成することを可能にしてます。\n"
"\n"
"短かい例は次の通りです:\n"
"\n"
"    {:ok, pid} = Task.Supervisor.start_link()\n"
"    task = Task.Supervisor.async(pid, fn ->\n"
"      # 何か行う\n"
"    end)\n"
"    Task.await(task)\n"
"\n"
"しかし、ほとんどの場合、監視ツリーにタスクスーパーバイザを追加\n"
"したいと思うでしょう。\n"
"\n"
"    import Supervisor.Spec\n"
"\n"
"    children = [\n"
"      supervisor(Task.Supervisor, [[name: MyApp.TaskSupervisor]])\n"
"    ]\n"
"\n"
"これで監視されたタスクを動的に開始できます:\n"
"\n"
"    Task.Supervisor.start_child(MyApp.TaskSupervisor, fn ->\n"
"      # 何かをする\n"
"    end)\n"
"\n"
"または、async/awaitパターンを使うこともできます:\n"
"\n"
"    Task.Supervisor.async(MyApp.TaskSupervisor, fn ->\n"
"      # 何かする\n"
"    end) |> Task.await()\n"
"\n"
"最後に、サポートされている他のオペレーションは`Task.Supervisor`で\n"
"チェックしてください。\n"
"\n"
"## 分散タスク\n"
"\n"
"ElixirはTaskスーパーバイザを提供していますので、それを使用することで\n"
"ノードを越えてタスクを動的に生成することは簡単です。:\n"
"\n"
"    # リモートノードにおいて\n"
"    Task.Supervisor.start_link(name: MyApp.DistSupervisor)\n"
"\n"
"    # クライアントにおいて\n"
"    Task.Supervisor.async({MyApp.DistSupervisor, :remote@local},\n"
"                          MyMod, :my_fun, [arg1, arg2, arg3])\n"
"\n"
"分散タスクを扱う場合は、匿名関数で動作する`Task.Supervisor.async/2`\n"
"ではなく、明示的なモジュール、関数、引数を期待する関数\n"
"`Task.Supervisor.async/4` を使用する必要があることに注意\n"
"してください。これは、匿名関数は関連するすべてのノードに同一の\n"
"モジュールバージョンが存在することを期待するためです。 分散プロセスに\n"
"関する情報は`Agent`モジュールのドキュメントをチェックしてください。\n"
"そこで説明されている制限はエコシステム全体に適用される\n"
"からです。\n"

#. TRANSLATORS: def Task.yield(task, timeout \\ 5000)
#: lib/task.ex:448
#, fuzzy
msgid ""
"Temporarily blocks the current process waiting for a task reply.\n"
"\n"
"Returns `{:ok, reply}` if the reply is received, `nil` if\n"
"no reply has arrived, or `{:exit, reason}` if the task has already\n"
"exited. Keep in mind that normally a task failure also causes\n"
"the process owning the task to exit. Therefore this function can\n"
"return `{:exit, reason}` only if\n"
"\n"
"  * the task process exited with the reason `:normal`\n"
"  * it isn't linked to the caller\n"
"  * the caller is trapping exits\n"
"\n"
"A timeout, in milliseconds, can be given with default value\n"
"of `5000`. If the time runs out before a message from\n"
"the task is received, this function will return `nil`\n"
"and the monitor will remain active. Therefore `yield/2` can be\n"
"called multiple times on the same task.\n"
"\n"
"This function assumes the task's monitor is still active or the\n"
"monitor's `:DOWN` message is in the message queue. If it has been\n"
"demonitored or the message already received, this function will wait\n"
"for the duration of the timeout awaiting the message.\n"
"\n"
"If you intend to shut the task down if it has not responded within "
"`timeout`\n"
"milliseconds, you should chain this together with `shutdown/1`, like so:\n"
"\n"
"    case Task.yield(task, timeout) || Task.shutdown(task) do\n"
"      {:ok, result} ->\n"
"        result\n"
"      nil ->\n"
"        Logger.warn \"Failed to get a result in #{timeout}ms\"\n"
"        nil\n"
"    end\n"
"\n"
"That ensures that if the task completes after the `timeout` but before "
"`shutdown/1`\n"
"has been called, you will still get the result, since `shutdown/1` is "
"designed to\n"
"handle this case and return the result.\n"
msgstr ""
"テンポラリにタスクの応答を待ために現在のプロセスをブロックします。\n"
"\n"
"replyが受信されたら`{:ok, reply}` 、タスクが終了したら`{:exit,\n"
"reason}`、replyが到着しなかったら`nil`を返します。通常、タスクが死ぬこ\n"
"とで処理自身が失敗した結果を表現することを注意してください。したがって、\n"
"この関数が`{:exit, reason}`を返すのは以下の場合だけです:\n"
"\n"
"  * タスクプロセスがreasonが`:normal`で終了した\n"
"  * 呼出し側へリンクされていなかった\n"
"  * 呼出し側がexitをトラップした\n"
"\n"
"ミリ秒のタイムアウトを与えることもでき、デフォルト値は\n"
"`5000`です。タイムアウトの場合、この関数は`nil`を返し、モニタ\n"
"はアクティブのままです。したがって`yield/2`は同じタスクに\n"
"対して複数回呼び出すことができます。\n"
"\n"
"この関数はタスクのモニタがアクティブあるいは、`:DOWN`メッセー\n"
"ジがメッセージキューにあることを仮定しています。もし非モニタ\n"
"されていた、あるいは、メッセージが既に受信されていたら、この\n"
"関数はタイムアウトの期間中メッセージを待つでしょう。\n"

#. TRANSLATORS: def Task.async_stream(enumerable, module, function, args, options \\ [])
#: lib/task.ex:285
msgid ""
"Returns a stream that runs the given `module`, `function` and `args`\n"
"concurrently on each item in `enumerable`.\n"
"\n"
"Each item will be appended to the given `args` and processed by its\n"
"own task. The tasks will be linked to an intermediate process that is\n"
"then linked to the current process. This means a failure in a task\n"
"terminates the current process and a failure in the current process\n"
"terminates all tasks.\n"
"\n"
"When streamed, each task will emit `{:ok, val}` upon successful\n"
"completion or `{:exit, val}` if the caller is trapping exits. Results\n"
"are emitted in the same order as the original `enumerable`.\n"
"\n"
"The level of concurrency can be controlled via the `:max_concurrency`\n"
"option and defaults to `System.schedulers_online/1`. The timeout\n"
"can also be given as option and defaults to 5000 and it defaults to\n"
"the maximum amount of time to wait without a task reply.\n"
"\n"
"Finally, consider using `Task.Supervisor.async_stream/6` to start tasks\n"
"under a supervisor. If you find yourself trapping exits to handle exits\n"
"inside the async stream, consider using `Task.Supervisor."
"async_stream_nolink/6`\n"
"to start tasks that are not linked to the current process.\n"
"\n"
"## Options\n"
"\n"
"  * `:max_concurrency` - sets the maximum number of tasks to run\n"
"    at the same time. Defaults to `System.schedulers_online/1`.\n"
"  * `:timeout` - the maximum amount of time to wait without\n"
"    receiving a task reply (across all running tasks).\n"
"\n"
"## Example\n"
"\n"
"Let's build a stream and then enumerate it:\n"
"\n"
"    stream = Task.async_stream(collection, Mod, :expensive_fun, [])\n"
"    Enum.to_list(stream)\n"
"\n"
"The concurrency can be increased or decreased using the `:max_concurrency`\n"
"option. For example, if the tasks are IO heavy, the value can be increased:\n"
"\n"
"    max_concurrency = System.schedulers_online * 2\n"
"    stream = Task.async_stream(collection, Mod, :expensive_fun, [], "
"max_concurrency: max_concurrency)\n"
"    Enum.to_list(stream)\n"
"\n"
msgstr ""

#. TRANSLATORS: def Task.start_link(mod, fun, args)
#: lib/task.ex:163
msgid "Starts a task as part of a supervision tree.\n"
msgstr "監督ツリーの一部としてタスクを開始します。\n"

#. TRANSLATORS: def Task.async(fun)
#: lib/task.ex:195
msgid ""
"Starts a task that must be awaited on.\n"
"\n"
"This function spawns a process that is linked to and monitored\n"
"by the caller process. A `Task` struct is returned containing\n"
"the relevant information.\n"
"\n"
"Read the `Task` module documentation for more info on general\n"
"usage of `async/1` and `async/3`.\n"
"\n"
"See also `async/3`.\n"
msgstr ""
"待機しなければならないタスクを開始します。\n"
"\n"
"この関数は、呼び出し元プロセスによりリンクされ、モニタされる、\n"
"プロセスを生成します。関連した情報を含む`Task`構造体が\n"
"返されます。\n"
"\n"
"`async/1` と `async/3` の一斑的な使用法については、\n"
" `Task`モジュールのドキュメントを参照してください。\n"
"\n"
"`async/3`も参照してください。\n"

#. TRANSLATORS: def Task.async(mod, fun, args)
#: lib/task.ex:212
msgid ""
"Starts a task that must be awaited on.\n"
"\n"
"A `Task` struct is returned containing the relevant information.\n"
"Developers must eventually call `Task.await/2` or `Task.yield/2`\n"
"followed by `Task.shutdown/2` on the returned task.\n"
"\n"
"Read the `Task` module documentation for more info on general\n"
"usage of `async/1` and `async/3`.\n"
"\n"
"## Linking\n"
"\n"
"This function spawns a process that is linked to and monitored\n"
"by the caller process. The linking part is important because it\n"
"aborts the task if the parent process dies. It also guarantees\n"
"the code before async/await has the same properties after you\n"
"add the async call. For example, imagine you have this:\n"
"\n"
"    x = heavy_fun()\n"
"    y = some_fun()\n"
"    x + y\n"
"\n"
"Now you want to make the `heavy_fun()` async:\n"
"\n"
"    x = Task.async(&heavy_fun/0)\n"
"    y = some_fun()\n"
"    Task.await(x) + y\n"
"\n"
"As before, if `heavy_fun/0` fails, the whole computation will\n"
"fail, including the parent process. If you don't want the task\n"
"to fail then you must change the `heavy_fun/0` code in the\n"
"same way you would achieve it if you didn't have the async call.\n"
"For example, to either return `{:ok, val} | :error` results or,\n"
"in more extreme cases, by using `try/rescue`. In other words,\n"
"an asynchronous task should be thought of as an extension of a\n"
"process rather than a mechanism to isolate it from all errors.\n"
"\n"
"If you don't want to link the caller to the task, then you\n"
"must use a supervised task with `Task.Supervisor` and call\n"
"`Task.Supervisor.async_nolink/2`.\n"
"\n"
"In any case, avoid any of the following:\n"
"\n"
"  * Setting `:trap_exit` to `true` - trapping exits should be\n"
"    used only in special circumstances as it would make your\n"
"    process immune to not only exits from the task but from\n"
"    any other processes.\n"
"\n"
"    Moreover, even when trapping exits, calling `await` will\n"
"    still exit if the task has terminated without sending its\n"
"    result back.\n"
"\n"
"  * Unlinking the task process started with `async`/`await`.\n"
"    If you unlink the processes and the task does not belong\n"
"    to any supervisor, you may leave dangling tasks in case\n"
"    the parent dies.\n"
"\n"
"## Message format\n"
"\n"
"The reply sent by the task will be in the format `{ref, result}`,\n"
"where `ref` is the monitor reference held by the task struct\n"
"and `result` is the return value of the task function.\n"
msgstr ""
"待機しなければならないタスクを開始します。\n"
"\n"
"関連情報を含む`Task`構造体が返されます。開発者は最終的には\n"
"返されたタスクに対して、`Task.await/2`か`Task.yield/2`を、\n"
"続けて`Task.shutdown/2`を呼び出さなければなりません。\n"
"\n"
"`async/1`と`async/3`の一般的な使用法については`Task`モジュールの\n"
"ドキュメントを読んでください。\n"
"\n"
"## リンク付け\n"
"\n"
"この関数は呼び出し元プロセスによりリンクされモニタされる\n"
"プロセスを生成します。リンク部分は、親プロセスが\n"
"死んだ場合にタスクを停止させるので重要です。また、\n"
"非同期呼出しを追加した後にasync/awaitが同じ属性を持つ前に\n"
"コードを保証します。たとえば、これがあると想像してください:\n"
"\n"
"    x = heavy_fun()\n"
"    y = some_fun()\n"
"    x + y\n"
"\n"
"今、`heavy_fun()`を非同期にしたいとします:\n"
"\n"
"    x = Task.async(&heavy_fun/0)\n"
"    y = some_fun()\n"
"    Task.await(x) + y\n"
"\n"
"前述のように、`heavy_fun/0`が失敗した場合、親プロセスを含む\n"
"計算全体が失敗します。 タスクを失敗させたくない場合は、非同期\n"
"呼び出しがない場合と同じ方法で`heavy_fun/0`を変更する必要が\n"
"あります。 たとえば、`{:ok, val} | :error`のいずれかの結果を返すか、\n"
"さらに極端な場合は`try/rescue`を使用します。言い替えると、\n"
"非同期タスクは、すべてのエラーからプロセスを分離するメカニズム\n"
"ではなく、プロセスの拡張として考える必要が\n"
"あります。\n"
"\n"
"呼び出し元をタスクにリンクしたくない場合は、`Task.Supervisor`で\n"
"監視タスクを使用して、`Task.Supervisor.async_nolink/2`を呼ぶ\n"
"必要があります。\n"
"\n"
"いずれにしても、以下のどのケースも避けてください:\n"
"\n"
"  * `:trap_exit` を true にセットすること - exitをトラップす\n"
"    ることは、そのタスクからのexitだけでなく、他の全てのプロ\n"
"    セスからも影響がない、特殊な状況だけで使うべきです。\n"
"\n"
"    さらに、トラップが存在するときでも、そのタスクが戻す結果を送\n"
"    信することなく終了しても、`await`の呼出しは終了します。\n"
"\n"
"  * `async`/`await`で開始したタスクプロセスのリンクの解除。も\n"
"    しプロセスをアンリンクし、タスクがどのスーパバイザも所有\n"
"    していないなら、親が死んだ場合でもタスクが残ってしまうか\n"
"    もしれません。\n"
"\n"
"## Message format\n"
"\n"
"タスクから送信された応答は`{ref, result}`のフォーマットです。\n"
"`ref`はタスクに保持されたモニタリファレンスです。`result`はタスク\n"
"関数からの戻された値です。\n"

#. TRANSLATORS: def Task.await(task, timeout \\ 5000)
#: lib/task.ex:366
#, fuzzy
msgid ""
"Awaits a task reply and returns it.\n"
"\n"
"A timeout, in milliseconds, can be given with default value\n"
"of `5000`. In case the task process dies, this function will\n"
"exit with the same reason as the task.\n"
"\n"
"If the timeout is exceeded, `await` will exit; however,\n"
"the task will continue to run. When the calling process exits, its\n"
"exit signal will terminate the task if it is not trapping exits.\n"
"\n"
"This function assumes the task's monitor is still active or the monitor's\n"
"`:DOWN` message is in the message queue. If it has been demonitored, or the\n"
"message already received, this function will wait for the duration of the\n"
"timeout awaiting the message.\n"
"\n"
"This function can only be called once for any given task. If you want\n"
"to be able to check multiple times if a long-running task has finished\n"
"its computation, use `yield/2` instead.\n"
"\n"
"## Compatibility with OTP behaviours\n"
"\n"
"It is not recommended to `await` a long-running task inside an OTP\n"
"behaviour such as `GenServer`. Instead, you should match on the message\n"
"coming from a task inside your `GenServer.handle_info/2` callback.\n"
"\n"
"## Examples\n"
"\n"
"    iex> task = Task.async(fn -> 1 + 1 end)\n"
"    iex> Task.await(task)\n"
"    2\n"
"\n"
msgstr ""
"タスクの応答を待ちます。\n"
"\n"
"ミリ秒でのtimeoutを与えることができます。デフォルト値`5000`で\n"
"す。タスクプロセスが死んだ場合、この関数はタスクと同じreason\n"
"でexitします。\n"
"\n"
"タイムアウトに到達したら、`await`はexitしますが、タスクは動き\n"
"つづけます。呼出し側プロセスが終了したとき、そのexit シグナル\n"
"がexitをトラップしていない限り、タスクを終了させます。\n"
"\n"
"この関数はタスクのモニタがまだ動作中である、あるいはモニタの\n"
"`:DOWN`メッセージがメッセージキューにあると仮定しています。も\n"
"し非モニタされた、あるいはメッセージが既に受信されたら、この\n"
"関数はtimeoutの期間中、メッセージを待ちつづけます。\n"
"\n"
"この関数は常にタスクを非モニタするので、そのタスクは二度と使\n"
"うことができません。タスクの応答を複数回待つためには、\n"
"`yield/2`を代わりに使ってください。\n"
"\n"
"## Compatibility with OTP behaviours\n"
"\n"
"`GenServer`のようなOTPビヘイビアの中で長い時間かかるタスクに`await`を使\n"
"うことを推奨しません。かわりに、`handle_info`コールバックの中でタスクか\n"
"らのメッセージをマッチングするべきです。\n"

#. TRANSLATORS: def Task.async_stream(enumerable, fun, options \\ [])
#: lib/task.ex:337
msgid ""
"Returns a stream that runs the given `function` concurrently on each\n"
"item in `enumerable`.\n"
"\n"
"Each `enumerable` item is passed as argument to the `function` and\n"
"processed by its own task. The tasks will be linked to the current\n"
"process, similar to `async/1`.\n"
"\n"
"See `async_stream/5` for discussion and examples.\n"
msgstr ""

#. TRANSLATORS: def Task.start(mod, fun, args)
#: lib/task.ex:183
msgid ""
"Starts a task.\n"
"\n"
"This is only used when the task is used for side-effects\n"
"(i.e. no interest in the returned result) and it should not\n"
"be linked to the current process.\n"
msgstr ""
"タスクを開始します。\n"
"\n"
"タスクが副作用(即ち、戻り結果に対する関心がない)のために\n"
"使われるときにのみ使われ、それは現在のプロセスとリンク\n"
"されていてはなりません。\n"

#. TRANSLATORS: def Task.__struct__()
#: lib/task.ex:138
msgid ""
"The Task struct.\n"
"\n"
"It contains these fields:\n"
"\n"
"  * `:pid` - the PID of the task process; `nil` if the task does\n"
"    not use a task process\n"
"\n"
"  * `:ref` - the task monitor reference\n"
"\n"
"  * `:owner` - the PID of the process that started the task\n"
"\n"
msgstr ""
"タスク構造体。\n"
"\n"
"次の3つのフィールドを含みます:\n"
"\n"
"  * `:pid` - タスクプロセスのPID; タスクがタスクプロセスを使用して\n"
"    いない場合は`nil`。\n"
"\n"
"  * `:ref` - タスクモニタのリファレンス\n"
"\n"
"  * `:owner` - タスクを開始したプロセスのPID\n"
"\n"

#. TRANSLATORS: def Task.yield_many(tasks, timeout \\ 5000)
#: lib/task.ex:509
#, fuzzy
msgid ""
"Yields to multiple tasks in the given time interval.\n"
"\n"
"This function receives a list of tasks and waits for their\n"
"replies in the given time interval. It returns a list\n"
"of tuples of two elements, with the task as the first element\n"
"and the yielded result as the second.\n"
"\n"
"Similarly to `yield/2`, each task's result will be\n"
"\n"
"  * `{:ok, term}` if the task has successfully reported its\n"
"    result back in the given time interval\n"
"  * `{:exit, reason}` if the task has died\n"
"  * `nil` if the task keeps running past the timeout\n"
"\n"
"Check `yield/2` for more information.\n"
"\n"
"## Example\n"
"\n"
"`Task.yield_many/2` allows developers to spawn multiple tasks\n"
"and retrieve the results received in a given timeframe.\n"
"If we combine it with `Task.shutdown/2`, it allows us to gather\n"
"those results and cancel the tasks that have not replied in time.\n"
"\n"
"Let's see an example.\n"
"\n"
"    tasks =\n"
"      for i <- 1..10 do\n"
"        Task.async(fn ->\n"
"          Process.sleep(i * 1000)\n"
"          i\n"
"        end)\n"
"      end\n"
"\n"
"    tasks_with_results = Task.yield_many(tasks, 5000)\n"
"\n"
"    results = Enum.map(tasks_with_results, fn {task, res} ->\n"
"      # Shutdown the tasks that did not reply nor exit\n"
"      res || Task.shutdown(task, :brutal_kill)\n"
"    end)\n"
"\n"
"    # Here we are matching only on {:ok, value} and\n"
"    # ignoring {:exit, _} (crashed tasks) and `nil` (no replies)\n"
"    for {:ok, value} <- results do\n"
"      IO.inspect value\n"
"    end\n"
"\n"
"In the example above, we create tasks that sleep from 1\n"
"up to 10 seconds and return the amount of seconds they slept.\n"
"If you execute the code all at once, you should see 1 up to 5\n"
"printed, as those were the tasks that have replied in the\n"
"given time. All other tasks will have been shut down using\n"
"the `Task.shutdown/2` call.\n"
msgstr ""
"与えられた時間の間、複数のタスクを待ちます。\n"
"\n"
"この関数はタスクのリストを受取り、それらの与えられた時間の間、\n"
"応答を待ちます。最初の要素としてタスク、二つめの\n"
"要素として`yield`の結果からなる、2要素のタプルのリストを返します。\n"
"\n"
"`yield/2`と似て、タスクの結果により以下を返します:\n"
"\n"
"  * `{:ok, term}` 与えられた時間内で、結果が戻り、タスク成功と報告されたと"
"き\n"
"  * `{:exit, reason}` タスクが死んだとき\n"
"  * `nil` タイムアウト後も動き続けていたとき\n"
"\n"
"詳細は`yield/2`をチェック知てください。\n"
"\n"
"## Example\n"
"\n"
"`Task.yield_many/2`は開発者に複数のタスクを生成し、与えられた\n"
"時間フレームの間に受信した結果を取りにいくことを許します。\n"
"もし`Task.shutdown/2`と組合せたら、それらの結果を集めて\n"
"時間内に答えなかったタスクをキャンセルすることを許します。\n"
"\n"
"例を見てみましょう。\n"
"\n"
"    tasks =\n"
"      for i <- 1..10 do\n"
"        Task.async(fn ->\n"
"          :timer.sleep(i * 1000)\n"
"          i\n"
"        end)\n"
"      end\n"
"\n"
"    tasks_with_results = Task.yield_many(tasks, 5000)\n"
"\n"
"    results = Enum.map(tasks_with_results, fn {task, res} ->\n"
"      # Shutdown the tasks that did not reply nor exit\n"
"      res || Task.shutdown(task, :brutal_kill)\n"
"    end)\n"
"\n"
"    # Here we are matching only on {:ok, value} and\n"
"    # ignoring {:exit, _} (crashed tasks) and `nil` (no replies)\n"
"    for {:ok, value} <- results do\n"
"      IO.inspect value\n"
"    end\n"
"\n"
"上の例では、1秒から10秒スリープして、その後スリープした秒数を\n"
"返すタスクを作成しています。\n"
"もし上のコード全てを一度実行すると、与えられた時間内に\n"
"応答できるタスクがそれらなので、1から5が表示されるのを\n"
"見るでしょう。他の全てのタスクは`Task.shutdown/2`の呼出しに\n"
"よってshutdownされます。\n"

#. TRANSLATORS: def Task.shutdown(task, shutdown \\ 5000)
#: lib/task.ex:608
#, fuzzy
msgid ""
"Unlinks and shuts down the task, and then checks for a reply.\n"
"\n"
"Returns `{:ok, reply}` if the reply is received while shutting down the "
"task,\n"
"`{:exit, reason}` if the task died, otherwise `nil`.\n"
"\n"
"The shutdown method is either a timeout or `:brutal_kill`. In case\n"
"of a `timeout`, a `:shutdown` exit signal is sent to the task process\n"
"and if it does not exit within the timeout, it is killed. With `:"
"brutal_kill`\n"
"the task is killed straight away. In case the task terminates abnormally\n"
"(possibly killed by another process), this function will exit with the same "
"reason.\n"
"\n"
"It is not required to call this function when terminating the caller, "
"unless\n"
"exiting with reason `:normal` or if the task is trapping exits. If the "
"caller is\n"
"exiting with a reason other than `:normal` and the task is not trapping "
"exits, the\n"
"caller's exit signal will stop the task. The caller can exit with reason\n"
"`:shutdown` to shutdown all of its linked processes, including tasks, that\n"
"are not trapping exits without generating any log messages.\n"
"\n"
"If a task's monitor has already been demonitored or received  and there is "
"not\n"
"a response waiting in the message queue this function will return\n"
"`{:exit, :noproc}` as the result or exit reason can not be determined.\n"
msgstr ""
"タスクをunlinkしshutdownし、応答をチェックします。\n"
"\n"
"タスクのシャットダウン中にもし応答が受信されたら、`{:ok,\n"
"reply}`を返し、タスクが異常終了したら`{:exit, reason}`を返し、\n"
"さもなければ`nil`を返します。\n"
"\n"
"shutdownメソッドはタイムアウトか`:brutal_kill`が出来ます。\n"
"`timeout`の場合、`:shutdown` exitシグナルがタスクプロセスに送\n"
"信され、タイムアウトの間にexitしないならkillされます。\n"
"`:brutal_kill`では、タスクは直接killされます。タスクが異常終\n"
"了した場合、あるいはタスクがタイムアウトでkillされた場合、こ\n"
"の関数は同じ reason で exit します。\n"
"\n"
"reason `:normal`で終了していないかぎり、またはタスクがexitを\n"
"トラップしていないかぎり、呼出し側を終了するときにこの関数を\n"
"呼ぶことは必要ありません。もし呼出し側が`:normal`以外の\n"
"reasonでexitしたり、タスクがexitをトラップしていないなら、呼\n"
"出し側のexitシグナルがタスクを終了させます。呼出し側がreason\n"
"`:shutdown`のexitでリンクされたプロセスをシャットダウンし、タ\n"
"スクもいかなるログメッセージも無しにexitします(トラップされて\n"
"いないなら)。\n"
"\n"
"この関数はタスクのモニタがアクティブあるいは、`:DOWN`メッセー\n"
"ジがメッセージキューにあることを仮定しています。もし非モニタ\n"
"されていた、あるいは、メッセージが既に受信されていたら、この\n"
"関数はタイムアウトの期間中メッセージを待つでしょう。\n"

#~ msgid ""
#~ "Receives a group of tasks and a message and finds\n"
#~ "a task that matches the given message.\n"
#~ "\n"
#~ "This function returns a tuple with the returned value\n"
#~ "in case the message matches a task that exited with\n"
#~ "success alongside the matching task. It returns `nil`\n"
#~ "if no task was found. It exits if the task has failed.\n"
#~ "\n"
#~ "This function is useful in situations where multiple\n"
#~ "tasks are spawned and their results are collected\n"
#~ "later on. For example, a `GenServer` can spawn tasks,\n"
#~ "store the tasks in a list and later use `Task.find/2`\n"
#~ "to see if incoming messages are from any of the tasks.\n"
#~ msgstr ""
#~ "タスクとメッセージのグループを受け取り、与えられたメッセージ\n"
#~ "にマッチするタスクを見付けます。\n"
#~ "\n"
#~ "この関数は、タスク付のタプルを返し、返された値は成功して終了\n"
#~ "したタスクにマッチするメッセージです。タスクが見付けられない\n"
#~ "時は、`nil`を返します。タスクが失敗したときは、exitします。\n"
#~ "\n"
#~ "この関数は、複数のタスクが生成され、それらの結果をあとで集め\n"
#~ "るというシチュエーションで、便利です。例えば、`GenServer`はタ\n"
#~ "スクを生成することができ、タスクをリストに格納して、他のタス\n"
#~ "クからのメッセージが来たかどうかを知るために、後で\n"
#~ "`Task.find/2`を使うことが出来ます。\n"

#~ msgid ""
#~ "Receives a group of tasks and a message and finds\n"
#~ "a task that matches the given message.\n"
#~ "\n"
#~ "This function returns a tuple with the returned value\n"
#~ "in case the message matches a task that exited with\n"
#~ "success alongside the matching task. It raises in case\n"
#~ "the found task failed or `nil` if no task was found.\n"
#~ "\n"
#~ "This function is useful in situations where multiple\n"
#~ "tasks are spawned and their results are collected\n"
#~ "later on. For example, a `GenServer` can spawn tasks,\n"
#~ "store the tasks in a list and later use `Task.find/2`\n"
#~ "to see if incoming messages are from any of the tasks.\n"
#~ "\n"
#~ "## Examples\n"
#~ "\n"
#~ "    defmodule TaskFinder do\n"
#~ "      def run do\n"
#~ "        task1 = Task.async fn -> :timer.sleep(1000); 1 end\n"
#~ "        task2 = Task.async fn -> :timer.sleep(5000); 2 end\n"
#~ "        await [task1, task2]\n"
#~ "      end\n"
#~ "\n"
#~ "      # Be careful, this will receive all messages sent\n"
#~ "      # to this process. It will return the first task\n"
#~ "      # reply and the list of tasks that came second.\n"
#~ "      def await(tasks) do\n"
#~ "        receive do\n"
#~ "          message ->\n"
#~ "            case Task.find(tasks, message) do\n"
#~ "              {reply, task} ->\n"
#~ "                {reply, List.delete(tasks, task)}\n"
#~ "              nil ->\n"
#~ "                await(tasks)\n"
#~ "            end\n"
#~ "        end\n"
#~ "      end\n"
#~ "    end\n"
#~ "\n"
#~ "    TaskFinder.run\n"
#~ msgstr ""
#~ "一群のタスクとメッセージを受けて、そのメッセージ\n"
#~ "にマッチするタスクを見付けます。\n"
#~ "\n"
#~ "この関数は、\n"
#~ "マッチしたタスクが処理に成功して終了した場合に\n"
#~ "備えて、そのタスクが返した値とタスクのタプルを返します。\n"
#~ "タスクが失敗を見付けたら、例外を上げ、タスクが見付\n"
#~ "からない場合、`nil`を返します。\n"
#~ "\n"
#~ "この関数は複数のタスクを生成し、それらの結果を後で\n"
#~ "集めるときに便利です。例えば、`GenServer`が\n"
#~ "タスクを生成し、リストにタスクを保存しておき、\n"
#~ "後で、そららのタスクからメッセージを受信したとき\n"
#~ "`Task.find/2`を使います。\n"
#~ "\n"
#~ "## Examples\n"
#~ "\n"
#~ "    defmodule TaskFinder do\n"
#~ "      def run do\n"
#~ "        task1 = Task.async fn -> :timer.sleep(1000); 1 end\n"
#~ "        task2 = Task.async fn -> :timer.sleep(5000); 2 end\n"
#~ "        await [task1, task2]\n"
#~ "      end\n"
#~ "\n"
#~ "      # Be careful, this will receive all messages sent\n"
#~ "      # to this process. It will return the first task\n"
#~ "      # reply and the list of tasks that came second.\n"
#~ "      def await(tasks) do\n"
#~ "        receive do\n"
#~ "          message ->\n"
#~ "            case Task.find(tasks, message) do\n"
#~ "              {reply, task} ->\n"
#~ "                {reply, List.delete(tasks, task)}\n"
#~ "              nil ->\n"
#~ "                await(tasks)\n"
#~ "            end\n"
#~ "        end\n"
#~ "      end\n"
#~ "    end\n"
#~ "\n"
#~ "    TaskFinder.run\n"

#~ msgid ""
#~ "Starts a task that can be awaited on.\n"
#~ "\n"
#~ "Similar to `async/1`, but the task is specified by the given\n"
#~ "module, function and arguments.\n"
#~ msgstr ""
#~ "待機することができるタスクを開始します。\n"
#~ "\n"
#~ "`async/1`と似ていますが、タスクは与えられたモジュール、関数\n"
#~ "および引数により指定されます。\n"

#~ msgid ""
#~ "Awaits a task reply.\n"
#~ "\n"
#~ "A timeout, in milliseconds, can be given with default value\n"
#~ "of `5000`. In case the task process dies, this function will\n"
#~ "exit with the same reason as the task.\n"
#~ msgstr ""
#~ "タスクの応答を待ちます。\n"
#~ "\n"
#~ "タイムアウト(ミリ秒)を与えることができ、デフォルト値は`5000`です。\n"
#~ "タスクプロセスが死んだ場合、この関数は、\n"
#~ "そのタスクと同じreasonでexitします。\n"

#~ msgid ""
#~ "Conveniences for spawning and awaiting for tasks.\n"
#~ "\n"
#~ "Tasks are processes meant to execute one particular\n"
#~ "action throughout their life-cycle, often with little or no\n"
#~ "communication with other processes. The most common use case\n"
#~ "for tasks is to compute a value asynchronously:\n"
#~ "\n"
#~ "    task = Task.async(fn -> do_some_work() end)\n"
#~ "    res  = do_some_other_work()\n"
#~ "    res + Task.await(task)\n"
#~ "\n"
#~ "Tasks spawned with `async` can be awaited on by its caller\n"
#~ "process (and only its caller) as shown in the example above.\n"
#~ "They are implemented by spawning a process that sends a message\n"
#~ "to the caller once the given computation is performed.\n"
#~ "\n"
#~ "Besides `async/1` and `await/2`, tasks can also be\n"
#~ "started as part of supervision trees and dynamically spawned\n"
#~ "in remote nodes. We will explore all three scenarios next.\n"
#~ "\n"
#~ "## async and await\n"
#~ "\n"
#~ "The most common way to spawn a task is with `Task.async/1`. A new\n"
#~ "process will be created, linked and monitored by the caller. Once\n"
#~ "the task action finishes, a message will be sent to the caller\n"
#~ "with the result.\n"
#~ "\n"
#~ "`Task.await/2` is used to read the message sent by the task. On\n"
#~ "`await`, Elixir will also setup a monitor to verify if the process\n"
#~ "exited for any abnormal reason (or in case exits are being\n"
#~ "trapped by the caller).\n"
#~ "\n"
#~ "## Supervised tasks\n"
#~ "\n"
#~ "It is also possible to spawn a task inside a supervision tree\n"
#~ "with `start_link/1` and `start_link/3`:\n"
#~ "\n"
#~ "    Task.start_link(fn -> IO.puts \"ok\" end)\n"
#~ "\n"
#~ "Such tasks can be mounted in your supervision tree as:\n"
#~ "\n"
#~ "    import Supervisor.Spec\n"
#~ "\n"
#~ "    children = [\n"
#~ "      worker(Task, [fn -> IO.puts \"ok\" end])\n"
#~ "    ]\n"
#~ "\n"
#~ "Since these tasks are supervised and not directly linked to\n"
#~ "the caller, they cannot be awaited on. Note `start_link/1`,\n"
#~ "unlike `async/1`, returns `{:ok, pid}` (which is\n"
#~ "the result expected by supervision trees).\n"
#~ "\n"
#~ "## Supervision trees\n"
#~ "\n"
#~ "The `Task.Supervisor` module allows developers to start supervisors\n"
#~ "that dynamically supervise tasks:\n"
#~ "\n"
#~ "    {:ok, pid} = Task.Supervisor.start_link()\n"
#~ "    Task.Supervisor.async(pid, MyMod, :my_fun, [arg1, arg2, arg3])\n"
#~ "\n"
#~ "`Task.Supervisor` also makes it possible to spawn tasks in remote nodes "
#~ "as\n"
#~ "long as the supervisor is registered locally or globally:\n"
#~ "\n"
#~ "    # In the remote node\n"
#~ "    Task.Supervisor.start_link(name: :tasks_sup)\n"
#~ "\n"
#~ "    # In the client\n"
#~ "    Task.Supervisor.async({:tasks_sup, :remote@local}, MyMod, :my_fun, "
#~ "[arg1, arg2, arg3])\n"
#~ "\n"
#~ "`Task.Supervisor` is more often started in your supervision tree as:\n"
#~ "\n"
#~ "    import Supervisor.Spec\n"
#~ "\n"
#~ "    children = [\n"
#~ "      supervisor(Task.Supervisor, [[name: :tasks_sup]])\n"
#~ "    ]\n"
#~ "\n"
#~ "Note that, when working with distributed tasks, one should use the "
#~ "`async/3` API,\n"
#~ "that expects explicit module, function and arguments, instead of "
#~ "`async/1` that\n"
#~ "works with anonymous functions. That's because the anonymous function API "
#~ "expects\n"
#~ "the same module version to exist on all involved nodes. Check the `Agent` "
#~ "module\n"
#~ "documentation for more information on distributed processes, as the "
#~ "limitations\n"
#~ "described in the agents documentation apply to the whole ecosystem.\n"
#~ "\n"
#~ "Finally, check `Task.Supervisor` for other operations supported by the "
#~ "Task\n"
#~ "supervisor.\n"
#~ msgstr ""
#~ "タスクの生成と、待ち受けに便利なものです。\n"
#~ "\n"
#~ "タスクは、そのライフサイクルを通して、一つの特定の活動を実行するはずの\n"
#~ "プロセスです。そのプロセスは、しばしば、少しだけ、または全く他のプロセ\n"
#~ "スとコミュニケーションをとりません。\n"
#~ "タスクのための最も一般的なユースケースは、\n"
#~ "非同期的に値を計算することです:\n"
#~ "\n"
#~ "    task = Task.async(fn -> do_some_work() end)\n"
#~ "    res  = do_some_other_work()\n"
#~ "    res + Task.await(task)\n"
#~ "\n"
#~ "`async`により生み出されたタスクは、上の例で見られるように、\n"
#~ "呼び出しプロセス(そしてその呼び出し側だけに)により待たれます。\n"
#~ "一度与えられた計算が実行されるなら、呼び出し側に\n"
#~ "メッセージを送信するプロセスを生み出すことによって、それらは\n"
#~ "実装されます。\n"
#~ "\n"
#~ "`async/1`と`await/2`の他に、タスクはスーパビジョンツリー\n"
#~ "の一部として開始したり、リモートノードで動的に生み出すことも\n"
#~ "出来ます。次に、全3つのシナリオを調査します。\n"
#~ "\n"
#~ "## async and await\n"
#~ "\n"
#~ "タスクを生む最も一般的な方法は`Task.async/1`です。新しい\n"
#~ "プロセスが作成され、呼び出し側によりリンクされ、モニタされます。\n"
#~ "一度タスクのアクションが終了したら、結果として呼び出し側に\n"
#~ "メッセージが送信されます。\n"
#~ "\n"
#~ "`Task.await/2`はタスクにより送信されたメッセージを読み出すために使われ\n"
#~ "ます。`await`で、Elixirは、プロセスが異常な理由でexitしているかどうか\n"
#~ "(または、呼び出し側によりトラップされるexitしているかどうか)、検証する\n"
#~ "ためのモニタをセットアップします。\n"
#~ "\n"
#~ "## Supervised tasks\n"
#~ "\n"
#~ "`start_link/2`と`start_link/3`でスーパビジョンツリーの内でタスクを\n"
#~ "生み出すこともできます:\n"
#~ "\n"
#~ "    Task.start_link(fn -> IO.puts \"ok\" end)\n"
#~ "\n"
#~ "そのようなタスクは以下のようにして、スーパビジョンツリーに\n"
#~ "取り付けることもできます:\n"
#~ "\n"
#~ "    import Supervisor.Spec\n"
#~ "\n"
#~ "    children = [\n"
#~ "      worker(Task, [fn -> IO.puts \"ok\" end])\n"
#~ "    ]\n"
#~ "\n"
#~ "これらのタスクはスーパバイズされ、直接呼び出し側にリンクされて\n"
#~ "いないので、awaitで待つことが出来ません。\n"
#~ "`start_link/1`(`async/1`と違って)は、`{:ok, pid}`\n"
#~ "(スーバビジョンツリーにより期待される結果です)を返すことに\n"
#~ "注意してください。\n"
#~ "\n"
#~ "## Supervision trees\n"
#~ "\n"
#~ "`Task.Supervisor`モジュールは、開発者に、\n"
#~ "動的にタスクをスーパバイズするスーパバイザを開始することを許します:\n"
#~ "\n"
#~ "    {:ok, pid} = Task.Supervisor.start_link()\n"
#~ "    Task.Supervisor.async(pid, MyMod, :my_fun, [arg1, arg2, arg3])\n"
#~ "\n"
#~ "スーパバイザがローカルまたは、グローバルに登録される限り、\n"
#~ "`Task.Supervisor`もまた、リモートノードでタスクを生むことを可能にします:\n"
#~ "\n"
#~ "    # In the remote node\n"
#~ "    Task.Supervisor.start_link(name: :tasks_sup)\n"
#~ "\n"
#~ "    # In the client\n"
#~ "    Task.Supervisor.async({:tasks_sup, :remote@local}, MyMod, :my_fun, "
#~ "[arg1, arg2, arg3])\n"
#~ "\n"
#~ "`Task.Supervisor`は、スーバビジョンツリーでよりしばしば開始されます:\n"
#~ "\n"
#~ "    import Supervisor.Spec\n"
#~ "\n"
#~ "    children = [\n"
#~ "      supervisor(Task.Supervisor, [[name: :tasks_sup]])\n"
#~ "    ]\n"
#~ "\n"
#~ "なお、分散されたタスクで動くとき、無名関数を動かす`async/1`のかわりに、\n"
#~ "モジュール、関数、引数を明示的に期待する、`async/3`APIを使うべきです。\n"
#~ "これは、無名関数APIは全ての起動されたノードで同じモジュールバージョンが\n"
#~ "存在することを期待するためです。\n"
#~ "全エコシステムに適用される、エージェントドキュメントで記述される制限として"
#~ "の、\n"
#~ "分散プロセスの詳細は、`Agent`モジュールドキュメントをチェックしてくださ"
#~ "い。\n"
#~ "\n"
#~ "最後に、他のタスクスーパバイザによりサポートされるオペレーションについて\n"
#~ "の詳細は、 `Task.Supervisor` をチェックしてください。\n"
