#. TRANSLATORS: @type on_start
#: lib/supervisor.ex:246 
msgid ""
"Return values of `start_link` functions"
msgstr ""
#. TRANSLATORS: @type options
#: lib/supervisor.ex:259 
msgid ""
"Options used by the `start*` functions"
msgstr ""
#. TRANSLATORS: def Supervisor.start_link(module, arg, options \\ [])
#: lib/supervisor.ex:301 
msgid ""
"Starts a supervisor process with the given `module` and `arg`.\n"
"\n"
"To start the supervisor, the `c:init/1` callback will be invoked in the given\n"
"`module`, with `arg` as its argument. The `c:init/1` callback must return a\n"
"supervisor specification which can be created with the help of the functions\n"
"in the `Supervisor.Spec` module (especially `Supervisor.Spec.supervise/2`).\n"
"\n"
"If the `c:init/1` callback returns `:ignore`, this function returns\n"
"`:ignore` as well and the supervisor terminates with reason `:normal`.\n"
"If it fails or returns an incorrect value, this function returns\n"
"`{:error, term}` where `term` is a term with information about the\n"
"error, and the supervisor terminates with reason `term`.\n"
"\n"
"The `:name` option can also be given in order to register a supervisor\n"
"name, the supported values are described in the \"Name registration\"\n"
"section in the `GenServer` module docs.\n"
msgstr ""
#. TRANSLATORS: def Supervisor.start_link(children, options)
#: lib/supervisor.ex:268 
msgid ""
"Starts a supervisor with the given children.\n"
"\n"
"A strategy is required to be provided through the `:strategy` option.\n"
"Furthermore, the `:max_restarts` and `:max_seconds` options can be\n"
"configured as described in the documentation for `Supervisor.Spec.supervise/2`.\n"
"\n"
"The options can also be used to register a supervisor name.\n"
"The supported values are described under the \"Name registration\"\n"
"section in the `GenServer` module docs.\n"
"\n"
"If the supervisor and its child processes are successfully created\n"
"(i.e., if the start function of each child process returns `{:ok, child}`,\n"
"`{:ok, child, info}`, or `:ignore`) this function returns\n"
"`{:ok, pid}`, where `pid` is the PID of the supervisor. If a process with the\n"
" specified name already exists, the function returns `{:error,\n"
" {:already_started, pid}}`, where `pid` is the PID of that process.\n"
"\n"
"If the start function of any of the child processes fails or returns an error\n"
"tuple or an erroneous value, the supervisor first terminates with reason\n"
"`:shutdown` all the child processes that have already been started, and then\n"
"terminates itself and returns `{:error, {:shutdown, reason}}`.\n"
"\n"
"Note that a supervisor started with this function is linked to the parent\n"
"process and exits not only on crashes but also if the parent process exits\n"
"with `:normal` reason.\n"
msgstr ""
#. TRANSLATORS: def Supervisor.restart_child(supervisor, child_id)
#: lib/supervisor.ex:423 
msgid ""
"Restarts a child process identified by `child_id`.\n"
"\n"
"The child specification must exist and the corresponding child process must not\n"
"be running.\n"
"\n"
"Note that for temporary children, the child specification is automatically deleted\n"
"when the child terminates, and thus it is not possible to restart such children.\n"
"\n"
"If the child process start function returns `{:ok, child}` or `{:ok, child, info}`,\n"
"the PID is added to the supervisor and this function returns the same value.\n"
"\n"
"If the child process start function returns `:ignore`, the PID remains set to\n"
"`:undefined` and this function returns `{:ok, :undefined}`.\n"
"\n"
"This function may return an error with an appropriate error tuple if the\n"
"`child_id` is not found, or if the current process is running or being\n"
"restarted.\n"
"\n"
"If the child process start function returns an error tuple or an erroneous value,\n"
"or if it fails, this function returns `{:error, error}`.\n"
"\n"
"This operation is not supported by `:simple_one_for_one` supervisors.\n"
msgstr ""
#. TRANSLATORS: @type supervisor
#: lib/supervisor.ex:265 
msgid ""
"The supervisor reference"
msgstr ""
#. TRANSLATORS: def Supervisor.count_children(supervisor)
#: lib/supervisor.ex:483 
msgid ""
"Returns a map containing count values for the given supervisor.\n"
"\n"
"The map contains the following keys:\n"
"\n"
"  * `:specs` - the total count of children, dead or alive\n"
"\n"
"  * `:active` - the count of all actively running child processes managed by\n"
"    this supervisor\n"
"\n"
"  * `:supervisors` - the count of all supervisors whether or not these\n"
"    child supervisors are still alive\n"
"\n"
"  * `:workers` - the count of all workers, whether or not these child workers\n"
"    are still alive\n"
"\n"
msgstr ""
#. TRANSLATORS: @callback init/1
#: lib/supervisor.ex:237 
msgid ""
"Callback invoked to start the supervisor and during hot code upgrades.\n"
msgstr ""
#. TRANSLATORS: def Supervisor.which_children(supervisor)
#: lib/supervisor.ex:454 
msgid ""
"Returns a list with information about all children of the given supervisor.\n"
"\n"
"Note that calling this function when supervising a large number of children\n"
"under low memory conditions can cause an out of memory exception.\n"
"\n"
"This function returns a list of `{id, child, type, modules}` tuples, where:\n"
"\n"
"  * `id` - as defined in the child specification or `:undefined` in the case\n"
"    of a `simple_one_for_one` supervisor\n"
"\n"
"  * `child` - the PID of the corresponding child process, `:restarting` if the\n"
"    process is about to be restarted, or `:undefined` if there is no such\n"
"    process\n"
"\n"
"  * `type` - `:worker` or `:supervisor`, as specified by the child specification\n"
"\n"
"  * `modules` - as specified by the child specification\n"
"\n"
msgstr ""
#. TRANSLATORS: def Supervisor.terminate_child(supervisor, pid_or_child_id)
#: lib/supervisor.ex:380 
msgid ""
"Terminates the given children, identified by PID or child id.\n"
"\n"
"If the supervisor is not a `:simple_one_for_one`, the child id is expected\n"
"and the process, if there's one, is terminated; the child specification is\n"
"kept unless the child is temporary.\n"
"\n"
"In case of a `:simple_one_for_one` supervisor, a PID is expected. If the child\n"
"specification identifier is given instead of a `pid`, this function returns\n"
"`{:error, :simple_one_for_one}`.\n"
"\n"
"A non-temporary child process may later be restarted by the supervisor. The child\n"
"process can also be restarted explicitly by calling `restart_child/2`. Use\n"
"`delete_child/2` to remove the child specification.\n"
"\n"
"If successful, this function returns `:ok`. If there is no child specification\n"
"for the given child id or there is no process with the given PID, this\n"
"function returns `{:error, :not_found}`.\n"
msgstr ""
#. TRANSLATORS: def Supervisor.delete_child(supervisor, child_id)
#: lib/supervisor.ex:405 
msgid ""
"Deletes the child specification identified by `child_id`.\n"
"\n"
"The corresponding child process must not be running; use `terminate_child/2`\n"
"to terminate it if it's running.\n"
"\n"
"If successful, this function returns `:ok`. This function may return an error\n"
"with an appropriate error tuple if the `child_id` is not found, or if the\n"
"current process is running or being restarted.\n"
"\n"
"This operation is not supported by `:simple_one_for_one` supervisors.\n"
msgstr ""
#. TRANSLATORS: Elixir.Supervisor Summary
#: lib/supervisor.ex:2 
msgid ""
"A behaviour module for implementing supervision functionality.\n"
"\n"
"A supervisor is a process which supervises other processes, which we refer\n"
"to as *child processes*. Supervisors are used to build a hierarchical process\n"
"structure called a *supervision tree*. Supervision trees are a nice way to\n"
"structure fault-tolerant applications.\n"
"\n"
"A supervisor implemented using this module has a standard set\n"
"of interface functions and includes functionality for tracing and error\n"
"reporting. It also fits into a supervision tree.\n"
"\n"
"## Examples\n"
"\n"
"In order to define a supervisor, we need to first define a child process\n"
"that is going to be supervised. In order to do so, we will define a GenServer\n"
"that represents a stack:\n"
"\n"
"    defmodule Stack do\n"
"      use GenServer\n"
"\n"
"      def start_link(state, opts \\\\ []) do\n"
"        GenServer.start_link(__MODULE__, state, opts)\n"
"      end\n"
"\n"
"      def handle_call(:pop, _from, [h | t]) do\n"
"        {:reply, h, t}\n"
"      end\n"
"\n"
"      def handle_cast({:push, h}, t) do\n"
"        {:noreply, [h | t]}\n"
"      end\n"
"    end\n"
"\n"
"We can now define our supervisor and start it as follows:\n"
"\n"
"    # Import helpers for defining supervisors\n"
"    import Supervisor.Spec\n"
"\n"
"    # Supervise the Stack server which will be started with\n"
"    # two arguments. The initial stack, [:hello], and a\n"
"    # keyword list containing the GenServer options that\n"
"    # set the registered name of the server to MyStack.\n"
"    children = [\n"
"      worker(Stack, [[:hello], [name: MyStack]])\n"
"    ]\n"
"\n"
"    # Start the supervisor with our child\n"
"    {:ok, pid} = Supervisor.start_link(children, strategy: :one_for_one)\n"
"\n"
"    # There is one child worker started\n"
"    Supervisor.count_children(pid)\n"
"    #=> %{active: 1, specs: 1, supervisors: 0, workers: 1}\n"
"\n"
"Notice that when starting the GenServer, we are registering it\n"
"with name `MyStack`, which allows us to call it directly and\n"
"get what is on the stack:\n"
"\n"
"    GenServer.call(MyStack, :pop)\n"
"    #=> :hello\n"
"\n"
"    GenServer.cast(MyStack, {:push, :world})\n"
"    #=> :ok\n"
"\n"
"    GenServer.call(MyStack, :pop)\n"
"    #=> :world\n"
"\n"
"However, there is a bug in our stack server. If we call `:pop` and\n"
"the stack is empty, it is going to crash because no clause matches:\n"
"\n"
"    GenServer.call(MyStack, :pop)\n"
"    ** (exit) exited in: GenServer.call(MyStack, :pop, 5000)\n"
"\n"
"Luckily, since the server is being supervised by a supervisor, the\n"
"supervisor will automatically start a new one, with the initial stack\n"
"of `[:hello]`:\n"
"\n"
"    GenServer.call(MyStack, :pop)\n"
"    #=> :hello\n"
"\n"
"Supervisors support different strategies; in the example above, we\n"
"have chosen `:one_for_one`. Furthermore, each supervisor can have many\n"
"workers and supervisors as children, each of them with their specific\n"
"configuration, shutdown values, and restart strategies.\n"
"\n"
"The rest of this documentation will cover supervision strategies; also read\n"
"the documentation for the `Supervisor.Spec` module to learn about the\n"
"specification for workers and supervisors.\n"
"\n"
"## Module-based supervisors\n"
"\n"
"In the example above, a supervisor was started by passing the supervision\n"
"structure to `start_link/2`. However, supervisors can also be created by\n"
"explicitly defining a supervision module:\n"
"\n"
"    defmodule MyApp.Supervisor do\n"
"      # Automatically imports Supervisor.Spec\n"
"      use Supervisor\n"
"\n"
"      def start_link do\n"
"        Supervisor.start_link(__MODULE__, [])\n"
"      end\n"
"\n"
"      def init([]) do\n"
"        children = [\n"
"          worker(Stack, [[:hello]])\n"
"        ]\n"
"\n"
"        # supervise/2 is imported from Supervisor.Spec\n"
"        supervise(children, strategy: :one_for_one)\n"
"      end\n"
"    end\n"
"\n"
"You may want to use a module-based supervisor if:\n"
"\n"
"  * You need to perform some particular action on supervisor\n"
"    initialization, like setting up an ETS table.\n"
"\n"
"  * You want to perform partial hot-code swapping of the\n"
"    tree. For example, if you add or remove children,\n"
"    the module-based supervision will add and remove the\n"
"    new children directly, while dynamic supervision\n"
"    requires the whole tree to be restarted in order to\n"
"    perform such swaps.\n"
"\n"
"## Strategies\n"
"\n"
"Supervisors support different supervision strategies (through the `:strategy`\n"
"option, as seen above):\n"
"\n"
"  * `:one_for_one` - if a child process terminates, only that\n"
"    process is restarted.\n"
"\n"
"  * `:one_for_all` - if a child process terminates, all other child\n"
"    processes are terminated and then all child processes (including\n"
"    the terminated one) are restarted.\n"
"\n"
"  * `:rest_for_one` - if a child process terminates, the \"rest\" of\n"
"    the child processes, i.e., the child processes after the terminated\n"
"    one in start order, are terminated. Then the terminated child\n"
"    process and the rest of the child processes are restarted.\n"
"\n"
"  * `:simple_one_for_one` - similar to `:one_for_one` but suits better\n"
"    when dynamically attaching children. This strategy requires the\n"
"    supervisor specification to contain only one child. Many functions\n"
"    in this module behave slightly differently when this strategy is\n"
"    used.\n"
"\n"
"## Simple one for one\n"
"\n"
"The `:simple_one_for_one` supervisor is useful when you want to dynamically\n"
"start and stop supervised children. For example, imagine you want to\n"
"dynamically create multiple stacks. We can do so by defining a `:simple_one_for_one`\n"
"supervisor:\n"
"\n"
"    # Import helpers for defining supervisors\n"
"    import Supervisor.Spec\n"
"\n"
"    # This time, we don't pass any argument because\n"
"    # the argument will be given when we start the child\n"
"    children = [\n"
"      worker(Stack, [], restart: :transient)\n"
"    ]\n"
"\n"
"    # Start the supervisor with our one child as a template\n"
"    {:ok, sup_pid} = Supervisor.start_link(children, strategy: :simple_one_for_one)\n"
"\n"
"    # No child worker is active yet until start_child is called\n"
"    Supervisor.count_children(sup_pid)\n"
"    #=> %{active: 0, specs: 1, supervisors: 0, workers: 0}\n"
"\n"
"There are a couple differences here:\n"
"\n"
"  * the simple one for one specification can define only one child which\n"
"    works as a template for when we call `start_child/2`\n"
"\n"
"  * we have defined the child to have a restart strategy of `:transient`. This\n"
"    means that, if the child process exits due to a `:normal`, `:shutdown`,\n"
"    or `{:shutdown, term}` reason, it won't be restarted. This is useful\n"
"    as it allows our workers to politely shutdown and be removed from the\n"
"    `:simple_one_for_one` supervisor, without being restarted. You can find\n"
"    more information about restart strategies in the documentation for the\n"
"    `Supervisor.Spec` module\n"
"\n"
"With the supervisor defined, let's dynamically start stacks:\n"
"\n"
"    {:ok, pid} = Supervisor.start_child(sup_pid, [[:hello, :world], []])\n"
"    GenServer.call(pid, :pop) #=> :hello\n"
"    GenServer.call(pid, :pop) #=> :world\n"
"\n"
"    {:ok, pid} = Supervisor.start_child(sup_pid, [[:something, :else], []])\n"
"    GenServer.call(pid, :pop) #=> :something\n"
"    GenServer.call(pid, :pop) #=> :else\n"
"\n"
"    Supervisor.count_children(sup_pid)\n"
"    #=> %{active: 2, specs: 1, supervisors: 0, workers: 2}\n"
"\n"
"## Exit reasons\n"
"\n"
"From the example above, you may have noticed that the `:transient` restart\n"
"strategy for the worker does not restart the child in case it exits with\n"
"reason `:normal`, `:shutdown` or `{:shutdown, term}`.\n"
"\n"
"So one may ask: which exit reason should I choose when exiting my worker?\n"
"There are three options:\n"
"\n"
"  * `:normal` - in such cases, the exit won't be logged, there is no restart\n"
"    in transient mode, and linked processes do not exit\n"
"\n"
"  * `:shutdown` or `{:shutdown, term}` - in such cases, the exit won't be\n"
"    logged, there is no restart in transient mode, and linked processes exit\n"
"    with the same reason unless they're trapping exits\n"
"\n"
"  * any other term - in such cases, the exit will be logged, there are\n"
"    restarts in transient mode, and linked processes exit with the same reason\n"
"    unless they're trapping exits\n"
"\n"
"## Name registration\n"
"\n"
"A supervisor is bound to the same name registration rules as a `GenServer`.\n"
"Read more about these rules in the documentation for `GenServer`.\n"
"\n"
msgstr ""
#. TRANSLATORS: @type on_start_child
#: lib/supervisor.ex:250 
msgid ""
"Return values of `start_child` functions"
msgstr ""
#. TRANSLATORS: @type name
#: lib/supervisor.ex:256 
msgid ""
"The Supervisor name"
msgstr ""
#. TRANSLATORS: def Supervisor.stop(supervisor, reason \\ :normal, timeout \\ :infinity)
#: lib/supervisor.ex:507 
msgid ""
"Stops the given supervisor with the given `reason`.\n"
"\n"
"It returns `:ok` if the supervisor terminates with the given\n"
"reason. If it terminates with another reason, the call exits.\n"
"\n"
"This function keeps OTP semantics regarding error reporting.\n"
"If the reason is any other than `:normal`, `:shutdown` or\n"
"`{:shutdown, _}`, an error report is logged.\n"
msgstr ""
#. TRANSLATORS: def Supervisor.start_child(supervisor, child_spec_or_args)
#: lib/supervisor.ex:345 
msgid ""
"Dynamically adds a child specification to `supervisor` and starts that child.\n"
"\n"
"`child_spec` should be a valid child specification (unless the supervisor\n"
"is a `:simple_one_for_one` supervisor, see below). The child process will\n"
"be started as defined in the child specification.\n"
"\n"
"In the case of `:simple_one_for_one`, the child specification defined in\n"
"the supervisor is used and instead of a `child_spec`, an arbitrary list\n"
"of terms is expected. The child process will then be started by appending\n"
"the given list to the existing function arguments in the child specification.\n"
"\n"
"If a child specification with the specified id already exists, `child_spec` is\n"
"discarded and this function returns an error with `:already_started` or\n"
"`:already_present` if the corresponding child process is running or not,\n"
"respectively.\n"
"\n"
"If the child process start function returns `{:ok, child}` or `{:ok, child,\n"
"info}`, then child specification and PID are added to the supervisor and\n"
"this function returns the same value.\n"
"\n"
"If the child process start function returns `:ignore`, the child specification\n"
"is added to the supervisor, the PID is set to `:undefined` and this function\n"
"returns `{:ok, :undefined}`.\n"
"\n"
"If the child process start function returns an error tuple or an erroneous\n"
"value, or if it fails, the child specification is discarded and this function\n"
"returns `{:error, error}` where `error` is a term containing information about\n"
"the error and child specification.\n"
msgstr ""
