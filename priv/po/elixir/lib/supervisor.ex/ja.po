msgid ""
msgstr ""
"Project-Id-Version: l 10n_elixir\n"
"PO-Revision-Date: 2017-02-25 22:13+0900\n"
"Last-Translator: 小田 照敬 <EMAIL@ADDRESS>\n"
"Language-Team: Japanese\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"POT-Creation-Date: \n"
"X-Generator: Poedit 1.8.12\n"

#. TRANSLATORS: @type on_start
#: lib/supervisor.ex:246
msgid "Return values of `start_link` functions"
msgstr "`start_link`関数の返り値"

#. TRANSLATORS: def Supervisor.stop(supervisor, reason \\ :normal, timeout \\ :infinity)
#: lib/supervisor.ex:507
msgid ""
"Stops the given supervisor with the given `reason`.\n"
"\n"
"It returns `:ok` if the supervisor terminates with the given\n"
"reason. If it terminates with another reason, the call exits.\n"
"\n"
"This function keeps OTP semantics regarding error reporting.\n"
"If the reason is any other than `:normal`, `:shutdown` or\n"
"`{:shutdown, _}`, an error report is logged.\n"
msgstr ""
"指定した`reason`で指定のスーパバイザを停止します。\n"
"\n"
"スーババイザが指定した理由で終了した場合、`:ok`を返します。\n"
"他の理由で終了した場合は、呼び出しは終了します。\n"
"\n"
"この関数はエラーレポートに関するOTPセマンティクスを維持します。\n"
"理由が、`:normal`, `:shutdown`あるいは`{:shutdown, _}`以外の\n"
"場合は、エラーレポートがログ出力されます。\n"

#. TRANSLATORS: @type options
#: lib/supervisor.ex:259
msgid "Options used by the `start*` functions"
msgstr "`start*`関数で使われるオプション"

#. TRANSLATORS: @callback init/1
#: lib/supervisor.ex:237
msgid ""
"Callback invoked to start the supervisor and during hot code upgrades.\n"
msgstr ""
"スーパバイザの起動のために、また、ホットコードアップグレード中に呼び出される"
"コールバックです。\n"

#. TRANSLATORS: def Supervisor.restart_child(supervisor, child_id)
#: lib/supervisor.ex:423
msgid ""
"Restarts a child process identified by `child_id`.\n"
"\n"
"The child specification must exist and the corresponding child process must "
"not\n"
"be running.\n"
"\n"
"Note that for temporary children, the child specification is automatically "
"deleted\n"
"when the child terminates, and thus it is not possible to restart such "
"children.\n"
"\n"
"If the child process start function returns `{:ok, child}` or `{:ok, child, "
"info}`,\n"
"the PID is added to the supervisor and this function returns the same "
"value.\n"
"\n"
"If the child process start function returns `:ignore`, the PID remains set "
"to\n"
"`:undefined` and this function returns `{:ok, :undefined}`.\n"
"\n"
"This function may return an error with an appropriate error tuple if the\n"
"`child_id` is not found, or if the current process is running or being\n"
"restarted.\n"
"\n"
"If the child process start function returns an error tuple or an erroneous "
"value,\n"
"or if it fails, this function returns `{:error, error}`.\n"
"\n"
"This operation is not supported by `:simple_one_for_one` supervisors.\n"
msgstr ""
"`child_id`で識別される子プロセスをリスタートします。\n"
"\n"
"子の仕様が存在しなくてはなりません。また、対応する子プロセスが実行中で\n"
"あってはいけません。\n"
"\n"
"テンポラリ指定の子については、子の仕様が子の終了とともに自動的に削除されます"
"ので、\n"
"そのような子は再起動できないことに注意してください。\n"
"\n"
"子プロセスのスタート関数が`{:ok, child}`または`{:ok, child, info}`を返した場"
"合、\n"
"そのPIDがスーパバイザに追加され、この関数は同じ値を返します。\n"
"\n"
"子プロセスのスタート関数が`:ignore`を返した場合、PIDは`:undefined`の\n"
"ままで、この関数は`{:ok, :undefined}`を返します。\n"
"\n"
"この関数は、`child_id`が見付からない、現在のプロセスが実行中である、また"
"は、\n"
"再起動中の場合、適切なエラータプルを持つエラーを帰すことができます。\n"
"\n"
"子プロセスのスタート関数がエラータプルまたは間違った値を返す場合、\n"
"あるいは関数が失敗した場合、この関数は`{:error, error}`を返します。\n"
"\n"
"この操作は`:simple_one_for_one`スーパバイザではサポートされて\n"
"いません。\n"

#. TRANSLATORS: @type supervisor
#: lib/supervisor.ex:265
msgid "The supervisor reference"
msgstr "スーパバイザのリファンレンス"

#. TRANSLATORS: def Supervisor.count_children(supervisor)
#: lib/supervisor.ex:483
msgid ""
"Returns a map containing count values for the given supervisor.\n"
"\n"
"The map contains the following keys:\n"
"\n"
"  * `:specs` - the total count of children, dead or alive\n"
"\n"
"  * `:active` - the count of all actively running child processes managed "
"by\n"
"    this supervisor\n"
"\n"
"  * `:supervisors` - the count of all supervisors whether or not these\n"
"    child supervisors are still alive\n"
"\n"
"  * `:workers` - the count of all workers, whether or not these child "
"workers\n"
"    are still alive\n"
"\n"
msgstr ""
"指定したスーパバイザの子プロセスのカウント値を含むマップを返します。\n"
"\n"
"マップは以下のキーを含みます:\n"
"\n"
"  * `:specs` - 子プロセスの総数。その生死は問わない\n"
"\n"
"  * `:active` - このスーパバイザが管理している実行中のアクティブな\n"
"     子プロセスの総数\n"
"\n"
"  * `:supervisors` - スーパバイザの総数。これら子のスーパーバイザが生きてい"
"るかは問わない、\n"
"     \n"
"\n"
"  * `:workers` - ワーカーの総数。これら子プロセスが生きているかは問わない\n"
"\n"

#. TRANSLATORS: def Supervisor.which_children(supervisor)
#: lib/supervisor.ex:454
msgid ""
"Returns a list with information about all children of the given "
"supervisor.\n"
"\n"
"Note that calling this function when supervising a large number of "
"children\n"
"under low memory conditions can cause an out of memory exception.\n"
"\n"
"This function returns a list of `{id, child, type, modules}` tuples, "
"where:\n"
"\n"
"  * `id` - as defined in the child specification or `:undefined` in the "
"case\n"
"    of a `simple_one_for_one` supervisor\n"
"\n"
"  * `child` - the PID of the corresponding child process, `:restarting` if "
"the\n"
"    process is about to be restarted, or `:undefined` if there is no such\n"
"    process\n"
"\n"
"  * `type` - `:worker` or `:supervisor`, as specified by the child "
"specification\n"
"\n"
"  * `modules` - as specified by the child specification\n"
"\n"
msgstr ""
"指定したスーパーバイザのすべての子プロセスに関する情報を持つリストを返しま"
"す。\n"
"\n"
"メモリが少ない状況で非常に多くの子プロセスを監視している際にこの関数を\n"
"実行すると、`out of memory`例外を引き起こす場合があることに注意してくださ"
"い。\n"
"\n"
"この関数は`{id, child, type, modules}`タプルのリストを返します。ここで:\n"
"\n"
"  * `id` - 子仕様で定義されたid、または、`simple_one_for_one`スーパバイザ"
"の\n"
"    場合は`:undefined`\n"
"\n"
"  * `child` - 対応する子プロセスのpid。プロセスが再起動中の場合は`:"
"restarting`、\n"
"    そのようなプロセスがない場合は`:undefined`\n"
"\n"
"  * `type` - 子仕様で指定された`:worker` または `:supervisor` \n"
"\n"
"  * `modules` - 子仕様が定義されたモジュール\n"
"\n"

#. TRANSLATORS: def Supervisor.terminate_child(supervisor, pid_or_child_id)
#: lib/supervisor.ex:380
msgid ""
"Terminates the given children, identified by PID or child id.\n"
"\n"
"If the supervisor is not a `:simple_one_for_one`, the child id is expected\n"
"and the process, if there's one, is terminated; the child specification is\n"
"kept unless the child is temporary.\n"
"\n"
"In case of a `:simple_one_for_one` supervisor, a PID is expected. If the "
"child\n"
"specification identifier is given instead of a `pid`, this function "
"returns\n"
"`{:error, :simple_one_for_one}`.\n"
"\n"
"A non-temporary child process may later be restarted by the supervisor. The "
"child\n"
"process can also be restarted explicitly by calling `restart_child/2`. Use\n"
"`delete_child/2` to remove the child specification.\n"
"\n"
"If successful, this function returns `:ok`. If there is no child "
"specification\n"
"for the given child id or there is no process with the given PID, this\n"
"function returns `{:error, :not_found}`.\n"
msgstr ""
"PIDまたはchild idで識別される、指定の子プロセスを終了します。\n"
"\n"
"スーパバイザが`simple_one_for_one`でない場合、引数はchild idで、\n"
"そのプロセスが存在する場合は終了させられます; 子プロセスがテンポラ\n"
"リでない限り、子プロセス仕様は保持されます。\n"
"\n"
"`:simple_one_for_one`スーパバイザの場合、引数はpidです。`pid`でなく\n"
"子プロセス仕様識別子が指定された場合、この関数は`{:error, \n"
":simple_one_for_one}`を返します。\n"
"\n"
"テンポラリでない子プロセスはスーパバイザにより再起動されます。\n"
"この子プロセスは、`restart_child/2`を呼び出すことで明示的に再起動する\n"
"こともできます。子プロセス仕様を削除するには`delete_child/2`を使用してくださ"
"い。\n"
"\n"
"成功した場合、この関数は`:ok`を返します。指定したchilid_idの子プロセス仕様"
"が\n"
"存在しない、または指定したPIDのプロセスが存在しない場合、\n"
"この関数は`{:error, :not_found}`を返します。\n"

#. TRANSLATORS: def Supervisor.start_link(module, arg, options \\ [])
#: lib/supervisor.ex:301
msgid ""
"Starts a supervisor process with the given `module` and `arg`.\n"
"\n"
"To start the supervisor, the `c:init/1` callback will be invoked in the "
"given\n"
"`module`, with `arg` as its argument. The `c:init/1` callback must return "
"a\n"
"supervisor specification which can be created with the help of the "
"functions\n"
"in the `Supervisor.Spec` module (especially `Supervisor.Spec."
"supervise/2`).\n"
"\n"
"If the `c:init/1` callback returns `:ignore`, this function returns\n"
"`:ignore` as well and the supervisor terminates with reason `:normal`.\n"
"If it fails or returns an incorrect value, this function returns\n"
"`{:error, term}` where `term` is a term with information about the\n"
"error, and the supervisor terminates with reason `term`.\n"
"\n"
"The `:name` option can also be given in order to register a supervisor\n"
"name, the supported values are described in the \"Name registration\"\n"
"section in the `GenServer` module docs.\n"
msgstr ""
"指定した`module`と`arg`でスーパバイザモジュールを起動します。\n"
"\n"
"スーパバイザを起動するために、指定したモジュールの`init/1`コールバックが\n"
"`arg`を引数として実行されます。`init/1`コールバックは`Supervisor.Spec`\n"
"モジュールの関数（特に、`Supervisor.Spec.supervise/2`）で作成することが\n"
"できるスーパーバイザ仕様を返さなくてはなりません。\n"
"\n"
"`init/1`コールバックが`:ignore`を返した場合、この関数も`:ignore`を返し、\n"
"スーパバイザは理由`:normal` で終了します。コールバックが失敗したり、\n"
"間違った値を返した場合、この関数は`{:error, term}`を返します。ここで、\n"
"`term`はエラーに関する情報を持つ項です。そして、スーパバイザは理由`term`で\n"
"終了します。\n"
"\n"
"スーパバイザ名を登録するために`:name`オプションを使うこともできます。\n"
"サポートされている値は、`GenServer`モジュールのドキュメントの「名前の\n"
"登録」セクションに記述されています。\n"

#. TRANSLATORS: def Supervisor.start_link(children, options)
#: lib/supervisor.ex:268
msgid ""
"Starts a supervisor with the given children.\n"
"\n"
"A strategy is required to be provided through the `:strategy` option.\n"
"Furthermore, the `:max_restarts` and `:max_seconds` options can be\n"
"configured as described in the documentation for `Supervisor.Spec."
"supervise/2`.\n"
"\n"
"The options can also be used to register a supervisor name.\n"
"The supported values are described under the \"Name registration\"\n"
"section in the `GenServer` module docs.\n"
"\n"
"If the supervisor and its child processes are successfully created\n"
"(i.e., if the start function of each child process returns `{:ok, child}`,\n"
"`{:ok, child, info}`, or `:ignore`) this function returns\n"
"`{:ok, pid}`, where `pid` is the PID of the supervisor. If a process with "
"the\n"
" specified name already exists, the function returns `{:error,\n"
" {:already_started, pid}}`, where `pid` is the PID of that process.\n"
"\n"
"If the start function of any of the child processes fails or returns an "
"error\n"
"tuple or an erroneous value, the supervisor first terminates with reason\n"
"`:shutdown` all the child processes that have already been started, and "
"then\n"
"terminates itself and returns `{:error, {:shutdown, reason}}`.\n"
"\n"
"Note that a supervisor started with this function is linked to the parent\n"
"process and exits not only on crashes but also if the parent process exits\n"
"with `:normal` reason.\n"
msgstr ""
"指定した子プロセスを持つスーパバイザを起動します。\n"
"\n"
"`:strategy`オプションで再起動戦略を指定する必要があります。\n"
"さらに、`Supervisor.Spec.supervise/2`のドキュメントで記述されている\n"
"ように、`:max_restarts`と`:max_seconds`の値を構成することができます。\n"
"\n"
"オプションを使用してスーパバイザの名前を登録することもできます。\n"
"サポートされている値は、`GenServer`モジュールのドキュメントの「名前の\n"
"登録」セクションに記述されています。\n"
"\n"
"スーパバイザとその子プロセスの作成が成功した場合(すなわち、\n"
"すべての子プロセスのスタート関数が`{:ok, chlid}`、`{:ok, child, info}`、\n"
"または、`:ignore`を返した場合)、この関数は`{:ok, pid}`を返します。\n"
"ここで、`pid`はスーパバイザのプPIDです。指定した名前を持つプロセスが\n"
"すでの存在している場合、この関数は`{:error, {:already_started, pid}}`\n"
"を返します。ここで、`pid`はそのプロセスのPIDです。\n"
"\n"
"子プロセスのいずれかのスタート関数が失敗した、あるいは\n"
"エラータプルまたは誤った値を返した場合、スーパバイザは、まず\n"
"起動済みのすべての子プロセスを理由`:shutdown`を付けて停止し、次に\n"
"自分自身を停止し、`{:error, {:shutdown, reason}}`を返します。\n"
"\n"
"この関数で起動されたスーパーバイザは親プロセスにリンクされ、\n"
"親プロセスがクラッシュした時だけでなく、理由`:normal` で終了した\n"
"場合も、終了することに注意してください。\n"

#. TRANSLATORS: def Supervisor.start_child(supervisor, child_spec_or_args)
#: lib/supervisor.ex:345
msgid ""
"Dynamically adds a child specification to `supervisor` and starts that "
"child.\n"
"\n"
"`child_spec` should be a valid child specification (unless the supervisor\n"
"is a `:simple_one_for_one` supervisor, see below). The child process will\n"
"be started as defined in the child specification.\n"
"\n"
"In the case of `:simple_one_for_one`, the child specification defined in\n"
"the supervisor is used and instead of a `child_spec`, an arbitrary list\n"
"of terms is expected. The child process will then be started by appending\n"
"the given list to the existing function arguments in the child "
"specification.\n"
"\n"
"If a child specification with the specified id already exists, `child_spec` "
"is\n"
"discarded and this function returns an error with `:already_started` or\n"
"`:already_present` if the corresponding child process is running or not,\n"
"respectively.\n"
"\n"
"If the child process start function returns `{:ok, child}` or `{:ok, "
"child,\n"
"info}`, then child specification and PID are added to the supervisor and\n"
"this function returns the same value.\n"
"\n"
"If the child process start function returns `:ignore`, the child "
"specification\n"
"is added to the supervisor, the PID is set to `:undefined` and this "
"function\n"
"returns `{:ok, :undefined}`.\n"
"\n"
"If the child process start function returns an error tuple or an erroneous\n"
"value, or if it fails, the child specification is discarded and this "
"function\n"
"returns `{:error, error}` where `error` is a term containing information "
"about\n"
"the error and child specification.\n"
msgstr ""
"スーパバイザに、子プロセスの仕様を動的に追加し、その子プロセスを\n"
"起動します。\n"
"\n"
"`child_spec`は有効な子プロセス仕様でなければなりません(スーパバイザが\n"
"`:simple_one_for_one`スーパバイザでない限り。下を参照してください)。\n"
"子プロセス仕様に定義されているとおりに子プロセスが起動されます。\n"
"\n"
"`:simple_one_for_one`の場合は、スーパバイザで定義された子プロセス仕様が\n"
"使用され、`child_spec`ではなく、任意の語のリストを引数にとります。\n"
"子プロセスは、子プロセス仕様にある既存の関数引数に指定したリストを追加する\n"
"ことにより起動されます。\n"
"\n"
"指定されたIDを持つ子プロセス仕様が既に存在していた場合、`child_spec`は捨てら"
"れ、\n"
"この関数は、対応する子プロセスが動作中か否かで、各々`:already_started`また"
"は\n"
"`:already_present`のエラーを返します。\n"
"\n"
"子プロセスのスタート関数が`{:ok, child}`または`{:ok, child, info}`を返した場"
"合、\n"
"子プロセス仕様とPIDがスーパバイザに追加され、この関数は同じ値を返します。\n"
"\n"
"子プロセスのスタート関数が`:ignore`を返した場合、子プロセス仕様はスーパバイ"
"ザに\n"
"追加され、PIDは`:undefined`に設定されます。そして、この関数は\n"
"`{:ok, :undefined}`を返します。\n"
"\n"
"子プロセスのスタート関数がエラータプルまたは間違った値を返す場合、\n"
"あるいは関数が失敗した場合、子プロセス仕様は捨てられ、この関数は\n"
"`{:error, error}`を返します。ここで`error`はエラーと子プロセス仕様に\n"
"関数情報を含む項です。\n"

#. TRANSLATORS: def Supervisor.delete_child(supervisor, child_id)
#: lib/supervisor.ex:405
msgid ""
"Deletes the child specification identified by `child_id`.\n"
"\n"
"The corresponding child process must not be running; use "
"`terminate_child/2`\n"
"to terminate it if it's running.\n"
"\n"
"If successful, this function returns `:ok`. This function may return an "
"error\n"
"with an appropriate error tuple if the `child_id` is not found, or if the\n"
"current process is running or being restarted.\n"
"\n"
"This operation is not supported by `:simple_one_for_one` supervisors.\n"
msgstr ""
"`child_id`で識別される子の仕様を削除します。\n"
"\n"
"対応する子プロセスは実行中であってはいけません。実行中の場合は、\n"
"`terminate_child/2`を使って終了させてください。\n"
"\n"
"成功した場合、この関数は`:ok`を返します。`child_id`が見付からない、\n"
"現在のプロセスが実行中または再起動中の場合、この関数は適切なエラータプルを持"
"つ\n"
"エラーを返すことができます。\n"
"\n"
"この操作は`:simple_one_for_one`スーパバイザではサポートされません。\n"

#. TRANSLATORS: @type on_start_child
#: lib/supervisor.ex:250
msgid "Return values of `start_child` functions"
msgstr "`start_child`関数の戻値"

#. TRANSLATORS: @type name
#: lib/supervisor.ex:256
msgid "The Supervisor name"
msgstr "スーパバイザの名前"

#. TRANSLATORS: Elixir.Supervisor Summary
#: lib/supervisor.ex:2
msgid ""
"A behaviour module for implementing supervision functionality.\n"
"\n"
"A supervisor is a process which supervises other processes, which we refer\n"
"to as *child processes*. Supervisors are used to build a hierarchical "
"process\n"
"structure called a *supervision tree*. Supervision trees are a nice way to\n"
"structure fault-tolerant applications.\n"
"\n"
"A supervisor implemented using this module has a standard set\n"
"of interface functions and includes functionality for tracing and error\n"
"reporting. It also fits into a supervision tree.\n"
"\n"
"## Examples\n"
"\n"
"In order to define a supervisor, we need to first define a child process\n"
"that is going to be supervised. In order to do so, we will define a "
"GenServer\n"
"that represents a stack:\n"
"\n"
"    defmodule Stack do\n"
"      use GenServer\n"
"\n"
"      def start_link(state, opts \\\\ []) do\n"
"        GenServer.start_link(__MODULE__, state, opts)\n"
"      end\n"
"\n"
"      def handle_call(:pop, _from, [h | t]) do\n"
"        {:reply, h, t}\n"
"      end\n"
"\n"
"      def handle_cast({:push, h}, t) do\n"
"        {:noreply, [h | t]}\n"
"      end\n"
"    end\n"
"\n"
"We can now define our supervisor and start it as follows:\n"
"\n"
"    # Import helpers for defining supervisors\n"
"    import Supervisor.Spec\n"
"\n"
"    # Supervise the Stack server which will be started with\n"
"    # two arguments. The initial stack, [:hello], and a\n"
"    # keyword list containing the GenServer options that\n"
"    # set the registered name of the server to MyStack.\n"
"    children = [\n"
"      worker(Stack, [[:hello], [name: MyStack]])\n"
"    ]\n"
"\n"
"    # Start the supervisor with our child\n"
"    {:ok, pid} = Supervisor.start_link(children, strategy: :one_for_one)\n"
"\n"
"    # There is one child worker started\n"
"    Supervisor.count_children(pid)\n"
"    #=> %{active: 1, specs: 1, supervisors: 0, workers: 1}\n"
"\n"
"Notice that when starting the GenServer, we are registering it\n"
"with name `MyStack`, which allows us to call it directly and\n"
"get what is on the stack:\n"
"\n"
"    GenServer.call(MyStack, :pop)\n"
"    #=> :hello\n"
"\n"
"    GenServer.cast(MyStack, {:push, :world})\n"
"    #=> :ok\n"
"\n"
"    GenServer.call(MyStack, :pop)\n"
"    #=> :world\n"
"\n"
"However, there is a bug in our stack server. If we call `:pop` and\n"
"the stack is empty, it is going to crash because no clause matches:\n"
"\n"
"    GenServer.call(MyStack, :pop)\n"
"    ** (exit) exited in: GenServer.call(MyStack, :pop, 5000)\n"
"\n"
"Luckily, since the server is being supervised by a supervisor, the\n"
"supervisor will automatically start a new one, with the initial stack\n"
"of `[:hello]`:\n"
"\n"
"    GenServer.call(MyStack, :pop)\n"
"    #=> :hello\n"
"\n"
"Supervisors support different strategies; in the example above, we\n"
"have chosen `:one_for_one`. Furthermore, each supervisor can have many\n"
"workers and supervisors as children, each of them with their specific\n"
"configuration, shutdown values, and restart strategies.\n"
"\n"
"The rest of this documentation will cover supervision strategies; also "
"read\n"
"the documentation for the `Supervisor.Spec` module to learn about the\n"
"specification for workers and supervisors.\n"
"\n"
"## Module-based supervisors\n"
"\n"
"In the example above, a supervisor was started by passing the supervision\n"
"structure to `start_link/2`. However, supervisors can also be created by\n"
"explicitly defining a supervision module:\n"
"\n"
"    defmodule MyApp.Supervisor do\n"
"      # Automatically imports Supervisor.Spec\n"
"      use Supervisor\n"
"\n"
"      def start_link do\n"
"        Supervisor.start_link(__MODULE__, [])\n"
"      end\n"
"\n"
"      def init([]) do\n"
"        children = [\n"
"          worker(Stack, [[:hello]])\n"
"        ]\n"
"\n"
"        # supervise/2 is imported from Supervisor.Spec\n"
"        supervise(children, strategy: :one_for_one)\n"
"      end\n"
"    end\n"
"\n"
"You may want to use a module-based supervisor if:\n"
"\n"
"  * You need to perform some particular action on supervisor\n"
"    initialization, like setting up an ETS table.\n"
"\n"
"  * You want to perform partial hot-code swapping of the\n"
"    tree. For example, if you add or remove children,\n"
"    the module-based supervision will add and remove the\n"
"    new children directly, while dynamic supervision\n"
"    requires the whole tree to be restarted in order to\n"
"    perform such swaps.\n"
"\n"
"## Strategies\n"
"\n"
"Supervisors support different supervision strategies (through the `:"
"strategy`\n"
"option, as seen above):\n"
"\n"
"  * `:one_for_one` - if a child process terminates, only that\n"
"    process is restarted.\n"
"\n"
"  * `:one_for_all` - if a child process terminates, all other child\n"
"    processes are terminated and then all child processes (including\n"
"    the terminated one) are restarted.\n"
"\n"
"  * `:rest_for_one` - if a child process terminates, the \"rest\" of\n"
"    the child processes, i.e., the child processes after the terminated\n"
"    one in start order, are terminated. Then the terminated child\n"
"    process and the rest of the child processes are restarted.\n"
"\n"
"  * `:simple_one_for_one` - similar to `:one_for_one` but suits better\n"
"    when dynamically attaching children. This strategy requires the\n"
"    supervisor specification to contain only one child. Many functions\n"
"    in this module behave slightly differently when this strategy is\n"
"    used.\n"
"\n"
"## Simple one for one\n"
"\n"
"The `:simple_one_for_one` supervisor is useful when you want to "
"dynamically\n"
"start and stop supervised children. For example, imagine you want to\n"
"dynamically create multiple stacks. We can do so by defining a `:"
"simple_one_for_one`\n"
"supervisor:\n"
"\n"
"    # Import helpers for defining supervisors\n"
"    import Supervisor.Spec\n"
"\n"
"    # This time, we don't pass any argument because\n"
"    # the argument will be given when we start the child\n"
"    children = [\n"
"      worker(Stack, [], restart: :transient)\n"
"    ]\n"
"\n"
"    # Start the supervisor with our one child as a template\n"
"    {:ok, sup_pid} = Supervisor.start_link(children, strategy: :"
"simple_one_for_one)\n"
"\n"
"    # No child worker is active yet until start_child is called\n"
"    Supervisor.count_children(sup_pid)\n"
"    #=> %{active: 0, specs: 1, supervisors: 0, workers: 0}\n"
"\n"
"There are a couple differences here:\n"
"\n"
"  * the simple one for one specification can define only one child which\n"
"    works as a template for when we call `start_child/2`\n"
"\n"
"  * we have defined the child to have a restart strategy of `:transient`. "
"This\n"
"    means that, if the child process exits due to a `:normal`, `:"
"shutdown`,\n"
"    or `{:shutdown, term}` reason, it won't be restarted. This is useful\n"
"    as it allows our workers to politely shutdown and be removed from the\n"
"    `:simple_one_for_one` supervisor, without being restarted. You can "
"find\n"
"    more information about restart strategies in the documentation for the\n"
"    `Supervisor.Spec` module\n"
"\n"
"With the supervisor defined, let's dynamically start stacks:\n"
"\n"
"    {:ok, pid} = Supervisor.start_child(sup_pid, [[:hello, :world], []])\n"
"    GenServer.call(pid, :pop) #=> :hello\n"
"    GenServer.call(pid, :pop) #=> :world\n"
"\n"
"    {:ok, pid} = Supervisor.start_child(sup_pid, [[:something, :else], "
"[]])\n"
"    GenServer.call(pid, :pop) #=> :something\n"
"    GenServer.call(pid, :pop) #=> :else\n"
"\n"
"    Supervisor.count_children(sup_pid)\n"
"    #=> %{active: 2, specs: 1, supervisors: 0, workers: 2}\n"
"\n"
"## Exit reasons\n"
"\n"
"From the example above, you may have noticed that the `:transient` restart\n"
"strategy for the worker does not restart the child in case it exits with\n"
"reason `:normal`, `:shutdown` or `{:shutdown, term}`.\n"
"\n"
"So one may ask: which exit reason should I choose when exiting my worker?\n"
"There are three options:\n"
"\n"
"  * `:normal` - in such cases, the exit won't be logged, there is no "
"restart\n"
"    in transient mode, and linked processes do not exit\n"
"\n"
"  * `:shutdown` or `{:shutdown, term}` - in such cases, the exit won't be\n"
"    logged, there is no restart in transient mode, and linked processes "
"exit\n"
"    with the same reason unless they're trapping exits\n"
"\n"
"  * any other term - in such cases, the exit will be logged, there are\n"
"    restarts in transient mode, and linked processes exit with the same "
"reason\n"
"    unless they're trapping exits\n"
"\n"
"## Name registration\n"
"\n"
"A supervisor is bound to the same name registration rules as a "
"`GenServer`.\n"
"Read more about these rules in the documentation for `GenServer`.\n"
"\n"
msgstr ""
"監視機能を実装するためのビヘイビアモジュールです。\n"
"\n"
"スーパバイザは、他のプロセス（ここでは*子プロセス*と呼ぶ）を\n"
"監視するプロセスです。スーパバイザは、*監視ツリー*と呼ばれる\n"
"階層的なプロセス構造を作成するのに使用されます。監視ツリーは\n"
"フォールトトレラントなアプリケーションを構築するための良い方法である。\n"
"\n"
"このモジュールを使って実装されたスーパバイザは、標準的なインタフェース\n"
"関数のセットを持ち、トレース機能とエラーレポート機能を含みます。これも\n"
"監視ツリーにふさわしいものです。\n"
"\n"
"## 例\n"
"\n"
"スーパバイザを定義するためには、まず監視される子プロセスを定義する必要が\n"
"あります。それをするために、スタックを表現するGenServerを定義\n"
"します:\n"
"\n"
"    defmodule Stack do\n"
"      use GenServer\n"
"\n"
"      def start_link(state, opts \\\\ []) do\n"
"        GenServer.start_link(__MODULE__, state, opts)\n"
"      end\n"
"\n"
"      def handle_call(:pop, _from, [h|t]) do\n"
"        {:reply, h, t}\n"
"      end\n"
"\n"
"      def handle_cast({:push, h}, t) do\n"
"        {:noreply, [h|t]}\n"
"      end\n"
"    end\n"
"\n"
"次にスーパバイザを定義し、次のように起動します:\n"
"\n"
"    # スーパーバイザを定義するためのヘルパーをインポート\n"
"    import Supervisor.Spec\n"
"\n"
"    # 2つの引数で起動されるStackサーバーを監視する。\n"
"    # 引数は、初期スタック [:hello]とサーバの登録名をMyStackに\n"
"    # 設定するGenServerオプションを含むキーワードリストです。\n"
"    children = [\n"
"      worker(Stack, [[:hello], [name: :sup_stack]])\n"
"    ]\n"
"\n"
"    # 子プロセスを1つ持つスーパーバイザを起動する\n"
"    {:ok, pid} = Supervisor.start_link(children, strategy: :one_for_one)\n"
"\n"
"    # 起動した子ワーカーが1つ存在する\n"
"    Supervisor.count_children(pid)\n"
"    #=> %{active: 1, specs: 1, supervisors: 0, workers: 1}\n"
"\n"
"GenServerを起動する際、`MyStack`という名前でそれを登録して\n"
"いることに注意してください。これによりそれを直接呼び出すことが\n"
"でき、スタックに何があるかを得ることができます。:\n"
"\n"
"    GenServer.call(MyStack, :pop)\n"
"    #=> :hello\n"
"\n"
"    GenServer.cast(MyStack, {:push, :world})\n"
"    #=> :ok\n"
"\n"
"    GenServer.call(MyStack, :pop)\n"
"    #=> :world\n"
"\n"
"しかし、このスタックサーバにはバグがあります。スタックが空のときに\n"
"`:pop`を呼び出すと、クラッシュします。マッチする節がないからです:\n"
"\n"
"    GenServer.call(MyStack, :pop)\n"
"    ** (exit) exited in: GenServer.call(MyStack, :pop, 5000)\n"
"\n"
"幸運にも、このサーバはスーパバイザに監視されていたので、\n"
"スーパバイザは自動的に初期スタック`[:hello]`を持つ新しいサーバを\n"
"開始します:\n"
"\n"
"    GenServer.call(MyStack, :pop)\n"
"    #=> :hello\n"
"\n"
"スーパバイザは様々な戦略をサポートします; 上の例では、`:one_for_one`を選\n"
"択しました。さらに、各スーパバイザは多くのワーカーとスーパバイザを子として\n"
"持つことができます。これらは各々独自の構成、停止値、再起動戦略を持ちます。\n"
"\n"
"以下では監視戦略を説明します。ワーカーとスーパーバイザの仕様に関して\n"
"知りたい場合は`Supervisor.Spec`モジュールのドキュメントを読んで\n"
"ください。\n"
"\n"
"## モジュールベースのスーパーバイザ\n"
"\n"
"上の例では、スーパバイザは、`start_link/2`に監視構造を渡すことにより\n"
"起動されました。しかし、スーパバイザは、スーパーバイザモジュールを\n"
"明示的に定義することによって作成することもできます:\n"
"\n"
"    defmodule MyApp.Supervisor do\n"
"      # 自動的にSupervisor.Specをインポートする\n"
"      use Supervisor\n"
"\n"
"      def start_link do\n"
"        Supervisor.start_link(__MODULE__, [])\n"
"      end\n"
"\n"
"      def init([]) do\n"
"        children = [\n"
"          worker(Stack, [[:hello]])\n"
"        ]\n"
"\n"
"        # supervise/2はSupervisor.Specからインポートされている\n"
"        supervise(children, strategy: :one_for_one)\n"
"      end\n"
"    end\n"
"\n"
"以下のような場合にモジュールベースのスーパバイザを使いたくなるでしょう:\n"
"\n"
"  * たとえば、ETSテーブルの設定など、スーパーバイザの初期化時に\n"
"     特定の作業を実行する必要がある。\n"
"\n"
"  * ツリーの部分的なホットコードスワッピングを実行したい。\n"
"    例えば、子プロセスを追加または削除をする場合、モジュールベースの\n"
"    スーパーバイザは、新たな子プロセスを直接、追加または削除します。一方、\n"
"    動的なスーパーバイザでは、そのようなスワップを実行するには\n"
"    ツリー全体の再起動が必要です。\n"
"\n"
"## 戦略\n"
"\n"
"スーパーバイザは様々な監視戦略をサポートしています（上で示したように\n"
"`:strategy`オプションで設定します）。\n"
"\n"
"  * `:one_for_one` - 子プロセスが終了した場合、そのプロセスだけが\n"
"     再起動されます\n"
"\n"
"  * `:one_for_all` - 子プロセスが終了した場合、他のすべてのプロセスも\n"
"    終了させられ、その後、（終了したプロセスを含む）すべての子プロセスが\n"
"    再起動されます。\n"
"\n"
"  * `:rest_for_one` - 子プロセスが終了した場合、「残りの」子プロセス\n"
"    （すなわち、終了したプロセスより後に起動した子プロセス）が\n"
"    終了させられ、その後、終了した子プロセスと残りの子プロセスが\n"
"    再起動されます。\n"
"\n"
"  * `:simple_one_for_one` - `:one_for_one`に似ていますが、動的に\n"
"    子プロセスをアタッチする場合に適しています。この戦略は\n"
"    スーパバイザ仕様に含める子プロセスは1つだけであることを要求します。\n"
"    この戦略が仕様された場合、このモジュールの多くの関数はわずかに\n"
"    異るふるまいをします。\n"
"\n"
"## Simple one for one戦略\n"
"\n"
"`:simple_one_for_one`スーパバイザは、監視する子プロセスを動的に起動、\n"
"停止した場合に便利です。たとえば、複数のスタックを動的に作成したい時などで"
"す。\n"
"`:simple_one_for_one`スーパバイザを定義することにより次のように実現\n"
"できます:\n"
"\n"
"    # スーパーバイザを定義するヘルパーをインポートする\n"
"    import Supervisor.Spec\n"
"\n"
"    # 今度は引数をわたさない。なぜなら、引数は子プロセスを\n"
"    # 起動するときに渡すからである。\n"
"    children = [\n"
"      worker(Stack, [], restart: :transient)\n"
"    ]\n"
"\n"
"    # 1つの子プロセスを持つスーパーバイザを起動する\n"
"    {:ok, sup_pid} = Supervisor.start_link(children, strategy: :"
"simple_one_for_one)\n"
"\n"
"    # start_chileが実行されるまでアクティブな子ワーカーは存在しない\n"
"    Supervisor.count_children(sup_pid)\n"
"    #=> %{active: 0, specs: 1, supervisors: 0, workers: 0}\n"
"\n"
"`:one_for_one` 戦略とはいくつかの違いがあります:\n"
"\n"
"  * `simple one for one`の仕様は、子プロセスを1つしか定義できません。\n"
"    これは`start_child/2`を呼ぶ際のテンプレートとして働きます。\n"
"\n"
"  * 再起動戦略が`:transient`の子プロセスを定義しました。これは、子プロセス"
"が\n"
"    `:normal`、`:shutdown`、 `{:shutdown, term}`のいずれかの理由で終了した\n"
"    場合、この子プロセスは再起動されないことを意味します。これは、ワーカー"
"を\n"
"    やさしく停止させ、再起動することなく`:simple_one_for_one`スーパーバイ"
"ザ\n"
"    から削除できるため、便利です。再起動戦略に関するより詳しい情報は\n"
"    `Supervisor.Spec`モジュールのドキュメントにあります。\n"
"\n"
"スーパーバイザを定義したので、動的にスタックを起動しましょう:\n"
"\n"
"    {:ok, pid} = Supervisor.start_child(sup_pid, [[:hello, :world], []])\n"
"    GenServer.call(pid, :pop) #=> :hello\n"
"    GenServer.call(pid, :pop) #=> :world\n"
"\n"
"    {:ok, pid} = Supervisor.start_child(sup_pid, [[:something, :else], "
"[]])\n"
"    GenServer.call(pid, :pop) #=> :something\n"
"    GenServer.call(pid, :pop) #=> :else\n"
"\n"
"    Supervisor.count_children(sup_pid)\n"
"    #=> %{active: 2, specs: 1, supervisors: 0, workers: 2}\n"
"\n"
"## 終了理由\n"
"\n"
"上の例から、ワーカーの再起動戦略が`:transient`の場合、`:normal`、\n"
"`:shutdown`、`{:shutdown, term}`のいずれかの理由で終了した場合、\n"
"子プロセスを再起動しないことに気付いたでしょう。\n"
"\n"
"そこで次の質問が浮かぶでしょう。すなわち、ワーカーを終了させる時には、\n"
"どの終了理由を選べばいいのか、です。3つの選択肢があります:\n"
"\n"
"  * `:normal` - この場合、終了のログは出力されません。`:transient`モードで"
"は\n"
"    再起動はされず、リンクされたプロセスも終了しません。\n"
"\n"
"  * `:shutdown` または `{:shutdown, term}` - この場合、終了のログは出力\n"
"    されません。`:transient`モードでは再起動はされません。リンクされた\n"
"    プロセスは終了が捕捉されていない限り、同じ理由で終了します。\n"
"\n"
"  * その他の項 - この場合、終了のログが出力されます。`:transient`モードで"
"も\n"
"    再起動されます。リンクされたプロセスは終了が捕捉されていない限り、\n"
"    同じ理由で終了します、\n"
"\n"
"## 名前の登録\n"
"\n"
"スーパーバイザは、`GenServer`と同じ名前登録規則に従います。\n"
"この規則の詳細は、`GenServer`のドキュメントを参照してください。\n"
