msgid ""
msgstr ""
"Project-Id-Version: l 10n_elixir\n"
"POT-Creation-Date: \n"
"PO-Revision-Date: 2017-03-13 10:38+0900\n"
"Last-Translator: 小田 照敬 <EMAIL@ADDRESS>\n"
"Language-Team: Japanese\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Poedit 1.8.12\n"

#. TRANSLATORS: @callback format_status/2
#: lib/gen_server.ex:488
msgid ""
"Invoked in some cases to retrieve a formatted version of the `GenServer` "
"status.\n"
"\n"
"This callback can be useful to control the *appearance* of the status of "
"the\n"
"`GenServer`. For example, it can be used to return a compact representation "
"of\n"
"the `GenServer`'s state to avoid having large state terms printed.\n"
"\n"
"  * one of `:sys.get_status/1` or `:sys.get_status/2` is invoked to get the\n"
"    status of the `GenServer`; in such cases, `reason` is `:normal`\n"
"\n"
"  * the `GenServer` terminates abnormally and logs an error; in such cases,\n"
"    `reason` is `:terminate`\n"
"\n"
"`pdict_and_state` is a two-elements list `[pdict, state]` where `pdict` is "
"a\n"
"list of `{key, value}` tuples representing the current process dictionary "
"of\n"
"the `GenServer` and `state` is the current state of the `GenServer`.\n"
msgstr ""
"場合によって、`GenServer`の状態のフォーマット済バージョンを\n"
"取得するために呼び出されます。\n"
"\n"
"このコールバックは、`GenServer`の状態の*外観*を制御するのに便利です。\n"
"たとえば、`GenServer`の状態を簡潔な表現で返し、状態の項目を大量に\n"
"印刷するのを避けることに使用できます。\n"
"\n"
"  * `GenServer`の状態を得るために`:sys.get_status/1`または`:sys.get_status/2`"
"の\n"
"    いずれかが呼び出されます。このような場合`reason`は`:normal`です。\n"
"\n"
"  * `GenServer`が異常終了し、エラーをログ出力する。このような場合、\n"
"    `reason`は`:terminate`です。\n"
"\n"
"`pdict_and_state`は2要素のリスト`[pdict、state]`です。ここで、\n"
"`pdict`は`GenServer`の現在のプロセス辞書を表す`{key、value}`タプルの\n"
"リストであり、`state`は`GenServer`の現在の状態です。\n"

#. TRANSLATORS: @callback init/1
#: lib/gen_server.ex:277
msgid ""
"Invoked when the server is started. `start_link/3` or `start/3` will\n"
"block until it returns.\n"
"\n"
"`args` is the argument term (second argument) passed to `start_link/3`.\n"
"\n"
"Returning `{:ok, state}` will cause `start_link/3` to return\n"
"`{:ok, pid}` and the process to enter its loop.\n"
"\n"
"Returning `{:ok, state, timeout}` is similar to `{:ok, state}`\n"
"except `handle_info(:timeout, state)` will be called after `timeout`\n"
"milliseconds if no messages are received within the timeout.\n"
"\n"
"Returning `{:ok, state, :hibernate}` is similar to\n"
"`{:ok, state}` except the process is hibernated before entering the loop. "
"See\n"
"`c:handle_call/3` for more information on hibernation.\n"
"\n"
"Returning `:ignore` will cause `start_link/3` to return `:ignore` and the\n"
"process will exit normally without entering the loop or calling `c:"
"terminate/2`.\n"
"If used when part of a supervision tree the parent supervisor will not fail\n"
"to start nor immediately try to restart the `GenServer`. The remainder of "
"the\n"
"supervision tree will be (re)started and so the `GenServer` should not be\n"
"required by other processes. It can be started later with\n"
"`Supervisor.restart_child/2` as the child specification is saved in the "
"parent\n"
"supervisor. The main use cases for this are:\n"
"\n"
"  * The `GenServer` is disabled by configuration but might be enabled "
"later.\n"
"  * An error occurred and it will be handled by a different mechanism than "
"the\n"
"   `Supervisor`. Likely this approach involves calling `Supervisor."
"restart_child/2`\n"
"    after a delay to attempt a restart.\n"
"\n"
"Returning `{:stop, reason}` will cause `start_link/3` to return\n"
"`{:error, reason}` and the process to exit with reason `reason` without\n"
"entering the loop or calling `c:terminate/2`.\n"
msgstr ""
"サーバが起動した際に起動されます。`start_link/3`または`start/3`は、\n"
"この関数が戻るまでブロックされます。\n"
"\n"
"`args` は `start_link/3`へ渡される(2番目の)引数です。\n"
"\n"
"`{:ok, state}`を返すと、`start_link/3`は`{:ok, pid}` を返し、\n"
"プロセスはループに入ります。\n"
"\n"
"`{:ok, state, timeout}`を返すことは、\n"
"メッセージが届かない場合、`timeout`ミリ秒後に\n"
"`handle_info(:timeout, new_state)`が呼ばれることを除いて、\n"
"`{:ok, state}`と同じです。\n"
"\n"
"`{:ok, state, :hibernate}`を返すことは、\n"
"プロセスがループに入るまえにハイバネートされることを除いて、\n"
"`{:ok, state}`と同じです。\n"
"ハイバネーション関する詳細は`c:handle_call/3`を参照してください。\n"
"\n"
"`:ignore`を返すと、`start_link/3`は`:ignore`を返し、プロセスは\n"
"ループに入ることも`c:terminate/2`を呼び出すこともなく\n"
"正常終了します。監視ツリー配下にある場合、親のスーパーバイザは\n"
"失敗することはなく、ただちに`GenServer`を再起動することもありません。\n"
"監視ツリーの他のプロセスは（再）起動されます。したがって、`GenServer`は\n"
"他のプロセスから必要とされるべきではありません。`GenServer`は\n"
"後ほど`Supervisor.restart_child/2`を使って起動できます。子プロセスの仕様が\n"
"親であるスーパーバイザに保存されているからです。これの主なユースケースは\n"
"次のとおりです。\n"
"\n"
"  * `GenServer` が構成により無効になっているが、後に有効にされるかもしれない"
"場合\n"
"  * エラーが発生し、`Supervisor`とは異なるメカニズムで処理される場合。\n"
"    おそらくこのアプローチには、後で再起動を試みるために`Supervisor."
"restart_child/2`\n"
"    を呼び出すことが含まれるでしょう。\n"
"\n"
"`{:stop, reason}`を返すと、`start_link/3`は`{:error, reason}`を返し、\n"
"プロセスはループに入ることも`c:terminate/2`を呼び出すこともなく\n"
"理由`reason`で終了します。\n"

#. TRANSLATORS: def GenServer.abcast(nodes \\ [node() | Node.list()], name, request)
#: lib/gen_server.ex:787
msgid ""
"Casts all servers locally registered as `name` at the specified nodes.\n"
"\n"
"This function returns immediately and ignores nodes that do not exist, or "
"where the\n"
"server name does not exist.\n"
"\n"
"See `multi_call/4` for more information.\n"
msgstr ""
"指定したノードで`name`としてローカルに登録されているすべてのサーバに\n"
"キャストします。\n"
"\n"
"この関数は直ちに帰り、存在しないノードやサーバ名が存在しない\n"
"ノードは無視します。\n"
"\n"
"詳細は、 `multi_call/4` を参照してください。\n"

#. TRANSLATORS: @callback handle_cast/2
#: lib/gen_server.ex:383
msgid ""
"Invoked to handle asynchronous `cast/2` messages.\n"
"\n"
"`request` is the request message sent by a `cast/2` and `state` is the "
"current\n"
"state of the `GenServer`.\n"
"\n"
"Returning `{:noreply, new_state}` continues the loop with new state "
"`new_state`.\n"
"\n"
"Returning `{:noreply, new_state, timeout}` is similar to\n"
"`{:noreply, new_state}` except `handle_info(:timeout, new_state)` will be\n"
"called after `timeout` milliseconds if no messages are received.\n"
"\n"
"Returning `{:noreply, new_state, :hibernate}` is similar to\n"
"`{:noreply, new_state}` except the process is hibernated before continuing "
"the\n"
"loop. See `c:handle_call/3` for more information.\n"
"\n"
"Returning `{:stop, reason, new_state}` stops the loop and `c:terminate/2` "
"is\n"
"called with the reason `reason` and state `new_state`. The process exits "
"with\n"
"reason `reason`.\n"
"\n"
"If this callback is not implemented, the default implementation by\n"
"`use GenServer` will return `{:stop, {:bad_cast, request}, state}`.\n"
msgstr ""
"`cast/2`非同期メッセージを処理するために起動されます。\n"
"\n"
"`request` は `cast/2`により送信された要求メッセージであり、\n"
"`state`は`GenServer`の現在の状態です。\n"
"\n"
"`{:noreply, new_state}`を返すと、新たな状態`new_state`でループを継続しま"
"す。\n"
"\n"
"`{:noreply, new_state, timeout}`を返すことは、\n"
"メッセージが届かない場合、`timeout`ミリ秒後に\n"
"`handle_info(:timeout, new_state)`が呼ばれることを除いて、\n"
"`{:noreply, reply, new_state}`と同じです。\n"
"\n"
"`{:noreply, new_state, :hibernate}`を返すことは、\n"
"ループが継続される前にプロセスがハイバネートされることを\n"
"除いて、、`{:noreply, new_state}`と同じです。\n"
"詳細は`c:handle_call/3`を参照してください。\n"
"\n"
"`{:stop, reason, new_staet}`を返すと、ループを停止して\n"
"理由`reason`と状態`new_state`を引数に`c:terminate/2`が\n"
"呼び出されます。プロセスは理由`reason`で終了します。\n"
"\n"
"このコールバックが実装されていない場合、`use GenServer`による\n"
"デフォルト実装が`{:stop, {:bad_cast, request}, state}`を返します。\n"

#. TRANSLATORS: @type server
#: lib/gen_server.ex:528
msgid "The server reference"
msgstr "サーバのリファレンス"

#. TRANSLATORS: def GenServer.stop(server, reason \\ :normal, timeout \\ :infinity)
#: lib/gen_server.ex:687
msgid ""
"Stops the server with the given `reason`.\n"
"\n"
"The `c:terminate/2` callback of the given `server` will be invoked before\n"
"exiting. This function returns `:ok` if the server terminates with the\n"
"given reason; if it terminates with another reason, the call exits.\n"
"\n"
"This function keeps OTP semantics regarding error reporting.\n"
"If the reason is any other than `:normal`, `:shutdown` or\n"
"`{:shutdown, _}`, an error report is logged.\n"
msgstr ""
"指定した`reason`でサーバを停止します。\n"
"\n"
"指定した`server`の`c:terminate/2`コールバックが終了する前に\n"
"呼び出されます。この関数は、サーバーが指定した理由で終了した場合、\n"
"`:ok`を返します。別の理由で終了した場合は、呼び出しは終了します。\n"
"\n"
"この関数はエラーレポートに関するOTPセマンティクスに従います。\n"
"理由が`:normal`、`:shutdown`、`{:shutdown, _}`以外の場合、\n"
"エラーレポートがログ出力されます。\n"

#. TRANSLATORS: @callback handle_call/3
#: lib/gen_server.ex:318
msgid ""
"Invoked to handle synchronous `call/3` messages. `call/3` will block until "
"a\n"
"reply is received (unless the call times out or nodes are disconnected).\n"
"\n"
"`request` is the request message sent by a `call/3`, `from` is a 2-tuple\n"
"containing the caller's PID and a term that uniquely identifies the call, "
"and\n"
"`state` is the current state of the `GenServer`.\n"
"\n"
"Returning `{:reply, reply, new_state}` sends the response `reply` to the\n"
"caller and continues the loop with new state `new_state`.\n"
"\n"
"Returning `{:reply, reply, new_state, timeout}` is similar to\n"
"`{:reply, reply, new_state}` except `handle_info(:timeout, new_state)` will "
"be\n"
"called after `timeout` milliseconds if no messages are received.\n"
"\n"
"Returning `{:reply, reply, new_state, :hibernate}` is similar to\n"
"`{:reply, reply, new_state}` except the process is hibernated and will\n"
"continue the loop once a message is in its message queue. If a message is\n"
"already in the message queue this will be immediately. Hibernating a\n"
"`GenServer` causes garbage collection and leaves a continuous heap that\n"
"minimises the memory used by the process.\n"
"\n"
"Hibernating should not be used aggressively as too much time could be spent\n"
"garbage collecting. Normally it should only be used when a message is not\n"
"expected soon and minimising the memory of the process is shown to be\n"
"beneficial.\n"
"\n"
"Returning `{:noreply, new_state}` does not send a response to the caller "
"and\n"
"continues the loop with new state `new_state`. The response must be sent "
"with\n"
"`reply/2`.\n"
"\n"
"There are three main use cases for not replying using the return value:\n"
"\n"
"  * To reply before returning from the callback because the response is "
"known\n"
"    before calling a slow function.\n"
"  * To reply after returning from the callback because the response is not "
"yet\n"
"    available.\n"
"  * To reply from another process, such as a task.\n"
"\n"
"When replying from another process the `GenServer` should exit if the other\n"
"process exits without replying as the caller will be blocking awaiting a\n"
"reply.\n"
"\n"
"Returning `{:noreply, new_state, timeout | :hibernate}` is similar to\n"
"`{:noreply, new_state}` except a timeout or hibernation occurs as with a\n"
"`:reply` tuple.\n"
"\n"
"Returning `{:stop, reason, reply, new_state}` stops the loop and `c:"
"terminate/2`\n"
"is called with reason `reason` and state `new_state`. Then the `reply` is "
"sent\n"
"as the response to call and the process exits with reason `reason`.\n"
"\n"
"Returning `{:stop, reason, new_state}` is similar to\n"
"`{:stop, reason, reply, new_state}` except a reply is not sent.\n"
"\n"
"If this callback is not implemented, the default implementation by\n"
"`use GenServer` will return `{:stop, {:bad_call, request}, state}`.\n"
msgstr ""
"`call/3`同期メッセージを処理するために起動されます。\n"
"`call/3`は（呼出しタイムアウトかノードが切断されないかぎり）\n"
"応答を受信するまでブロックします。\n"
"\n"
"`request`は`call/3`により送信されたリクエストメッセージであり、\n"
"`from`は呼出し側のPIDと呼出しを一意に識別する項からなる2要素の\n"
"タプルであり、`state`は`GenServer`の現在の状態です。\n"
"\n"
"`{:reply, reply, new_state}`を返すと、応答`reply`を呼出し側に\n"
"送信し、新しい状態`new_state`でループを継続します。\n"
"\n"
"`{:reply, reply, new_state, timeout}`を返すことは、\n"
"メッセージが届かない場合、`timeout`ミリ秒後に\n"
"`handle_info(:timeout, new_state)`が呼ばれることを除いて、\n"
"`{:reply, reply, new_state}`と同じです。\n"
"\n"
"`{:reply, reply, new_state, :hibernate}`を返すことは、\n"
"プロセスがハイバネートされ、メッセージがメッセージキューに\n"
"届いたらループを再開することを除いて、`{:reply, reply, new_state}`と\n"
"同じです。メッセージが既にメッセージキューに届いていた場合、\n"
"これはすぐに実行されます。`GenEvent`のハイバネートは\n"
"ガベージコレクションを引き起し、プロセスにより使用されるメモリを\n"
"最小化し、連続したヒープ領域を作成します。\n"
"\n"
"ハイバネートは使いすぎてはいけません。余り頻繁におこなうと\n"
"ガベージコレクションに時間を取られるからです。通常は、メッセージが\n"
"すぐには来ないことが予想され、プロセスメモリの最小化が有益であることが\n"
"示された場合にのみ使用するべきです。\n"
"\n"
"`{:noreply, new_state}`を返すと、呼出し側に応答は送信せず、新しい状態\n"
"`new_state`でループを継続します。応答は`reply/2`で送信する必要があります。\n"
"\n"
"返り値を使って応答を返さないユースケースは主に3つあります。\n"
"\n"
"  * 関数を呼び出す前に応答が遲いことがわかっているので、コールバックから\n"
"    戻る前に応答を返すため\n"
"  * 応答がまだ準備できていないため、コールバックから戻った後に応答を返すた"
"め\n"
"  * タスクのような別のプロセスから応答を返すため\n"
"\n"
"別のプロセスから応答を返す場合、そのプロセスが応答せずに終了した場合は\n"
"`GENSERVER`も終了する必要があります。呼出し側は応答を待って\n"
"ブロックを続けるからです。\n"
"\n"
"`{:noreply, new_state, timeout | :hibernate}`を返すことは、\n"
"`:reply`タプルと同様のタイムアウトまたはハイバネーションが起きることを\n"
"除いて、`{:noreply, new_state}` と同じです。\n"
"\n"
"`{:stop, reason, reply, new_state}`を返すと、ループを停止して\n"
"理由`reason`と状態`new_state`を引数に`c:terminate/2`が呼び出されます。\n"
"その後、呼び出しの応答として`reply`が送信され、プロセスは理由`reason`で\n"
"終了します。\n"
"\n"
"`{:stop, reason, new_state}` を返すことは、応答が送信されないことを\n"
"除いて、`{:stop, reason, reply, new_state}`と同じです。\n"
"\n"
"このコールバックが実装されていない場合、`use GenServer`による\n"
"デフォルト実装が`{:stop, {:bad_call, request}, state}`を返します。\n"

#. TRANSLATORS: @type name
#: lib/gen_server.ex:513
msgid "The GenServer name"
msgstr "GenServerの名前"

#. TRANSLATORS: @callback handle_info/2
#: lib/gen_server.ex:411
msgid ""
"Invoked to handle all other messages.\n"
"\n"
"`msg` is the message and `state` is the current state of the `GenServer`. "
"When\n"
"a timeout occurs the message is `:timeout`.\n"
"\n"
"Return values are the same as `c:handle_cast/2`.\n"
"\n"
"If this callback is not implemented, the default implementation by\n"
"`use GenServer` will return `{:noreply, state}`.\n"
msgstr ""
"他のすべてのメッセージを処理するために起動されます。\n"
"\n"
"`msg`はメッセージであり、`state`は`GenServer`の現在の状態です。\n"
"タイムアウトが発生した場合、メッセージは`:timeout`です。\n"
"\n"
"返り値は、 `c:handle_cast/2`と同じです。\n"
"\n"
"このコールバックが実装されていない場合、`use GenServer`に\n"
"よるデフォルト実装が`{:noreply, state}`を返します。\n"

#. TRANSLATORS: def GenServer.multi_call(nodes \\ [node() | Node.list()], name, request, timeout \\ :infinity)
#: lib/gen_server.ex:815
msgid ""
"Calls all servers locally registered as `name` at the specified `nodes`.\n"
"\n"
"First, the `request` is sent to every node in `nodes`; then, the caller "
"waits\n"
"for the replies. This function returns a two-element tuple `{replies,\n"
"bad_nodes}` where:\n"
"\n"
"  * `replies` - is a list of `{node, reply}` tuples where `node` is the "
"node\n"
"    that replied and `reply` is its reply\n"
"  * `bad_nodes` - is a list of nodes that either did not exist or where a\n"
"    server with the given `name` did not exist or did not reply\n"
"\n"
"`nodes` is a list of node names to which the request is sent. The default\n"
"value is the list of all known nodes (including this node).\n"
"\n"
"To avoid that late answers (after the timeout) pollute the caller's message\n"
"queue, a middleman process is used to do the actual calls. Late answers "
"will\n"
"then be discarded when they arrive to a terminated process.\n"
"\n"
"## Examples\n"
"\n"
"Assuming the `Stack` GenServer mentioned in the docs for the `GenServer`\n"
"module is registered as `Stack` in the `:\"foo@my-machine\"` and\n"
"`:\"bar@my-machine\"` nodes:\n"
"\n"
"    GenServer.multi_call(Stack, :pop)\n"
"    #=> {[{:\"foo@my-machine\", :hello}, {:\"bar@my-machine\", :world}], "
"[]}\n"
"\n"
msgstr ""
"指定した`nodes`で`name`としてローカルに登録されているすべてのサーバを\n"
"呼び出します。\n"
"\n"
"まず、`request`は`node`のすべてのノードに送信されます。そして、\n"
"呼びさし側は応答を待ちます。この関数は2要素タブル`{replies, bad_nodes}`を \n"
"返します。ここで、\n"
"\n"
"  * `replies` - `{node, reply}`タプルのリストです。ここで`node`は応答したノー"
"ドであり、\n"
"    `reply`は応答です。\n"
"  * `bad_nodes` - 存在しないノード、または指定した`name`のサーバが存在しない"
"ノード、\n"
"    または応答しないノードのリストです。\n"
"\n"
"`nodes`はリクエストが送信されるノード名のリストです。デフォルト値は\n"
"既知のすべてのノード（このノードを含む）のリストです。\n"
"\n"
"（タイムアウト後の）遲い応答が、呼び出し側のメッセージキューを汚染する\n"
"ことを避けるために、実際の呼び出しには仲介者プロセスが使用されます。\n"
"遲い応答が終了したプロセスに届いた時には捨てられます。\n"
"\n"
"## 例\n"
"\n"
"`GenServer`モジュールのドキュメントで言及されている`Stack` \n"
"GenServerが、`:”foo@my-machine\"`ノードと`:\"bar@my-machine\"`で\n"
"`Stack`として登録されていると仮定します。\n"
"\n"
"    GenServer.multi_call(Stack, :pop)\n"
"    #=> {[{:\"foo@my-machine\", :hello}, {:\"bar@my-machine\", :world}], "
"[]}\n"
"\n"

#. TRANSLATORS: @type debug
#: lib/gen_server.ex:525
msgid "Debug options supported by the `start*` functions"
msgstr "`start*`関数によりサポートされるデバッグオプション"

#. TRANSLATORS: def GenServer.call(server, request, timeout \\ 5000)
#: lib/gen_server.ex:703
msgid ""
"Makes a synchronous call to the `server` and waits for its reply.\n"
"\n"
"The client sends the given `request` to the server and waits until a reply\n"
"arrives or a timeout occurs. `c:handle_call/3` will be called on the server\n"
"to handle the request.\n"
"\n"
"`server` can be any of the values described in the \"Name registration\"\n"
"section of the documentation for this module.\n"
"\n"
"## Timeouts\n"
"\n"
"`timeout` is an integer greater than zero which specifies how many\n"
"milliseconds to wait for a reply, or the atom `:infinity` to wait\n"
"indefinitely. The default value is `5000`. If no reply is received within\n"
"the specified time, the function call fails and the caller exits. If the\n"
"caller catches the failure and continues running, and the server is just "
"late\n"
"with the reply, it may arrive at any time later into the caller's message\n"
"queue. The caller must in this case be prepared for this and discard any "
"such\n"
"garbage messages that are two-element tuples with a reference as the first\n"
"element.\n"
msgstr ""
"`server`に同期的な呼び出しを行い、その応答を待ちます。\n"
"\n"
"クライアントは指定した`request`をサーバに送信し、\n"
"応答が到着するか、タイムアウトが起きるまで待ちます。\n"
"リクエストを処理するためにサーバ上で`c:handle_call/3`が呼び出されます。\n"
"\n"
"`server`には、このモジュールのドキュメントの「名前の登録」セクションで記述さ"
"れている\n"
"値のいずれかを指定できます。\n"
"\n"
"## タイウアウト\n"
"\n"
"`timeout`は、応答をどれだけ待つかをミリ秒で示す0より大きな整数か、永久に\n"
"待つことを示すアトム`:infinity`のいずれかです。デフォルト値は5000です。\n"
"指定した時間内に応答が受信されない場合、関数呼び出しは失敗し、呼び出し側は\n"
"終了します。呼び出し側が失敗を捕捉して、実行を継続しており、そして、サーバ"
"の\n"
"応答が単に遅れている場合は、呼び出し側のメッセージキューにいつか遅れて\n"
"到着します。この場合、呼び出し側はあらかじめこれに備え、最初の要素と\n"
"してリファレンスを持つ2要素のタプルであるゴミメッセージを捨てなければ\n"
"なりません。\n"

#. TRANSLATORS: @type option
#: lib/gen_server.ex:519
msgid "Option values used by the `start*` functions"
msgstr "`start*`関数により使用されるオプション値"

#. TRANSLATORS: def GenServer.whereis(pid)
#: lib/gen_server.ex:892
msgid ""
"Returns the `pid` or `{name, node}` of a GenServer process, or `nil` if\n"
"no process is associated with the given name.\n"
"\n"
"## Examples\n"
"\n"
"For example, to lookup a server process, monitor it and send a cast to it:\n"
"\n"
"    process = GenServer.whereis(server)\n"
"    monitor = Process.monitor(process)\n"
"    GenServer.cast(process, :hello)\n"
"\n"
msgstr ""
"GenServerプロセスの`pid`または`{name, node}`を返します。\n"
"指定した名前に関連するプロセスがない場合は`nil`を返します。\n"
"\n"
"## 例\n"
"\n"
"たとえば、サーバープロセスを検索して、それをモニタし、\n"
"それにキャストを送信するには次のようにします。\n"
"\n"
"    process = GenServer.whereis(server)\n"
"    monitor = Process.monitor(process)\n"
"    GenServer.cast(process, :hello)\n"
"\n"

#. TRANSLATORS: def GenServer.start_link(module, args, options \\ [])
#: lib/gen_server.ex:606
msgid ""
"Starts a `GenServer` process linked to the current process.\n"
"\n"
"This is often used to start the `GenServer` as part of a supervision tree.\n"
"\n"
"Once the server is started, the `c:init/1` function of the given `module` "
"is\n"
"called with `args` as its arguments to initialize the server. To ensure a\n"
"synchronized start-up procedure, this function does not return until `c:"
"init/1`\n"
"has returned.\n"
"\n"
"Note that a `GenServer` started with `start_link/3` is linked to the\n"
"parent process and will exit in case of crashes from the parent. The "
"GenServer\n"
"will also exit due to the `:normal` reasons in case it is configured to "
"trap\n"
"exits in the `c:init/1` callback.\n"
"\n"
"## Options\n"
"\n"
"  * `:name` - used for name registration as described in the \"Name\n"
"    registration\" section of the module documentation\n"
"\n"
"  * `:timeout` - if present, the server is allowed to spend the given amount "
"of\n"
"    milliseconds initializing or it will be terminated and the start "
"function\n"
"    will return `{:error, :timeout}`\n"
"\n"
"  * `:debug` - if present, the corresponding function in the [`:sys`\n"
"    module](http://www.erlang.org/doc/man/sys.html) is invoked\n"
"\n"
"  * `:spawn_opt` - if present, its value is passed as options to the\n"
"    underlying process as in `Process.spawn/4`\n"
"\n"
"## Return values\n"
"\n"
"If the server is successfully created and initialized, this function "
"returns\n"
"`{:ok, pid}`, where `pid` is the PID of the server. If a process with the\n"
"specified server name already exists, this function returns\n"
"`{:error, {:already_started, pid}}` with the PID of that process.\n"
"\n"
"If the `c:init/1` callback fails with `reason`, this function returns\n"
"`{:error, reason}`. Otherwise, if it returns `{:stop, reason}`\n"
"or `:ignore`, the process is terminated and this function returns\n"
"`{:error, reason}` or `:ignore`, respectively.\n"
msgstr ""
"現在のプロセスにリンクされた`GenServer`プロセスを起動します。\n"
"\n"
"通常、監視ツリー配下で`GenServer`を起動するために使用されます。\n"
"\n"
"サーバが起動されると、指定したモジュールの`c:init/1`関数が`args`を引数に\n"
"呼び出され、サーバーを初期化します。同期的な起動手続きを確実にするために、\n"
"`c:init/1`が返るまでこの関数は返りません。\n"
"\n"
"`start_link/3`で起動された`GenServer`は親プロセスにリンクされ、\n"
"親プロセスがクラッシュした場合は終了することに注意してください。\n"
"また、`init/1`コールバックで終了を捕捉するよう構成されている場合も\n"
"GenServerは`:normal`理由で終了します。\n"
"\n"
"## オプション\n"
"\n"
"  * `:name` - このモジュールのドキュメントの「名前の登録」セクションに記述\n"
"    されているように名前の登録に使用されます\n"
"\n"
"  * `:timeout` - 指定された場合、サーバーは初期化に指定したミリ秒を使うことが"
"できます。\n"
"    そうでなければ初期化は終了させられ、起動関数は`{:error, :timeout}`を返し"
"ます。\n"
"\n"
"  * `:debug` - 指定された場合、 [`:sys`モジュール](http://www.erlang.org/doc/"
"man/sys.html)の\n"
"    対応する関数が呼び出されます\n"
"\n"
"  * `:spawn_opt` - 指定された場合、 `Process.spawn/4`同様、配下のプロセスへ"
"の\n"
"    オプションとしてその値が渡されます\n"
"\n"
"## 返り値\n"
"\n"
"サーバの作成と初期化が成功した場合、この関数は`{:ok, pid}`を返します。\n"
"ここで`pid`はサーバーのPIDです。指定したサーバー名を持つプロセスが\n"
"すでに存在した場合、この関数は`{:error, {:already_started, pid}}`を\n"
"返します。ここでpidはそのプロセスのPIDです。\n"
"\n"
"`init/1`コールバックが`reason`で失敗した場合、この関数は`{:error, reason}`"
"を\n"
"返します。そうでなく、`init/1`が`{:stop, reason}`または`:ignore`を\n"
"返した場合、プロセスは終了させられ、この関数は各々`{:error, reason}`または\n"
"`:ignore`を返します。\n"

#. TRANSLATORS: def GenServer.reply(client, reply)
#: lib/gen_server.ex:850
msgid ""
"Replies to a client.\n"
"\n"
"This function can be used to explicitly send a reply to a client that "
"called\n"
"`call/3` or `multi_call/4` when the reply cannot be specified in the return\n"
"value of `c:handle_call/3`.\n"
"\n"
"`client` must be the `from` argument (the second argument) accepted by\n"
"`c:handle_call/3` callbacks. `reply` is an arbitrary term which will be "
"given\n"
"back to the client as the return value of the call.\n"
"\n"
"Note that `reply/2` can be called from any process, not just the GenServer\n"
"that originally received the call (as long as that GenServer communicated "
"the\n"
"`from` argument somehow).\n"
"\n"
"This function always returns `:ok`.\n"
"\n"
"## Examples\n"
"\n"
"    def handle_call(:reply_in_one_second, from, state) do\n"
"      Process.send_after(self(), {:reply, from}, 1_000)\n"
"      {:noreply, state}\n"
"    end\n"
"\n"
"    def handle_info({:reply, from}, state) do\n"
"      GenServer.reply(from, :one_second_has_passed)\n"
"      {:noreply, state}\n"
"    end\n"
"\n"
msgstr ""
"クライアントに応答します。\n"
"\n"
"この関数は、`c:handle_call/3`の返り値で応答を指定できない場合に、\n"
"`call/3`または`multi_call/4`を呼び出したクライアントに応答を明示的に\n"
"送信するために使用することができます。\n"
"\n"
"`client`は、`handle_call/3`コールバックで受け付けた`from`引数\n"
"（2番目の引数）でなくてはなりません。`reply`は任意の項で、\n"
"呼び出しの返り値としてクライアントに返されます。\n"
"\n"
"`reply/2`は呼び出しを最初に受信したGenServerだけでなく、\n"
"（GenServerが`from`引数と何らかの形で通信している限り）任意の\n"
"プロセスから呼び出される可能性があることに注意してください。\n"
"\n"
"この関数は常に`:ok`を返します。\n"
"\n"
"## 例\n"
"\n"
"    def handle_call(:reply_in_one_second, from, state) do\n"
"      Process.send_after(self(), {:reply, from}, 1_000)\n"
"      {:noreply, state}\n"
"    end\n"
"\n"
"    def handle_info({:reply, from}, state) do\n"
"      GenServer.reply(from, :one_second_has_passed)\n"
"      {:noreply, state}\n"
"    end\n"
"\n"

#. TRANSLATORS: @type from
#: lib/gen_server.ex:531
msgid ""
"Tuple describing the client of a call request.\n"
"\n"
"`pid` is the PID of the caller and `tag` is a unique term used to identify "
"the\n"
"call.\n"
msgstr ""
"呼出しリクエストのクライアントを記述するタプルです。\n"
"\n"
"`pid`は呼出し側のpidで、`tag`は呼出しを識別するために使われる\n"
"ユニークな項です。\n"

#. TRANSLATORS: @type on_start
#: lib/gen_server.ex:510
msgid "Return values of `start*` functions"
msgstr "`start*`関数の返り値"

#. TRANSLATORS: def GenServer.start(module, args, options \\ [])
#: lib/gen_server.ex:653
msgid ""
"Starts a `GenServer` process without links (outside of a supervision tree).\n"
"\n"
"See `start_link/3` for more information.\n"
msgstr ""
"リンクなし（監視ツリーの外側）で`GenServer`プロセスを起動します。\n"
"\n"
"詳細は`start_link/3`を参照してください。\n"

#. TRANSLATORS: Elixir.GenServer Summary
#: lib/gen_server.ex:2
msgid ""
"A behaviour module for implementing the server of a client-server relation.\n"
"\n"
"A GenServer is a process like any other Elixir process and it can be used\n"
"to keep state, execute code asynchronously and so on. The advantage of "
"using\n"
"a generic server process (GenServer) implemented using this module is that "
"it\n"
"will have a standard set of interface functions and include functionality "
"for\n"
"tracing and error reporting. It will also fit into a supervision tree.\n"
"\n"
"## Example\n"
"\n"
"The GenServer behaviour abstracts the common client-server interaction.\n"
"Developers are only required to implement the callbacks and functionality "
"they are\n"
"interested in.\n"
"\n"
"Let's start with a code example and then explore the available callbacks.\n"
"Imagine we want a GenServer that works like a stack, allowing us to push\n"
"and pop items:\n"
"\n"
"    defmodule Stack do\n"
"      use GenServer\n"
"\n"
"      # Callbacks\n"
"\n"
"      def handle_call(:pop, _from, [h | t]) do\n"
"        {:reply, h, t}\n"
"      end\n"
"\n"
"      def handle_cast({:push, item}, state) do\n"
"        {:noreply, [item | state]}\n"
"      end\n"
"    end\n"
"\n"
"    # Start the server\n"
"    {:ok, pid} = GenServer.start_link(Stack, [:hello])\n"
"\n"
"    # This is the client\n"
"    GenServer.call(pid, :pop)\n"
"    #=> :hello\n"
"\n"
"    GenServer.cast(pid, {:push, :world})\n"
"    #=> :ok\n"
"\n"
"    GenServer.call(pid, :pop)\n"
"    #=> :world\n"
"\n"
"We start our `Stack` by calling `start_link/3`, passing the module\n"
"with the server implementation and its initial argument (a list\n"
"representing the stack containing the item `:hello`). We can primarily\n"
"interact with the server by sending two types of messages. **call**\n"
"messages expect a reply from the server (and are therefore synchronous)\n"
"while **cast** messages do not.\n"
"\n"
"Every time you do a `GenServer.call/3`, the client will send a message\n"
"that must be handled by the `c:handle_call/3` callback in the GenServer.\n"
"A `cast/2` message must be handled by `c:handle_cast/2`.\n"
"\n"
"## Callbacks\n"
"\n"
"There are 6 callbacks required to be implemented in a `GenServer`. By\n"
"adding `use GenServer` to your module, Elixir will automatically define\n"
"all 6 callbacks for you, leaving it up to you to implement the ones\n"
"you want to customize.\n"
"\n"
"## Name Registration\n"
"\n"
"Both `start_link/3` and `start/3` support the `GenServer` to register\n"
"a name on start via the `:name` option. Registered names are also\n"
"automatically cleaned up on termination. The supported values are:\n"
"\n"
"  * an atom - the GenServer is registered locally with the given name\n"
"    using `Process.register/2`.\n"
"\n"
"  * `{:global, term}`- the GenServer is registered globally with the given\n"
"    term using the functions in the `:global` module.\n"
"\n"
"  * `{:via, module, term}` - the GenServer is registered with the given\n"
"    mechanism and name. The `:via` option expects a module that exports\n"
"    `register_name/2`, `unregister_name/1`, `whereis_name/1` and `send/2`.\n"
"    One such example is the `:global` module which uses these functions\n"
"    for keeping the list of names of processes and their associated PIDs\n"
"    that are available globally for a network of Elixir nodes. Elixir also\n"
"    ships with a local, decentralized and scalable registry called "
"`Registry`\n"
"    for locally storing names that are generated dynamically.\n"
"\n"
"For example, we could start and register our `Stack` server locally as "
"follows:\n"
"\n"
"    # Start the server and register it locally with name MyStack\n"
"    {:ok, _} = GenServer.start_link(Stack, [:hello], name: MyStack)\n"
"\n"
"    # Now messages can be sent directly to MyStack\n"
"    GenServer.call(MyStack, :pop) #=> :hello\n"
"\n"
"Once the server is started, the remaining functions in this module "
"(`call/3`,\n"
"`cast/2`, and friends) will also accept an atom, or any `:global` or `:via`\n"
"tuples. In general, the following formats are supported:\n"
"\n"
"  * a `pid`\n"
"  * an `atom` if the server is locally registered\n"
"  * `{atom, node}` if the server is locally registered at another node\n"
"  * `{:global, term}` if the server is globally registered\n"
"  * `{:via, module, name}` if the server is registered through an "
"alternative\n"
"    registry\n"
"\n"
"If there is an interest to register dynamic names locally, do not use\n"
"atoms, as atoms are never garbage collected and therefore dynamically\n"
"generated atoms won't be garbage collected. For such cases, you can\n"
"set up your own local registry by using the `Registry` module.\n"
"\n"
"## Client / Server APIs\n"
"\n"
"Although in the example above we have used `GenServer.start_link/3` and\n"
"friends to directly start and communicate with the server, most of the\n"
"time we don't call the `GenServer` functions directly. Instead, we wrap\n"
"the calls in new functions representing the public API of the server.\n"
"\n"
"Here is a better implementation of our Stack module:\n"
"\n"
"    defmodule Stack do\n"
"      use GenServer\n"
"\n"
"      # Client\n"
"\n"
"      def start_link(default) do\n"
"        GenServer.start_link(__MODULE__, default)\n"
"      end\n"
"\n"
"      def push(pid, item) do\n"
"        GenServer.cast(pid, {:push, item})\n"
"      end\n"
"\n"
"      def pop(pid) do\n"
"        GenServer.call(pid, :pop)\n"
"      end\n"
"\n"
"      # Server (callbacks)\n"
"\n"
"      def handle_call(:pop, _from, [h | t]) do\n"
"        {:reply, h, t}\n"
"      end\n"
"\n"
"      def handle_call(request, from, state) do\n"
"        # Call the default implementation from GenServer\n"
"        super(request, from, state)\n"
"      end\n"
"\n"
"      def handle_cast({:push, item}, state) do\n"
"        {:noreply, [item | state]}\n"
"      end\n"
"\n"
"      def handle_cast(request, state) do\n"
"        super(request, state)\n"
"      end\n"
"    end\n"
"\n"
"In practice, it is common to have both server and client functions in\n"
"the same module. If the server and/or client implementations are growing\n"
"complex, you may want to have them in different modules.\n"
"\n"
"## Receiving \"regular\" messages\n"
"\n"
"The goal of a `GenServer` is to abstract the \"receive\" loop for "
"developers,\n"
"automatically handling system messages, support code change, synchronous\n"
"calls and more. Therefore, you should never call your own \"receive\" "
"inside\n"
"the GenServer callbacks as doing so will cause the GenServer to misbehave.\n"
"\n"
"Besides the synchronous and asynchronous communication provided by `call/3`\n"
"and `cast/2`, \"regular\" messages sent by functions such `Kernel.send/2`,\n"
"`Process.send_after/4` and similar, can be handled inside the `c:"
"handle_info/2`\n"
"callback.\n"
"\n"
"`c:handle_info/2` can be used in many situations, such as handling monitor\n"
"DOWN messages sent by `Process.monitor/1`. Another use case for `c:"
"handle_info/2`\n"
"is to perform periodic work, with the help of `Process.send_after/4`:\n"
"\n"
"    defmodule MyApp.Periodically do\n"
"      use GenServer\n"
"\n"
"      def start_link do\n"
"        GenServer.start_link(__MODULE__, %{})\n"
"      end\n"
"\n"
"      def init(state) do\n"
"        schedule_work() # Schedule work to be performed on start\n"
"        {:ok, state}\n"
"      end\n"
"\n"
"      def handle_info(:work, state) do\n"
"        # Do the desired work here\n"
"        schedule_work() # Reschedule once more\n"
"        {:noreply, state}\n"
"      end\n"
"\n"
"      defp schedule_work() do\n"
"        Process.send_after(self(), :work, 2 * 60 * 60 * 1000) # In 2 hours\n"
"      end\n"
"    end\n"
"\n"
"## Debugging with the :sys module\n"
"\n"
"GenServers, as [special processes](http://erlang.org/doc/design_principles/"
"spec_proc.html),\n"
"can be debugged using the `:sys` module. Through various hooks, this module\n"
"allows developers to introspect the state of the process and trace\n"
"system events that happen during its execution, such as received messages,\n"
"sent replies and state changes.\n"
"\n"
"Let's explore the basic functions from the `:sys` module used for "
"debugging:\n"
"\n"
"  * [`:sys.get_state/2`](http://erlang.org/doc/man/sys.html#get_state-2) -\n"
"    allows retrieval of the state of the process. In the case of\n"
"    a GenServer process, it will be the callback module state, as\n"
"    passed into the callback functions as last argument.\n"
"  * [`:sys.get_status/2`](http://erlang.org/doc/man/sys.html#get_status-2) "
"-\n"
"    allows retrieval of the status of the process. This status includes\n"
"    the process dictionary, if the process is running or is suspended,\n"
"    the parent PID, the debugger state, and the state of the behaviour "
"module,\n"
"    which includes the callback module state (as returned by `:sys."
"get_state/2`).\n"
"    It's possible to change how this status is represented by defining\n"
"    the optional `c:GenServer.format_status/2` callback.\n"
"  * [`:sys.trace/3`](http://erlang.org/doc/man/sys.html#trace-3) -\n"
"    prints all the system events to `:stdio`.\n"
"  * [`:sys.statistics/3`](http://erlang.org/doc/man/sys.html#statistics-3) "
"-\n"
"    manages collection of process statistics.\n"
"  * [`:sys.no_debug/2`](http://erlang.org/doc/man/sys.html#no_debug-2) -\n"
"    turns off all debug handlers for the given process. It is very "
"important\n"
"    to switch off debugging once we're done. Excessive debug handlers or\n"
"    those that should be turned off, but weren't, can seriously damage\n"
"    the performance of the system.\n"
"\n"
"Let's see how we could use those functions for debugging the stack server\n"
"we defined earlier.\n"
"\n"
"    iex> {:ok, pid} = Stack.start_link([])\n"
"    iex> :sys.statistics(pid, true) # turn on collecting process statistics\n"
"    iex> :sys.trace(pid, true) # turn on event printing\n"
"    iex> Stack.push(pid, 1)\n"
"    *DBG* <0.122.0> got cast {push,1}\n"
"    *DBG* <0.122.0> new state [1]\n"
"    :ok\n"
"    iex> :sys.get_state(pid)\n"
"    [1]\n"
"    iex> Stack.pop(pid)\n"
"    *DBG* <0.122.0> got call pop from <0.80.0>\n"
"    *DBG* <0.122.0> sent 1 to <0.80.0>, new state []\n"
"    1\n"
"    iex> :sys.statistics(pid, :get)\n"
"    {:ok,\n"
"     [start_time: {{2016, 7, 16}, {12, 29, 41}},\n"
"      current_time: {{2016, 7, 16}, {12, 29, 50}},\n"
"      reductions: 117, messages_in: 2, messages_out: 0]}\n"
"    iex> :sys.no_debug(pid) # turn off all debug handlers\n"
"    :ok\n"
"    iex> :sys.get_status(pid)\n"
"    {:status, #PID<0.122.0>, {:module, :gen_server},\n"
"     [[\"$initial_call\": {Stack, :init, 1},            # pdict\n"
"       \"$ancestors\": [#PID<0.80.0>, #PID<0.51.0>]],\n"
"      :running,                                       # :running | :"
"suspended\n"
"      #PID<0.80.0>,                                   # parent\n"
"      [],                                             # debugger state\n"
"      [header: 'Status for generic server <0.122.0>', # module status\n"
"       data: [{'Status', :running}, {'Parent', #PID<0.80.0>},\n"
"         {'Logged events', []}], data: [{'State', [1]}]]]}\n"
"\n"
"## Learn more\n"
"\n"
"If you wish to find out more about gen servers, the Elixir Getting Started\n"
"guide provides a tutorial-like introduction. The documentation and links\n"
"in Erlang can also provide extra insight.\n"
"\n"
"  * [GenServer – Elixir's Getting Started Guide](http://elixir-lang.org/"
"getting-started/mix-otp/genserver.html)\n"
"  * [`:gen_server` module documentation](http://www.erlang.org/doc/man/"
"gen_server.html)\n"
"  * [gen_server Behaviour – OTP Design Principles](http://www.erlang.org/doc/"
"design_principles/gen_server_concepts.html)\n"
"  * [Clients and Servers – Learn You Some Erlang for Great Good!](http://"
"learnyousomeerlang.com/clients-and-servers)\n"
msgstr ""
"クライアント-サーバ型のサーバを実装するためのビヘイビアモジュールです。\n"
"\n"
"GenServerは他のElixirプロセスと同様一つのプロセスであり、状態を保持したり、\n"
"コードを非同期に実行したりすることができます。このモジュールを使用して\n"
"実装された汎用サーバープロセス（GenServer）を使用する利点は、それが、\n"
"標準的な一連のインターフェース関数を持ち、トレースを行ったり、エラーレポート"
"を\n"
"行う機能を含んでいることです。また、監視ツリーにも適合します。\n"
"\n"
"## 例\n"
"\n"
"GenServerビヘイビアは一般的なクライアント-サーバインタラクションを抽象化しま"
"す。\n"
"開発者には自らが興味のある機能とコールバックの実装が要求されるだけです。\n"
"\n"
"コード例から始め、それから利用可能なコールバックを調査しましょう。\n"
"アイテムをプッシュしたりポップしたりできるスタックのように働くGenServerが\n"
"欲しいとします:\n"
"\n"
"    defmodule Stack do\n"
"      use GenServer\n"
"    \n"
"      # コールバック関数\n"
"    \n"
"      def handle_call(:pop, _from, [h|t]) do\n"
"        {:reply, h, t}\n"
"      end\n"
"    \n"
"      def handle_cast({:push, item}, state) do\n"
"        {:noreply, [item|state]}\n"
"      end\n"
"    end\n"
"    \n"
"    # サーバーを起動\n"
"    {:ok, pid} = GenServer.start_link(Stack, [:hello])\n"
"    \n"
"    # 以下はクライアント\n"
"    GenServer.call(pid, :pop)\n"
"    #=> :hello\n"
"    \n"
"    GenServer.cast(pid, {:push, :world})\n"
"    #=> :ok\n"
"    \n"
"    GenServer.call(pid, :pop)\n"
"    #=> :world\n"
"\n"
"`start_link/3`にサーバー実装であるモジュールと初期値（アイテム`:item`\n"
"を含むスタックを表すリスト）を渡して呼び出すことで`Stack`を起動します。\n"
"サーバーとは主に2つのタイプのメッセージを送ることにより対話することが\n"
"できます。**call**メッセージはサーバーからの応答を期待します（それゆえ、\n"
"同期的です）。一方、**case**メッセージは応答を期待しません。\n"
"\n"
"`GenServer.call/3`を実行するたびに、クライアントはGenServerの\n"
"`c:handle_call/3`コールバックで処理されなければならないメッセージを\n"
"送信することになります。`cast/2`メッセージは`c:handle_cast/2`で\n"
"処理されなければなりません。\n"
"\n"
"## コールバック関数\n"
"\n"
"`GenServer`では実装しなければならないコールバック関数が6つあります。\n"
"ただし、モジュールに`use GenServer`を追加すると、6つのコールバック関数\n"
"はすべてElixirが自動的に定義します。そのため、開発者はカスタマイズしたいも"
"の\n"
"だけを実装すれば良いのです。\n"
"\n"
"## 名前の登録\n"
"\n"
"`start_link/3`と`start/3`はどちらも、起動時に`:name`オプションを付ける\n"
"ことで、`GenServer`に名前を登録する機能を与えています。登録された名前は、\n"
"終了時に自動的に開放されます。サポートされている値は以下の通りです:\n"
"\n"
"  * アトム - GenServerは`Process.register/2`を使用して、与えられた名前で\n"
"    ローカルに登録されます。\n"
"\n"
"  * `{:global, term}`- GenServerは`:global`モジュールの関数を使用して、\n"
"    与えられた項でグローバルに登録されます。\n"
"\n"
"  * `{:via, module, term}` - GenServerは与えられたメカニズムと名前で\n"
"    登録されます。`:via`オプションには、`register_name/`, "
"`unregister_name/1`\n"
"    `whereis_name/1`, `send/2`をエクスポートするモジュールを指定します。\n"
"    その一例は`:global`モジュールです。このモジュールはこれらの関数を使って\n"
"    プロセス名と関連するPIDのリストを保持し、これはElixirノードのネットワーク"
"で\n"
"    グローバルに利用できます。Elixirは動的に生成される名前をローカルに格納す"
"る\n"
"    ための、非集中型でスケーラブルなローカルレジストリである`Registry`も提"
"供\n"
"    しています。\n"
"\n"
"たとえば、Stackサーバを次のように起動してローカルに登録することができます。\n"
"\n"
"    # サーバーを起動し、MyStackという名前でローカルに登録する\n"
"    {:ok, _} = GenServer.start_link(Stack, [:hello], name: MyStack)\n"
"    \n"
"    # これによりメッセージをMyStackに直接信できるk\n"
"    GenServer.call(MyStack, :pop) #=> :hello\n"
"\n"
"サーバが起動されると、このモジュールの残りの関数（`call/3`、`cast/2`など）"
"も\n"
"アトムや任意の`:global`、`:via`タプルを受け付けます。一般的に、以下のフォー"
"マットが\n"
"サポートされています:\n"
"\n"
"  * `pid`\n"
"  * `atom`、サーバがローカルに登録されている場合\n"
"  * `{atom, node}`、サーバが他のノードでローカルに登録されている場合\n"
"  * `{:global, term}` サーバがグローバルに登録されている場合\n"
"  * `{:via, module, name}` サーバが代替レジストリを介して登録されている場合\n"
"\n"
"動的な名前をローカルに登録することに興味がある場合は、アトムを使用\n"
"しないでください。なぜなら、アトムは決してガーベージコレクションされることが"
"なく、\n"
"そのため、動的に生成されるアトムはガーベージコレクションされないからです。\n"
"そのような場合は、`Registry`モジュールを使用して独自のローカルレジストリを設"
"定してください。\n"
"\n"
"## クライアント / サーバー API\n"
"\n"
"上の例では、`GenServer.start_link/3`やその姉妹関数を使用して、\n"
"直接、サーバーを起動したり、通信を行いましたが、ほとんどの場合、\n"
"`GenServer`関数を直接呼び出すことはしません。代わりに、サーバーの\n"
"公開APIを表す新しい関数でこれらの呼び出しをラップします。\n"
"\n"
"以下はStackモジュールのよりよい実装です:\n"
"\n"
"    defmodule Stack do\n"
"      use GenServer\n"
"\n"
"      # クライアント\n"
"\n"
"      def start_link(default) do\n"
"        GenServer.start_link(__MODULE__, default)\n"
"      end\n"
"\n"
"      def push(pid, item) do\n"
"        GenServer.cast(pid, {:push, item})\n"
"      end\n"
"\n"
"      def pop(pid) do\n"
"        GenServer.call(pid, :pop)\n"
"      end\n"
"\n"
"      # サーバー (コールバック関数)\n"
"\n"
"      def handle_call(:pop, _from, [h|t]) do\n"
"        {:reply, h, t}\n"
"      end\n"
"    \n"
"      def handle_call(request, from, state) do\n"
"        # GenServerのデフォルト実装を呼び出す\n"
"        super(request, from, state)\n"
"      end\n"
"    \n"
"      def handle_cast({:push, item}, state) do\n"
"        {:noreply, [item|state]}\n"
"      end\n"
"    \n"
"      def handle_cast(request, state) do\n"
"        super(request, state)\n"
"      end\n"
"    end\n"
"\n"
"実際、同じモジュール内でサーバとクライアントの両方の関数を持つことは\n"
"一般的です。サーバとクライアント実装が複雑になった場合、\n"
"両者を別のモジュールにしたくなるかもしれません。\n"
"\n"
"## 「正規」メッセージの受信\n"
"\n"
"`GenServer`の目的は、開発者のための「受信」ループの抽象化、\n"
"システムメッセージの自動的な処理、コード変更のサポート、同期的な呼出しなど"
"を\n"
"行うことです。したがって、GenServerコールバック関数の中で独自に「受信」を\n"
"してはいけません。それをするとGenServerを誤動作させる原因になるからです。\n"
"\n"
"`call/3`や`cast/2`で提供される同期通信と非同期通信に加えて、 `Kernel.send/2`"
"や\n"
"`Process.send_after/4`などの関数により送信される「通常の」メッセージを`c:"
"handle_info/2`\n"
"コールバック関数内で処理することができます。\n"
"\n"
"`c:handle_info/2`は、`Process.monitor/1`により送信されるDOWNメッセージの監視"
"処理\n"
"など、様々な状況で使用することができます。`c:handle_info/2`のもう一つの使用例"
"は\n"
"`Process.send_after/4`と共に定期的な作業を実行することです。\n"
"\n"
"    defmodule MyApp.Periodically do\n"
"      use GenServer\n"
"\n"
"      def start_link do\n"
"        GenServer.start_link(__MODULE__, %{})\n"
"      end\n"
"\n"
"      def init(state) do\n"
"        schedule_work() # 起動時に実行すべきスケジュール作業\n"
"        {:ok, state}\n"
"      end\n"
"\n"
"      def handle_info(:work, state) do\n"
"        # ここで必要な作業を行う\n"
"        schedule_work() # 再スケジュール作業\n"
"        {:noreply, state}\n"
"      end\n"
"\n"
"      defp schedule_work() do\n"
"        Process.send_after(self(), :work, 2 * 60 * 60 * 1000) # In 2 hours\n"
"      end\n"
"    end\n"
"\n"
"## :sysモジュールによるデバッグ作業\n"
"\n"
"[特別なプロセス](http://erlang.org/doc/design_principles/spec_proc.html)とし"
"て\n"
"GenServerは`:sys`モジュールを使ってデバッグすることができます。様々なフックを"
"通して\n"
"このモジュールはプロセスの状態を調査し、実行中に起きる（受信メッセージのよう"
"な）\n"
"システムイベントを追跡し、応答や状態変化を送信することが可能です。\n"
"\n"
"デバッグに使用される`:sys`モジュールの基本的な関数を調べてみましょう。\n"
"\n"
"  * [`:sys.get_state/2`](http://erlang.org/doc/man/sys.html#get_state-2) -\n"
"    プロセスの状態が取得できます。GenServerプロセスの場合では、\n"
"    コールバックモジュールの状態になります。コールバック関数の最後の引数とし"
"て\n"
"    渡されるからです。\n"
"  * [`:sys.get_status/2`](http://erlang.org/doc/man/sys.html#get_status-2) "
"-\n"
"    プロセスのステータスが取得できます。このステータスには、プロセスが実行"
"中\n"
"    またはサスペンドされている場合のプロセス辞書、親プロセスのPID、デバッガ"
"の\n"
"    状態、（`:sys.get_state/2`により返される）コールバックモジュールの状態を"
"含む\n"
"    ビヘイビアモジュールの状態が含まれます。オプションの`c:GenServer."
"format_status/2`\n"
"    コールバックを定義することによりこの状態の表示方法を変更することができま"
"す。\n"
"  * [`:sys.trace/3`](http://erlang.org/doc/man/sys.html#trace-3) -\n"
"    すべてのシステムイベントを`:stdio`に出力します。\n"
"  * [`:sys.statistics/3`](http://erlang.org/doc/man/sys.html#statistics-3) "
"-\n"
"    プロセス統計のコレクションを管理します。\n"
"  * [`:sys.no_debug/2`](http://erlang.org/doc/man/sys.html#no_debug-2) -\n"
"    指定したプロセスのすべてのデバッグハンドラを向こうにします。完了後には\n"
"    デバッグをオフにすることが重要です。過度のデバッグハンドラまたは無効に\n"
"    すべきなのにしていないデバッグハンドラはシステムのパフォーマンスを著し"
"く\n"
"    損なう可能性があります。\n"
"\n"
"以前に定義したスタックサーあのデバッグにおいてこれらの関数をどのように使用す"
"るか\n"
"見てみましょう。\n"
"\n"
"    iex> {:ok, pid} = Stack.start_link([])\n"
"    iex> :sys.statistics(pid, true) # プロセス統計の収集を有効にするt\n"
"    iex> :sys.trace(pid, true) # イベントのプリント出力を有効にする\n"
"    iex> Stack.push(pid, 1)\n"
"    *DBG* <0.122.0> got cast {push,1}\n"
"    *DBG* <0.122.0> new state [1]\n"
"    :ok\n"
"    iex> :sys.get_state(pid)\n"
"    [1]\n"
"    iex> Stack.pop(pid)\n"
"    *DBG* <0.122.0> got call pop from <0.80.0>\n"
"    *DBG* <0.122.0> sent 1 to <0.80.0>, new state []\n"
"    1\n"
"    iex> :sys.statistics(pid, :get)\n"
"    {:ok,\n"
"     [start_time: {{2016, 7, 16}, {12, 29, 41}},\n"
"      current_time: {{2016, 7, 16}, {12, 29, 50}},\n"
"      reductions: 117, messages_in: 2, messages_out: 0]}\n"
"    iex> :sys.no_debug(pid) # すべてのデバッグハンドラを無効にする\n"
"    :ok\n"
"    iex> :sys.get_status(pid)\n"
"    {:status, #PID<0.122.0>, {:module, :gen_server},\n"
"     [[\"$initial_call\": {Stack, :init, 1},            # pdict\n"
"       \"$ancestors\": [#PID<0.80.0>, #PID<0.51.0>]],\n"
"      :running,                                       # :running | :"
"suspended\n"
"      #PID<0.80.0>,                                   # 親プロセス\n"
"      [],                                             # デバッガの状態\n"
"      [header: 'Status for generic server <0.122.0>', # モジュールのステータ"
"ス\n"
"       data: [{'Status', :running}, {'Parent', #PID<0.80.0>},\n"
"         {'Logged events', []}], data: [{'State', [1]}]]]}\n"
"\n"
"## さらなる学習のために\n"
"\n"
"gen serverについてもっと知りたいなら、Elixir getting started guide\n"
"がチュートリアルライクの導入を提供します。Erlangのドキュメントとリンク\n"
"もまた、追加の洞察を提供することができます。\n"
"\n"
"  * [GenServer – Elixir's Getting Started Guide](http://elixir-lang.org/"
"getting-started/mix-otp/genserver.html)\n"
"  * [`:gen_server` module documentation](http://www.erlang.org/doc/man/"
"gen_server.html)\n"
"  * [gen_server Behaviour – OTP Design Principles](http://www.erlang.org/doc/"
"design_principles/gen_server_concepts.html)\n"
"  * [Clients and Servers – Learn You Some Erlang for Great Good!](http://"
"learnyousomeerlang.com/clients-and-servers)\n"

#. TRANSLATORS: def GenServer.cast(server, request)
#: lib/gen_server.ex:744
msgid ""
"Sends an asynchronous request to the `server`.\n"
"\n"
"This function always returns `:ok` regardless of whether\n"
"the destination `server` (or node) exists. Therefore it\n"
"is unknown whether the destination `server` successfully\n"
"handled the message.\n"
"\n"
"`c:handle_cast/2` will be called on the server to handle\n"
"the request. In case the `server` is on a node which is\n"
"not yet connected to the caller one, the call is going to\n"
"block until a connection happens. This is different than\n"
"the behaviour in OTP's `:gen_server` where the message\n"
"is sent by another process in this case, which could cause\n"
"messages to other nodes to arrive out of order.\n"
msgstr ""
"`server`へ非同期リクエストを送信します。\n"
"\n"
"この関数は、送信先の`server`(またはノード)が存在するか否かを問わず、\n"
"常に`:ok`を返します。従って、送信先の`server`がメッセージの処理に成功した\n"
"かどうかは分りません。\n"
"\n"
"リクエストを処理するため、サーバ上で`c:handle_cast/2` が\n"
"呼び出されます。`server`が呼び出し側のノードとまだ接続されて\n"
"いないノードにある場合、コネクションが行われるまで呼び出しを\n"
"ブロックします。これは、OTPの`:gen_server`の振る舞いとは\n"
"異なります。そこではこのような場合、別のプロセスによりメッセージが\n"
"送信され、これにより他のノードへのメッセージの到着順が\n"
"乱れる原因になる場合があります。\n"

#. TRANSLATORS: @callback code_change/3
#: lib/gen_server.ex:465
msgid ""
"Invoked to change the state of the `GenServer` when a different version of "
"a\n"
"module is loaded (hot code swapping) and the state's term structure should "
"be\n"
"changed.\n"
"\n"
"`old_vsn` is the previous version of the module (defined by the `@vsn`\n"
"attribute) when upgrading. When downgrading the previous version is wrapped "
"in\n"
"a 2-tuple with first element `:down`. `state` is the current state of the\n"
"`GenServer` and `extra` is any extra data required to change the state.\n"
"\n"
"Returning `{:ok, new_state}` changes the state to `new_state` and the code\n"
"change is successful.\n"
"\n"
"Returning `{:error, reason}` fails the code change with reason `reason` and\n"
"the state remains as the previous state.\n"
"\n"
"If `c:code_change/3` raises the code change fails and the loop will "
"continue\n"
"with its previous state. Therefore this callback does not usually contain "
"side effects.\n"
msgstr ""
"異ったバージョンのモジュールがロードされた時、\n"
"`GenServer`の状態を変更するために呼び出されます(ホットコード\n"
"スワッピング)。状態の項構造体が変更されます。\n"
"\n"
"`old_vsn`は、アップグレードの場合はモジュールの（`@vsn`属性で\n"
"定義される）前バージョンです。ダウングレードの場合は、前バージョンは\n"
"2要素タプルで包まれ、その第1要素は`:down`です。`state`は`GenServer`の\n"
"現在の状態で、`extra`は状態の変更に必要な任意の追加データです。\n"
"\n"
"`{:ok, new_state}`を返すと、状態は`new_state`に変更され、コード変更は\n"
"成功です。\n"
"\n"
"`{:error, reason}`を返すと、コードの変更は理由`reason`で失敗し、\n"
"状態は以前の状態のままです。\n"
"\n"
"`c:code_change/3`が例外を発生させた場合、コード変更は失敗であり、\n"
"ループは以前の状態のまま継続します。したがって、通常、このコールバックは\n"
"副作用を持ちません。\n"
"\n"
"もし`code_change/3`が例外を上げるなら、code changeは失敗し、\n"
"ループは以前のステートで再開します。したがって、このコール\n"
"バックは通常副作用を含みません。\n"

#. TRANSLATORS: @callback terminate/2
#: lib/gen_server.ex:427
msgid ""
"Invoked when the server is about to exit. It should do any cleanup "
"required.\n"
"\n"
"`reason` is exit reason and `state` is the current state of the "
"`GenServer`.\n"
"The return value is ignored.\n"
"\n"
"`c:terminate/2` is called if a callback (except `c:init/1`) returns a `:"
"stop`\n"
"tuple, raises, calls `Kernel.exit/1` or returns an invalid value. It may "
"also\n"
"be called if the `GenServer` traps exits using `Process.flag/2` *and* the\n"
"parent process sends an exit signal.\n"
"\n"
"If part of a supervision tree a `GenServer`'s `Supervisor` will send an "
"exit\n"
"signal when shutting it down. The exit signal is based on the shutdown\n"
"strategy in the child's specification. If it is `:brutal_kill` the "
"`GenServer`\n"
"is killed and so `c:terminate/2` is not called. However if it is a timeout "
"the\n"
"`Supervisor` will send the exit signal `:shutdown` and the `GenServer` will\n"
"have the duration of the timeout to call `c:terminate/2` - if the process "
"is\n"
"still alive after the timeout it is killed.\n"
"\n"
"If the `GenServer` receives an exit signal (that is not `:normal`) from any\n"
"process when it is not trapping exits it will exit abruptly with the same\n"
"reason and so not call `c:terminate/2`. Note that a process does *NOT* trap\n"
"exits by default and an exit signal is sent when a linked process exits or "
"its\n"
"node is disconnected.\n"
"\n"
"Therefore it is not guaranteed that `c:terminate/2` is called when a "
"`GenServer`\n"
"exits. For such reasons, we usually recommend important clean-up rules to\n"
"happen in separated processes either by use of monitoring or by links\n"
"themselves. For example if the `GenServer` controls a `port` (e.g.\n"
"`:gen_tcp.socket`) or `t:File.io_device/0`, they will be closed on receiving "
"a\n"
"`GenServer`'s exit signal and do not need to be closed in `c:terminate/2`.\n"
"\n"
"If `reason` is not `:normal`, `:shutdown` nor `{:shutdown, term}` an error "
"is\n"
"logged.\n"
msgstr ""
"サーバが終了しようとする時に呼び出されます。必要なクリーンアップ\n"
"を行う必要があります。\n"
"\n"
"`reason`は終了理由であり、`state`は`GenServer`の現在の状態です。\n"
"返り値は無視されます。\n"
"\n"
"（`c:init/1`を除く）コールバックが`:stop`タプルを返した、例外を発生させた、\n"
"`Kernel.exit/1`を呼び出した、不正な値を返した場合、`c:terminate/2`が\n"
"呼び出されます。`GenServer`が`Process.flag/2`を使用して終了を捕捉しており、\n"
"*かつ*、親プロセスが終了シグナルを送信した場合も`c:terminate/2`は呼び出されま"
"す。\n"
"\n"
"監視ツリーの配下にある場合、`GenServer`の`Supervisor`はサーバーを\n"
"シャットダウンする際に終了シグナルを送信します。終了シグナルは子プロセス仕様"
"の\n"
"シャットダウン戦略に基づきます。戦略が`:brutal_kill` の場合、`GenServer`は\n"
"異常終了させられ、`c:terminate/2`は呼び出されません。しかし、タイムアウトの\n"
"場合、`Supervisor`は終了シグナル`:shutdown`を送信し、`GenServer`は\n"
"タイムアウトまでの間に`c:terminate/2`を呼び出すことができます。タイムアウト"
"が\n"
"過ぎてもプロセスが生きている場合は強制終了させられます。\n"
"\n"
"終了を捕捉していない`GenServer`が任意のプロセスから（`:normal`以外の）\n"
"終了シグナルを受信した場合、`GenServer`は同じ理由で突然終了するので、\n"
"`c:terminate/2`は呼び出されません。プロセスはデフォルトでは終了を\n"
"捕捉*しない*こと、終了シグナルはリンクしたプロセスが終了した場合やノードが\n"
"切断した場合も送信されることに注意してください。\n"
"\n"
"したがって、`GenSerer`が終了した時に`terminate/2`が呼び出される\n"
"ことは保証されません。このような理由から、通常、モニタの利用か\n"
"リンクそれ自身による別のプロセスで行わせる重要なクリーンアップルールが\n"
"推奨されます。たとえば、`GenServer`が`port`（たとえば、`:gen_tcp.socket`）"
"や\n"
"`File.io_device`を制御している場合、それらが`GenServer`の終了シグナルを\n"
"受信することによりクローズされるようにすれば、`c:terminate/2`でクローズ\n"
"する必要はありません。\n"
"\n"
"`reason`が`:normal`、`:shutdown`、`{:shutdown, term}`以外の\n"
"場合、エラーはログ出力されます。\n"
