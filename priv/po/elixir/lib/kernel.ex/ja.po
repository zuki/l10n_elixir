msgid ""
msgstr ""
"Project-Id-Version: l 10n_elixir\n"
"POT-Creation-Date: \n"
"PO-Revision-Date: 2017-03-14 18:10+0900\n"
"Last-Translator: 小田 照敬 <EMAIL@ADDRESS>\n"
"Language-Team: Japanese\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Poedit 1.8.12\n"

#. TRANSLATORS: def Kernel.exit(reason)
#: lib/kernel.ex:194
msgid ""
"Stops the execution of the calling process with the given reason.\n"
"\n"
"Since evaluating this function causes the process to terminate,\n"
"it has no return value.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"When a process reaches its end, by default it exits with\n"
"reason `:normal`. You can also call `exit/1` explicitly if you\n"
"want to terminate a process but not signal any failure:\n"
"\n"
"    exit(:normal)\n"
"\n"
"In case something goes wrong, you can also use `exit/1` with\n"
"a different reason:\n"
"\n"
"    exit(:seems_bad)\n"
"\n"
"If the exit reason is not `:normal`, all the processes linked to the "
"process\n"
"that exited will crash (unless they are trapping exits).\n"
"\n"
"## OTP exits\n"
"\n"
"Exits are used by the OTP to determine if a process exited abnormally\n"
"or not. The following exits are considered \"normal\":\n"
"\n"
"  * `exit(:normal)`\n"
"  * `exit(:shutdown)`\n"
"  * `exit({:shutdown, term})`\n"
"\n"
"Exiting with any other reason is considered abnormal and treated\n"
"as a crash. This means the default supervisor behaviour kicks in,\n"
"error reports are emitted, etc.\n"
"\n"
"This behaviour is relied on in many different places. For example,\n"
"`ExUnit` uses `exit(:shutdown)` when exiting the test process to\n"
"signal linked processes, supervision trees and so on to politely\n"
"shutdown too.\n"
"\n"
"## CLI exits\n"
"\n"
"Building on top of the exit signals mentioned above, if the\n"
"process started by the command line exits with any of the three\n"
"reasons above, its exit is considered normal and the Operating\n"
"System process will exit with status 0.\n"
"\n"
"It is, however, possible to customize the Operating System exit\n"
"signal by invoking:\n"
"\n"
"    exit({:shutdown, integer})\n"
"\n"
"This will cause the OS process to exit with the status given by\n"
"`integer` while signaling all linked OTP processes to politely\n"
"shutdown.\n"
"\n"
"Any other exit reason will cause the OS process to exit with\n"
"status `1` and linked OTP processes to crash.\n"
msgstr ""
"指定した理由で呼び出したプロセスの実行を停止します。\n"
"\n"
"この関数を評価するとプロセスが終了するので、返り値はありません。\n"
"\n"
"コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"プロセスが終わりに達すると、デフォルトではプロセスは理由`:normal`で\n"
"終了します。プロセスを終了させたいが、失敗のシグナルを出したくない\n"
"場合は、`exit/1`を明示的に呼ぶ出すこともできます。\n"
"\n"
"    exit(:normal)\n"
"\n"
"何かうまく行かたかった場合も、異なる理由を引数にして`exit/1`を使用する\n"
"ことができます。\n"
"\n"
"    exit(:seems_bad)\n"
"\n"
"終了理由が`:normal`以外の場合、終了したプロセスにリンクしている\n"
"プロセスは（終了を捕捉していない限り）すべてクラッシュします。\n"
"\n"
"## OTPの終了\n"
"\n"
"OTPでは終了はプロセスが異常終了したか否かの決定に使われます。\n"
"以下の終了は\"normal\"とみなされます。\n"
"\n"
"  * `exit(:normal)`\n"
"  * `exit(:shutdown)`\n"
"  * `exit({:shutdown, term})`\n"
"\n"
"その他の理由の終了はすべて異常だとみなされ、クラッシュとして扱われます。\n"
"これはスーパーバイザのデフォルトのふるまいが作動し、エラーレポートの\n"
"作成などが行われることを忌みます。\n"
"\n"
"このふるまいは様々な場所で頼りにされています。たとえば、`ExUnit`はテスト\n"
"プロセスを終了する時、`exit(:shutdown)` を使用して、リンクされたプロセスや\n"
"監視ツリーなどを標準的な方法で停止するよう通知します。\n"
"\n"
"## CLIの終了\n"
"\n"
"CLIは上で述べた終了シグナルに基づいて構築されていますので、コマンドライン\n"
"から起動されたプロセスが上の3つの理由のいずれかで終了した場合、その終了は\n"
"正常だとみなされ、オペレーティングシステムのプロセスはステータス0で終了しま"
"す。\n"
"\n"
"しかし、次のように実行することにより、オペレーティングシステムの終了\n"
"シグナルをカスタマイズすることも可能です：\n"
"\n"
"    exit({:shutdown, integer})\n"
"\n"
"これは、リンクされたすべてのOTPプロセスに標準的な停止を通知する一方で、\n"
"OSプロセスを`integer`で指定したステータスで終了させます。\n"
"\n"
"その他の理由の終了はすべてOSプロセスをステータス1で終了させ、リンクされた\n"
"OTPプロセスをクラッシュさせます。\n"

#. TRANSLATORS: def Kernel.round(number)
#: lib/kernel.ex:599
msgid ""
"Rounds a number to the nearest integer.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> round(5.6)\n"
"    6\n"
"\n"
"    iex> round(5.2)\n"
"    5\n"
"\n"
"    iex> round(-9.9)\n"
"    -10\n"
"\n"
"    iex> round(-9)\n"
"    -9\n"
"\n"
msgstr ""
"指定した数を最も近い整数に丸めます。\n"
"\n"
"ガードテストに使えます。コンパイラによりインライン化されます。\n"
"\n"
"## Examples\n"
"\n"
"    iex> round(5.6)\n"
"    6\n"
"    iex> round(5.2)\n"
"    5\n"
"    iex> round(-9.9)\n"
"    -10\n"
"    iex> round(-9)\n"
"    -9\n"
"\n"

#. TRANSLATORS: defmacro Kernel.update_in(path, fun)
#: lib/kernel.ex:2031
msgid ""
"Updates a nested structure via the given `path`.\n"
"\n"
"This is similar to `update_in/3`, except the path is extracted via\n"
"a macro rather than passing a list. For example:\n"
"\n"
"    update_in(opts[:foo][:bar], &(&1 + 1))\n"
"\n"
"Is equivalent to:\n"
"\n"
"    update_in(opts, [:foo, :bar], &(&1 + 1))\n"
"\n"
"Note that in order for this macro to work, the complete path must always\n"
"be visible by this macro. For more information about the supported path\n"
"expressions, please check `get_and_update_in/2` docs.\n"
"\n"
"## Examples\n"
"\n"
"    iex> users = %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}\n"
"    iex> update_in(users[\"john\"][:age], &(&1 + 1))\n"
"    %{\"john\" => %{age: 28}, \"meg\" => %{age: 23}}\n"
"\n"
"    iex> users = %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}\n"
"    iex> update_in(users[\"john\"].age, &(&1 + 1))\n"
"    %{\"john\" => %{age: 28}, \"meg\" => %{age: 23}}\n"
"\n"
msgstr ""
"指定した`path`によりネストした構造を更新します。\n"
"\n"
"リストを渡してpathを指定するのではなく、マクロによってpathが\n"
"抽出されることを除いて、これは`update_in/3`と同じです。\n"
"たとえば、\n"
"\n"
"    update_in(opts[:foo][:bar], &(&1 + 1))\n"
"\n"
"は、以下と等しいです。\n"
"\n"
"    update_in(opts, [:foo, :bar], &(&1 + 1))\n"
"\n"
"このマクロが機能するためには、完全なパスが常にこのマクロに見えて\n"
"いなければならないことに注意してください。サポートされている\n"
"パス式に関しては`get_and_update_in/2`のドキュメントをチェックしてください。\n"
"\n"
"## 例\n"
"\n"
"    iex> users = %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}\n"
"    iex> update_in(users[\"john\"][:age], &(&1 + 1))\n"
"    %{\"john\" => %{age: 28}, \"meg\" => %{age: 23}}\n"
"\n"
"    iex> users = %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}\n"
"    iex> update_in(users[\"john\"].age, &(&1 + 1))\n"
"    %{\"john\" => %{age: 28}, \"meg\" => %{age: 23}}\n"
"\n"

#. TRANSLATORS: defmacro Kernel.sigil_w(term, modifiers)
#: lib/kernel.ex:4331
msgid ""
"Handles the sigil `~w`.\n"
"\n"
"It returns a list of \"words\" split by whitespace. Character unescaping "
"and\n"
"interpolation happens for each word.\n"
"\n"
"## Modifiers\n"
"\n"
"  * `s`: words in the list are strings (default)\n"
"  * `a`: words in the list are atoms\n"
"  * `c`: words in the list are charlists\n"
"\n"
"## Examples\n"
"\n"
"    iex> ~w(foo #{:bar} baz)\n"
"    [\"foo\", \"bar\", \"baz\"]\n"
"\n"
"    iex> ~w(foo #{\" bar baz \"})\n"
"    [\"foo\", \"bar\", \"baz\"]\n"
"\n"
"    iex> ~w(--source test/enum_test.exs)\n"
"    [\"--source\", \"test/enum_test.exs\"]\n"
"\n"
"    iex> ~w(foo bar baz)a\n"
"    [:foo, :bar, :baz]\n"
"\n"
msgstr ""
"シジル`~w`を処理します。\n"
"\n"
"ホワイトスペースにより分割された\"words\"のリストを返します。\n"
"各ワードについて、文字のアンエスケープと式の埋め込みが行われます。\n"
"\n"
"## モディファイア\n"
"\n"
"  * `s`: リストのワードは文字列 (デフォルト)\n"
"  * `a`: リストのワードはアトム\n"
"  * `c`: リストのワードは文字のリスト\n"
"\n"
"## 例\n"
"\n"
"    iex> ~w(foo #{:bar} baz)\n"
"    [\"foo\", \"bar\", \"baz\"]\n"
"\n"
"    iex> ~w(--source test/enum_test.exs)\n"
"    [\"--source\", \"test/enum_test.exs\"]\n"
"\n"
"    iex> ~w(foo bar baz)a\n"
"    [:foo, :bar, :baz]\n"
"\n"

#. TRANSLATORS: def Kernel.==(left, right)
#: lib/kernel.ex:1133
msgid ""
"Returns `true` if the two items are equal.\n"
"\n"
"This operator considers 1 and 1.0 to be equal. For stricter\n"
"semantics, use `===` instead.\n"
"\n"
"All terms in Elixir can be compared with each other.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> 1 == 2\n"
"    false\n"
"\n"
"    iex> 1 == 1.0\n"
"    true\n"
"\n"
msgstr ""
"2つの項目が等しい場合、`true`を返します。\n"
"\n"
"この演算子は、1と1.0を等しいとみなします。より厳密な\n"
"セマンティクスには、代わりに`===`を使用してください。\n"
"\n"
"Elixirのすべての項は互いに比較加能です。\n"
"\n"
"ガードの中のテストに使えます。コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> 1 == 2\n"
"    false\n"
"\n"
"    iex> 1 == 1.0\n"
"    true\n"
"\n"

#. TRANSLATORS: def Kernel.is_number(term)
#: lib/kernel.ex:397
msgid ""
"Returns `true` if `term` is either an integer or a floating point number;\n"
"otherwise returns `false`.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
msgstr ""
"`term`が整数か浮動小数点数のいずれかの場合は`true`を返します。\n"
"それ以外は`false`を返します。\n"
"\n"
"ガードテストに使えます。コンパイラによりインライン化されます。\n"

#. TRANSLATORS: def Kernel.is_boolean(term)
#: lib/kernel.ex:327
msgid ""
"Returns `true` if `term` is either the atom `true` or the atom `false` (i."
"e.,\n"
"a boolean); otherwise returns `false`.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
msgstr ""
"`term`がアトム`true`またはアトム`false`のいずれか（すなわちブール値）\n"
"のばあいは`true`を返します。それ以外は`false`を返します。\n"
"\n"
"ガードテストに使えます。コンパイラによりインライン化されます。\n"

#. TRANSLATORS: defmacro Kernel.var!(var, context \\ nil)
#: lib/kernel.ex:3053
msgid ""
"When used inside quoting, marks that the given variable should\n"
"not be hygienized.\n"
"\n"
"The argument can be either a variable unquoted or in standard tuple form\n"
"`{name, meta, context}`.\n"
"\n"
"Check `Kernel.SpecialForms.quote/2` for more information.\n"
msgstr ""
"quote内で使用された場合、指定した変数が健全であるべきではないことを\n"
"マークします。\n"
"\n"
"引数は、unquoteされた変数か、`{name, meta, context}`の形の標準的な\n"
"タプルのいずれかです。\n"
"\n"
"詳細は、`Kernel.SpecialForms.quote/2`をチェックしてください。\n"

#. TRANSLATORS: def Kernel.hd(list)
#: lib/kernel.ex:260
msgid ""
"Returns the head of a list. Raises `ArgumentError` if the list is empty.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    hd([1, 2, 3, 4])\n"
"    #=> 1\n"
"\n"
"    hd([])\n"
"    #=> ** (ArgumentError) argument error\n"
"\n"
msgstr ""
"リストのヘッドを返します。リストが空の場合は`ArgumentError`を\n"
"発生させます。\n"
"\n"
"ガード節で使えます。コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    hd([1, 2, 3, 4])\n"
"    #=> 1\n"
"\n"
"    hd([])\n"
"    #=> ** (ArgumentError) argument error\n"
"\n"

#. TRANSLATORS: def Kernel.get_in(data, keys)
#: lib/kernel.ex:1753
msgid ""
"Gets a value from a nested structure.\n"
"\n"
"Uses the `Access` module to traverse the structures\n"
"according to the given `keys`, unless the `key` is a\n"
"function.\n"
"\n"
"If a key is a function, the function will be invoked\n"
"passing three arguments, the operation (`:get`), the\n"
"data to be accessed, and a function to be invoked next.\n"
"\n"
"This means `get_in/2` can be extended to provide\n"
"custom lookups. The downside is that functions cannot be\n"
"stored as keys in the accessed data structures.\n"
"\n"
"## Examples\n"
"\n"
"    iex> users = %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}\n"
"    iex> get_in(users, [\"john\", :age])\n"
"    27\n"
"\n"
"In case any of entries in the middle returns `nil`, `nil` will be returned\n"
"as per the Access module:\n"
"\n"
"    iex> users = %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}\n"
"    iex> get_in(users, [\"unknown\", :age])\n"
"    nil\n"
"\n"
"When one of the keys is a function, the function is invoked.\n"
"In the example below, we use a function to get all the maps\n"
"inside a list:\n"
"\n"
"    iex> users = [%{name: \"john\", age: 27}, %{name: \"meg\", age: 23}]\n"
"    iex> all = fn :get, data, next -> Enum.map(data, next) end\n"
"    iex> get_in(users, [all, :age])\n"
"    [27, 23]\n"
"\n"
"If the previous value before invoking the function is `nil`,\n"
"the function *will* receive nil as a value and must handle it\n"
"accordingly.\n"
msgstr ""
"ネストした構造体から値を取得します。\n"
"\n"
"`key`が関数でないかぎり、`Access`モジュールを使って指定した`key`に\n"
"基いて構造体を走査します。\n"
"\n"
"キーが関数の場合、その関数に3つの引数、すなわち、操作（`:get`）、\n"
"アクセスするべきデータ、次に実行する関数、が渡されて実行されます。\n"
"\n"
"これは、独自の検索方法を提供するよう、`get_in/3`は拡張可能である\n"
"ことを意味します。欠点は、アクセスされるデータ構造体にキーとして\n"
"格納できないことです。\n"
"\n"
"## 例\n"
"\n"
"    iex> users = %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}\n"
"    iex> get_in(users, [\"john\", :age])\n"
"    27\n"
"\n"
"中間の項目のいずれかが`nil`を返した場合、Accessモジュール毎に\n"
"`nil`が返されます:\n"
"\n"
"    iex> users = %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}\n"
"    iex> get_in(users, [\"unknown\", :age])\n"
"    nil\n"
"\n"
"キーの一つが関数の場合、関数が実行されます。 下の例では、\n"
"リスト中のすべてのマップを取得するために関数を使っています:\n"
"\n"
"    iex> users = [%{name: \"john\", age: 27}, %{name: \"meg\", age: 23}]\n"
"    iex> all = fn :get, data, next -> Enum.map(data, next) end\n"
"    iex> get_in(users, [all, :age])\n"
"    [27, 23]\n"
"\n"
"関数を実行する前の以前の値がnilの場合、関数は値としてnilを受け取*ります*\n"
"ので、状況に応じて処理しなければなりません。\n"

#. TRANSLATORS: def Kernel.struct!(struct, kv \\ [])
#: lib/kernel.ex:1703
msgid ""
"Similar to `struct/2` but checks for key validity.\n"
"\n"
"The function `struct!/2` emulates the compile time behaviour\n"
"of structs. This means that:\n"
"\n"
"  * when building a struct, as in `struct!(SomeStruct, key: :value)`,\n"
"    it is equivalent to `%SomeStruct{key: :value}` and therefore this\n"
"    function will check if every given key-value belongs to the struct.\n"
"    If the struct is enforcing any key via `@enforce_keys`, those will\n"
"    be enforced as well;\n"
"\n"
"  * when updating a struct, as in `struct!(%SomeStruct{}, key: :value)`,\n"
"    it is equivalent to `%SomeStruct{struct | key: :value}` and therefore "
"this\n"
"    function will check if every given key-value belongs to the struct.\n"
"    However, updating structs does not enforce keys, as keys are enforced\n"
"    only when building;\n"
"\n"
msgstr ""
"`struct/2`と同じですが、キーの正当性をチェックします。\n"
"\n"
"関数`struct!/2`は構造体のコンパイル時のビヘイビアを\n"
"エミュレートします。これは次を意味します。\n"
"\n"
"  * `struct!(SomeStruct, key: :value)`などで構造体を構築する際、\n"
"    これは`%SomeStruct{key: :value}`に等しいので、この関数は\n"
"    指定されたすべてのキー/値が構造体に含まれるものであるかチェックします。\n"
"    構造体が`@enforce_keys`により任意のキーを強制している場合は\n"
"    それらのキーも強制されます:\n"
"\n"
"  * `struct!(%SomeStruct{}, key: :value)`などで構造体を更新する際、\n"
"    これは`%SomeStruct{struct | key: :value}`に等しいので、この関数は\n"
"    指定されたすべてのキー/値が構造体に含まれるものであるかチェックします。\n"
"    しかし、構造体の更新はキーを強制しません。キーが強制されるのは構築時\n"
"    だけだからです。\n"
"\n"

#. TRANSLATORS: def Kernel.map_size(map)
#: lib/kernel.ex:492
msgid ""
"Returns the size of a map.\n"
"\n"
"The size of a map is the number of key-value pairs that the map contains.\n"
"\n"
"This operation happens in constant time.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> map_size(%{a: \"foo\", b: \"bar\"})\n"
"    2\n"
"\n"
msgstr ""
"マップのサイズを返します。\n"
"\n"
"マップのサイズは、マップが含むkey-valueペアの数です。\n"
"\n"
"このオペレーションは定数時間で実行されます。\n"
"\n"
"ガードテストに使えます。コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> map_size(%{a: \"foo\", b: \"bar\"})\n"
"    2\n"
"\n"

#. TRANSLATORS: defmacro Kernel.destructure(left, right)
#: lib/kernel.ex:2617
msgid ""
"Destructures two lists, assigning each term in the\n"
"right one to the matching term in the left one.\n"
"\n"
"Unlike pattern matching via `=`, if the sizes of the left\n"
"and right lists don't match, destructuring simply stops\n"
"instead of raising an error.\n"
"\n"
"## Examples\n"
"\n"
"    iex> destructure([x, y, z], [1, 2, 3, 4, 5])\n"
"    iex> {x, y, z}\n"
"    {1, 2, 3}\n"
"\n"
"In the example above, even though the right list has more entries than the\n"
"left one, destructuring works fine. If the right list is smaller, the\n"
"remaining items are simply set to `nil`:\n"
"\n"
"    iex> destructure([x, y, z], [1])\n"
"    iex> {x, y, z}\n"
"    {1, nil, nil}\n"
"\n"
"The left-hand side supports any expression you would use\n"
"on the left-hand side of a match:\n"
"\n"
"    x = 1\n"
"    destructure([^x, y, z], [1, 2, 3])\n"
"\n"
"The example above will only work if `x` matches the first value in the "
"right\n"
"list. Otherwise, it will raise a `MatchError` (like the `=` operator would\n"
"do).\n"
msgstr ""
"右側のリストの各項目を左側の対応する項目に代入することにより、\n"
"2つのリストを非構造化します。\n"
"\n"
"`=`によるパターンマッチングとは異なり、左右のリストのサイズが\n"
"一致しなくてもエラーは発生させず、非構造化を停止するだけです。\n"
"\n"
"## 例\n"
"\n"
"    iex> destructure([x, y, z], [1, 2, 3, 4, 5])\n"
"    iex> {x, y, z}\n"
"    {1, 2, 3}\n"
"\n"
"上の例では、右のリストは左のリストより多くの項目がありますが、\n"
"非構造化は問題なく動きます。右のリストの方が小さい場合は、\n"
"残りの項目には単に`nil`が代入されます。\n"
"\n"
"    iex> destructure([x, y, z], [1])\n"
"    iex> {x, y, z}\n"
"    {1, nil, nil}\n"
"\n"
"左側には、マッチの左辺で使うことができる任意の式を\n"
"指定できます。\n"
"\n"
"    x = 1\n"
"    destructure([^x, y, z], [1, 2, 3])\n"
"\n"
"上の例は、`x`が右側のリストの最初の値とマッチする場合のみ動作します。\n"
"そうでなければ、（`=`オペレータと同じように）`MatchError`を発生\n"
"させます。\n"

#. TRANSLATORS: def Kernel.apply(fun, args)
#: lib/kernel.ex:60
msgid ""
"Invokes the given `fun` with the list of arguments `args`.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> apply(fn x -> x * 2 end, [2])\n"
"    4\n"
"\n"
msgstr ""
"リスト`args`を引数に、指定した`fun`を呼び出します。\n"
"\n"
"コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> apply(fn x -> x * 2 end, [2])\n"
"    4\n"
"\n"

#. TRANSLATORS: def Kernel.is_port(term)
#: lib/kernel.ex:418
msgid ""
"Returns `true` if `term` is a port identifier; otherwise returns `false`.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
msgstr ""
"`term`がポート識別子の場合は`true`を返します。それ以外は`false`を返します。\n"
"\n"
"ガードテストに使えます。コンパイラによりインライン化されます。\n"

#. TRANSLATORS: def Kernel.tuple_size(tuple)
#: lib/kernel.ex:839
msgid ""
"Returns the size of a tuple.\n"
"\n"
"This operation happens in constant time.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> tuple_size {:a, :b, :c}\n"
"    3\n"
"\n"
msgstr ""
"タプルのサイズを返します。\n"
"\n"
"このオペレーションは定数時間で実行されます。\n"
"\n"
"ガードテストに使えます。コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> tuple_size {:a, :b, :c}\n"
"    3\n"
"\n"

#. TRANSLATORS: defmacro Kernel.and(left, right)
#: lib/kernel.ex:1296
msgid ""
"Boolean and.\n"
"\n"
"If the first argument is `false`, `false` is returned; otherwise, the "
"second\n"
"argument is returned.\n"
"\n"
"Requires only the first argument to be a boolean since it short-circuits. "
"If\n"
"the first argument is not a boolean, an `ArgumentError` exception is "
"raised.\n"
"\n"
"Allowed in guard tests.\n"
"\n"
"## Examples\n"
"\n"
"    iex> true and false\n"
"    false\n"
"    iex> true and \"yay!\"\n"
"    \"yay!\"\n"
"\n"
msgstr ""
"論理積です。\n"
"\n"
"第1引数が`false`の場合、`false`が返されます。そうでなければ、第2引数が\n"
"返されます。\n"
"\n"
"短絡演算子のため、第1引数のみ論理値である必要があります。第1引数が\n"
"論理値でない場合は`ArgumentError`例外が発生します。\n"
"\n"
"ガードテストで使えます。\n"
"\n"
"## Examples\n"
"\n"
"    iex> true and false\n"
"    false\n"
"    iex> true and \"yay!\"\n"
"    \"yay!\"\n"
"\n"

#. TRANSLATORS: def Kernel./(left, right)
#: lib/kernel.ex:949
msgid ""
"Arithmetic division.\n"
"\n"
"The result is always a float. Use `div/2` and `rem/2` if you want\n"
"an integer division or the remainder.\n"
"\n"
"Raises `ArithmeticError` if `right` is 0 or 0.0.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    1 / 2\n"
"    #=> 0.5\n"
"\n"
"    -3.0 / 2.0\n"
"    #=> -1.5\n"
"\n"
"    5 / 1\n"
"    #=> 5.0\n"
"\n"
"    7 / 0\n"
"    #=> ** (ArithmeticError) bad argument in arithmetic expression\n"
"\n"
msgstr ""
"算術的除算です。\n"
"\n"
"結果は常に浮動小数点数です。整数の除算と余りが必要な場合は\n"
"`div/2`と`rem/2`を使ってください。\n"
"\n"
"`right`が0または0.0の場合、`ArithmeticError`が発生します。\n"
"\n"
"ガードテストで使えます。コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    1 / 2\n"
"    #=> 0.5\n"
"\n"
"    -3.0 / 2.0\n"
"    #=> -1.5\n"
"\n"
"    5 / 1\n"
"    #=> 5.0\n"
"\n"
"    7 / 0\n"
"    #=> ** (ArithmeticError) bad argument in arithmetic expression\n"
"\n"

#. TRANSLATORS: defmacro Kernel.if(condition, clauses)
#: lib/kernel.ex:2513
msgid ""
"Provides an `if/2` macro.\n"
"\n"
"This macro expects the first argument to be a condition and the second\n"
"argument to be a keyword list.\n"
"\n"
"## One-liner examples\n"
"\n"
"    if(foo, do: bar)\n"
"\n"
"In the example above, `bar` will be returned if `foo` evaluates to\n"
"`true` (i.e., it is neither `false` nor `nil`). Otherwise, `nil` will be\n"
"returned.\n"
"\n"
"An `else` option can be given to specify the opposite:\n"
"\n"
"    if(foo, do: bar, else: baz)\n"
"\n"
"## Blocks examples\n"
"\n"
"It's also possible to pass a block to the `if/2` macro. The first\n"
"example above would be translated to:\n"
"\n"
"    if foo do\n"
"      bar\n"
"    end\n"
"\n"
"Note that `do/end` become delimiters. The second example would\n"
"translate to:\n"
"\n"
"    if foo do\n"
"      bar\n"
"    else\n"
"      baz\n"
"    end\n"
"\n"
"In order to compare more than two clauses, the `cond/1` macro has to be "
"used.\n"
msgstr ""
"`if/2`マクロを提供します。\n"
"\n"
"このマクロは、最初の引数には条件を、第2引数にはキーワードリストを期待しま"
"す。\n"
"\n"
"## ワンライナーの例\n"
"\n"
"    if(foo, do: bar)\n"
"\n"
"この例では、`foo`が`true`（すなわち、`false`でも`nil`でもない）と\n"
"評価された場合、`bar`が返されます。そうでなければ、`nil`が返されます。\n"
"\n"
"反対の動作を指定するために`else`オプションを指定することができます。\n"
"\n"
"    if(foo, do: bar, else: baz)\n"
"\n"
"## ブロックの例\n"
"\n"
"`if/2`マクロにはブロックを渡すこともできます。上の最初の例は、\n"
"次のように翻訳されます。\n"
"\n"
"    if foo do\n"
"      bar\n"
"    end\n"
"\n"
"`do/end`はデリミタになることに注意してください。2番目の例は\n"
"次のように翻訳されます。\n"
"\n"
"    if foo do\n"
"      bar\n"
"    else\n"
"      baz\n"
"    end\n"
"\n"
"2つ以上の節を比較する場合は`cond/1`マクロを使用するべきです。\n"
"\n"

#. TRANSLATORS: defmacro Kernel.raise(msg)
#: lib/kernel.ex:1397
msgid ""
"Raises an exception.\n"
"\n"
"If the argument `msg` is a binary, it raises a `RuntimeError` exception\n"
"using the given argument as message.\n"
"\n"
"If `msg` is an atom, it just calls `raise/2` with the atom as the first\n"
"argument and `[]` as the second argument.\n"
"\n"
"If `msg` is anything else, raises an `ArgumentError` exception.\n"
"\n"
"## Examples\n"
"\n"
"    iex> raise \"oops\"\n"
"    ** (RuntimeError) oops\n"
"\n"
"    try do\n"
"      1 + :foo\n"
"    rescue\n"
"      x in [ArithmeticError] ->\n"
"        IO.puts \"that was expected\"\n"
"        raise x\n"
"    end\n"
"\n"
msgstr ""
"例外を発生させます。\n"
"\n"
"引数`msg`がバイナリの場合、指定した引数をメッセージとして使い、\n"
"`RuntimeError`例外を発生させます。\n"
"\n"
"`msg`がアトムの場合は単に、アトムを第1引数、`[]`を第2引数として\n"
"`raise/2`を呼び出します。\n"
"\n"
"`msg`がそれ以外の場合、`ArgumentError`例外を発生させます。\n"
"\n"
"## 例\n"
"\n"
"    iex> raise \"oops\"\n"
"    ** (RuntimeError) oops\n"
"\n"
"    try do\n"
"      1 + :foo\n"
"    rescue\n"
"      x in [ArithmeticError] ->\n"
"        IO.puts \"that was expected\"\n"
"        raise x\n"
"    end\n"
"\n"

#. TRANSLATORS: defmacro Kernel.alias!(alias)
#: lib/kernel.ex:3081
msgid ""
"When used inside quoting, marks that the given alias should not\n"
"be hygienized. This means the alias will be expanded when\n"
"the macro is expanded.\n"
"\n"
"Check `Kernel.SpecialForms.quote/2` for more information.\n"
msgstr ""
"quoteの内側で使われた時、その別名が健全(hygienezed)であっては\n"
"ならないとマークします。これは別名はマクロが展開された時に展開\n"
"されるだろうことを意味します。\n"
"\n"
"更なる情報は、`Kernel.SpecialForms.quote/2`をチェックしてくだ\n"
"さい。\n"

#. TRANSLATORS: def Kernel.=~(left, right)
#: lib/kernel.ex:1554
msgid ""
"Matches the term on the left against the regular expression or string on "
"the\n"
"right.\n"
"\n"
"Returns `true` if `left` matches `right` (if it's a regular expression)\n"
"or contains `right` (if it's a string).\n"
"\n"
"## Examples\n"
"\n"
"    iex> \"abcd\" =~ ~r/c(d)/\n"
"    true\n"
"\n"
"    iex> \"abcd\" =~ ~r/e/\n"
"    false\n"
"\n"
"    iex> \"abcd\" =~ \"bc\"\n"
"    true\n"
"\n"
"    iex> \"abcd\" =~ \"ad\"\n"
"    false\n"
"\n"
"    iex> \"abcd\" =~ \"\"\n"
"    true\n"
"\n"
msgstr ""
"左オペランドの項を右オペランドの正規表現または文字列に\n"
"マッチさせます。\n"
"\n"
"`left`が`right`（正規表現）にマッチした場合、あるいは、\n"
"`left`が`right`（文字列）を含む場合、`true`を返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> \"abcd\" =~ ~r/c(d)/\n"
"    true\n"
"\n"
"    iex> \"abcd\" =~ ~r/e/\n"
"    false\n"
"\n"
"    iex> \"abcd\" =~ \"bc\"\n"
"    true\n"
"\n"
"    iex> \"abcd\" =~ \"ad\"\n"
"    false\n"
"\n"
"    iex> \"abcd\" =~ \"\"\n"
"    true\n"
"\n"

#. TRANSLATORS: def Kernel.spawn_monitor(module, fun, args)
#: lib/kernel.ex:765
msgid ""
"Spawns the given module and function passing the given args,\n"
"monitors it and returns its PID and monitoring reference.\n"
"\n"
"Check the `Process` and `Node` modules for other functions\n"
"to handle processes, including spawning functions in nodes.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    spawn_monitor(SomeModule, :function, [1, 2, 3])\n"
"\n"
msgstr ""
"指定した引数を渡して、指定したモジュールの関数を生成し、\n"
"それをモニターして、そのPIDとモニターのリファレンスを返します。\n"
"\n"
"別のノードでの関数の生成を含む、プロセスを扱うその他の関数に\n"
"ついては`Process`モジュールと`Node`モジュールをチェックしてください。\n"
"\n"
"コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    spawn_monitor(SomeModule, :function, [1, 2, 3])\n"
"\n"

#. TRANSLATORS: def Kernel.tl(list)
#: lib/kernel.ex:796
msgid ""
"Returns the tail of a list. Raises `ArgumentError` if the list is empty.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    tl([1, 2, 3, :go])\n"
"    #=> [2, 3, :go]\n"
"\n"
"    tl([])\n"
"    #=> ** (ArgumentError) argument error\n"
"\n"
msgstr ""
"リストのテイルを返します。リストが空の場合は`ArgumentError`を\n"
"発生させます。\n"
"\n"
"ガードテストに使えます。コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    tl([1, 2, 3, :go])\n"
"    #=> [2, 3, :go]\n"
"\n"
"    tl([])\n"
"    #=> ** (ArgumentError) argument error\n"
"\n"

#. TRANSLATORS: def Kernel.*(left, right)
#: lib/kernel.ex:930
msgid ""
"Arithmetic multiplication.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> 1 * 2\n"
"    2\n"
"\n"
msgstr ""
"算術的乗算です。\n"
"\n"
"ガードテストで使えます。コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> 1 * 2\n"
"    2\n"
"\n"

#. TRANSLATORS: def Kernel.>=(left, right)
#: lib/kernel.ex:1115
msgid ""
"Returns `true` if left is more than or equal to right.\n"
"\n"
"All terms in Elixir can be compared with each other.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> 1 >= 2\n"
"    false\n"
"\n"
msgstr ""
"左オペランドが右オペランドより大きい、または等しい場合、`true`を返します。\n"
"\n"
"Elixirのすべての項は互いに比較加能です。\n"
"\n"
"ガードの中のテストに使えます。コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> 1 >= 2\n"
"    false\n"
"\n"

#. TRANSLATORS: def Kernel.spawn(module, fun, args)
#: lib/kernel.ex:680
msgid ""
"Spawns the given module and function passing the given args\n"
"and returns its PID.\n"
"\n"
"Check the `Process` and `Node` modules for other functions\n"
"to handle processes, including spawning functions in nodes.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    spawn(SomeModule, :function, [1, 2, 3])\n"
"\n"
msgstr ""
"指定した引数を渡して、指定したモジュールの関数を生成し、\n"
"そのPIDを返します。\n"
"\n"
"別のノードでの関数の生成を含む、プロセスを扱うその他の関数に\n"
"ついては`Process`モジュールと`Node`モジュールをチェックしてください。\n"
"\n"
"コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    spawn(SomeModule, :function, [1, 2, 3])\n"
"\n"

#. TRANSLATORS: def Kernel.--(left, right)
#: lib/kernel.ex:1017
msgid ""
"Removes the first occurrence of an item on the left list\n"
"for each item on the right.\n"
"\n"
"The complexity of `a -- b` is proportional to `length(a) * length(b)`,\n"
"meaning that it will be very slow if both `a` and `b` are long lists.\n"
"In such cases, consider converting each list to a `MapSet` and using\n"
"`MapSet.difference/2`.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> [1, 2, 3] -- [1, 2]\n"
"    [3]\n"
"\n"
"    iex> [1, 2, 3, 2, 1] -- [1, 2, 2]\n"
"    [3, 1]\n"
"\n"
msgstr ""
"右オペランドの各項目について左オペランドのリストで最初に現れる項目を\n"
"削除します。\n"
"\n"
"`a -- b`の計算量は、`length(a) * length(b)`に比例します。これは、\n"
"`a`と`b`が共に長いリストの場合、非常に時間がかかることを意味します。\n"
"そのような場合、それぞれのリストを`MapSet`に変換して\n"
"`MapSet.difference/2`を使用することを検討してください。\n"
"\n"
"コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> [1, 2, 3] -- [1, 2]\n"
"    [3]\n"
"\n"
"    iex> [1, 2, 3, 2, 1] -- [1, 2, 2]\n"
"    [3, 1]\n"
"\n"

#. TRANSLATORS: def Kernel.pop_in(data, keys)
#: lib/kernel.ex:1927
msgid ""
"Pops a key from the given nested structure.\n"
"\n"
"Uses the `Access` protocol to traverse the structures\n"
"according to the given `keys`, unless the `key` is a\n"
"function. If the key is a function, it will be invoked\n"
"as specified in `get_and_update_in/3`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> users = %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}\n"
"    iex> pop_in(users, [\"john\", :age])\n"
"    {27, %{\"john\" => %{}, \"meg\" => %{age: 23}}}\n"
"\n"
"In case any entry returns `nil`, its key will be removed\n"
"and the deletion will be considered a success.\n"
msgstr ""
"指定したネストした構造体からキーをポップします。\n"
"\n"
"`key`が関数でないかぎり、`Access`プロトコルをを使って指定した\n"
"`keys`に基いて構造体を走査します。キーが関数の場合は、`get_and_update_in/3`"
"で\n"
"説明したように関数が実行されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> users = %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}\n"
"    iex> pop_in(users, [\"john\", :age])\n"
"    {27, %{\"john\" => %{}, \"meg\" => %{age: 23}}}\n"
"\n"
"中間の項目のいずれかが`nil`を返した場合、そのキーは削除され、\n"
"削除は成功とみなされます。\n"

#. TRANSLATORS: def Kernel.node(arg)
#: lib/kernel.ex:563
msgid ""
"Returns the node where the given argument is located.\n"
"The argument can be a PID, a reference, or a port.\n"
"If the local node is not alive, `:nonode@nohost` is returned.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
msgstr ""
"指定した引数が存在するノードを返します。引数には、PID、リファレンス、\n"
"ポートを指定できます。ノードが生きていない場合は`:nonode@nohost`が\n"
"返されます。\n"
"\n"
"ガードテストに使えます。コンパイラによりインライン化されます。\n"

#. TRANSLATORS: defmacro Kernel.defdelegate(funs, opts)
#: lib/kernel.ex:4067
msgid ""
"Defines a function that delegates to another module.\n"
"\n"
"Functions defined with `defdelegate/2` are public and can be invoked from\n"
"outside the module they're defined in (like if they were defined using\n"
"`def/2`). When the desire is to delegate as private functions, `import/2` "
"should\n"
"be used.\n"
"\n"
"Delegation only works with functions; delegating macros is not supported.\n"
"\n"
"## Options\n"
"\n"
"  * `:to` - the module to dispatch to.\n"
"\n"
"  * `:as` - the function to call on the target given in `:to`.\n"
"    This parameter is optional and defaults to the name being\n"
"    delegated (`funs`).\n"
"\n"
"## Examples\n"
"\n"
"    defmodule MyList do\n"
"      defdelegate reverse(list), to: :lists\n"
"      defdelegate other_reverse(list), to: :lists, as: :reverse\n"
"    end\n"
"\n"
"    MyList.reverse([1, 2, 3])\n"
"    #=> [3, 2, 1]\n"
"\n"
"    MyList.other_reverse([1, 2, 3])\n"
"    #=> [3, 2, 1]\n"
"\n"
msgstr ""
"別のモジュールへ委譲する関数を定義します。\n"
"\n"
"`defdelegate/2`で定義された関数は、公開関数であり、\n"
"（`def/2`を使って定義された関数のように）関数が定義された\n"
"モジュールの外部から呼び出すことができます。\n"
"プライベート関数として移譲したい場合は、`import/2`を\n"
"使う必要があります。\n"
"\n"
"移譲ができるのは関数のみです。マクロの移譲はサポートされていません。\n"
"\n"
"## オプション\n"
"\n"
"  * `:to` -  ディスパッチするモジュール。\n"
"\n"
"  * `:as` -  `:to`で指定したターゲット上で呼び出す関数。\n"
"    このパラメタはオプションで、デフォルトは移譲される名前(`funs`)です。\n"
"\n"
"## 例\n"
"\n"
"    defmodule MyList do\n"
"      defdelegate reverse(list), to: :lists\n"
"      defdelegate other_reverse(list), to: :lists, as: :reverse\n"
"    end\n"
"\n"
"    MyList.reverse([1, 2, 3])\n"
"    #=> [3, 2, 1]\n"
"\n"
"    MyList.other_reverse([1, 2, 3])\n"
"    #=> [3, 2, 1]\n"
"\n"

#. TRANSLATORS: def Kernel.is_pid(term)
#: lib/kernel.ex:408
msgid ""
"Returns `true` if `term` is a PID (process identifier); otherwise returns "
"`false`.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
msgstr ""
"`term`がPID（プロセス識別子）の場合は`true`を返します。\n"
"それ以外は`false`を返します。\n"
"\n"
"ガードテストに使えます。コンパイラによりインライン化されます。\n"

#. TRANSLATORS: defmacro Kernel.raise(exception, attrs)
#: lib/kernel.ex:1450
msgid ""
"Raises an exception.\n"
"\n"
"Calls the `exception/1` function on the given argument (which has to be a\n"
"module name like `ArgumentError` or `RuntimeError`) passing `attrs` as the\n"
"attributes in order to retrieve the exception struct.\n"
"\n"
"Any module that contains a call to the `defexception/1` macro automatically\n"
"implements the `c:Exception.exception/1` callback expected by `raise/2`.\n"
"For more information, see `defexception/1`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> raise(ArgumentError, message: \"Sample\")\n"
"    ** (ArgumentError) Sample\n"
"\n"
msgstr ""
"例外を発生させます。\n"
"\n"
"例外構造体を取得するために、指定した引数（`ArgumentError`や\n"
"`RuntimeError`などのモジュール名でなければなりません）の\n"
"`exception/1`関数を`attrs`を属性として渡して呼び出します。\n"
"\n"
"`defexception/1`マクロの呼び出しを含む任意のモジュールは、\n"
"`raise/2`により期待される`c:Exception.exception/1`コールバックを\n"
"自動的に実装します。詳細は、`defexception/1`を参照してください。\n"
"\n"
"## 例\n"
"\n"
"    iex> raise(ArgumentError, message: \"Sample\")\n"
"    ** (ArgumentError) Sample\n"
"\n"

#. TRANSLATORS: defmacro Kernel.unless(condition, clauses)
#: lib/kernel.ex:2573
msgid ""
"Provides an `unless` macro.\n"
"\n"
"This macro evaluates and returns the `do` block passed in as the second\n"
"argument unless `clause` evaluates to `true`. Otherwise, it returns the "
"value\n"
"of the `else` block if present or `nil` if not.\n"
"\n"
"See also `if/2`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> unless(Enum.empty?([]), do: \"Hello\")\n"
"    nil\n"
"\n"
"    iex> unless(Enum.empty?([1, 2, 3]), do: \"Hello\")\n"
"    \"Hello\"\n"
"\n"
"    iex> unless Enum.sum([2, 2]) == 5 do\n"
"    ...>   \"Math still works\"\n"
"    ...> else\n"
"    ...>   \"Math is broken\"\n"
"    ...> end\n"
"    \"Math still works\"\n"
"\n"
msgstr ""
"`unless`マクロを提供します。\n"
"\n"
"このマクロは、`clause`が`true`に評価されない限り、2番目の引数として\n"
"渡された`do`ブロックを評価して返します。\n"
"そうでない場合、`else`ブロックが存在すればその値を返し、存在しない場合は\n"
"`nil`を返します。\n"
"\n"
"`if/2`も参照してください。\n"
"\n"
"## 例\n"
"\n"
"    iex> unless(Enum.empty?([]), do: \"Hello\")\n"
"    nil\n"
"\n"
"    iex> unless(Enum.empty?([1, 2, 3]), do: \"Hello\")\n"
"    \"Hello\"\n"
"\n"
"    iex> unless Enum.sum([2, 2]) == 5 do\n"
"    ...>   \"Math still works\"\n"
"    ...> else\n"
"    ...>   \"Math is broken\"\n"
"    ...> end\n"
"    \"Math still works\"\n"
"\n"

#. TRANSLATORS: def Kernel.is_integer(term)
#: lib/kernel.ex:377
msgid ""
"Returns `true` if `term` is an integer; otherwise returns `false`.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
msgstr ""
"`term`が整数の場合は`true`を返します。それ以外は`false`を返します。\n"
"\n"
"ガードテストに使えます。コンパイラによりインライン化されます。\n"

#. TRANSLATORS: def Kernel.is_bitstring(term)
#: lib/kernel.ex:309
msgid ""
"Returns `true` if `term` is a bitstring (including a binary); otherwise "
"returns `false`.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> is_bitstring \"foo\"\n"
"    true\n"
"    iex> is_bitstring <<1::3>>\n"
"    true\n"
"\n"
msgstr ""
"`term`がビット列（バイナリを含む）の場合は`true`を返します。\n"
"それ以外は`false`を返します。\n"
"\n"
"ガードテストに使えます。コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> is_bitstring \"foo\"\n"
"    true\n"
"    iex> is_bitstring <<1::3>>\n"
"    true\n"
"\n"

#. TRANSLATORS: defmacro Kernel.put_in(path, value)
#: lib/kernel.ex:1960
msgid ""
"Puts a value in a nested structure via the given `path`.\n"
"\n"
"This is similar to `put_in/3`, except the path is extracted via\n"
"a macro rather than passing a list. For example:\n"
"\n"
"    put_in(opts[:foo][:bar], :baz)\n"
"\n"
"Is equivalent to:\n"
"\n"
"    put_in(opts, [:foo, :bar], :baz)\n"
"\n"
"Note that in order for this macro to work, the complete path must always\n"
"be visible by this macro. For more information about the supported path\n"
"expressions, please check `get_and_update_in/2` docs.\n"
"\n"
"## Examples\n"
"\n"
"    iex> users = %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}\n"
"    iex> put_in(users[\"john\"][:age], 28)\n"
"    %{\"john\" => %{age: 28}, \"meg\" => %{age: 23}}\n"
"\n"
"    iex> users = %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}\n"
"    iex> put_in(users[\"john\"].age, 28)\n"
"    %{\"john\" => %{age: 28}, \"meg\" => %{age: 23}}\n"
"\n"
msgstr ""
"指定した`path`によりネストした構造に値を設定します。\n"
"\n"
"リストを渡してpathを指定するのではなく、マクロによってpathが\n"
"抽出されることを除いて、`put_in/3`と同じです。たとえば:\n"
"\n"
"    put_in(opts[:foo][:bar], :baz)\n"
"\n"
"は、以下と同じです。\n"
"\n"
"    put_in(opts, [:foo, :bar], :baz)\n"
"\n"
"このマクロが機能するためには、完全なパスが常にこのマクロに見えて\n"
"いなければならないことに注意してください。サポートされているパス式の\n"
"詳細は`get_and_update_in/2`のドキュメントをチェックしてください。\n"
"\n"
"## 例\n"
"\n"
"    iex> users = %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}\n"
"    iex> put_in(users[\"john\"][:age], 28)\n"
"    %{\"john\" => %{age: 28}, \"meg\" => %{age: 23}}\n"
"\n"
"    iex> users = %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}\n"
"    iex> put_in(users[\"john\"].age, 28)\n"
"    %{\"john\" => %{age: 28}, \"meg\" => %{age: 23}}\n"
"\n"

#. TRANSLATORS: defmacro Kernel.!(arg)
#: lib/kernel.ex:1319
msgid ""
"Boolean not.\n"
"\n"
"Receives any argument (not just booleans) and returns `true` if the "
"argument\n"
"is `false` or `nil`; returns `false` otherwise.\n"
"\n"
"Not allowed in guard clauses.\n"
"\n"
"## Examples\n"
"\n"
"    iex> !Enum.empty?([])\n"
"    false\n"
"\n"
"    iex> !List.first([])\n"
"    true\n"
"\n"
msgstr ""
"論理否定です。\n"
"\n"
"（ブール値だけでなく）任意の引数を受け取り、引数が`false`または`nil`の\n"
"場合は`true`を返します。それ以外は`false`を返します。\n"
"\n"
"ガード節では使用できません。\n"
"\n"
"## 例\n"
"\n"
"    iex> !Enum.empty?([])\n"
"    false\n"
"\n"
"    iex> !List.first([])\n"
"    true\n"
"\n"

#. TRANSLATORS: defmacro Kernel.get_and_update_in(path, fun)
#: lib/kernel.ex:2068
msgid ""
"Gets a value and updates a nested data structure via the given `path`.\n"
"\n"
"This is similar to `get_and_update_in/3`, except the path is extracted\n"
"via a macro rather than passing a list. For example:\n"
"\n"
"    get_and_update_in(opts[:foo][:bar], &{&1, &1 + 1})\n"
"\n"
"Is equivalent to:\n"
"\n"
"    get_and_update_in(opts, [:foo, :bar], &{&1, &1 + 1})\n"
"\n"
"Note that in order for this macro to work, the complete path must always\n"
"be visible by this macro. See the Paths section below.\n"
"\n"
"## Examples\n"
"\n"
"    iex> users = %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}\n"
"    iex> get_and_update_in(users[\"john\"].age, &{&1, &1 + 1})\n"
"    {27, %{\"john\" => %{age: 28}, \"meg\" => %{age: 23}}}\n"
"\n"
"## Paths\n"
"\n"
"A path may start with a variable, local or remote call, and must be\n"
"followed by one or more:\n"
"\n"
"  * `foo[bar]` - accesses the key `bar` in `foo`; in case `foo` is nil,\n"
"    `nil` is returned\n"
"\n"
"  * `foo.bar` - accesses a map/struct field; in case the field is not\n"
"    present, an error is raised\n"
"\n"
"Here are some valid paths:\n"
"\n"
"    users[\"john\"][:age]\n"
"    users[\"john\"].age\n"
"    User.all[\"john\"].age\n"
"    all_users()[\"john\"].age\n"
"\n"
"Here are some invalid ones:\n"
"\n"
"    # Does a remote call after the initial value\n"
"    users[\"john\"].do_something(arg1, arg2)\n"
"\n"
"    # Does not access any key or field\n"
"    users\n"
"\n"
msgstr ""
"指定した`path`を経由してネストしたデータ構造の値を取得・更新します。\n"
"\n"
"リストを渡して`path`を指定するのではなく、マクロによって`path`が\n"
"抽出されることを除いて、`get_and_update_in/3`と同じです。たとえば、\n"
"\n"
"    get_and_update_in(opts[:foo][:bar], &{&1, &1 + 1})\n"
"\n"
"は、以下と等しいです。\n"
"\n"
"    get_and_update_in(opts, [:foo, :bar], &{&1, &1 + 1})\n"
"\n"
"このマクロが機能するためには、完全なパスが常にこのマクロに見えて\n"
"いなければならないことに注意してください。以下の「パス」セクションを\n"
"参照してください。\n"
"\n"
"## 例\n"
"\n"
"    iex> users = %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}\n"
"    iex> get_and_update_in(users[\"john\"].age, &{&1, &1 + 1})\n"
"    {27, %{\"john\" => %{age: 28}, \"meg\" => %{age: 23}}}\n"
"\n"
"## パス\n"
"\n"
"パスは、変数またはローカルコール、リモートコールで始まり、以下が\n"
"一つ以上続かなければなりません:\n"
"\n"
"  * `foo[bar]` - `foo`内のキー`bar`をアクセスします。`foo`がnilの場合は、\n"
"    `nil`が返ります。\n"
"\n"
"  * `foo.bar` - マップまたは構造体のフィルドをアクセスします。\n"
"    フィールドが存在しない場合はエラーが発生します。\n"
"\n"
"以下は正しいパスです:\n"
"\n"
"    users[\"john\"][:age]\n"
"    users[\"john\"].age\n"
"    User.all[\"john\"].age\n"
"    all_users()[\"john\"].age\n"
"\n"
"以下は不正なパスです:\n"
"\n"
"    # 初期値の後でリモートコールをする\n"
"    users[\"john\"].do_something(arg1, arg2)\n"
"\n"
"    # キーやフィールドにまったくアクセスしない\n"
"    users\n"
"\n"

#. TRANSLATORS: def Kernel.rem(dividend, divisor)
#: lib/kernel.ex:575
msgid ""
"Computes the remainder of an integer division.\n"
"\n"
"`rem/2` uses truncated division, which means that\n"
"the result will always have the sign of the `dividend`.\n"
"\n"
"Raises an `ArithmeticError` exception if one of the arguments is not an\n"
"integer, or when the `divisor` is `0`.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> rem(5, 2)\n"
"    1\n"
"    iex> rem(6, -4)\n"
"    2\n"
"\n"
msgstr ""
"整数除算の余りを計算します。\n"
"\n"
"`rem/2`は切り捨て除算を使用します。これは結果は常に`dividend`の\n"
"符号を持つことを意味します。\n"
"\n"
"引数の1つが整数でない場合、または、`divisor`が`0`の場合は、\n"
"`ArithmeticError`例外を発生させます。\n"
"\n"
"ガードテストで使えます。コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> rem(5, 2)\n"
"    1\n"
"    iex> rem(6, -4)\n"
"    2\n"
"\n"

#. TRANSLATORS: def Kernel.+(value)
#: lib/kernel.ex:895
msgid ""
"Arithmetic unary plus.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> +1\n"
"    1\n"
"\n"
msgstr ""
"算術的単項プラスです。\n"
"\n"
"ガードテストで使えます。コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> +1\n"
"    1\n"
"\n"

#. TRANSLATORS: def Kernel.is_binary(term)
#: lib/kernel.ex:289
msgid ""
"Returns `true` if `term` is a binary; otherwise returns `false`.\n"
"\n"
"A binary always contains a complete number of bytes.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> is_binary \"foo\"\n"
"    true\n"
"    iex> is_binary <<1::3>>\n"
"    false\n"
"\n"
msgstr ""
"`term`がバイナリの場合`true`を返します。それ以外は`false`を返します。\n"
"\n"
"バイナリは常に完全な数のバイトを含みます。\n"
"\n"
"ガードテストに使えます。コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> is_binary \"foo\"\n"
"    true\n"
"    iex> is_binary <<1::3>>\n"
"    false\n"
"\n"

#. TRANSLATORS: defmacro Kernel.defstruct(fields)
#: lib/kernel.ex:3450
msgid ""
"Defines a struct.\n"
"\n"
"A struct is a tagged map that allows developers to provide\n"
"default values for keys, tags to be used in polymorphic\n"
"dispatches and compile time assertions.\n"
"\n"
"To define a struct, a developer must define both `__struct__/0` and\n"
"`__struct__/1` functions. `defstruct/1` is a convenience macro which\n"
"defines such functions with some conveniences.\n"
"\n"
"For more information about structs, please check `Kernel.SpecialForms.%/2`.\n"
"\n"
"## Examples\n"
"\n"
"    defmodule User do\n"
"      defstruct name: nil, age: nil\n"
"    end\n"
"\n"
"Struct fields are evaluated at compile-time, which allows\n"
"them to be dynamic. In the example below, `10 + 11` is\n"
"evaluated at compile-time and the age field is stored\n"
"with value `21`:\n"
"\n"
"    defmodule User do\n"
"      defstruct name: nil, age: 10 + 11\n"
"    end\n"
"\n"
"The `fields` argument is usually a keyword list with field names\n"
"as atom keys and default values as corresponding values. `defstruct/1`\n"
"also supports a list of atoms as its argument: in that case, the atoms\n"
"in the list will be used as the struct's field names and they will all\n"
"default to `nil`.\n"
"\n"
"    defmodule Post do\n"
"      defstruct [:title, :content, :author]\n"
"    end\n"
"\n"
"## Deriving\n"
"\n"
"Although structs are maps, by default structs do not implement\n"
"any of the protocols implemented for maps. For example, attempting\n"
"to use a protocol with the `User` struct leads to an error:\n"
"\n"
"    john = %User{name: \"John\"}\n"
"    MyProtocol.call(john)\n"
"    ** (Protocol.UndefinedError) protocol MyProtocol not implemented for "
"%User{...}\n"
"\n"
"`defstruct/1`, however, allows protocol implementations to be\n"
"*derived*. This can be done by defining a `@derive` attribute as a\n"
"list before invoking `defstruct/1`:\n"
"\n"
"    defmodule User do\n"
"      @derive [MyProtocol]\n"
"      defstruct name: nil, age: 10 + 11\n"
"    end\n"
"\n"
"    MyProtocol.call(john) #=> works\n"
"\n"
"For each protocol in the `@derive` list, Elixir will assert there is an\n"
"implementation of that protocol for any (regardless if fallback to any\n"
"is `true`) and check if the any implementation defines a `__deriving__/3`\n"
"callback. If so, the callback is invoked, otherwise an implementation\n"
"that simply points to the any implementation is automatically derived.\n"
"\n"
"## Enforcing keys\n"
"\n"
"When building a struct, Elixir will automatically guarantee all keys\n"
"belongs to the struct:\n"
"\n"
"    %User{name: \"john\", unknown: :key}\n"
"    ** (KeyError) key :unknown not found in: %User{age: 21, name: nil}\n"
"\n"
"Elixir also allows developers to enforce certain keys must always be\n"
"given when building the struct:\n"
"\n"
"    defmodule User do\n"
"      @enforce_keys [:name]\n"
"      defstruct name: nil, age: 10 + 11\n"
"    end\n"
"\n"
"Now trying to build a struct without the name key will fail:\n"
"\n"
"    %User{age: 21}\n"
"    ** (ArgumentError) the following keys must also be given when building "
"struct User: [:name]\n"
"\n"
"Keep in mind `@enforce_keys` is a simple compile-time guarantee\n"
"to aid developers when building structs. It is not enforced on\n"
"updates and it does not provide any sort of value-validation.\n"
"\n"
"## Types\n"
"\n"
"It is recommended to define types for structs. By convention such type\n"
"is called `t`. To define a struct inside a type, the struct literal syntax\n"
"is used:\n"
"\n"
"    defmodule User do\n"
"      defstruct name: \"John\", age: 25\n"
"      @type t :: %User{name: String.t, age: non_neg_integer}\n"
"    end\n"
"\n"
"It is recommended to only use the struct syntax when defining the struct's\n"
"type. When referring to another struct it's better to use `User.t` instead "
"of\n"
"`%User{}`.\n"
"\n"
"The types of the struct fields that are not included in `%User{}` default "
"to\n"
"`term`.\n"
"\n"
"Structs whose internal structure is private to the local module (pattern\n"
"matching them or directly accessing their fields should not be allowed) "
"should\n"
"use the `@opaque` attribute. Structs whose internal structure is public "
"should\n"
"use `@type`.\n"
msgstr ""
"構造体を定義します。\n"
"\n"
"構造体はタグ付けされたマップであり、キーのデフォルト値、\n"
"ポリモーフィックディスパッチに使われるタグ、コンパイル時\n"
"アサーションを提供可能にします。\n"
"\n"
"構造体を定義するには、`__struct__/0`と`__struct__/1`の両関数を\n"
"定義する必要があります。`defstruct/1`はそのような関数をいくらか\n"
"便利に定義する便利なマクロです。\n"
"\n"
"構造体に関する詳細は、`Kernel.SpecialForms.%/2`をチェックしてください。\n"
"\n"
"## 例\n"
"\n"
"    defmodule User do\n"
"      defstruct name: nil, age: nil\n"
"    end\n"
"\n"
"構造体のフィールドはコンパイル時に評価されます。そのため、\n"
"フィールドを動的に定義できます。以下の例では、`10 + 11`が\n"
"コンパイル時に評価され、ageフィールドには値`21`が格納されます。\n"
"\n"
"    defmodule User do\n"
"      defstruct name: nil, age: 10 + 11\n"
"    end\n"
"\n"
"`fields`引数は通常、フィールド名をアトムキーとして、デフォルト値を対応する\n"
"値として持つキーワードリストです。`defstruct/1`は、引数としてアトムの\n"
"リストもサポートしています。この場合、リスト中のアトムは構造体の\n"
"フィールド名として使用され、すべてのデフォルト値は`nil`となります。\n"
"\n"
"    defmodule Post do\n"
"      defstruct [:title, :content, :author]\n"
"    end\n"
"\n"
"## 導出\n"
"\n"
"構造体はマップですが、デフォルトでは、構造体はマップが\n"
"実装しているプロトコルを何一つ実装していません。たとえば、\n"
"`User`構造体で何かプロトコルを使おうとすると、エラーになります。\n"
"\n"
"    john = %User{name: \"John\"}\n"
"    MyProtocol.call(john)\n"
"    ** (Protocol.UndefinedError) protocol MyProtocol not implemented for "
"%User{...}\n"
"\n"
"しかし、`defstruct/1`はプロトコル実装を*導出* させることができます。\n"
"これは、`defstruct/1`を起動する前に`@derive`属性をリストとして定義する\n"
"ことにより行うことができます。\n"
"\n"
"    defmodule User do\n"
"      @derive [MyProtocol]\n"
"      defstruct name: nil, age: 10 + 11\n"
"    end\n"
"\n"
"    MyProtocol.call(john) #=> 動く\n"
"\n"
"`@derive`リストの各プロトコルについて、Elixirは（Anyへのフォールバックが\n"
"`true`であるか否かにかかわらず）Anyに対するそのプロトコルの実装が存在すると\n"
"アサートし、そのAny実装が`__deriving__/3`コールバックを定義しているか否かを\n"
"チェックします。定義されていれば、そのコールバックが呼び出され、そうでない場"
"合は、\n"
"単にAny実装を指す実装が自動的に導出されます。\n"
"\n"
"## キーの強制\n"
"\n"
"構造体を構築する際、Elixirはすべてのキーがその構造体に属することを自動的に\n"
"保証します。\n"
"\n"
"    %User{name: \"john\", unknown: :key}\n"
"    ** (KeyError) key :unknown not found in: %User{age: 21, name: nil}\n"
"\n"
"Elixirは構造体を構築する際に、特定のキーが常に指定されるよう強制することが\n"
"できます。\n"
"\n"
"    defmodule User do\n"
"      @enforce_keys [:name]\n"
"      defstruct name: nil, age: 10 + 11\n"
"    end\n"
"\n"
"これで、nameキーなしに構造体を構築しようとすると失敗するようになります。\n"
"\n"
"    %User{age: 21}\n"
"    ** (ArgumentError) the following keys must also be given when building "
"struct User: [:name]\n"
"\n"
"`@enforce_keys`は構造体の構築時に開発者を助ける単なるコンパイル時の保証で\n"
"あることに留意してください。更新時には強制されませんし、いかなる種類の\n"
"値の検証も提供しません。\n"
"\n"
"## 型\n"
"\n"
"構造体の型を定義することが推奨されています。慣例により、このようなタイプは\n"
"`t`と呼ばれています。型内で構造体を定義するために、構造体リテラル構文が\n"
"使われます。\n"
"\n"
"    defmodule User do\n"
"      defstruct name: \"john\", age: 25\n"
"      @type t :: %User{name: String.t, age: integer}\n"
"    end\n"
"\n"
"構造体の型を定義する際には構造構文のみを使用することが推奨されています。\n"
"別の構造体を参照する場合は、`%User{}`ではなく、`User.t`を使ってください。\n"
"\n"
" `%User{}`に含まれていない構造体フィールドの型はデフォルトで`term`になりま"
"す。\n"
"\n"
"内部構造がローカルモジュールに対してプライベートである構造体（パターンマッチ"
"や\n"
"フィールドへの直接アクセスが許されない）は`@opaque`属性を使うべきです。\n"
"内部構造がパブリックである構造体は`@type`を使うべきです。\n"

#. TRANSLATORS: def Kernel.spawn_monitor(fun)
#: lib/kernel.ex:743
msgid ""
"Spawns the given function, monitors it and returns its PID\n"
"and monitoring reference.\n"
"\n"
"Check the `Process` and `Node` modules for other functions\n"
"to handle processes, including spawning functions in nodes.\n"
"\n"
"The anonymous function receives 0 arguments, and may return any value.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    current = self()\n"
"    spawn_monitor(fn -> send current, {self(), 1 + 2} end)\n"
"\n"
msgstr ""
"指定した関数を生成し、それをモニターし、そのPIDとモニターのリファレンスを\n"
"返します。\n"
"\n"
"別のノードでの関数の生成を含む、プロセスを扱うその他の関数に\n"
"ついては`Process`モジュールと`Node`モジュールをチェックしてください。\n"
"\n"
"無名関数は0個の引数を受け取り、任意の値を返すことができます。\n"
"\n"
"コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    current = self()\n"
"    spawn_monitor(fn -> send current, {self(), 1 + 2} end)\n"
"\n"

#. TRANSLATORS: def Kernel.spawn_link(fun)
#: lib/kernel.ex:699
msgid ""
"Spawns the given function, links it to the current process and returns its "
"PID.\n"
"\n"
"Check the `Process` and `Node` modules for other functions\n"
"to handle processes, including spawning functions in nodes.\n"
"\n"
"The anonymous function receives 0 arguments, and may return any value.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    current = self()\n"
"    child   = spawn_link(fn -> send current, {self(), 1 + 2} end)\n"
"\n"
"    receive do\n"
"      {^child, 3} -> IO.puts \"Received 3 back\"\n"
"    end\n"
"\n"
msgstr ""
"指定した関数を生成し、それを現在のプロセスにリンクして、\n"
"そのPIDを返します。\n"
"\n"
"別のノードでの関数の生成を含む、プロセスを扱うその他の関数に\n"
"ついては`Process`モジュールと`Node`モジュールをチェックしてください。\n"
"\n"
"無名関数は0個の引数を受け取り、任意の値を返すことができます。\n"
"\n"
"コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    current = self()\n"
"    child   = spawn_link(fn -> send current, {self(), 1 + 2} end)\n"
"\n"
"    receive do\n"
"      {^child, 3} -> IO.puts \"Received 3 back\"\n"
"    end\n"
"\n"

#. TRANSLATORS: def Kernel.++(left, right)
#: lib/kernel.ex:979
msgid ""
"Concatenates a proper list and a term, returning a list.\n"
"\n"
"The complexity of `a ++ b` is proportional to `length(a)`, so avoid "
"repeatedly\n"
"appending to lists of arbitrary length, e.g. `list ++ [item]`.\n"
"Instead, consider prepending via `[item | rest]` and then reversing.\n"
"\n"
"If the `right` operand is not a proper list, it returns an improper list.\n"
"If the `left` operand is not a proper list, it raises `ArgumentError`.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> [1] ++ [2, 3]\n"
"    [1, 2, 3]\n"
"\n"
"    iex> 'foo' ++ 'bar'\n"
"    'foobar'\n"
"\n"
"    # returns an improper list\n"
"    iex> [1] ++ 2\n"
"    [1 | 2]\n"
"\n"
"    # returns a proper list\n"
"    iex> [1] ++ [2]\n"
"    [1, 2]\n"
"\n"
"    # improper list on the right will return an improper list\n"
"    iex> [1] ++ [2 | 3]\n"
"    [1, 2 | 3]\n"
"\n"
msgstr ""
"正しいリストと項を連結してリストを返します。\n"
"\n"
"`a ++ b`の計算量は`length(a)`に比例します。したがって、\n"
"`list ++ [item]`のように、任意の長さのリストの後に繰返し追加することは\n"
"を避けてください。代わりに、`[item | rest]`により先頭に追加して、\n"
"最後に反転する方法を検討してください。\n"
"\n"
"`right`オペランドが正しいリストでない場合、不適切なリストを返します。\n"
"`left`オペランドが正しいリストでない場合、`ArgumentError`を発生させます。\n"
"\n"
"コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> [1] ++ [2, 3]\n"
"    [1, 2, 3]\n"
"\n"
"    iex> 'foo' ++ 'bar'\n"
"    'foobar'\n"
"\n"
"    # 不適切なリストを返す\n"
"    iex> [1] ++ 2\n"
"    [1 | 2]\n"
"\n"
"    # 正しいリストを返す\n"
"    iex> [1] ++ [2]\n"
"    [1, 2]\n"
"\n"
"    # 右オペランドの不適切なリストは不適切なリストを返す\n"
"    iex> [1] ++ [2 | 3]\n"
"    [1, 2 | 3]\n"
"\n"

#. TRANSLATORS: def Kernel.is_atom(term)
#: lib/kernel.ex:279
msgid ""
"Returns `true` if `term` is an atom; otherwise returns `false`.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
msgstr ""
"`term`がアトムの場合は`true`を返します。それ以外は`false`を返します。\n"
"\n"
"ガードテストに使えます。コンパイラによりインライン化されます。\n"

#. TRANSLATORS: def Kernel.!==(left, right)
#: lib/kernel.ex:1207
msgid ""
"Returns `true` if the two items are not exactly equal.\n"
"\n"
"All terms in Elixir can be compared with each other.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> 1 !== 2\n"
"    true\n"
"\n"
"    iex> 1 !== 1.0\n"
"    true\n"
"\n"
msgstr ""
"2つの項目が一致しない場合、`true`を返します。\n"
"\n"
"Elixirのすべての項は互いに比較加能です。\n"
"\n"
"ガードテストに使えます。コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> 1 !== 2\n"
"    true\n"
"\n"
"    iex> 1 !== 1.0\n"
"    true\n"
"\n"

#. TRANSLATORS: def Kernel.is_function(term)
#: lib/kernel.ex:348
msgid ""
"Returns `true` if `term` is a function; otherwise returns `false`.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
msgstr ""
"`term`が関数の場合は`true`を返します。それ以外は`false`を返します。\n"
"\n"
"ガードテストに使えます。コンパイラによりインライン化されます。\n"

#. TRANSLATORS: def Kernel.macro_exported?(module, macro, arity)
#: lib/kernel.ex:2880
msgid ""
"Returns `true` if `module` is loaded and contains a\n"
"public `macro` with the given `arity`, otherwise `false`.\n"
"\n"
"Note that this function does not load the module in case\n"
"it is not loaded. Check `Code.ensure_loaded/1` for more\n"
"information.\n"
"\n"
"If `module` is an Erlang module (as opposed to an Elixir module), this\n"
"function always returns `false`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> macro_exported?(Kernel, :use, 2)\n"
"    true\n"
"\n"
"    iex> macro_exported?(:erlang, :abs, 1)\n"
"    false\n"
"\n"
msgstr ""
"`module`がロードされており、指定した`arity`の公開`macro`が\n"
"含まれている場合は`true`を返し、それ以外は`false`を返します。\n"
"\n"
"この関数は、モジュールがロードされていない場合、ロードを\n"
"しないことに注意してください。詳細は`Code.ensure_loaded/1`を\n"
"チェックしてください。\n"
"\n"
"`module`が（Elixirのモジュールでなく）Erlangのモジュールの場合、\n"
"この関数は常に`false`を返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> macro_exported?(Kernel, :use, 2)\n"
"    true\n"
"\n"
"    iex> macro_exported?(:erlang, :abs, 1)\n"
"    false\n"
"\n"

#. TRANSLATORS: def Kernel.node()
#: lib/kernel.ex:552
msgid ""
"Returns an atom representing the name of the local node.\n"
"If the node is not alive, `:nonode@nohost` is returned instead.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
msgstr ""
"ローカルノードの名前を表すアトムを返します。\n"
"ノードが生きていない場合は代わりに`:nonode@nohost`が返されます。\n"
"\n"
"ガードテストに使えます。コンパイラによりインライン化されます。\n"

#. TRANSLATORS: def Kernel.>(left, right)
#: lib/kernel.ex:1079
msgid ""
"Returns `true` if left is more than right.\n"
"\n"
"All terms in Elixir can be compared with each other.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> 1 > 2\n"
"    false\n"
"\n"
msgstr ""
"左オペランドが右オペランドより大きい場合、`true`を返します。\n"
"\n"
"Elixirのすべての項は互いに比較加能です。\n"
"\n"
"ガードの中のテストに使えます。コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> 1 > 2\n"
"    false\n"
"\n"

#. TRANSLATORS: defmacro Kernel.@(expr)
#: lib/kernel.ex:2333
msgid ""
"Reads and writes attributes of the current module.\n"
"\n"
"The canonical example for attributes is annotating that a module\n"
"implements the OTP behaviour called `gen_server`:\n"
"\n"
"    defmodule MyServer do\n"
"      @behaviour :gen_server\n"
"      # ... callbacks ...\n"
"    end\n"
"\n"
"By default Elixir supports all the module attributes supported by Erlang, "
"but\n"
"custom attributes can be used as well:\n"
"\n"
"    defmodule MyServer do\n"
"      @my_data 13\n"
"      IO.inspect @my_data #=> 13\n"
"    end\n"
"\n"
"Unlike Erlang, such attributes are not stored in the module by default "
"since\n"
"it is common in Elixir to use custom attributes to store temporary data "
"that\n"
"will be available at compile-time. Custom attributes may be configured to\n"
"behave closer to Erlang by using `Module.register_attribute/3`.\n"
"\n"
"Finally, notice that attributes can also be read inside functions:\n"
"\n"
"    defmodule MyServer do\n"
"      @my_data 11\n"
"      def first_data, do: @my_data\n"
"      @my_data 13\n"
"      def second_data, do: @my_data\n"
"    end\n"
"\n"
"    MyServer.first_data #=> 11\n"
"    MyServer.second_data #=> 13\n"
"\n"
"It is important to note that reading an attribute takes a snapshot of\n"
"its current value. In other words, the value is read at compilation\n"
"time and not at runtime. Check the `Module` module for other functions\n"
"to manipulate module attributes.\n"
msgstr ""
"現在のモジュールの属性を読み書きします。\n"
"\n"
"属性の標準的な例は、モジュールが`gen_server`という\n"
"OTPビヘイビアを実装しているという注釈をすることです:\n"
"\n"
"    defmodule MyServer do\n"
"      @behaviour :gen_server\n"
"      # ... callbacks ...\n"
"    end\n"
"\n"
"ElixirはデフォルトでErlangがサポートしているすべてのモジュール属性を\n"
"サポートしており、さらに、カスタム属性も使用することができます。\n"
"\n"
"    defmodule MyServer do\n"
"      @my_data 13\n"
"      IO.inspect @my_data #=> 13\n"
"    end\n"
"\n"
"Erlangとは異なり、そのような属性はデフォルトではモジュールに格納されませ"
"ん。\n"
"Elixirではカスタム属性はコンパイル時に利用する一時的なデータを格納する目的"
"で\n"
"使われるのが一般的だからです。`Module.register_attribute/3`を使用することによ"
"り\n"
"Erlangに似たふるまいにカスタム属性を構成することができます。\n"
"\n"
"最後に、属性は関数内でも読むことができることに注意してください:\n"
"\n"
"    defmodule MyServer do\n"
"      @my_data 11\n"
"      def first_data, do: @my_data\n"
"      @my_data 13\n"
"      def second_data, do: @my_data\n"
"    end\n"
"\n"
"    MyServer.first_data #=> 11\n"
"    MyServer.second_data #=> 13\n"
"\n"
"属性を読むことは、現在値のスナップショットを取ることである\n"
"点に注意することが重要です。言い替えると、値はコンパイル時に読まれるものであ"
"り、\n"
"実行時に読まれるものではありません。モジュール属性を操作する他の関数について"
"は、\n"
"`Module`モジュールをチェックしてください。\n"

#. TRANSLATORS: defmacro Kernel.sigil_W(term, modifiers)
#: lib/kernel.ex:4368
msgid ""
"Handles the sigil `~W`.\n"
"\n"
"It returns a list of \"words\" split by whitespace without escaping nor\n"
"interpreting interpolations.\n"
"\n"
"## Modifiers\n"
"\n"
"  * `s`: words in the list are strings (default)\n"
"  * `a`: words in the list are atoms\n"
"  * `c`: words in the list are charlists\n"
"\n"
"## Examples\n"
"\n"
"    iex> ~W(foo #{bar} baz)\n"
"    [\"foo\", \"\\#{bar}\", \"baz\"]\n"
"\n"
msgstr ""
"シジル`~W`を処理します。\n"
"\n"
"文字のエスケープや式の埋め込みをすることなく、\n"
"ホワイトスペースにより分割した\"words\"のリストを返します。\n"
"\n"
"## モディファイア\n"
"\n"
"  * `s`: リストのワードは文字列 (デフォルト)\n"
"  * `a`: リストのワードはアトム\n"
"  * `c`: リストのワードは文字のリスト\n"
"\n"
"## 例\n"
"\n"
"    iex> ~W(foo #{bar} baz)\n"
"    [\"foo\", \"\\#{bar}\", \"baz\"]\n"
"\n"

#. TRANSLATORS: def Kernel.trunc(number)
#: lib/kernel.ex:816
msgid ""
"Returns the integer part of `number`.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> trunc(5.4)\n"
"    5\n"
"\n"
"    iex> trunc(-5.99)\n"
"    -5\n"
"\n"
"    iex> trunc(-5)\n"
"    -5\n"
"\n"
msgstr ""
"`number`の整数部分を返します。\n"
"\n"
"ガードテストに使えます。コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> trunc(5.4)\n"
"    5\n"
"\n"
"    iex> trunc(-5.99)\n"
"    -5\n"
"\n"
"    iex> trunc(-5)\n"
"    -5\n"
"\n"

#. TRANSLATORS: defmacro Kernel.||(left, right)
#: lib/kernel.ex:2736
msgid ""
"Provides a short-circuit operator that evaluates and returns the second\n"
"expression only if the first one does not evaluate to `true` (i.e., it\n"
"is either `nil` or `false`). Returns the first expression otherwise.\n"
"\n"
"Not allowed in guard clauses.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.empty?([1]) || Enum.empty?([1])\n"
"    false\n"
"\n"
"    iex> List.first([]) || true\n"
"    true\n"
"\n"
"    iex> Enum.empty?([1]) || 1\n"
"    1\n"
"\n"
"    iex> Enum.empty?([]) || throw(:bad)\n"
"    true\n"
"\n"
"Note that, unlike `or/2`, this operator accepts any expression\n"
"as the first argument, not only booleans.\n"
msgstr ""
"最初の式が`true`（すなわち、`nil`でも`false`でもない）と評価されない場合にの"
"み\n"
"2番目の式を評価して返す短絡演算子を提供します。それ以外は、最初の式を\n"
"返します。\n"
"\n"
"ガードの中では使えません。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.empty?([1]) || Enum.empty?([1])\n"
"    false\n"
"\n"
"    iex> List.first([]) || true\n"
"    true\n"
"\n"
"    iex> Enum.empty?([1]) || 1\n"
"    1\n"
"\n"
"    iex> Enum.empty?([]) || throw(:bad)\n"
"    true\n"
"\n"
"`or/2`演算子とは異なり、この演算子は第1引数として\n"
"論理値だけでなく任意の式を受け付けることに注意してください。\n"

#. TRANSLATORS: defmacro Kernel.sigil_T(date, modifiers)
#: lib/kernel.ex:4293
msgid ""
"Handles the sigil `~T` for times.\n"
"\n"
"The lower case `~t` variant does not exist as interpolation\n"
"and escape characters are not useful for time sigils.\n"
"\n"
"## Examples\n"
"\n"
"    iex> ~T[13:00:07]\n"
"    ~T[13:00:07]\n"
"    iex> ~T[13:00:07.001]\n"
"    ~T[13:00:07.001]\n"
"\n"
msgstr ""
"時間を表すシジル`~T`を処理します。\n"
"\n"
"式の埋め込みや文字のエスケープは時間シギルには役に立ちませんので、\n"
"小文字のシジル`~t`はありません。\n"
"\n"
"## 例\n"
"\n"
"    iex> ~T[13:00:07]\n"
"    ~T[13:00:07]\n"
"    iex> ~T[13:00:07.001]\n"
"    ~T[13:00:07.001]\n"
"\n"

#. TRANSLATORS: def Kernel.inspect(arg, opts \\ [])
#: lib/kernel.ex:1590
msgid ""
"Inspects the given argument according to the `Inspect` protocol.\n"
"The second argument is a keyword list with options to control\n"
"inspection.\n"
"\n"
"## Options\n"
"\n"
"`inspect/2` accepts a list of options that are internally\n"
"translated to an `Inspect.Opts` struct. Check the docs for\n"
"`Inspect.Opts` to see the supported options.\n"
"\n"
"## Examples\n"
"\n"
"    iex> inspect(:foo)\n"
"    \":foo\"\n"
"\n"
"    iex> inspect [1, 2, 3, 4, 5], limit: 3\n"
"    \"[1, 2, 3, ...]\"\n"
"\n"
"    iex> inspect [1, 2, 3], pretty: true, width: 0\n"
"    \"[1,\\n 2,\\n 3]\"\n"
"\n"
"    iex> inspect(\"olá\" <> <<0>>)\n"
"    \"<<111, 108, 195, 161, 0>>\"\n"
"\n"
"    iex> inspect(\"olá\" <> <<0>>, binaries: :as_strings)\n"
"    \"\\\"olá\\\\0\\\"\"\n"
"\n"
"    iex> inspect(\"olá\", binaries: :as_binaries)\n"
"    \"<<111, 108, 195, 161>>\"\n"
"\n"
"    iex> inspect('bar')\n"
"    \"'bar'\"\n"
"\n"
"    iex> inspect([0 | 'bar'])\n"
"    \"[0, 98, 97, 114]\"\n"
"\n"
"    iex> inspect(100, base: :octal)\n"
"    \"0o144\"\n"
"\n"
"    iex> inspect(100, base: :hex)\n"
"    \"0x64\"\n"
"\n"
"Note that the `Inspect` protocol does not necessarily return a valid\n"
"representation of an Elixir term. In such cases, the inspected result\n"
"must start with `#`. For example, inspecting a function will return:\n"
"\n"
"    inspect fn a, b -> a + b end\n"
"    #=> #Function<...>\n"
"\n"
msgstr ""
"`Inspect`プロトコルに従って指定した引数をインスペクションします。\n"
"2番目の引数はキーワードリストで、インスペクションを制御するオプションです。\n"
"\n"
"## オプション\n"
"\n"
"`inspect/2`はオプションのリストを受け付け、内部では`Inspect.Opts`構造体に\n"
"変換されます。サポートするオプションについては`Inspect.Opts`のドキュメント"
"を\n"
"チェックしてください。\n"
"\n"
"## 例\n"
"\n"
"    iex> inspect(:foo)\n"
"    \":foo\"\n"
"\n"
"    iex> inspect [1, 2, 3, 4, 5], limit: 3\n"
"    \"[1, 2, 3, ...]\"\n"
"\n"
"    iex> inspect [1, 2, 3], pretty: true, width: 0\n"
"    \"[1,\\n 2,\\n 3]\"\n"
"\n"
"    iex> inspect(\"olá\" <> <<0>>)\n"
"    \"<<111, 108, 195, 161, 0>>\"\n"
"\n"
"    iex> inspect(\"olá\" <> <<0>>, binaries: :as_strings)\n"
"    \"\\\"olá\\\\0\\\"\"\n"
"\n"
"    iex> inspect(\"olá\", binaries: :as_binaries)\n"
"    \"<<111, 108, 195, 161>>\"\n"
"\n"
"    iex> inspect('bar')\n"
"    \"'bar'\"\n"
"\n"
"    iex> inspect([0 | 'bar'])\n"
"    \"[0, 98, 97, 114]\"\n"
"\n"
"    iex> inspect(100, base: :octal)\n"
"    \"0o144\"\n"
"\n"
"    iex> inspect(100, base: :hex)\n"
"    \"0x64\"\n"
"\n"
"`Inspect`プロトコルは、必ずしもElixirの項として妥当な表現を返す\n"
"わけではないことに注意してください。そのような場合、インスペクション\n"
"された結果は、必ず’#’で始まります。たとえば、関数をインスペクションすると\n"
"以下のように返されます:\n"
"\n"
"    inspect fn a, b -> a + b end\n"
"    #=> #Function<...>\n"
"\n"

#. TRANSLATORS: def Kernel.struct(struct, kv \\ [])
#: lib/kernel.ex:1653
msgid ""
"Creates and updates structs.\n"
"\n"
"The `struct` argument may be an atom (which defines `defstruct`)\n"
"or a `struct` itself. The second argument is any `Enumerable` that\n"
"emits two-element tuples (key-value pairs) during enumeration.\n"
"\n"
"Keys in the `Enumerable` that don't exist in the struct are automatically\n"
"discarded. Note that keys must be atoms, as only atoms are allowed when\n"
"defining a struct.\n"
"\n"
"This function is useful for dynamically creating and updating structs, as\n"
"well as for converting maps to structs; in the latter case, just inserting\n"
"the appropriate `:__struct__` field into the map may not be enough and\n"
"`struct/2` should be used instead.\n"
"\n"
"## Examples\n"
"\n"
"    defmodule User do\n"
"      defstruct name: \"john\"\n"
"    end\n"
"\n"
"    struct(User)\n"
"    #=> %User{name: \"john\"}\n"
"\n"
"    opts = [name: \"meg\"]\n"
"    user = struct(User, opts)\n"
"    #=> %User{name: \"meg\"}\n"
"\n"
"    struct(user, unknown: \"value\")\n"
"    #=> %User{name: \"meg\"}\n"
"\n"
"    struct(User, %{name: \"meg\"})\n"
"    #=> %User{name: \"meg\"}\n"
"\n"
"    # String keys are ignored\n"
"    struct(User, %{\"name\" => \"meg\"})\n"
"    #=> %User{name: \"john\"}\n"
"\n"
msgstr ""
"構造体の作成と更新を行います。\n"
"\n"
"`struct`引数には、（`defstruct`を定義する）アトムか`struct`自身を指定できま"
"す。\n"
"第2引数は、列挙のあいだ2要素タプル（key-valueペア）を発行する任意の\n"
"`Enumerable`です。\n"
"\n"
"構造体に存在しない`Enumerable`のキーは自動的に捨てられます。\n"
"キーはアトムでなければなりません。構造体を定義する際にはアトムしか\n"
"許されないからです。\n"
"\n"
"この関数は、動的に構造体を作成・更新する場合や、マップを構造体に変換する\n"
"場合に便利です。後者の場合、単に`:__struct__`フィールドをマップに挿入する\n"
"だけでは不十分であり、代わりに`struct/2`を使用するべきです。\n"
"\n"
"## 例\n"
"\n"
"    defmodule User do\n"
"      defstruct name: \"john\"\n"
"    end\n"
"\n"
"    struct(User)\n"
"    #=> %User{name: \"john\"}\n"
"\n"
"    opts = [name: \"meg\"]\n"
"    user = struct(User, opts)\n"
"    #=> %User{name: \"meg\"}\n"
"\n"
"    struct(user, unknown: \"value\")\n"
"    #=> %User{name: \"meg\"}\n"
"\n"
"    struct(User, %{name: \"meg\"})\n"
"    #=> %User{name: \"meg\"}\n"
"\n"
"    # 文字列のキーは無視される\n"
"    struct(User, %{\"name\" => \"meg\"})\n"
"    #=> %User{name: \"john\"}\n"
"\n"

#. TRANSLATORS: def Kernel.spawn(fun)
#: lib/kernel.ex:655
msgid ""
"Spawns the given function and returns its PID.\n"
"\n"
"Check the `Process` and `Node` modules for other functions\n"
"to handle processes, including spawning functions in nodes.\n"
"\n"
"The anonymous function receives 0 arguments, and may return any value.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    current = self()\n"
"    child   = spawn(fn -> send current, {self(), 1 + 2} end)\n"
"\n"
"    receive do\n"
"      {^child, 3} -> IO.puts \"Received 3 back\"\n"
"    end\n"
"\n"
msgstr ""
"指定した関数を生成し、そのPIDを返します。\n"
"\n"
"別のノードでの関数の生成を含む、プロセスを扱うその他の関数に\n"
"ついては`Process`モジュールと`Node`モジュールをチェックしてください。\n"
"\n"
"無名関数は0個の引数を受け取り、任意の値を返すことができます。\n"
"\n"
"コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    current = self()\n"
"    child   = spawn(fn -> send current, {self(), 1 + 2} end)\n"
"\n"
"    receive do\n"
"      {^child, 3} -> IO.puts \"Received 3 back\"\n"
"    end\n"
"\n"

#. TRANSLATORS: defmacro Kernel.in(left, right)
#: lib/kernel.ex:2908
msgid ""
"Checks if the element on the left-hand side is a member of the\n"
"collection on the right-hand side.\n"
"\n"
"## Examples\n"
"\n"
"    iex> x = 1\n"
"    iex> x in [1, 2, 3]\n"
"    true\n"
"\n"
"This operator (which is a macro) simply translates to a call to\n"
"`Enum.member?/2`. The example above would translate to:\n"
"\n"
"    Enum.member?([1, 2, 3], x)\n"
"\n"
"## Guards\n"
"\n"
"The `in/2` operator can be used in guard clauses as long as the\n"
"right-hand side is a range or a list. In such cases, Elixir will expand the\n"
"operator to a valid guard expression. For example:\n"
"\n"
"    when x in [1, 2, 3]\n"
"\n"
"translates to:\n"
"\n"
"    when x === 1 or x === 2 or x === 3\n"
"\n"
"When using ranges:\n"
"\n"
"    when x in 1..3\n"
"\n"
"translates to:\n"
"\n"
"    when x >= 1 and x <= 3\n"
"\n"
msgstr ""
"左辺の要素が、右辺のコレクションのメンバであるか否かを\n"
"チェックします。\n"
"\n"
"## 例\n"
"\n"
"    iex> x = 1\n"
"    iex> x in [1, 2, 3]\n"
"    true\n"
"\n"
"この演算子（マクロです）は`Enum.member?/2`の呼出しに\n"
"翻訳するだけです。上の例は、次のように翻訳されます:\n"
"\n"
"    Enum.member?([1,2,3], x)\n"
"\n"
"## ガード\n"
"\n"
"`in/2`オペレータは、右辺が範囲またはリストであれば、ガード節で\n"
"使うことができます。この場合、Elixirはこのオペレータを正しいガード式に\n"
"展開します。たとえば\n"
"\n"
"    when x in [1,2,3]\n"
"\n"
"は、以下のように展開します。\n"
"\n"
"    when x === 1 or x === 2 or x === 3\n"
"\n"
"範囲を使った場合\n"
"\n"
"    when x in 1..3\n"
"\n"
"は、以下のように展開します:\n"
"\n"
"    when x >= 1 and x <= 3\n"
"\n"

#. TRANSLATORS: defmacro Kernel.match?(pattern, expr)
#: lib/kernel.ex:2277
msgid ""
"A convenience macro that checks if the right side (an expression) matches "
"the\n"
"left side (a pattern).\n"
"\n"
"## Examples\n"
"\n"
"    iex> match?(1, 1)\n"
"    true\n"
"\n"
"    iex> match?(1, 2)\n"
"    false\n"
"\n"
"    iex> match?({1, _}, {1, 2})\n"
"    true\n"
"\n"
"    iex> map = %{a: 1, b: 2}\n"
"    iex> match?(%{a: _}, map)\n"
"    true\n"
"\n"
"    iex> a = 1\n"
"    iex> match?(^a, 1)\n"
"    true\n"
"\n"
"`match?/2` is very useful when filtering of finding a value in an "
"enumerable:\n"
"\n"
"    list = [{:a, 1}, {:b, 2}, {:a, 3}]\n"
"    Enum.filter list, &match?({:a, _}, &1)\n"
"    #=> [{:a, 1}, {:a, 3}]\n"
"\n"
"Guard clauses can also be given to the match:\n"
"\n"
"    list = [{:a, 1}, {:b, 2}, {:a, 3}]\n"
"    Enum.filter list, &match?({:a, x} when x < 2, &1)\n"
"    #=> [{:a, 1}]\n"
"\n"
"However, variables assigned in the match will not be available\n"
"outside of the function call (unlike regular pattern matching with the `=`\n"
"operator):\n"
"\n"
"    iex> match?(_x, 1)\n"
"    true\n"
"    iex> binding()\n"
"    []\n"
"\n"
msgstr ""
"右辺（式）が左辺（パターン）にマッチするかどうかをチェックする\n"
"便利なマクロです。\n"
"\n"
"## 例\n"
"\n"
"    iex> match?(1, 1)\n"
"    true\n"
"\n"
"    iex> match?(1, 2)\n"
"    false\n"
"\n"
"    iex> match?({1, _}, {1, 2})\n"
"    true\n"
"\n"
"    iex> map = %{a: 1, b: 2}\n"
"    iex> match?(%{a: _}, map)\n"
"    true\n"
"\n"
"    iex> a = 1\n"
"    iex> match?(^a, 1)\n"
"    true\n"
"\n"
"`match/2`は、enumerableで値を見つけるフィルタリングをする際に、\n"
"非常に便利です。\n"
"\n"
"    list = [{:a, 1}, {:b, 2}, {:a, 3}]\n"
"    Enum.filter list, &match?({:a, _}, &1)\n"
"    #=> [{:a, 1}, {:a, 3}]\n"
"\n"
"マッチにガード節を指定することもできます。\n"
"\n"
"    list = [{:a, 1}, {:b, 2}, {:a, 3}]\n"
"    Enum.filter list, &match?({:a, x} when x < 2, &1)\n"
"    #=> [{:a, 1}]\n"
"\n"
"ただし、（`=`演算子による通常のパターンマッチとは異なり）マッチで\n"
"代入された変数には関数コールの外部からは利用できません。\n"
"\n"
"    iex> match?(_x, 1)\n"
"    true\n"
"    iex> binding()\n"
"    []\n"
"\n"

#. TRANSLATORS: def Kernel.!=(left, right)
#: lib/kernel.ex:1157
msgid ""
"Returns `true` if the two items are not equal.\n"
"\n"
"This operator considers 1 and 1.0 to be equal. For match\n"
"comparison, use `!==` instead.\n"
"\n"
"All terms in Elixir can be compared with each other.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> 1 != 2\n"
"    true\n"
"\n"
"    iex> 1 != 1.0\n"
"    false\n"
"\n"
msgstr ""
"2つの項目が等しくない場合、`true`を返します。\n"
"\n"
"この演算子は、1と1.0を等しいとみなします。一致比較には、\n"
"代わりに`!==`を使用してください。\n"
"\n"
"Elixirのすべての項は互いに比較加能です。\n"
"\n"
"ガードテストに使えます。コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> 1 != 2\n"
"    true\n"
"\n"
"    iex> 1 != 1.0\n"
"    false\n"
"\n"

#. TRANSLATORS: def Kernel.length(list)
#: lib/kernel.ex:458
msgid ""
"Returns the length of `list`.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> length([1, 2, 3, 4, 5, 6, 7, 8, 9])\n"
"    9\n"
"\n"
msgstr ""
"`list`の長さを返します。\n"
"\n"
"ガードテスに使えます。コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> length([1, 2, 3, 4, 5, 6, 7, 8, 9])\n"
"    9\n"
"\n"

#. TRANSLATORS: def Kernel.<(left, right)
#: lib/kernel.ex:1061
msgid ""
"Returns `true` if left is less than right.\n"
"\n"
"All terms in Elixir can be compared with each other.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> 1 < 2\n"
"    true\n"
"\n"
msgstr ""
"左オペランドが右オペランドより小さい場合、`true`を返します。\n"
"\n"
"Elixirのすべての項は互いに比較加能です。\n"
"\n"
"ガードの中のテストに使えます。コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> 1 < 2\n"
"    true\n"
"\n"

#. TRANSLATORS: def Kernel.apply(module, fun, args)
#: lib/kernel.ex:76
msgid ""
"Invokes the given `fun` from `module` with the list of arguments `args`.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> apply(Enum, :reverse, [[1, 2, 3]])\n"
"    [3, 2, 1]\n"
"\n"
msgstr ""
"リスト`args`を引数に、指定した`module`の`fun`を呼び出します。\n"
"\n"
"コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> apply(Enum, :reverse, [[1, 2, 3]])\n"
"    [3, 2, 1]\n"
"\n"

#. TRANSLATORS: def Kernel.is_map(term)
#: lib/kernel.ex:448
msgid ""
"Returns `true` if `term` is a map; otherwise returns `false`.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
msgstr ""
"`term`がマップの場合は`true`を返します。それ以外は`false`を返します。\n"
"\n"
"ガードテストに使えます。コンパイラによりインライン化されます。\n"

#. TRANSLATORS: def Kernel.elem(tuple, index)
#: lib/kernel.ex:1228
msgid ""
"Gets the element at the zero-based `index` in `tuple`.\n"
"\n"
"It raises `ArgumentError` when index is negative or it is out of range of "
"the tuple elements.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    tuple = {:foo, :bar, 3}\n"
"    elem(tuple, 1)\n"
"    #=> :bar\n"
"\n"
"    elem({}, 0)\n"
"    #=> ** (ArgumentError) argument error\n"
"\n"
"    elem({:foo, :bar}, 2)\n"
"    #=> ** (ArgumentError) argument error\n"
"\n"
msgstr ""
"`tuple`から０始まりの`index`位置の要素を取得します。\n"
"\n"
"indexが負値あるいはタプル要素の範囲外の場合は、`ArgumentError`例外が発生しま"
"す。\n"
"\n"
"ガード節で使えます。コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    tuple = {:foo, :bar, 3}\n"
"    elem(tuple, 1)\n"
"    #=> :bar\n"
"\n"
"    elem({}, 0)\n"
"    #=> ** (ArgumentError) argument error\n"
"\n"
"    elem({:foo, :bar}, 2)\n"
"    #=> ** (ArgumentError) argument error\n"
"\n"

#. TRANSLATORS: defmacro Kernel.&&(left, right)
#: lib/kernel.ex:2700
msgid ""
"Provides a short-circuit operator that evaluates and returns\n"
"the second expression only if the first one evaluates to `true`\n"
"(i.e., it is neither `nil` nor `false`). Returns the first expression\n"
"otherwise.\n"
"\n"
"Not allowed in guard clauses.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.empty?([]) && Enum.empty?([])\n"
"    true\n"
"\n"
"    iex> List.first([]) && true\n"
"    nil\n"
"\n"
"    iex> Enum.empty?([]) && List.first([1])\n"
"    1\n"
"\n"
"    iex> false && throw(:bad)\n"
"    false\n"
"\n"
"Note that, unlike `and/2`, this operator accepts any expression\n"
"as the first argument, not only booleans.\n"
msgstr ""
"最初の式が`true`（すなわち、`nil`でも`false`でもない）と評価された場合にの"
"み\n"
"2番目の式を評価して返す短絡演算子を提供します。それ以外は、最初の式を\n"
"返します。\n"
"\n"
"ガードの中では使えません。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.empty?([]) && Enum.empty?([])\n"
"    true\n"
"\n"
"    iex> List.first([]) && true\n"
"    nil\n"
"\n"
"    iex> Enum.empty?([]) && List.first([1])\n"
"    1\n"
"\n"
"    iex> false && throw(:bad)\n"
"    false\n"
"\n"
"`and/2`とは異なり、この演算子は、第1引数として論理値だけでなく、\n"
"任意の式を受け付けることに注意してください。\n"

#. TRANSLATORS: defmacro Kernel.sigil_c(term, modifiers)
#: lib/kernel.ex:4197
msgid ""
"Handles the sigil `~c`.\n"
"\n"
"It returns a charlist as if it were a single quoted string, unescaping\n"
"characters and replacing interpolations.\n"
"\n"
"## Examples\n"
"\n"
"    iex> ~c(foo)\n"
"    'foo'\n"
"\n"
"    iex> ~c(f#{:o}o)\n"
"    'foo'\n"
"\n"
"    iex> ~c(f\\#{:o}o)\n"
"    'f\\#{:o}o'\n"
"\n"
msgstr ""
"シジル`~c`を処理します。\n"
"\n"
"一重引用苻で囲まれた文字列のように、文字をアンエスケープし、\n"
"式の埋め込みを行った、文字のリストを返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> ~c(foo)\n"
"    'foo'\n"
"\n"
"    iex> ~c(f#{:o}o)\n"
"    'foo'\n"
"\n"
"    iex> ~c(f\\#{:o}o)\n"
"    'f\\#{:o}o'\n"
"\n"

#. TRANSLATORS: def Kernel.<=(left, right)
#: lib/kernel.ex:1097
msgid ""
"Returns `true` if left is less than or equal to right.\n"
"\n"
"All terms in Elixir can be compared with each other.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> 1 <= 2\n"
"    true\n"
"\n"
msgstr ""
"左オペランドが右オペランドより小さいか等しい場合、`true`を返します。\n"
"\n"
"Elixirのすべての項は互いに比較加能です。\n"
"\n"
"ガードの中のテストに使えます。コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> 1 <= 2\n"
"    true\n"
"\n"

#. TRANSLATORS: def Kernel.abs(number)
#: lib/kernel.ex:41
msgid ""
"Returns an integer or float which is the arithmetical absolute value of "
"`number`.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> abs(-3.33)\n"
"    3.33\n"
"\n"
"    iex> abs(-3)\n"
"    3\n"
"\n"
msgstr ""
"`number`の算術的絶対値である整数または浮動小数点数で返します。\n"
"\n"
"ガード中のテストで使うことができます。コンパイラによりインライン化されま"
"す。\n"
"\n"
"## 例\n"
"\n"
"    iex> abs(-3.33)\n"
"    3.33\n"
"\n"
"    iex> abs(-3)\n"
"    3\n"
"\n"

#. TRANSLATORS: defmacro Kernel.defimpl(name, opts, do_block \\ [])
#: lib/kernel.ex:3891
msgid ""
"Defines an implementation for the given protocol.\n"
"\n"
"See `defprotocol/2` for more information and examples on protocols.\n"
"\n"
"Inside an implementation, the name of the protocol can be accessed\n"
"via `@protocol` and the current target as `@for`.\n"
msgstr ""
"指定したプロトコルの実装を定義します。\n"
"\n"
"プロトコルに関する詳細と例は`defprotocol/2`を参照してください。\n"
"\n"
"実装の中では、プロトコルの名前は`@protocol`で、現在のターゲットは`@for`で\n"
"アクセスできます。\n"

#. TRANSLATORS: def Kernel.not(arg)
#: lib/kernel.ex:1042
msgid ""
"Boolean not.\n"
"\n"
"`arg` must be a boolean; if it's not, an `ArgumentError` exception is "
"raised.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> not false\n"
"    true\n"
"\n"
msgstr ""
"論理否定です。\n"
"\n"
"`arg`はブール値でなくてはなりません。そうでない場合、`ArgumentError`\n"
"例外が発生します。\n"
"\n"
"ガードテストで使えます。コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> not false\n"
"    true\n"
"\n"

#. TRANSLATORS: defmacro Kernel.defmacrop(call, expr \\ nil)
#: lib/kernel.ex:3419
msgid ""
"Defines a private macro with the given name and body.\n"
"\n"
"Private macros are only accessible from the same module in which they are\n"
"defined.\n"
"\n"
"Check `defmacro/2` for more information.\n"
"\n"
msgstr ""
"指定した名前と本体でプライベートマクロを定義します。\n"
"\n"
"プライベートマクロはそれが定義された同じモジュールからのみアクセスできま"
"す。\n"
"\n"
"詳細は `defmacro/2` をチェックしてください。\n"

#. TRANSLATORS: defmacro Kernel.defmacro(call, expr \\ nil)
#: lib/kernel.ex:3396
msgid ""
"Defines a macro with the given name and body.\n"
"\n"
"## Examples\n"
"\n"
"    defmodule MyLogic do\n"
"      defmacro unless(expr, opts) do\n"
"        quote do\n"
"          if !unquote(expr), unquote(opts)\n"
"        end\n"
"      end\n"
"    end\n"
"\n"
"    require MyLogic\n"
"    MyLogic.unless false do\n"
"      IO.puts \"It works\"\n"
"    end\n"
"\n"
msgstr ""
"指定した名前と本体でマクロを定義します。\n"
"\n"
"## 例\n"
"\n"
"    defmodule MyLogic do\n"
"      defmacro unless(expr, opts) do\n"
"        quote do\n"
"          if !unquote(expr), unquote(opts)\n"
"        end\n"
"      end\n"
"    end\n"
"\n"
"    require MyLogic\n"
"    MyLogic.unless false do\n"
"      IO.puts \"It works\"\n"
"    end\n"
"\n"

#. TRANSLATORS: defmacro Kernel.sigil_N(date, modifiers)
#: lib/kernel.ex:4312
msgid ""
"Handles the sigil `~N` for naive date times.\n"
"\n"
"The lower case `~n` variant does not exist as interpolation\n"
"and escape characters are not useful for datetime sigils.\n"
"\n"
"## Examples\n"
"\n"
"    iex> ~N[2015-01-13 13:00:07]\n"
"    ~N[2015-01-13 13:00:07]\n"
"    iex> ~N[2015-01-13T13:00:07.001]\n"
"    ~N[2015-01-13 13:00:07.001]\n"
"\n"
msgstr ""
"ナイーブな日時を表すシジル`~N`を処理します。\n"
"\n"
"式の埋め込みや文字のエスケープは日付シギルには役に立ちませんので\n"
"小文字のシギル`~n`はありません。\n"
"\n"
"## 例\n"
"\n"
"    iex> ~N[2015-01-13 13:00:07]\n"
"    ~N[2015-01-13 13:00:07]\n"
"    iex> ~N[2015-01-13T13:00:07.001]\n"
"    ~N[2015-01-13 13:00:07.001]\n"
"\n"

#. TRANSLATORS: defmacro Kernel.<>(left, right)
#: lib/kernel.ex:1356
msgid ""
"Concatenates two binaries.\n"
"\n"
"## Examples\n"
"\n"
"    iex> \"foo\" <> \"bar\"\n"
"    \"foobar\"\n"
"\n"
"The `<>` operator can also be used in pattern matching (and guard clauses) "
"as\n"
"long as the first part is a literal binary:\n"
"\n"
"    iex> \"foo\" <> x = \"foobar\"\n"
"    iex> x\n"
"    \"bar\"\n"
"\n"
"`x <> \"bar\" = \"foobar\"` would have resulted in a `CompileError` "
"exception.\n"
"\n"
msgstr ""
"2つのバイナリを連結します。\n"
"\n"
"## 例\n"
"\n"
"    iex> \"foo\" <> \"bar\"\n"
"    \"foobar\"\n"
"\n"
"`<>`演算子は最初の部分がリテラルバイナリであれば、パターンマッチ（と\n"
"ガード節）に使用することもできます。\n"
"\n"
"    iex> \"foo\" <> x = \"foobar\"\n"
"    iex> x\n"
"    \"bar\"\n"
"\n"
"`x <> \"bar\" = \"foobar\"`は`CompileError`例外となります。\n"
"\n"

#. TRANSLATORS: def Kernel.max(first, second)
#: lib/kernel.ex:512
msgid ""
"Returns the biggest of the two given terms according to\n"
"Erlang's term ordering. If the terms compare equal, the\n"
"first one is returned.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> max(1, 2)\n"
"    2\n"
"    iex> max(:a, :b)\n"
"    :b\n"
"\n"
msgstr ""
"Erlangの項の順序に基づき、指定した2つの項の大きいほうを\n"
"返します。2つの項が等しい場合は最初の項を返します。\n"
"\n"
"コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> max(1, 2)\n"
"    2\n"
"    iex> max(:a, :b)\n"
"    :b\n"
"\n"

#. TRANSLATORS: defmacro Kernel.reraise(exception, attrs, stacktrace)
#: lib/kernel.ex:1532
msgid ""
"Raises an exception preserving a previous stacktrace.\n"
"\n"
"`reraise/3` works like `reraise/2`, except it passes arguments to the\n"
"`exception/1` function as explained in `raise/2`.\n"
"\n"
"## Examples\n"
"\n"
"    try do\n"
"      raise \"oops\"\n"
"    rescue\n"
"      exception ->\n"
"        stacktrace = System.stacktrace\n"
"        reraise WrapperError, [exception: exception], stacktrace\n"
"    end\n"
msgstr ""
"以前のスタックトレースを保存したまま例外を発生させます。\n"
"\n"
"`raise/2`で説明したように、引数を`exception/1`へ渡すことを除いて、\n"
"`reraise/3`は`raise/2`と同じ動作をします。\n"
"\n"
"## 例\n"
"\n"
"    try do\n"
"      raise \"oops\"\n"
"    rescue\n"
"      exception ->\n"
"        stacktrace = System.stacktrace\n"
"        reraise WrapperError, [exception: exception], stacktrace\n"
"    end\n"

#. TRANSLATORS: def Kernel.-(left, right)
#: lib/kernel.ex:876
msgid ""
"Arithmetic subtraction.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> 1 - 2\n"
"    -1\n"
"\n"
msgstr ""
"算術的減算です。\n"
"\n"
"ガードテストで使えます。コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> 1 - 2\n"
"    -1\n"
"\n"

#. TRANSLATORS: defmacro Kernel.defoverridable(keywords)
#: lib/kernel.ex:3905
msgid ""
"Makes the given functions in the current module overridable.\n"
"\n"
"An overridable function is lazily defined, allowing a developer to override\n"
"it.\n"
"\n"
"## Example\n"
"\n"
"    defmodule DefaultMod do\n"
"      defmacro __using__(_opts) do\n"
"        quote do\n"
"          def test(x, y) do\n"
"            x + y\n"
"          end\n"
"\n"
"          defoverridable [test: 2]\n"
"        end\n"
"      end\n"
"    end\n"
"\n"
"    defmodule InheritMod do\n"
"      use DefaultMod\n"
"\n"
"      def test(x, y) do\n"
"        x * y + super(x, y)\n"
"      end\n"
"    end\n"
"\n"
"As seen as in the example above, `super` can be used to call the default\n"
"implementation.\n"
"\n"
msgstr ""
"現在のモジュールの指定した関数を上書き可能にします。\n"
"\n"
"上書き可能関数は定義を遅延するので、開発者は関数を上書きすることができま"
"す。\n"
"\n"
"## 例\n"
"\n"
"    defmodule DefaultMod do\n"
"      defmacro __using__(_opts) do\n"
"        quote do\n"
"          def test(x, y) do\n"
"            x + y\n"
"          end\n"
"\n"
"          defoverridable [test: 2]\n"
"        end\n"
"      end\n"
"    end\n"
"\n"
"    defmodule InheritMod do\n"
"      use DefaultMod\n"
"\n"
"      def test(x, y) do\n"
"        x * y + super(x, y)\n"
"      end\n"
"    end\n"
"\n"
"この例でわかるように、`super`を使用してデオフォルト実装を呼び出すことができま"
"す。\n"
"\n"

#. TRANSLATORS: def Kernel.update_in(data, keys, fun)
#: lib/kernel.ex:1834
msgid ""
"Updates a key in a nested structure.\n"
"\n"
"Uses the `Access` module to traverse the structures\n"
"according to the given `keys`, unless the `key` is a\n"
"function. If the key is a function, it will be invoked\n"
"as specified in `get_and_update_in/3`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> users = %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}\n"
"    iex> update_in(users, [\"john\", :age], &(&1 + 1))\n"
"    %{\"john\" => %{age: 28}, \"meg\" => %{age: 23}}\n"
"\n"
"In case any of entries in the middle returns `nil`,\n"
"an error will be raised when trying to access it next.\n"
msgstr ""
"ネストした構造のキーを更新します。\n"
"\n"
"`key`が関数でないかぎり、`Access`モジュールを使って\n"
"指定した`keys`に基いて構造体を走査します。キーが関数の\n"
"場合は、`get_and_update_in/3`で説明されたように実行されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> users = %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}\n"
"    iex> update_in(users, [\"john\", :age], &(&1 + 1))\n"
"    %{\"john\" => %{age: 28}, \"meg\" => %{age: 23}}\n"
"\n"
"中間の項目のいずれかが`nil`を返した場合、次にそれをアクセスした\n"
"際にエラーが発生します。\n"

#. TRANSLATORS: defmacro Kernel.to_charlist(arg)
#: lib/kernel.ex:2246
msgid ""
"Converts the argument to a charlist according to the `List.Chars` protocol.\n"
"\n"
"## Examples\n"
"\n"
"    iex> to_charlist(:foo)\n"
"    'foo'\n"
"\n"
msgstr ""
"`List.Chars`プロトコルに従って、引数を文字のリストに変換します。\n"
"\n"
"## 例\n"
"\n"
"    iex> to_char_list(:foo)\n"
"    'foo'\n"
"\n"

#. TRANSLATORS: defmacro Kernel.use(module, opts \\ [])
#: lib/kernel.ex:3943
msgid ""
"Uses the given module in the current context.\n"
"\n"
"When calling:\n"
"\n"
"    use MyModule, some: :options\n"
"\n"
"the `__using__/1` macro from the `MyModule` module is invoked with the "
"second\n"
"argument passed to `use` as its argument. Since `__using__/1` is a macro, "
"all\n"
"the usual macro rules apply, and its return value should be quoted code\n"
"that is then inserted where `use/2` is called.\n"
"\n"
"## Examples\n"
"\n"
"For example, in order to write test cases using the `ExUnit` framework\n"
"provided with Elixir, a developer should `use` the `ExUnit.Case` module:\n"
"\n"
"    defmodule AssertionTest do\n"
"      use ExUnit.Case, async: true\n"
"\n"
"      test \"always pass\" do\n"
"        assert true\n"
"      end\n"
"    end\n"
"\n"
"In this example, `ExUnit.Case.__using__/1` is called with the keyword list\n"
"`[async: true]` as its argument; `use/2` translates to:\n"
"\n"
"    defmodule AssertionTest do\n"
"      require ExUnit.Case\n"
"      ExUnit.Case.__using__([async: true])\n"
"\n"
"      test \"always pass\" do\n"
"        assert true\n"
"      end\n"
"    end\n"
"\n"
"`ExUnit.Case` will then define the `__using__/1` macro:\n"
"\n"
"    defmodule ExUnit.Case do\n"
"      defmacro __using__(opts) do\n"
"        # do something with opts\n"
"        quote do\n"
"          # return some code to inject in the caller\n"
"        end\n"
"      end\n"
"    end\n"
"\n"
"## Best practices\n"
"\n"
"`__using__/1` is typically used when there is a need to set some state (via\n"
"module attributes) or callbacks (like `@before_compile`, see the "
"documentation\n"
"for `Module` for more information) into the caller.\n"
"\n"
"`__using__/1` may also be used to alias, require, or import functionality\n"
"from different modules:\n"
"\n"
"    defmodule MyModule do\n"
"      defmacro __using__(opts) do\n"
"        quote do\n"
"          import MyModule.Foo\n"
"          import MyModule.Bar\n"
"          import MyModule.Baz\n"
"\n"
"          alias MyModule.Repo\n"
"        end\n"
"      end\n"
"    end\n"
"\n"
"However, do not provide `__using__/1` if all it does is to import,\n"
"alias or require the module itself. For example, avoid this:\n"
"\n"
"    defmodule MyModule do\n"
"      defmacro __using__(_opts) do\n"
"        quote do\n"
"          import MyModule\n"
"        end\n"
"      end\n"
"    end\n"
"\n"
"In such cases, developers should instead import or alias the module\n"
"directly, so that they can customize those as they wish,\n"
"without the indirection behind `use/2`.\n"
"\n"
"Finally, developers should also avoid defining functions inside\n"
"the `__using__/1` callback, unless those functions are the default\n"
"implementation of a previously defined `@callback` or are functions\n"
"meant to be overridden (see `defoverridable/1`). Even in these cases,\n"
"defining functions should be seen as a \"last resource\".\n"
"\n"
"In case you want to provide some existing functionality to the user module,\n"
"please define it in a module which will be imported accordingly; for "
"example,\n"
"`ExUnit.Case` doesn't define the `test/3` macro in the module that calls\n"
"`use ExUnit.Case`, but it defines `ExUnit.Case.test/3` and just imports "
"that\n"
"into the caller when used.\n"
msgstr ""
"指定したモジュールを現在のコンテキストで使用します。\n"
"\n"
"次のように呼び出すと、\n"
"\n"
"    use MyModule, some: :options\n"
"\n"
"`use`に渡された第2引数を引数として、`MyModule`モジュールから\n"
"`__using__/1`マクロが呼び出されます。`__using__/1`はマクロなので、\n"
"一般的なマクロ規則がすべて適用され、返り値はquoteされたコードで\n"
"であり、`use/2`が予備刺された位置に挿入されます。\n"
"\n"
"## 例\n"
"\n"
"たとえば、Elixirが提供するExUnitフレームワークを使ってテストを書くために"
"は、\n"
"開発者は`ExUnit.Case`モジュールをuseするべきです。\n"
"\n"
"    defmodule AssertionTest do\n"
"      use ExUnit.Case, async: true\n"
"\n"
"      test \"always pass\" do\n"
"        assert true\n"
"      end\n"
"    end\n"
"\n"
"この例では、キーワードリスト`[async: true]` を引数として\n"
"`ExUnit.Case.__using__/1`が呼び出されます。\n"
"\n"
"    defmodule AssertionTest do\n"
"      require ExUnit.Case\n"
"      ExUnit.Case.__using__([async: true])\n"
"\n"
"      test \"always pass\" do\n"
"        assert true\n"
"      end\n"
"    end\n"
"\n"
"`ExUnit.Case`は次に`__using__/1`マクロを定義します。\n"
"\n"
"    defmodule ExUnit.Case do\n"
"      defmacro __using__(opts) do\n"
"        # optsで何かを実行\n"
"        quote do\n"
"          # 呼び出し元に注入する何らかのコードを返す\n"
"        end\n"
"      end\n"
"    end\n"
"\n"
"## ベストプラクティス\n"
"\n"
"`__using__/1`は通常、（モジュール属性を使用して）何らかの状態を設定したり、\n"
"（`@before_compile`のように)コールバックを呼出し側にセットする（詳細は\n"
"`Module`モジュールのドキュメントを参照）ことが必要な場合に使用されます。\n"
"\n"
"`__using__/1`は、異なるモジュールの機能をalias、require、importするためにも\n"
"使用できます。\n"
"\n"
"    defmodule MyModule do\n"
"      defmacro __using__(opts) do\n"
"        quote do\n"
"          import MyModule.Foo\n"
"          import MyModule.Bar\n"
"          import MyModule.Baz\n"
"\n"
"          alias MyModule.Repo\n"
"        end\n"
"      end\n"
"    end\n"
"\n"
"ただし、モジュール自体をimport、alias、requireするだけの\n"
"`__using__/1`を提供してはいけません。たとえば、次はしないでください。\n"
"\n"
"    defmodule MyModule do\n"
"      defmacro __using__(opts) do\n"
"        quote do\n"
"          import MyModule\n"
"        end\n"
"      end\n"
"    end\n"
"\n"
"そのような場合は、直接importやaliasをするべきです。そうすれば、\n"
"`use/2`を通じた回りくどい方法なしに、望みどおりにカスタマイズ\n"
"することができます。\n"
"\n"
"最後に、先に定義された`@callback`のデフォルト実装関数であるか、\n"
"上書きされるべき関数である（`defoverridable/1`を参照）場合を除いて、\n"
"`__using__/1`コールバック内で関数を定義することも避けてください。\n"
"たとえそのような場合も、関数の定義は「最後のリソース」だと考えるべきです。\n"
"\n"
"既存の機能をユーザモジュールに提供したい場合、それに応じてインポートされる\n"
"モジュール内で定義してください。たとえば、`ExUnit.Case`は`use ExUnit.Case`"
"を\n"
"呼び出すモジュールで`test/3`マクロを定義しません。`ExUnit.Case.test/3`を\n"
"定義して、使用時に呼び出し元にインポートするだけです。\n"

#. TRANSLATORS: defmacro Kernel.sigil_C(term, modifiers)
#: lib/kernel.ex:4177
msgid ""
"Handles the sigil `~C`.\n"
"\n"
"It simply returns a charlist without escaping characters and without\n"
"interpolations.\n"
"\n"
"## Examples\n"
"\n"
"    iex> ~C(foo)\n"
"    'foo'\n"
"\n"
"    iex> ~C(f#{o}o)\n"
"    'f\\#{o}o'\n"
"\n"
msgstr ""
"シジル`~C`を処理します。\n"
"\n"
"文字のエスケープや式の埋め込みをすることなく、単に\n"
"文字のリストを返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> ~C(foo)\n"
"    'foo'\n"
"\n"
"    iex> ~C(f#{o}o)\n"
"    'f\\#{o}o'\n"
"\n"

#. TRANSLATORS: def Kernel.===(left, right)
#: lib/kernel.ex:1181
msgid ""
"Returns `true` if the two items are exactly equal.\n"
"\n"
"The items are only considered to be exactly equal if they\n"
"have the same value and are of the same type. For example,\n"
"`1 == 1.0` returns true, but since they are of different\n"
"types, `1 === 1.0` returns false.\n"
"\n"
"All terms in Elixir can be compared with each other.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> 1 === 2\n"
"    false\n"
"\n"
"    iex> 1 === 1.0\n"
"    false\n"
"\n"
msgstr ""
"2つの項目が正確に等しい場合、`true`を返します。\n"
"\n"
"両者が同じ値を持ち、同じ型の場合に限り、正確に等しいと\n"
"みなされます。たとえば、`1 == 1.0`はtrueを返しますが、\n"
"両者方が違うので`1 === 1.0`はfalseを返します。\n"
"\n"
"Elixirのすべての項は互いに比較加能です。\n"
"\n"
"ガードの中のテストに使えます。コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> 1 === 2\n"
"    false\n"
"\n"
"    iex> 1 === 1.0\n"
"    false\n"
"\n"

#. TRANSLATORS: def Kernel.is_tuple(term)
#: lib/kernel.ex:438
msgid ""
"Returns `true` if `term` is a tuple; otherwise returns `false`.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
msgstr ""
"`term`がタプルの場合は`true`を返します。それ以外は`false`を返します。\n"
"\n"
"ガードテストに使えます。コンパイラによりインライン化されます。\n"

#. TRANSLATORS: defmacro Kernel...(first, last)
#: lib/kernel.ex:2656
msgid ""
"Returns a range with the specified start and end.\n"
"\n"
"Both ends are included.\n"
"\n"
"## Examples\n"
"\n"
"    iex> 0 in 1..3\n"
"    false\n"
"\n"
"    iex> 1 in 1..3\n"
"    true\n"
"\n"
"    iex> 2 in 1..3\n"
"    true\n"
"\n"
"    iex> 3 in 1..3\n"
"    true\n"
"\n"
msgstr ""
"指定した始まりと終わりを持つ範囲を返します。\n"
"\n"
"両端を含みます。\n"
"\n"
"## Examples\n"
"\n"
"    iex> 0 in 1..3\n"
"    false\n"
"\n"
"    iex> 1 in 1..3\n"
"    true\n"
"\n"
"    iex> 2 in 1..3\n"
"    true\n"
"\n"
"    iex> 3 in 1..3\n"
"    true\n"
"\n"

#. TRANSLATORS: def Kernel.is_function(term, arity)
#: lib/kernel.ex:358
msgid ""
"Returns `true` if `term` is a function that can be applied with `arity` "
"number of arguments;\n"
"otherwise returns `false`.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> is_function(fn(x) -> x * 2 end, 1)\n"
"    true\n"
"    iex> is_function(fn(x) -> x * 2 end, 2)\n"
"    false\n"
"\n"
msgstr ""
"`term`が`arity`個の引数が適用可能な関数の場合は`true`を返します。\n"
"それ以外は`false`を返します。\n"
"\n"
"ガードテストに使えます。コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> is_function(fn(x) -> x * 2 end, 1)\n"
"    true\n"
"    iex> is_function(fn(x) -> x * 2 end, 2)\n"
"    false\n"
"\n"

#. TRANSLATORS: defmacro Kernel.sigil_D(date, modifiers)
#: lib/kernel.ex:4277
msgid ""
"Handles the sigil `~D` for dates.\n"
"\n"
"The lower case `~d` variant does not exist as interpolation\n"
"and escape characters are not useful for date sigils.\n"
"\n"
"## Examples\n"
"\n"
"    iex> ~D[2015-01-13]\n"
"    ~D[2015-01-13]\n"
msgstr ""
"日付を表すシジル`~D`を処理します。\n"
"\n"
"式の埋め込みや文字のエスケープは日付シギルには役に立ちませんので\n"
"小文字のシギル`~d`はありません。\n"
"\n"
"## 例\n"
"\n"
"    iex> ~D[2015-01-13]\n"
"    ~D[2015-01-13]\n"

#. TRANSLATORS: def Kernel.bit_size(bitstring)
#: lib/kernel.ex:118
msgid ""
"Returns an integer which is the size in bits of `bitstring`.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> bit_size(<<433::16, 3::3>>)\n"
"    19\n"
"\n"
"    iex> bit_size(<<1, 2, 3>>)\n"
"    24\n"
"\n"
msgstr ""
"`bitstring`のビット列のサイズである整数を返します。\n"
"\n"
"ガード中のテストで使うことができます。コンパイラによりインライン化されま"
"す。\n"
"\n"
"## 例\n"
"\n"
"    iex> bit_size(<<433::16, 3::3>>)\n"
"    19\n"
"\n"
"    iex> bit_size(<<1, 2, 3>>)\n"
"    24\n"
"\n"

#. TRANSLATORS: def Kernel.min(first, second)
#: lib/kernel.ex:532
msgid ""
"Returns the smallest of the two given terms according to\n"
"Erlang's term ordering. If the terms compare equal, the\n"
"first one is returned.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> min(1, 2)\n"
"    1\n"
"    iex> min(\"foo\", \"bar\")\n"
"    \"bar\"\n"
"\n"
msgstr ""
"Erlangの項の順序に基づき、指定した2つの項の小さいほうを\n"
"返します。2つの項が等しい場合は最初の項を返します。\n"
"\n"
"コンパイラによりインライン化されます。\n"
"\n"
"## Examples\n"
"\n"
"    iex> min(1, 2)\n"
"    1\n"
"    iex> min(\"foo\", \"bar\")\n"
"    \"bar\"\n"
"\n"

#. TRANSLATORS: def Kernel.binary_part(binary, start, length)
#: lib/kernel.ex:92
msgid ""
"Extracts the part of the binary starting at `start` with length `length`.\n"
"Binaries are zero-indexed.\n"
"\n"
"If `start` or `length` reference in any way outside the binary, an\n"
"`ArgumentError` exception is raised.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> binary_part(\"foo\", 1, 2)\n"
"    \"oo\"\n"
"\n"
"A negative `length` can be used to extract bytes that come *before* the "
"byte\n"
"at `start`:\n"
"\n"
"    iex> binary_part(\"Hello\", 5, -3)\n"
"    \"llo\"\n"
"\n"
msgstr ""
"`start`位置から長さ`length`のバイナリ部分を抽出します。\n"
"バイナリは0始まりで数えます。\n"
"\n"
"`start`か`length`がバイナリの外部を参照した場合、\n"
"`ArgumentError`例外が発生します。\n"
"\n"
"ガードテストで使えます。コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> binary_part(\"foo\", 1, 2)\n"
"    \"oo\"\n"
"\n"
"負の`length`を使うことで、`start`のバイト位置の *前にある* バイトを抽出する\n"
"ことができます。\n"
"\n"
"    iex> binary_part(\"Hello\", 5, -3)\n"
"    \"llo\"\n"
"\n"

#. TRANSLATORS: defmacro Kernel.sigil_s(term, modifiers)
#: lib/kernel.ex:4151
msgid ""
"Handles the sigil `~s`.\n"
"\n"
"It returns a string as if it was a double quoted string, unescaping "
"characters\n"
"and replacing interpolations.\n"
"\n"
"## Examples\n"
"\n"
"    iex> ~s(foo)\n"
"    \"foo\"\n"
"\n"
"    iex> ~s(f#{:o}o)\n"
"    \"foo\"\n"
"\n"
"    iex> ~s(f\\#{:o}o)\n"
"    \"f\\#{:o}o\"\n"
"\n"
msgstr ""
"シジル`~s`を処理します。\n"
"\n"
"二重引用苻で囲まれた文字列のように、文字をアンエスケープし、\n"
"式の埋め込みを行った、文字列を返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> ~s(foo)\n"
"    \"foo\"\n"
"\n"
"    iex> ~s(f#{:o}o)\n"
"    \"foo\"\n"
"\n"
"    iex> ~s(f\\#{:o}o)\n"
"    \"f\\#{:o}o\"\n"
"\n"

#. TRANSLATORS: defmacro Kernel.reraise(msg, stacktrace)
#: lib/kernel.ex:1473
msgid ""
"Raises an exception preserving a previous stacktrace.\n"
"\n"
"Works like `raise/1` but does not generate a new stacktrace.\n"
"\n"
"Notice that `System.stacktrace/0` returns the stacktrace\n"
"of the last exception. That said, it is common to assign\n"
"the stacktrace as the first expression inside a `rescue`\n"
"clause as any other exception potentially raised (and\n"
"rescued) between the rescue clause and the raise call\n"
"may change the `System.stacktrace/0` value.\n"
"\n"
"## Examples\n"
"\n"
"    try do\n"
"      raise \"oops\"\n"
"    rescue\n"
"      exception ->\n"
"        stacktrace = System.stacktrace\n"
"        if Exception.message(exception) == \"oops\" do\n"
"          reraise exception, stacktrace\n"
"        end\n"
"    end\n"
msgstr ""
"以前のスタックトレースを保存したまま例外を発生させます。\n"
"\n"
"`raise/1`と似た働きをしますが、新しいスタックトレースを生成しません。\n"
"\n"
"`System.stacktrace/0`は、最後の例外のスタックトレースを返すことに\n"
"注意してください。とは言え、`rescue`節の中で最初の式としてスタック\n"
"トレースを代入することは普通です。なぜなら、rescue節とraise呼び出しの\n"
"間に発生する（そしてレスキューされる）可能性のあるその他の例外が\n"
"`System.stacktrace/0`の値を変える可能性があるからです。\n"
"\n"
"## 例\n"
"\n"
"    try do\n"
"      raise \"oops\"\n"
"    rescue\n"
"      exception ->\n"
"        stacktrace = System.stacktrace\n"
"        if Exception.message(exception) == \"oops\" do\n"
"          reraise exception, stacktrace\n"
"        end\n"
"    end\n"

#. TRANSLATORS: defmacro Kernel.sigil_S(term, modifiers)
#: lib/kernel.ex:4133
msgid ""
"Handles the sigil `~S`.\n"
"\n"
"It simply returns a string without escaping characters and without\n"
"interpolations.\n"
"\n"
"## Examples\n"
"\n"
"    iex> ~S(foo)\n"
"    \"foo\"\n"
"\n"
"    iex> ~S(f#{o}o)\n"
"    \"f\\#{o}o\"\n"
"\n"
msgstr ""
"シジル`~S`を処理します。\n"
"\n"
"文字のエスケープや式の埋め込みをすることなく、\n"
"単に文字列を返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> ~S(foo)\n"
"    \"foo\"\n"
"\n"
"    iex> ~S(f#{o}o)\n"
"    \"f\\#{o}o\"\n"
"\n"

#. TRANSLATORS: def Kernel.byte_size(bitstring)
#: lib/kernel.ex:137
msgid ""
"Returns the number of bytes needed to contain `bitstring`.\n"
"\n"
"That is, if the number of bits in `bitstring` is not divisible by 8, the\n"
"resulting number of bytes will be rounded up (by excess). This operation\n"
"happens in constant time.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> byte_size(<<433::16, 3::3>>)\n"
"    3\n"
"\n"
"    iex> byte_size(<<1, 2, 3>>)\n"
"    3\n"
"\n"
msgstr ""
"`bitstring`を格納するために必要なバイト数を返します。\n"
"\n"
"すなわち、`bitstring`のビット数が8で割り切れない場合、結果のバイト数は\n"
"（余剰分を足して）切り上げられます。このオペレーションは定数時間で実行されま"
"す。\n"
"\n"
"ガードテストに使えます。コンパイラによってインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> byte_size(<<433::16, 3::3>>)\n"
"    3\n"
"\n"
"    iex> byte_size(<<1, 2, 3>>)\n"
"    3\n"
"\n"

#. TRANSLATORS: def Kernel.is_list(term)
#: lib/kernel.ex:387
msgid ""
"Returns `true` if `term` is a list with zero or more elements; otherwise "
"returns `false`.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
msgstr ""
"`term`が0個以上の要素をもつリストの場合は`true`を返します。\n"
"それ以外は`false`を返します。\n"
"\n"
"ガードテストに使えます。コンパイラによりインライン化されます。\n"

#. TRANSLATORS: defmacro Kernel.pop_in(path)
#: lib/kernel.ex:1997
msgid ""
"Pops a key from the nested structure via the given `path`.\n"
"\n"
"This is similar to `pop_in/2`, except the path is extracted via\n"
"a macro rather than passing a list. For example:\n"
"\n"
"    pop_in(opts[:foo][:bar])\n"
"\n"
"Is equivalent to:\n"
"\n"
"    pop_in(opts, [:foo, :bar])\n"
"\n"
"Note that in order for this macro to work, the complete path must always\n"
"be visible by this macro. For more information about the supported path\n"
"expressions, please check `get_and_update_in/2` docs.\n"
"\n"
"## Examples\n"
"\n"
"    iex> users = %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}\n"
"    iex> pop_in(users[\"john\"][:age])\n"
"    {27, %{\"john\" => %{}, \"meg\" => %{age: 23}}}\n"
"\n"
"    iex> users = %{john: %{age: 27}, meg: %{age: 23}}\n"
"    iex> pop_in(users.john[:age])\n"
"    {27, %{john: %{}, meg: %{age: 23}}}\n"
"\n"
"In case any entry returns `nil`, its key will be removed\n"
"and the deletion will be considered a success.\n"
msgstr ""
"指定した`path`によりネストした構造からキーをポップします。\n"
"\n"
"リストを渡してpathを指定するのではなく、マクロによってpathが\n"
"抽出されることを除いて、`pop_in/2`と同じです。たとえば:\n"
"\n"
"    pop_in(opts[:foo][:bar])\n"
"\n"
"は、以下と同じです。\n"
"\n"
"    pop_in(opts, [:foo, :bar])\n"
"\n"
"このマクロが機能するためには、完全なパスが常にこのマクロに見えて\n"
"いなければならないことに注意してください。サポートされているパス式の\n"
"詳細は`get_and_update_in/2`のドキュメントをチェックしてください。\n"
"\n"
"## 例\n"
"\n"
"    iex> users = %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}\n"
"    iex> pop_in(users[\"john\"][:age])\n"
"    {27, %{\"john\" => %{}, \"meg\" => %{age: 23}}}\n"
"\n"
"    iex> users = %{john: %{age: 27}, meg: %{age: 23}}\n"
"    iex> pop_in(users.john[:age])\n"
"    {27, %{john: %{}, meg: %{age: 23}}}\n"
"\n"
"中間のエントリのいずれかが`nil`を返す場合、そのキーは\n"
"削除され、削除は成功とみなされます。\n"

#. TRANSLATORS: defmacro Kernel.def(call, expr \\ nil)
#: lib/kernel.ex:3298
msgid ""
"Defines a function with the given name and body.\n"
"\n"
"## Examples\n"
"\n"
"    defmodule Foo do\n"
"      def bar, do: :baz\n"
"    end\n"
"\n"
"    Foo.bar #=> :baz\n"
"\n"
"A function that expects arguments can be defined as follows:\n"
"\n"
"    defmodule Foo do\n"
"      def sum(a, b) do\n"
"        a + b\n"
"      end\n"
"    end\n"
"\n"
"In the example above, a `sum/2` function is defined; this function receives\n"
"two arguments and returns their sum.\n"
"\n"
"## Function and variable names\n"
"\n"
"Function and variable names have the following syntax:\n"
"A _lowercase ASCII letter_ or an _underscore_, followed by any number of\n"
"_lowercase or uppercase ASCII letters_, _numbers_, or _underscores_.\n"
"Optionally they can end in either an _exclamation mark_ or a _question "
"mark_.\n"
"\n"
"For variables, any identifier starting with an underscore should indicate "
"an\n"
"unused variable. For example:\n"
"\n"
"    def foo(bar) do\n"
"      []\n"
"    end\n"
"    #=> warning: variable bar is unused\n"
"\n"
"    def foo(_bar) do\n"
"      []\n"
"    end\n"
"    #=> no warning\n"
"\n"
"    def foo(_bar) do\n"
"      _bar\n"
"    end\n"
"    #=> warning: the underscored variable \"_bar\" is used after being set\n"
"\n"
"## rescue/catch/after\n"
"\n"
"Function bodies support `rescue`, `catch` and `after` as `SpecialForms."
"try/1`\n"
"does. The following two functions are equivalent:\n"
"\n"
"    def format(value) do\n"
"      try do\n"
"        format!(value)\n"
"      catch\n"
"        :exit, reason -> {:error, reason}\n"
"      end\n"
"    end\n"
"\n"
"    def format(value) do\n"
"      format!(value)\n"
"    catch\n"
"      :exit, reason -> {:error, reason}\n"
"    end\n"
"\n"
msgstr ""
"指定した名前と本体で関数を定義します。\n"
"\n"
"## 例\n"
"\n"
"    defmodule Foo do\n"
"      def bar, do: :baz\n"
"    end\n"
"\n"
"    Foo.bar #=> :baz\n"
"\n"
"引数を持つ関数は次のように定義することができます。\n"
"\n"
"    defmodule Foo do\n"
"      def sum(a, b) do\n"
"        a + b\n"
"      end\n"
"    end\n"
"\n"
"上の例では`sum/2`関数が定義されました。この関数は2つの引数を\n"
"受け取り、その合計を返します。\n"
"\n"
"## 関数と変数の名前\n"
"\n"
"関数と変数の名前のシンタックスは次のとおりです:\n"
"_小文字のASCII文字_ または _アンダースコア_ に続けて、\n"
"任意の数の _小文字または大文字のASCII文字_ 、 _数字_ 、または\n"
"_アンダースコア_ です。\n"
"オプションで、末尾に_感嘆符_ または _疑問符_ をつけることもできます。\n"
"\n"
"変数において、アンダースコアで始まる任意の識別子は、利用しない変数を\n"
"示すべきです。たとえば、 \n"
"\n"
"    def foo(bar) do\n"
"      []\n"
"    end\n"
"    #=> warning: variable bar is unused\n"
"\n"
"    def foo(_bar) do\n"
"      []\n"
"    end\n"
"    #=> no warning\n"
"\n"
"    def foo(_bar) do\n"
"      _bar\n"
"    end\n"
"    #=> warning: the underscored variable \"_bar\" is used after being set\n"
"\n"
"## rescue/catch/after\n"
"\n"
"関数本体では、`SpecialForms.try/1`を実行する際に、`rescue`、`catch`、\n"
"`after`が使えます。\n"
"\n"
"    def format(value) do\n"
"      try do\n"
"        format!(value)\n"
"      catch\n"
"        :exit, reason -> {:error, reason}\n"
"      end\n"
"    end\n"
"\n"
"    def format(value) do\n"
"      format!(value)\n"
"    catch\n"
"      :exit, reason -> {:error, reason}\n"
"    end\n"
"\n"

#. TRANSLATORS: def Kernel.is_reference(term)
#: lib/kernel.ex:428
msgid ""
"Returns `true` if `term` is a reference; otherwise returns `false`.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
msgstr ""
"`term`がリファレンスの場合は`true`を返します。それ以外は`false`を返します。\n"
"\n"
"ガードテストに使えます。コンパイラによりインライン化されます。\n"

#. TRANSLATORS: def Kernel.+(left, right)
#: lib/kernel.ex:857
msgid ""
"Arithmetic addition.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> 1 + 2\n"
"    3\n"
"\n"
msgstr ""
"算術的加算です。\n"
"\n"
"ガードテストで使えます。コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> 1 + 2\n"
"    3\n"
"\n"

#. TRANSLATORS: def Kernel.get_and_update_in(data, keys, fun)
#: lib/kernel.ex:1856
msgid ""
"Gets a value and updates a nested structure.\n"
"\n"
"`data` is a nested structure (ie. a map, keyword\n"
"list, or struct that implements the `Access` behaviour).\n"
"\n"
"The `fun` argument receives the value of `key` (or `nil` if `key`\n"
"is not present) and must return a two-element tuple: the \"get\" value\n"
"(the retrieved value, which can be operated on before being returned)\n"
"and the new value to be stored under `key`. The `fun` may also\n"
"return `:pop`, implying the current value shall be removed\n"
"from the structure and returned.\n"
"\n"
"It uses the `Access` module to traverse the structures\n"
"according to the given `keys`, unless the `key` is a\n"
"function.\n"
"\n"
"If a key is a function, the function will be invoked\n"
"passing three arguments, the operation (`:get_and_update`),\n"
"the data to be accessed, and a function to be invoked next.\n"
"\n"
"This means `get_and_update_in/3` can be extended to provide\n"
"custom lookups. The downside is that functions cannot be stored\n"
"as keys in the accessed data structures.\n"
"\n"
"## Examples\n"
"\n"
"This function is useful when there is a need to retrieve the current\n"
"value (or something calculated in function of the current value) and\n"
"update it at the same time. For example, it could be used to increase\n"
"the age of a user by one and return the previous age in one pass:\n"
"\n"
"    iex> users = %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}\n"
"    iex> get_and_update_in(users, [\"john\", :age], &{&1, &1 + 1})\n"
"    {27, %{\"john\" => %{age: 28}, \"meg\" => %{age: 23}}}\n"
"\n"
"When one of the keys is a function, the function is invoked.\n"
"In the example below, we use a function to get and increment all\n"
"ages inside a list:\n"
"\n"
"    iex> users = [%{name: \"john\", age: 27}, %{name: \"meg\", age: 23}]\n"
"    iex> all = fn :get_and_update, data, next ->\n"
"    ...>   Enum.map(data, next) |> :lists.unzip\n"
"    ...> end\n"
"    iex> get_and_update_in(users, [all, :age], &{&1, &1 + 1})\n"
"    {[27, 23], [%{name: \"john\", age: 28}, %{name: \"meg\", age: 24}]}\n"
"\n"
"If the previous value before invoking the function is `nil`,\n"
"the function *will* receive `nil` as a value and must handle it\n"
"accordingly (be it by failing or providing a sane default).\n"
"\n"
"The `Access` module ships with many convenience accessor functions,\n"
"like the `all` anonymous function defined above. See `Access.all/0`,\n"
"`Access.key/2` and others as examples.\n"
msgstr ""
"ネストした構造体から値を取得して、更新します。\n"
"\n"
"`data`はネストした構造体（すなわち、マップ、キーワードリスト、\n"
"`Access`ビヘイビアを実装した構造体）です。\n"
"\n"
"引数`fun`は、`key`の値（`key`が存在しない場合は`nil`）を受け取り、\n"
"「取得した」値（取り出した値で、返す前に操作することができます）と\n"
"`key`の下に格納される新たしい値からなる、2要素タプルを返さなければ\n"
"なりません。`fun`は`:pop`を返すこともできます。これは現在の値が\n"
"構造体から削除され、その値が返されることを意味します。\n"
"\n"
"`key`が関数でないかぎり、`Access`モジュールを使って指定した`key`に\n"
"基いて構造体を走査します。\n"
"\n"
"キーが関数の場合、その関数に、3つの引数、すなわち、\n"
"操作（`:get_and_update`）、アクセスするべきデータ、\n"
"次に実行する関数が渡されて実行されます。\n"
"\n"
"これは、独自の検索方法を提供するよう、`get_and_update_in/3`は\n"
"拡張可能であることを意味します。欠点は、アクセスされるデータ\n"
"構造体にキーとして格納できないことです。\n"
"\n"
"## 例\n"
"\n"
"この関数は、現在の値(または現在の値で計算される何か)の取得と\n"
"更新を同時に行いたい場合に便利です。たとえば、ユーザの年齢に\n"
"1を足することと、これまでの年齢を返すことを一度に行えます。\n"
"\n"
"    iex> users = %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}\n"
"    iex> get_and_update_in(users, [\"john\", :age], &{&1, &1 + 1})\n"
"    {27, %{\"john\" => %{age: 28}, \"meg\" => %{age: 23}}}\n"
"\n"
"キーの一つが関数の場合、関数が実行されます。\n"
"下の例では、リスト中のすべての年齢を取得し、増加させるために\n"
"関数を使っています:\n"
"\n"
"    iex> users = [%{name: \"john\", age: 27}, %{name: \"meg\", age: 23}]\n"
"    iex> all = fn :get_and_update, data, next ->\n"
"    ...>   Enum.map(data, next) |> List.unzip() |> List.to_tuple()\n"
"    ...> end\n"
"    iex> get_and_update_in(users, [all, :age], &{&1, &1 + 1})\n"
"    {[27, 23], [%{name: \"john\", age: 28}, %{name: \"meg\", age: 24}]}\n"
"\n"
"関数を実行する前の以前の値がnilの場合、関数は値として`nil`を受け取\n"
"*ります*ので、状況に応じて（失敗するとか、健全なデフォルトの値を\n"
"提供するなど）処理しなければなりません。\n"
"\n"
"`Access`モジュールは、上で定義した`all`無名関数のような、便利な\n"
"アクセサ関数をたくさん提供しています。例として、`Access.all/0`や\n"
"`Access.key/2`などを参照してください。\n"

#. TRANSLATORS: def Kernel.is_float(term)
#: lib/kernel.ex:338
msgid ""
"Returns `true` if `term` is a floating point number; otherwise returns "
"`false`.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
msgstr ""
"`term`が浮動小数点数の場合は`true`を返します。それ以外は`false`を返します。\n"
"\n"
"ガードテストに使えます。コンパイラによりインライン化されます。\n"

#. TRANSLATORS: defmacro Kernel.|>(left, right)
#: lib/kernel.ex:2771
msgid ""
"Pipe operator.\n"
"\n"
"This operator introduces the expression on the left-hand side as\n"
"the first argument to the function call on the right-hand side.\n"
"\n"
"## Examples\n"
"\n"
"    iex> [1, [2], 3] |> List.flatten()\n"
"    [1, 2, 3]\n"
"\n"
"The example above is the same as calling `List.flatten([1, [2], 3])`.\n"
"\n"
"The `|>` operator is mostly useful when there is a desire to execute a "
"series\n"
"of operations resembling a pipeline:\n"
"\n"
"    iex> [1, [2], 3] |> List.flatten |> Enum.map(fn x -> x * 2 end)\n"
"    [2, 4, 6]\n"
"\n"
"In the example above, the list `[1, [2], 3]` is passed as the first "
"argument\n"
"to the `List.flatten/1` function, then the flattened list is passed as the\n"
"first argument to the `Enum.map/2` function which doubles each element of "
"the\n"
"list.\n"
"\n"
"In other words, the expression above simply translates to:\n"
"\n"
"    Enum.map(List.flatten([1, [2], 3]), fn x -> x * 2 end)\n"
"\n"
"## Pitfalls\n"
"\n"
"There are two common pitfalls when using the pipe operator.\n"
"\n"
"The first one is related to operator precedence. For example,\n"
"the following expression:\n"
"\n"
"    String.graphemes \"Hello\" |> Enum.reverse\n"
"\n"
"Translates to:\n"
"\n"
"    String.graphemes(\"Hello\" |> Enum.reverse)\n"
"\n"
"which results in an error as the `Enumerable` protocol is not defined\n"
"for binaries. Adding explicit parentheses resolves the ambiguity:\n"
"\n"
"    String.graphemes(\"Hello\") |> Enum.reverse\n"
"\n"
"Or, even better:\n"
"\n"
"    \"Hello\" |> String.graphemes |> Enum.reverse\n"
"\n"
"The second pitfall is that the `|>` operator works on calls.\n"
"For example, when you write:\n"
"\n"
"    \"Hello\" |> some_function()\n"
"\n"
"Elixir sees the right-hand side is a function call and pipes\n"
"to it. This means that, if you want to pipe to an anonymous\n"
"or captured function, it must also be explicitly called.\n"
"\n"
"Given the anonymous function:\n"
"\n"
"    fun = fn x -> IO.puts(x) end\n"
"    fun.(\"Hello\")\n"
"\n"
"This won't work as it will rather try to invoke the local\n"
"function `fun`:\n"
"\n"
"    \"Hello\" |> fun()\n"
"\n"
"This works:\n"
"\n"
"    \"Hello\" |> fun.()\n"
"\n"
"As you can see, the `|>` operator retains the same semantics\n"
"as when the pipe is not used since both require the `fun.(...)`\n"
"notation.\n"
msgstr ""
"パイプオペレータです。\n"
"\n"
"この演算子は左辺の式を、右辺の関数呼び出しの第1引数として取り込みます。\n"
"\n"
"## 例\n"
"\n"
"    iex> [1, [2], 3] |> List.flatten()\n"
"    [1, 2, 3]\n"
"\n"
"上の例は、`List.flatten([1, [2], 3])`を呼び出すのと同じです。\n"
"\n"
"`|>`演算子は、パイプラインに似た一連の操作を実行したいほとんどの\n"
"場合で便利です。\n"
"\n"
"    iex> [1, [2], 3] |> List.flatten |> Enum.map(fn x -> x * 2 end)\n"
"    [2, 4, 6]\n"
"\n"
"上の例では、リスト`[1, [2], 3]`が第1引数として`List.flatten/1`関数に渡さ"
"れ、\n"
"次に、平坦化されたリストが第1引数として`Enum.map/2`関数に渡され、\n"
"リストの各要素が2倍されます。\n"
"\n"
"言い替えると、上の式は単に以下のように翻訳できます。\n"
"\n"
"    Enum.map(List.flatten([1, [2], 3]), fn x -> x * 2 end)\n"
"\n"
"## 落とし穴\n"
"\n"
"パイプオペレータを使用する際の一般的な落とし穴が2つあります。\n"
"\n"
"1つめの落とし穴は演算子の優先順位に関係するものです。たとえば、\n"
"次の式\n"
"\n"
"    String.graphemes \"Hello\" |> Enum.reverse\n"
"\n"
"は、次のように翻訳されます:\n"
"\n"
"    String.graphemes(\"Hello\" |> Enum.reverse)\n"
"\n"
"`Enumerable`プロトコルはバイナリでは定義されていないので、これは\n"
"エラーになります。明示的に括弧を追加すると曖昧さがなくなります。\n"
"\n"
"    String.graphemes(\"Hello\") |> Enum.reverse\n"
"\n"
"次のほうがさらに良い方法です。\n"
"\n"
"    \"Hello\" |> String.graphemes |> Enum.reverse\n"
"\n"
"第2の落とし穴は、`|>`演算子は呼び出し時に動作することです。たとえば、\n"
"次のように書くと、\n"
"\n"
"    \"Hello\" |> some_function()\n"
"\n"
"Elixirは右辺を関数呼び出しとみなし、それにパイプをつなぎます。\n"
"これは無名関数やキャプチャした関数にパイプをつなげたい場合は\n"
"明示的に呼び出す必要があることを意味します。\n"
"\n"
"次のような無名関数があると仮定します。\n"
"\n"
"    fun = fn x -> IO.puts(x) end\n"
"    fun.(\"Hello\")\n"
"\n"
"次は動きません。なぜなら、ローカル関数`fun`を実行しようとするからです。\n"
"\n"
"    \"Hello\" |> fun()\n"
"\n"
"次は動きます。\n"
"\n"
"    \"Hello\" |> fun.()\n"
"\n"
"ご覧のように、`|>`演算子はパイプが使用されていない時と同じセマンティクスを\n"
"保持します。どちらも`fun.(...)`標記を必要とするからです。\n"

#. TRANSLATORS: def Kernel.-(value)
#: lib/kernel.ex:911
msgid ""
"Arithmetic unary minus.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> -2\n"
"    -2\n"
"\n"
msgstr ""
"算術的単項マイナスです。\n"
"\n"
"ガードテストで使えます。コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> -2\n"
"    -2\n"
"\n"

#. TRANSLATORS: defmacro Kernel.binding(context \\ nil)
#: lib/kernel.ex:2472
msgid ""
"Returns the binding for the given context as a keyword list.\n"
"\n"
"In the returned result, keys are variable names and values are the\n"
"corresponding variable values.\n"
"\n"
"If the given `context` is `nil` (by default it is), the binding for the\n"
"current context is returned.\n"
"\n"
"## Examples\n"
"\n"
"    iex> x = 1\n"
"    iex> binding()\n"
"    [x: 1]\n"
"    iex> x = 2\n"
"    iex> binding()\n"
"    [x: 2]\n"
"\n"
"    iex> binding(:foo)\n"
"    []\n"
"    iex> var!(x, :foo) = 1\n"
"    1\n"
"    iex> binding(:foo)\n"
"    [x: 1]\n"
"\n"
msgstr ""
"指定したコンテキストのバインディングをキーワードリストで返します。\n"
"\n"
"返り値の、キーは変数名であり、値は対応する変数値です。\n"
"\n"
"指定した`context`が`nil`（デフォルトでもあります）の場合、\n"
"現在のコンテキストのバインディングが返されます。\n"
"\n"
"\n"
"## 例\n"
"\n"
"    iex> x = 1\n"
"    iex> binding()\n"
"    [x: 1]\n"
"    iex> x = 2\n"
"    iex> binding()\n"
"    [x: 2]\n"
"\n"
"    iex> binding(:foo)\n"
"    []\n"
"    iex> var!(x, :foo) = 1\n"
"    1\n"
"    iex> binding(:foo)\n"
"    [x: 1]\n"
"\n"

#. TRANSLATORS: def Kernel.throw(term)
#: lib/kernel.ex:784
msgid ""
"A non-local return from a function.\n"
"\n"
"Check `Kernel.SpecialForms.try/1` for more information.\n"
"\n"
"Inlined by the compiler.\n"
msgstr ""
"関数からの非ローカルリターンです。\n"
"\n"
"詳細は`Kernel.SpecialForms.try/1`をチェックしてください。\n"
"\n"
"コンパイラによりインライン化されます。\n"

#. TRANSLATORS: defmacro Kernel.is_nil(term)
#: lib/kernel.ex:2259
msgid ""
"Returns `true` if `term` is `nil`, `false` otherwise.\n"
"\n"
"Allowed in guard clauses.\n"
"\n"
"## Examples\n"
"\n"
"    iex> is_nil(1)\n"
"    false\n"
"\n"
"    iex> is_nil(nil)\n"
"    true\n"
"\n"
msgstr ""
"`term`が、`nil`の場合は`true`を、それ以外は`false`を返します。\n"
"\n"
"ガード節で使えます。\n"
"\n"
"## 例\n"
"\n"
"    iex> is_nil(1)\n"
"    false\n"
"\n"
"    iex> is_nil(nil)\n"
"    true\n"
"\n"

#. TRANSLATORS: defmacro Kernel.defp(call, expr \\ nil)
#: lib/kernel.ex:3369
msgid ""
"Defines a private function with the given name and body.\n"
"\n"
"Private functions are only accessible from within the module in which they "
"are\n"
"defined. Trying to access a private function from outside the module it's\n"
"defined in results in an `UndefinedFunctionError` exception.\n"
"\n"
"Check `def/2` for more information.\n"
"\n"
"## Examples\n"
"\n"
"    defmodule Foo do\n"
"      def bar do\n"
"        sum(1, 2)\n"
"      end\n"
"\n"
"      defp sum(a, b), do: a + b\n"
"    end\n"
"\n"
"    Foo.bar #=> 3\n"
"    Foo.sum(1, 2) #=> ** (UndefinedFunctionError) undefined function Foo."
"sum/2\n"
"\n"
msgstr ""
"指定した名前と本体でプライベート関数を定義します。\n"
"\n"
"プライベート関数は定義されたモジュール内からしかアクセスできません。\n"
"定義されたモジュールの外部からプライベート関数にアクセスしようとすると、\n"
"`UndefinedFunctionError`例外となります。\n"
"\n"
"詳細は `def/2` をチェックしてください。\n"
"\n"
"## 例\n"
"\n"
"    defmodule Foo do\n"
"      def bar do\n"
"        sum(1, 2)\n"
"      end\n"
"\n"
"      defp sum(a, b), do: a + b\n"
"    end\n"
"\n"
"    Foo.bar #=> 3\n"
"    Foo.sum(1, 2) #=> ** (UndefinedFunctionError) undefined function: Foo."
"sum/2\n"
"\n"

#. TRANSLATORS: defmacro Kernel.defmodule(alias, do_block)
#: lib/kernel.ex:3100
msgid ""
"Defines a module given by name with the given contents.\n"
"\n"
"This macro defines a module with the given `alias` as its name and with the\n"
"given contents. It returns a tuple with four elements:\n"
"\n"
"  * `:module`\n"
"  * the module name\n"
"  * the binary contents of the module\n"
"  * the result of evaluating the contents block\n"
"\n"
"## Examples\n"
"\n"
"    iex> defmodule Foo do\n"
"    ...>   def bar, do: :baz\n"
"    ...> end\n"
"    iex> Foo.bar\n"
"    :baz\n"
"\n"
"## Nesting\n"
"\n"
"Nesting a module inside another module affects the name of the nested "
"module:\n"
"\n"
"    defmodule Foo do\n"
"      defmodule Bar do\n"
"      end\n"
"    end\n"
"\n"
"In the example above, two modules - `Foo` and `Foo.Bar` - are created.\n"
"When nesting, Elixir automatically creates an alias to the inner module,\n"
"allowing the second module `Foo.Bar` to be accessed as `Bar` in the same\n"
"lexical scope where it's defined (the `Foo` module).\n"
"\n"
"If the `Foo.Bar` module is moved somewhere else, the references to `Bar` in\n"
"the `Foo` module need to be updated to the fully-qualified name (`Foo.Bar`) "
"or\n"
"an alias has to be explicitly set in the `Foo` module with the help of\n"
"`Kernel.SpecialForms.alias/2`.\n"
"\n"
"    defmodule Foo.Bar do\n"
"      # code\n"
"    end\n"
"\n"
"    defmodule Foo do\n"
"      alias Foo.Bar\n"
"      # code here can refer to \"Foo.Bar\" as just \"Bar\"\n"
"    end\n"
"\n"
"## Module names\n"
"\n"
"A module name can be any atom, but Elixir provides a special syntax which "
"is\n"
"usually used for module names. What is called a module name is an\n"
"_uppercase ASCII letter_ followed by any number of _lowercase or\n"
"uppercase ASCII letters_, _numbers_, or _underscores_.\n"
"This identifier is equivalent to an atom prefixed by `Elixir.`. So in the\n"
"`defmodule Foo` example `Foo` is equivalent to `:\"Elixir.Foo\"`\n"
"\n"
"## Dynamic names\n"
"\n"
"Elixir module names can be dynamically generated. This is very\n"
"useful when working with macros. For instance, one could write:\n"
"\n"
"    defmodule String.to_atom(\"Foo#{1}\") do\n"
"      # contents ...\n"
"    end\n"
"\n"
"Elixir will accept any module name as long as the expression passed as the\n"
"first argument to `defmodule/2` evaluates to an atom.\n"
"Note that, when a dynamic name is used, Elixir won't nest the name under "
"the\n"
"current module nor automatically set up an alias.\n"
"\n"
msgstr ""
"指定した名前で指定の内容を持つモジュールを定義します。\n"
"\n"
"このマクロは、指定した`alias`を名前に、指定した内容を持つモジュールを\n"
"定義します。\n"
"\n"
"以下の4要素タプルを返します。\n"
"\n"
"  * `:module`\n"
"  * モジュール名\n"
"  * モジュールのバイナリコンテンツ\n"
"  * コンテンツブロックの評価結果\n"
"\n"
"## 例\n"
"\n"
"    iex> defmodule Foo do\n"
"    ...>   def bar, do: :baz\n"
"    ...> end\n"
"    iex> Foo.bar\n"
"    :baz\n"
"\n"
"## ネスト\n"
"\n"
"別のモジュールの中にモジュールをネストすると、ネストしたモジュールの名前に\n"
"影響を及ぼします:\n"
"\n"
"    defmodule Foo do\n"
"      defmodule Bar do\n"
"      end\n"
"    end\n"
"\n"
"上の例では2つのモジュール`Foo`と`Foo.Bar`が作成されます。\n"
"モジュールをネストすると、Elixirは自動的に内部モジュールのエイリアスを\n"
"作成するので、2番目のモジュール`Foo.Bar`はそれが定義された同じ\n"
"レキシカルスコープ（`Foo`モジュール）の中では`Bar`としてアクセスできます。\n"
"\n"
"`Foo.Bar`モジュールを何処か別の場所に移動した場合、`Foo`モジュール内の\n"
"`Bar`への参照は、完全修飾名（`Foo.Bar`）に変更するか、`Foo`モジュール内で\n"
"`Kernel.SpecialForms.alias/2`を使って明示的にエイリアスを設定する必要が\n"
"あります。\n"
"\n"
"    defmodule Foo.Bar do\n"
"      # コード\n"
"    end\n"
"\n"
"    defmodule Foo do\n"
"      alias Foo.Bar\n"
"      # ここのコードは\"Foo.Bar”を単に\"Bar”で参照できる\n"
"    end\n"
"\n"
"## モジュール名\n"
"\n"
"モジュール名には任意のアトムが使用できますが、Elixirは、モジュール名として\n"
"通常使用される特別な構文を提供しています。モジュール名と呼ばれているもの"
"は、\n"
"_大文字のASCII文字_ に、任意の数の _小文字または大文字のASCII文字_ 、\n"
"_数字_ 、 _アンダースコア_ が続くものです。この識別子は、接頭辞として`Elixir."
"`が\n"
"ついたアトムと同等です。つまり、例にあげた`defmodule Foo`のFooは、\n"
"`:\"Elixir.Foo\"`と同等です。\n"
"\n"
"## 動的な名前\n"
"\n"
"Elixirのモジュール名は動的に生成することができます。これは\n"
"マクロで使用する際に非常に役立ちます。たとえば、次のように畫けます。\n"
"\n"
"    defmodule String.to_atom(\"Foo#{1}\") do\n"
"      # contents ...\n"
"    end\n"
"\n"
"Elixirは、`defmodule/2`の第1引数として渡された式がアトムとして評価される\n"
"ものであれば、どんなモジュール名も受け入れます。動的な名前を使用する際は、\n"
"Elixirは現在のモジュールの下に名前をネストしたり、自動的にエイリアスを設定\n"
"したりすることはないことに注意してください。\n"
"\n"

#. TRANSLATORS: def Kernel.put_in(data, keys, value)
#: lib/kernel.ex:1812
msgid ""
"Puts a value in a nested structure.\n"
"\n"
"Uses the `Access` module to traverse the structures\n"
"according to the given `keys`, unless the `key` is a\n"
"function. If the key is a function, it will be invoked\n"
"as specified in `get_and_update_in/3`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> users = %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}\n"
"    iex> put_in(users, [\"john\", :age], 28)\n"
"    %{\"john\" => %{age: 28}, \"meg\" => %{age: 23}}\n"
"\n"
"In case any of entries in the middle returns `nil`,\n"
"an error will be raised when trying to access it next.\n"
msgstr ""
"ネストした構造に値をプットします。\n"
"\n"
"`key`が関数でないかぎり、`Access`プロトコルを使って指定した\n"
"`keys`に基いて構造体を走査します。キーが関数の場合は、`get_and_update_in/3`"
"で\n"
"説明したように関数が実行されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> users = %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}\n"
"    iex> put_in(users, [\"john\", :age], 28)\n"
"    %{\"john\" => %{age: 28}, \"meg\" => %{age: 23}}\n"
"\n"
"中間の項目のいずれかが`nil`を返した場合、次にそれをアクセスした\n"
"際にエラーが発生します。\n"

#. TRANSLATORS: def Kernel.send(dest, msg)
#: lib/kernel.ex:625
msgid ""
"Sends a message to the given `dest` and returns the message.\n"
"\n"
"`dest` may be a remote or local PID, a (local) port, a locally\n"
"registered name, or a tuple `{registered_name, node}` for a registered\n"
"name at another node.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> send self(), :hello\n"
"    :hello\n"
"\n"
msgstr ""
"指定した`dest`にメッセージを送信し、そのメッセージを返します。\n"
"\n"
"`dest`には、リモートまたはローカルのPID、(ローカル)ポート、ローカルに\n"
"登録された名前、別のノードで登録された名前の場合はタプル\n"
"`{registered_name, node}`を指定できます。\n"
"\n"
"コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> send self(), :hello\n"
"    :hello\n"
"\n"

#. TRANSLATORS: def Kernel.self()
#: lib/kernel.ex:645
msgid ""
"Returns the PID (process identifier) of the calling process.\n"
"\n"
"Allowed in guard clauses. Inlined by the compiler.\n"
msgstr ""
"呼び出したプロセスのPID(プロセス識別子)を返します。\n"
"\n"
"ガード節で使用できます。コンパイラによりインライン化されます。\n"

#. TRANSLATORS: def Kernel.make_ref()
#: lib/kernel.ex:474
msgid ""
"Returns an almost unique reference.\n"
"\n"
"The returned reference will re-occur after approximately 2^82 calls;\n"
"therefore it is unique enough for practical purposes.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    make_ref() #=> #Reference<0.0.0.135>\n"
"\n"
msgstr ""
"ほとんどユニークなリファレンスを返します。\n"
"\n"
"返されたリファレンスはおよそ2^82回呼び出すと再び発生します;\n"
"したがって、実用上は十分にユニークです。\n"
"\n"
"コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    make_ref() #=> #Reference<0.0.0.135>\n"
"\n"

#. TRANSLATORS: def Kernel.div(dividend, divisor)
#: lib/kernel.ex:160
msgid ""
"Performs an integer division.\n"
"\n"
"Raises an `ArithmeticError` exception if one of the arguments is not an\n"
"integer, or when the `divisor` is `0`.\n"
"\n"
"Allowed in guard tests. Inlined by the compiler.\n"
"\n"
"`div/2` performs *truncated* integer division. This means that\n"
"the result is always rounded towards zero.\n"
"\n"
"If you want to perform floored integer division (rounding towards negative "
"infinity),\n"
"use `Integer.floor_div/2` instead.\n"
"\n"
"## Examples\n"
"\n"
"    div(5, 2)\n"
"    #=> 2\n"
"\n"
"    div(6, -4)\n"
"    #=> -1\n"
"\n"
"    div(-99, 2)\n"
"    #=> -49\n"
"\n"
"    div(100, 0)\n"
"    #=> ** (ArithmeticError) bad argument in arithmetic expression\n"
"\n"
msgstr ""
"整数割り算を実行します。\n"
"\n"
"引数のいずれかが整数でない場合、あるいは`divisor`が`0`の場合は\n"
"`ArithmeticError`例外が発生します。\n"
"\n"
"ガードテストに使えます。コンパイラによりインライン化されます。\n"
"\n"
"`div/2` は整数の*truncated* な割り算を行います。これは\n"
"結果が常に０の方向に丸められることを意味します。\n"
"\n"
"整数のflooredな割り算（負の無限大方向絵の丸め）を行いたい場合は、\n"
"`Integer.floor_div/2` を使ってください。\n"
"\n"
"## 例\n"
"\n"
"    div(5, 2)\n"
"    #=> 2\n"
"\n"
"    div(6, -4)\n"
"    #=> -1\n"
"\n"
"    div(-99, 2)\n"
"    #=> -49\n"
"\n"
"    div(100, 0)\n"
"    #=> ** (ArithmeticError) bad argument in arithmetic expression\n"
"\n"

#. TRANSLATORS: def Kernel.function_exported?(module, function, arity)
#: lib/kernel.ex:2861
msgid ""
"Returns `true` if `module` is loaded and contains a\n"
"public `function` with the given `arity`, otherwise `false`.\n"
"\n"
"Note that this function does not load the module in case\n"
"it is not loaded. Check `Code.ensure_loaded/1` for more\n"
"information.\n"
"\n"
"## Examples\n"
"\n"
"    iex> function_exported?(Enum, :member?, 2)\n"
"    true\n"
"\n"
msgstr ""
"`module`がロードされており、指定した`arity`の公開`function`が\n"
"含まれている場合は`true`を返し、それ以外は`false`を返します。\n"
"\n"
"この関数は、モジュールがロードされていない場合、ロードを\n"
"しないことに注意してください。詳細は`Code.ensure_loaded/1`を\n"
"チェックしてください。\n"
"\n"
"## 例\n"
"\n"
"    iex> function_exported?(Enum, :member?, 2)\n"
"    true\n"
"\n"

#. TRANSLATORS: defmacro Kernel.sigil_R(term, modifiers)
#: lib/kernel.ex:4257
msgid ""
"Handles the sigil `~R`.\n"
"\n"
"It returns a regular expression pattern without escaping\n"
"nor interpreting interpolations.\n"
"\n"
"More information on regexes can be found in the `Regex` module.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Regex.match?(~R(f#{1,3}o), \"f#o\")\n"
"    true\n"
"\n"
msgstr ""
"シジル`~R`を処理します。\n"
"\n"
"文字のエスケープや式の埋め込みをすることなく、\n"
"正規表現パターンを返します。\n"
"\n"
"正規表現の詳細に関しては`Regex`モジュールを参照してください。\n"
"\n"
"## 例\n"
"\n"
"    iex> Regex.match?(~R(f#{1,3}o), \"f#o\")\n"
"    true\n"
"\n"

#. TRANSLATORS: defmacro Kernel.defprotocol(name, do_block)
#: lib/kernel.ex:3711
msgid ""
"Defines a protocol.\n"
"\n"
"A protocol specifies an API that should be defined by its\n"
"implementations.\n"
"\n"
"## Examples\n"
"\n"
"In Elixir, we have two verbs for checking how many items there\n"
"are in a data structure: `length` and `size`.  `length` means the\n"
"information must be computed. For example, `length(list)` needs to\n"
"traverse the whole list to calculate its length. On the other hand,\n"
"`tuple_size(tuple)` and `byte_size(binary)` do not depend on the\n"
"tuple and binary size as the size information is precomputed in\n"
"the data structure.\n"
"\n"
"Although Elixir includes specific functions such as `tuple_size`,\n"
"`binary_size` and `map_size`, sometimes we want to be able to\n"
"retrieve the size of a data structure regardless of its type.\n"
"In Elixir we can write polymorphic code, i.e. code that works\n"
"with different shapes/types, by using protocols. A size protocol\n"
"could be implemented as follows:\n"
"\n"
"    defprotocol Size do\n"
"      @doc \"Calculates the size (and not the length!) of a data structure"
"\"\n"
"      def size(data)\n"
"    end\n"
"\n"
"Now that the protocol can be implemented for every data structure\n"
"the protocol may have a compliant implementation for:\n"
"\n"
"    defimpl Size, for: Binary do\n"
"      def size(binary), do: byte_size(binary)\n"
"    end\n"
"\n"
"    defimpl Size, for: Map do\n"
"      def size(map), do: map_size(map)\n"
"    end\n"
"\n"
"    defimpl Size, for: Tuple do\n"
"      def size(tuple), do: tuple_size(tuple)\n"
"    end\n"
"\n"
"Notice we didn't implement it for lists as we don't have the\n"
"`size` information on lists, rather its value needs to be\n"
"computed with `length`.\n"
"\n"
"It is possible to implement protocols for all Elixir types:\n"
"\n"
"  * Structs (see below)\n"
"  * `Tuple`\n"
"  * `Atom`\n"
"  * `List`\n"
"  * `BitString`\n"
"  * `Integer`\n"
"  * `Float`\n"
"  * `Function`\n"
"  * `PID`\n"
"  * `Map`\n"
"  * `Port`\n"
"  * `Reference`\n"
"  * `Any` (see below)\n"
"\n"
"## Protocols and Structs\n"
"\n"
"The real benefit of protocols comes when mixed with structs.\n"
"For instance, Elixir ships with many data types implemented as\n"
"structs, like `MapSet`. We can implement the `Size` protocol\n"
"for those types as well:\n"
"\n"
"    defimpl Size, for: MapSet do\n"
"      def size(map_set), do: MapSet.size(map_set)\n"
"    end\n"
"\n"
"When implementing a protocol for a struct, the `:for` option can\n"
"be omitted if the `defimpl` call is inside the module that defines\n"
"the struct:\n"
"\n"
"    defmodule User do\n"
"      defstruct [:email, :name]\n"
"\n"
"      defimpl Size do\n"
"        def size(%User{}), do: 2 # two fields\n"
"      end\n"
"    end\n"
"\n"
"If a protocol implementation is not found for a given type,\n"
"invoking the protocol will raise unless it is configured to\n"
"fallback to `Any`. Conveniences for building implementations\n"
"on top of existing ones are also available, look at `defstruct/1`\n"
"for more information about deriving\n"
"protocols.\n"
"\n"
"## Fallback to any\n"
"\n"
"In some cases, it may be convenient to provide a default\n"
"implementation for all types. This can be achieved by setting\n"
"the `@fallback_to_any` attribute to `true` in the protocol\n"
"definition:\n"
"\n"
"    defprotocol Size do\n"
"      @fallback_to_any true\n"
"      def size(data)\n"
"    end\n"
"\n"
"The `Size` protocol can now be implemented for `Any`:\n"
"\n"
"    defimpl Size, for: Any do\n"
"      def size(_), do: 0\n"
"    end\n"
"\n"
"Although the implementation above is arguably not a reasonable\n"
"one. For example, it makes no sense to say a PID or an Integer\n"
"have a size of 0. That's one of the reasons why `@fallback_to_any`\n"
"is an opt-in behaviour. For the majority of protocols, raising\n"
"an error when a protocol is not implemented is the proper behaviour.\n"
"\n"
"## Types\n"
"\n"
"Defining a protocol automatically defines a type named `t`, which\n"
"can be used as follows:\n"
"\n"
"    @spec print_size(Size.t) :: :ok\n"
"    def print_size(data) do\n"
"      IO.puts(case Size.size(data) do\n"
"        0 -> \"data has no items\"\n"
"        1 -> \"data has one item\"\n"
"        n -> \"data has #{n} items\"\n"
"      end)\n"
"    end\n"
"\n"
"The `@spec` above expresses that all types allowed to implement the\n"
"given protocol are valid argument types for the given function.\n"
"\n"
"## Reflection\n"
"\n"
"Any protocol module contains three extra functions:\n"
"\n"
"  * `__protocol__/1` - returns the protocol name when `:name` is given, and "
"a\n"
"    keyword list with the protocol functions and their arities when\n"
"    `:functions` is given\n"
"\n"
"  * `impl_for/1` - receives a structure and returns the module that\n"
"    implements the protocol for the structure, `nil` otherwise\n"
"\n"
"  * `impl_for!/1` - same as above but raises an error if an implementation "
"is\n"
"    not found\n"
"\n"
"        Enumerable.__protocol__(:functions)\n"
"        #=> [count: 1, member?: 2, reduce: 3]\n"
"\n"
"        Enumerable.impl_for([])\n"
"        #=> Enumerable.List\n"
"\n"
"        Enumerable.impl_for(42)\n"
"        #=> nil\n"
"\n"
"## Consolidation\n"
"\n"
"In order to cope with code loading in development, protocols in\n"
"Elixir provide a slow implementation of protocol dispatching specific\n"
"to development.\n"
"\n"
"In order to speed up dispatching in production environments, where\n"
"all implementations are known up-front, Elixir provides a feature\n"
"called protocol consolidation. For this reason, all protocols are\n"
"compiled with `debug_info` set to `true`, regardless of the option\n"
"set by `elixirc` compiler. The debug info though may be removed after\n"
"consolidation.\n"
"\n"
"Protocol consolidation is applied by default to all Mix projects.\n"
"For applying consolidation manually, please check the functions in\n"
"the `Protocol` module or the `mix compile.protocols` task.\n"
msgstr ""
"プロトコルを定義します。\n"
"\n"
"プロトコルはその実装が定義する必要のあるAPIを指定します。\n"
"\n"
"## 例\n"
"\n"
"Elixirでは、データ構造にいくつの項目があるかをチェックする2つの\n"
"動詞、`length`と`size`を持っています。`length`は情報が計算される\n"
"必要があることを意味します。たとえば、`length(list)`は、リストの長さを\n"
"計算するためにリスト全体を走査する必要があります。一方、`tuple_size(tuple)`"
"や\n"
"`byte_size(binary)`はタプルやバイナリのサイズに依存しません。データ構造内に\n"
"サイズ情報があらかじめ計算されているからです。\n"
"\n"
"Elixirには`tuple_size`や`binary_size`、`map_size`といった特定の関数が\n"
"ありますが、その型にかかわらずデータ構造のサイズを抽出できるようにしたと\n"
"思うことがあります。Elilxirではポリモーフィックなコード、すなわち、様々な\n"
"形や型で動作するコードを書くことができます。Sizeプロトコルは次のように定義\n"
"することができます。\n"
"\n"
"    defprotocol Size do\n"
"      @doc \"データ構造のサイズ（長さではない）を計算する\"\n"
"      def size(data)\n"
"    end\n"
"\n"
"すべてのデータ構造でプロトコルを実装できるようになったので、\n"
"次のようなプロトコルに準拠した実装を持つことができます。\n"
"\n"
"    defimpl Size, for: Binary do\n"
"      def size(binary), do: byte_size(binary)\n"
"    end\n"
"\n"
"    defimpl Size, for: Map do\n"
"      def size(map), do: map_size(map)\n"
"    end\n"
"\n"
"    defimpl Size, for: Tuple do\n"
"      def size(tuple), do: tuple_size(tuple)\n"
"    end\n"
"\n"
"リストについては実装していないことに注意してください。リストは`size`\n"
"情報を持っておらず、その値は`length`で計算する必要があるからです。\n"
"\n"
"Elixirのすべての型でプロトコルを実装することができます。\n"
"\n"
"  * 構造体（以下を参照）\n"
"  * `Tuple`\n"
"  * `Atom`\n"
"  * `List`\n"
"  * `BitString`\n"
"  * `Integer`\n"
"  * `Float`\n"
"  * `Function`\n"
"  * `PID`\n"
"  * `Map`\n"
"  * `Port`\n"
"  * `Reference`\n"
"  * `Any`（以下を参照）\n"
"\n"
"## プロトコルと構造体\n"
"\n"
"プロトコルの本当の利点は構造体と組み合わせた時に現れます。\n"
"たとえば、Elixirは、`MapSet`のように、構造体として実装されている\n"
"データタイプを数多く提供しています。そのような型にも`Size`プロトコルを\n"
"実装することができます。\n"
"\n"
"    defimpl Size, for: MapSet do\n"
"      def size(map_set), do: MapSet.size(map_set)\n"
"    end\n"
"\n"
"構造体のためのプロトコルを実装する際、その構造体を定義している\n"
"モジュール内で`defimpl`を呼び出す場合は`:for`オプションを\n"
"省略できます。\n"
"\n"
"    defmodule User do\n"
"      defstruct [:email, :name]\n"
"\n"
"      defimpl Size do\n"
"        def size(%User{}), do: 2 # フィールドは2つ\n"
"      end\n"
"    end\n"
"\n"
"指定した型にプロトコル実装が見つからない場合にそのプロトコルを呼び出すと、\n"
"`Any`型へのフォールバックが構成されていない限り、例外が発生します。\n"
"既存の実装の上に実行を構築するための便利関数も利用できます。プロトコルの\n"
"導出に関する詳細は`defstruct/1`を参照してください。\n"
"\n"
"## Any型へのフォールバック\n"
"\n"
"場合によっては、すべての型のためのデフォルト実装を提供すると\n"
"便利です。これはプロトコル定義で`@fallback_to_any`属性を`true`に\n"
"セットすることで実現できます。\n"
"\n"
"    defprotocol Size do\n"
"      @fallback_to_any true\n"
"      def size(data)\n"
"    end\n"
"\n"
"これで`Any`に対する`Size`プロトコルを実装できます。\n"
"\n"
"    defimpl Size, for: Any do\n"
"      def size(_), do: 0\n"
"    end\n"
"\n"
"この実装はもちろん合理的なものでありません。たとえば、PIDや整数の\n"
"サイズが0というのは意味がありません。これは`@fallback_to_any`が\n"
"オプトインビヘイビアである理由の1つです。大部分のプロトコルにとって、\n"
"プロトコルが実装されていない場合にエラーを発生させることは正しい\n"
"ふるまいです。\n"
"\n"
"## 型\n"
"\n"
"プロトコルを定義すると、自動的に`t`と呼ばれる型が定義されます。\n"
"これは以下のように使うことができます:\n"
"\n"
"    @spec print_size(Size.t) :: :ok\n"
"    def print_size(data) do\n"
"      IO.puts(case Size.size(data) do\n"
"        0 -> \"data has no items\"\n"
"        1 -> \"data has one item\"\n"
"        n -> \"data has #{n} items\"\n"
"      end)\n"
"    end\n"
"\n"
"上の`@spec`は、指定したプロトコルを実装できるすべての型が、指定した関数の\n"
"引数として有効な型であることを表します。\n"
"\n"
"## リフレクション\n"
"\n"
"すべてのプトロコルモジュールは3つの追加関数を持っています。\n"
"\n"
"  * `__protocol__/1` - `:name`が指定された場合はプロトコル名を、\n"
"    `:functions`が指定された場合はプロトコル関数とそのアリティを持つ\n"
"    キーワードリストを返します\n"
"\n"
"  * `impl_for/1` - 構造体を受け取り、その構造体に対するプロトコルを実装した\n"
"    モジュールを返します。そうでなければ、`nil`を返します\n"
"\n"
"  * `impl_for!/1` - 上と同じですが、実装が見付からないときにエラーを発生させ"
"ます。\n"
"\n"
"        Enumerable.__protocol__(:functions)\n"
"        #=> [count: 1, member?: 2, reduce: 3]\n"
"\n"
"        Enumerable.impl_for([])\n"
"        #=> Enumerable.List\n"
"\n"
"        Enumerable.impl_for(42)\n"
"        #=> nil\n"
"\n"
"## コンソリデーション\n"
"\n"
"開発時のコードローディングに対処するため、Elixirのプロトコルは\n"
"開発に特化したプロトコルディスパッチの遅い実装を提供します。\n"
"\n"
"事前にすべての実装がわかっている本番環境でディスパッチを高速化するために、\n"
"Elixirはプロトコルコンソリデーションと呼ばれる機能を提供しています。\n"
"このため、すべてのプロトコルは、`elixirc`コンパイラによるオプションの\n"
"設定に関わりなく、`debug_info`が`true`にセットされてコンパイルされます。\n"
"ただし、デバッグ情報はコンソリデーション後に削除されます。\n"
"\n"
"すべてのMixプロジェクトにはデフォルトでプロトコルコンソリデーションが\n"
"適用されます。コンソリデーションを手動で適用する方法に関しては\n"
"`Protocol`モジュールの関数、または、`mix compile.protocols`タスクを\n"
"チェックしてください。\n"

#. TRANSLATORS: defmacro Kernel.to_string(arg)
#: lib/kernel.ex:2230
msgid ""
"Converts the argument to a string according to the\n"
"`String.Chars` protocol.\n"
"\n"
"This is the function invoked when there is string interpolation.\n"
"\n"
"## Examples\n"
"\n"
"    iex> to_string(:foo)\n"
"    \"foo\"\n"
"\n"
msgstr ""
"`String.Chars`プロトコルに従って、引数を文字列に変換します。\n"
"\n"
"これは文字列に式の展開がある場合に起動される関数です。\n"
"\n"
"## 例\n"
"\n"
"    iex> to_string(:foo)\n"
"    \"foo\"\n"
"\n"

#. TRANSLATORS: defmacro Kernel.or(left, right)
#: lib/kernel.ex:1272
msgid ""
"Boolean or.\n"
"\n"
"If the first argument is `true`, `true` is returned; otherwise, the second\n"
"argument is returned.\n"
"\n"
"Requires only the first argument to be a boolean since it short-circuits.\n"
"If the first argument is not a boolean, an `ArgumentError` exception is\n"
"raised.\n"
"\n"
"Allowed in guard tests.\n"
"\n"
"## Examples\n"
"\n"
"    iex> true or false\n"
"    true\n"
"    iex> false or 42\n"
"    42\n"
"\n"
msgstr ""
"論理和です。\n"
"\n"
"第1引数が`true`の場合、`true`が返されます。そうでない場合は、第2引数が\n"
"返されます。\n"
"\n"
"短絡演算子なので、第1引数のみ論理値である必要があります。第1引数が論理値で\n"
"ない場合は、`ArgumentError`例外が発生します。\n"
"\n"
"ガードテストで使えます。\n"
"\n"
"## 例\n"
"\n"
"    iex> true or false\n"
"    true\n"
"    iex> false or 42\n"
"    42\n"
"\n"

#. TRANSLATORS: def Kernel.spawn_link(module, fun, args)
#: lib/kernel.ex:724
msgid ""
"Spawns the given module and function passing the given args,\n"
"links it to the current process and returns its PID.\n"
"\n"
"Check the `Process` and `Node` modules for other functions\n"
"to handle processes, including spawning functions in nodes.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    spawn_link(SomeModule, :function, [1, 2, 3])\n"
"\n"
msgstr ""
"指定した引数を渡して、指定したモジュールの関数を生成し、\n"
"それを現在のプロセスにリンクして、そのPIDを返します。\n"
"\n"
"別のノードでの関数の生成を含む、プロセスを扱うその他の関数に\n"
"ついては`Process`モジュールと`Node`モジュールをチェックしてください。\n"
"\n"
"コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    spawn_link(SomeModule, :function, [1, 2, 3])\n"
"\n"

#. TRANSLATORS: def Kernel.put_elem(tuple, index, value)
#: lib/kernel.ex:1253
msgid ""
"Inserts `value` at the given zero-based `index` in `tuple`.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> tuple = {:foo, :bar, 3}\n"
"    iex> put_elem(tuple, 0, :baz)\n"
"    {:baz, :bar, 3}\n"
"\n"
msgstr ""
"`tuple`のゼロ始まりの指定した`index`の位置に`value`を挿入します。\n"
"\n"
"コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> tuple = {:foo, :bar, 3}\n"
"    iex> put_elem(tuple, 0, :baz)\n"
"    {:baz, :bar, 3}\n"
"\n"

#. TRANSLATORS: defmacro Kernel.sigil_r(term, modifiers)
#: lib/kernel.ex:4228
msgid ""
"Handles the sigil `~r`.\n"
"\n"
"It returns a regular expression pattern, unescaping characters and "
"replacing\n"
"interpolations.\n"
"\n"
"More information on regexes can be found in the `Regex` module.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Regex.match?(~r(foo), \"foo\")\n"
"    true\n"
"\n"
"    iex> Regex.match?(~r/abc/, \"abc\")\n"
"    true\n"
"\n"
msgstr ""
"シジル`~r`を処理します。\n"
"\n"
"文字をアンエスケープし、式の埋め込みを行った正規表現パターンを返します。\n"
"\n"
"正規表現に関する詳細は`Regex`モジュールを参照してください。\n"
"\n"
"## 例\n"
"\n"
"    iex> Regex.match?(~r(foo), \"foo\")\n"
"    true\n"
"\n"
"    iex> Regex.match?(~r/abc/, \"abc\")\n"
"    true\n"
"\n"

#. TRANSLATORS: defmacro Kernel.defexception(fields)
#: lib/kernel.ex:3616
msgid ""
"Defines an exception.\n"
"\n"
"Exceptions are structs backed by a module that implements\n"
"the `Exception` behaviour. The `Exception` behaviour requires\n"
"two functions to be implemented:\n"
"\n"
"  * `exception/1` - receives the arguments given to `raise/2`\n"
"    and returns the exception struct. The default implementation\n"
"    accepts either a set of keyword arguments that is merged into\n"
"    the struct or a string to be used as the exception's message.\n"
"\n"
"  * `message/1` - receives the exception struct and must return its\n"
"    message. Most commonly exceptions have a message field which\n"
"    by default is accessed by this function. However, if an exception\n"
"    does not have a message field, this function must be explicitly\n"
"    implemented.\n"
"\n"
"Since exceptions are structs, the API supported by `defstruct/1`\n"
"is also available in `defexception/1`.\n"
"\n"
"## Raising exceptions\n"
"\n"
"The most common way to raise an exception is via `raise/2`:\n"
"\n"
"    defmodule MyAppError do\n"
"      defexception [:message]\n"
"    end\n"
"\n"
"    value = [:hello]\n"
"\n"
"    raise MyAppError,\n"
"      message: \"did not get what was expected, got: #{inspect value}\"\n"
"\n"
"In many cases it is more convenient to pass the expected value to\n"
"`raise/2` and generate the message in the `c:Exception.exception/1` "
"callback:\n"
"\n"
"    defmodule MyAppError do\n"
"      defexception [:message]\n"
"\n"
"      def exception(value) do\n"
"        msg = \"did not get what was expected, got: #{inspect value}\"\n"
"        %MyAppError{message: msg}\n"
"      end\n"
"    end\n"
"\n"
"    raise MyAppError, value\n"
"\n"
"The example above shows the preferred strategy for customizing\n"
"exception messages.\n"
msgstr ""
"例外を定義します。\n"
"\n"
"例外は、`Exception`ビヘイビアを実装するモジュールによりサポートされる\n"
"構造体です。`Exception`ビヘイビアは次の2つの関数の実装を要求します。\n"
"\n"
"  * `exception/1` -  `raise/2`に与えられた引数を受け取り、\n"
"     例外構造体を返します。デフォルト実装は、構造体にマージされる\n"
"     一連のキーワード引数か、例外メッセージとして使用される文字列の\n"
"     いずれかを受け取ります。\n"
"\n"
"  * `message/1` -  例外構造体を受け取り、そのメッセージを\n"
"     返さなければなりません。一般的な例外のほとんどは、\n"
"     デフォルトでこの関数からアクセスされるメッセージフィールドを持っていま"
"す。\n"
"     しかし、例外がメッセージフィールドを持っていない場合、\n"
"     この関数が明示的に実装されなければなりません。\n"
"\n"
"例外は構造体なので、`defstruct/1`でサポートされているAPIが\n"
"`defexception/1`でも利用できます。\n"
"\n"
"## 例外の発生\n"
"\n"
"例外を発生させるもっとも一般的な方法は`raise/2`の呼び出しです。\n"
"\n"
"    defmodule MyAppError do\n"
"      defexception [:message]\n"
"    end\n"
"\n"
"    value = [:hello]\n"
"\n"
"    raise MyAppError,\n"
"      message: \"did not get what was expected, got: #{inspect value}\"\n"
"\n"
"多くの場合、`raise/2`に引数で値を渡し、`exception/1`コールバックで\n"
"メッセージを生成するとより便利です。\n"
"\n"
"    defmodule MyAppError do\n"
"      defexception [:message]\n"
"\n"
"      def exception(value) do\n"
"        msg = \"did not get what was expected, got: #{inspect value}\"\n"
"        %MyAppError{message: msg}\n"
"      end\n"
"    end\n"
"\n"
"    raise MyAppError, value\n"
"\n"
"上の例は、例外メッセージをカスタマイズするための推奨戦略を示しています。\n"

#. TRANSLATORS: Elixir.Kernel Summary
#: lib/kernel.ex:9
msgid ""
"Provides the default macros and functions Elixir imports into your\n"
"environment.\n"
"\n"
"These macros and functions can be skipped or cherry-picked via the\n"
"`import/2` macro. For instance, if you want to tell Elixir not to\n"
"import the `if/2` macro, you can do:\n"
"\n"
"    import Kernel, except: [if: 2]\n"
"\n"
"Elixir also has special forms that are always imported and\n"
"cannot be skipped. These are described in `Kernel.SpecialForms`.\n"
"\n"
"Some of the functions described in this module are inlined by\n"
"the Elixir compiler into their Erlang counterparts in the `:erlang`\n"
"module. Those functions are called BIFs (built-in internal functions)\n"
"in Erlang-land and they exhibit interesting properties, as some of\n"
"them are allowed in guards and others are used for compiler\n"
"optimizations.\n"
"\n"
"Most of the inlined functions can be seen in effect when capturing\n"
"the function:\n"
"\n"
"    iex> &Kernel.is_atom/1\n"
"    &:erlang.is_atom/1\n"
"\n"
"Those functions will be explicitly marked in their docs as\n"
"\"inlined by the compiler\".\n"
msgstr ""
"Elixirが環境にインポートするデフォルトのマクロと関数を提供します。\n"
"\n"
"これらのマクロと関数のインポートは`import/2`マクロでスキップしたり、\n"
"チェリーピックすることができます。たとえば、`if/2`マクロをインポート\n"
"しないようにElixirに伝えたい場合は次のようにします:\n"
"\n"
"    import Kernel, except: [if: 2]\n"
"\n"
"Elixirには、常にインポートされスキップできない特別なものもあります。\n"
"これらは`Kernel.SpecialForms`に記述されています。\n"
"\n"
"このモジュールで記述されてる関数の中には、Elixirコンパイラによって\n"
"`:erlang`モジュールにあるErlangの対応する関数にインライン化される\n"
"ものがあります。これらの関数はErlangではBIF（ビルトイン内部関数）と\n"
"呼ばれており、ガードに使用できるものやコンパイラの最適化に使われる\n"
"ものなど、興味深い性質を示しています。\n"
"\n"
"インライン関数のほとんどは関数をキャプチャすることで実際に見ることができま"
"す:\n"
"\n"
"    iex> &Kernel.is_atom/1\n"
"    &:erlang.is_atom/1\n"
"\n"
"これらの関数は、ドキュメントにおいて「コンパイラによりインライン化される」"
"と\n"
"明示的にマークされています。\n"

#~ msgid ""
#~ "Same as `struct/2` but raises if any of provided keys doesn't exist in "
#~ "the struct.\n"
#~ msgstr ""
#~ "`struct/2`と同じですが、struct中に与えられたキーが\n"
#~ "存在しないと例外を上げます。\n"

#~ msgid ""
#~ "Performs an integer division.\n"
#~ "\n"
#~ "Raises an `ArithmeticError` exception if one of the arguments is not an\n"
#~ "integer.\n"
#~ "\n"
#~ "Allowed in guard tests. Inlined by the compiler.\n"
#~ "\n"
#~ "## Examples\n"
#~ "\n"
#~ "    iex> div(5, 2)\n"
#~ "    2\n"
#~ "\n"
#~ msgstr ""
#~ "整数の除算を実行します。\n"
#~ "\n"
#~ "引数の一つが整数でないなら、`ArithmeticError`例外を上げます。\n"
#~ "\n"
#~ "ガードテストで使えます。コンパイラによりインライン化されます。\n"
#~ "\n"
#~ "## 例\n"
#~ "\n"
#~ "    iex> div(5, 2)\n"
#~ "    2\n"
#~ "\n"

#~ msgid ""
#~ "Gets the element at the zero-based `index` in `tuple`.\n"
#~ "\n"
#~ "Allowed in guard tests. Inlined by the compiler.\n"
#~ "\n"
#~ "## Examples\n"
#~ "\n"
#~ "    iex> tuple = {:foo, :bar, 3}\n"
#~ "    iex> elem(tuple, 1)\n"
#~ "    :bar\n"
#~ "\n"
#~ msgstr ""
#~ "`tuple`の0始まりの`index`の場所の要素を取得します。\n"
#~ "\n"
#~ "ガードテストで使えます。コンパイラによりインライン化されます。\n"
#~ "\n"
#~ "## 例\n"
#~ "\n"
#~ "    iex> tuple = {:foo, :bar, 3}\n"
#~ "    iex> elem(tuple, 1)\n"
#~ "    :bar\n"
#~ "\n"

#~ msgid ""
#~ "Concatenates two lists.\n"
#~ "\n"
#~ "Inlined by the compiler.\n"
#~ "\n"
#~ "## Examples\n"
#~ "\n"
#~ "    iex> [1] ++ [2, 3]\n"
#~ "    [1, 2, 3]\n"
#~ "\n"
#~ "    iex> 'foo' ++ 'bar'\n"
#~ "    'foobar'\n"
#~ "\n"
#~ msgstr ""
#~ "二つのリストを連結します。\n"
#~ "\n"
#~ "ガードテストで使えます。コンパイラによりインライン化されます。\n"
#~ "\n"
#~ "## 例\n"
#~ "\n"
#~ "    iex> [1] ++ [2, 3]\n"
#~ "    [1,2,3]\n"
#~ "\n"
#~ "    iex> 'foo' ++ 'bar'\n"
#~ "    'foobar'\n"
#~ "\n"

#~ msgid ""
#~ "`use` is a simple mechanism for using a given module into\n"
#~ "the current context.\n"
#~ "\n"
#~ "## Examples\n"
#~ "\n"
#~ "For example, in order to write tests using the ExUnit framework,\n"
#~ "a developer should use the `ExUnit.Case` module:\n"
#~ "\n"
#~ "    defmodule AssertionTest do\n"
#~ "      use ExUnit.Case, async: true\n"
#~ "\n"
#~ "      test \"always pass\" do\n"
#~ "        assert true\n"
#~ "      end\n"
#~ "    end\n"
#~ "\n"
#~ "By calling `use`, a hook called `__using__` will be invoked in\n"
#~ "`ExUnit.Case` which will then do the proper setup.\n"
#~ "\n"
#~ "Simply put, `use` is simply a translation to:\n"
#~ "\n"
#~ "    defmodule AssertionTest do\n"
#~ "      require ExUnit.Case\n"
#~ "      ExUnit.Case.__using__([async: true])\n"
#~ "\n"
#~ "      test \"always pass\" do\n"
#~ "        assert true\n"
#~ "      end\n"
#~ "    end\n"
#~ "\n"
#~ msgstr ""
#~ "`use`はカレントコンテキストに与えられたモジュールを使うための\n"
#~ "シンプルなメカニズムです。\n"
#~ "\n"
#~ "## 例\n"
#~ "\n"
#~ "例えば、ExUnitフレームワークを使ってテストを書くために、\n"
#~ "開発者は`ExUnit.Case`モジュールをuseしなければなりません。\n"
#~ "\n"
#~ "    defmodule AssertionTest do\n"
#~ "      use ExUnit.Case, async: true\n"
#~ "\n"
#~ "      test \"always pass\" do\n"
#~ "        assert true\n"
#~ "      end\n"
#~ "    end\n"
#~ "\n"
#~ "`use`を呼ぶことにより、`ExUnit.Case`のセットアップをするために\n"
#~ "`__using__`と呼ばれるフックが起動されます。\n"
#~ "\n"
#~ "単に、`use`は以下のように翻訳されます:\n"
#~ "\n"
#~ "    defmodule AssertionTest do\n"
#~ "      require ExUnit.Case\n"
#~ "      ExUnit.Case.__using__([async: true])\n"
#~ "\n"
#~ "      test \"always pass\" do\n"
#~ "        assert true\n"
#~ "      end\n"
#~ "    end\n"
#~ "\n"

#~ msgid ""
#~ "Defines a function with the given name and contents.\n"
#~ "\n"
#~ "## Examples\n"
#~ "\n"
#~ "    defmodule Foo do\n"
#~ "      def bar, do: :baz\n"
#~ "    end\n"
#~ "\n"
#~ "    Foo.bar #=> :baz\n"
#~ "\n"
#~ "A function that expects arguments can be defined as follow:\n"
#~ "\n"
#~ "    defmodule Foo do\n"
#~ "      def sum(a, b) do\n"
#~ "        a + b\n"
#~ "      end\n"
#~ "    end\n"
#~ "\n"
#~ "In the example above, we defined a function `sum` that receives\n"
#~ "two arguments and sums them.\n"
#~ "\n"
#~ msgstr ""
#~ "与えられた名前とコンテンツで関数を定義します。\n"
#~ "\n"
#~ "## 例\n"
#~ "\n"
#~ "    defmodule Foo do\n"
#~ "      def bar, do: :baz\n"
#~ "    end\n"
#~ "\n"
#~ "    Foo.bar #=> :baz\n"
#~ "\n"
#~ "関数は下のように、引数を付けて定義することもできます:\n"
#~ "\n"
#~ "    defmodule Foo do\n"
#~ "      def sum(a, b) do\n"
#~ "        a + b\n"
#~ "      end\n"
#~ "    end\n"
#~ "\n"
#~ "上の例では、二つの引数をとり、それらの和を返す関数`sum`を定義しました。\n"
#~ "\n"

#~ msgid ""
#~ "Returns the size of a map.\n"
#~ "\n"
#~ "This operation happens in constant time.\n"
#~ "\n"
#~ "Allowed in guard tests. Inlined by the compiler.\n"
#~ msgstr ""
#~ "マップのサイズを返します。\n"
#~ "\n"
#~ "このオペレーションは定数時間で実行されます。\n"
#~ "\n"
#~ "ガード中のテストに使うことができます。コンパイラによりインライン化され\n"
#~ "ます。\n"

#~ msgid ""
#~ "Handles the sigil ~r. It returns a Regex pattern.\n"
#~ "\n"
#~ "## Examples\n"
#~ "\n"
#~ "    iex> Regex.match?(~r(foo), \"foo\")\n"
#~ "    true\n"
#~ "\n"
#~ msgstr ""
#~ "sigil ~rをハンドルします。\n"
#~ "Regexパターンを返します。\n"
#~ "\n"
#~ "## 例\n"
#~ "\n"
#~ "    iex> Regex.match?(~r(foo), \"foo\")\n"
#~ "    true\n"
#~ "\n"

#~ msgid ""
#~ "Boolean and. Requires only the first argument to be a\n"
#~ "boolean since it short-circuits.\n"
#~ "\n"
#~ "Allowed in guard tests.\n"
#~ "\n"
#~ "## Examples\n"
#~ "\n"
#~ "    iex> true and false\n"
#~ "    false\n"
#~ "\n"
#~ msgstr ""
#~ "ブール代数のand です。ショートサーキットなので、\n"
#~ "booleanであることを最初の引数だけに要求します。\n"
#~ "\n"
#~ "ガードテストで使えます。\n"
#~ "\n"
#~ "## 例\n"
#~ "\n"
#~ "    iex> true and false\n"
#~ "    false\n"
#~ "\n"
