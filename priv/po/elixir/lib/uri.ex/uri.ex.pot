#. TRANSLATORS: def URI.default_port(scheme, port)
#: lib/uri.ex:48 
msgid ""
"Registers the default port `port` for the given `scheme`.\n"
"\n"
"After this function is called, `port` will be returned by\n"
"`default_port/1` for the given scheme `scheme`. Note that this function\n"
"changes the default port for the given `scheme` *globally*, meaning for\n"
"every application.\n"
"\n"
"It is recommended for this function to be invoked in your\n"
"application's start callback in case you want to register\n"
"new URIs.\n"
msgstr ""
#. TRANSLATORS: Elixir.URI Summary
#: lib/uri.ex:2 
msgid ""
"Utilities for working with URIs.\n"
"\n"
"This module provides functions for working with URIs (for example, parsing\n"
"URIs or encoding query strings). For reference, most of the functions in this\n"
"module refer to [RFC 3986](https://tools.ietf.org/html/rfc3986).\n"
msgstr ""
#. TRANSLATORS: def URI.encode_query(enumerable)
#: lib/uri.ex:65 
msgid ""
"Encodes an enumerable into a query string.\n"
"\n"
"Takes an enumerable that enumerates as a list of two-element\n"
"tuples (e.g., a map or a keyword list) and returns a string\n"
"in the form of `key1=value1&key2=value2...` where keys and\n"
"values are URL encoded as per `encode_www_form/1`.\n"
"\n"
"Keys and values can be any term that implements the `String.Chars`\n"
"protocol, except lists which are explicitly forbidden.\n"
"\n"
"## Examples\n"
"\n"
"    iex> hd = %{\"foo\" => 1, \"bar\" => 2}\n"
"    iex> URI.encode_query(hd)\n"
"    \"bar=2&foo=1\"\n"
"\n"
"    iex> query = %{\"key\" => \"value with spaces\"}\n"
"    iex> URI.encode_query(query)\n"
"    \"key=value+with+spaces\"\n"
"\n"
"    iex> URI.encode_query %{key: [:a, :list]}\n"
"    ** (ArgumentError) encode_query/1 values cannot be lists, got: [:a, :list]\n"
"\n"
msgstr ""
#. TRANSLATORS: def URI.decode_query(query, map \\ %{})
#: lib/uri.ex:108 
msgid ""
"Decodes a query string into a map.\n"
"\n"
"Given a query string of the form of `key1=value1&key2=value2...`, this\n"
"function inserts each key-value pair in the query string as one entry in the\n"
"given `map`. Keys and values in the resulting map will be binaries. Keys and\n"
"values will be percent-unescaped.\n"
"\n"
"Use `query_decoder/1` if you want to iterate over each value manually.\n"
"\n"
"## Examples\n"
"\n"
"    iex> URI.decode_query(\"foo=1&bar=2\")\n"
"    %{\"bar\" => \"2\", \"foo\" => \"1\"}\n"
"\n"
"    iex> URI.decode_query(\"percent=oh+yes%21\", %{\"starting\" => \"map\"})\n"
"    %{\"percent\" => \"oh yes!\", \"starting\" => \"map\"}\n"
"\n"
msgstr ""
#. TRANSLATORS: def URI.to_string(uri)
#: lib/uri.ex:439 
msgid ""
"Returns the string representation of the given `URI` struct.\n"
"\n"
"    iex> URI.to_string(URI.parse(\"http://google.com\"))\n"
"    \"http://google.com\"\n"
"\n"
"    iex> URI.to_string(%URI{scheme: \"foo\", host: \"bar.baz\"})\n"
"    \"foo://bar.baz\"\n"
"\n"
msgstr ""
#. TRANSLATORS: def URI.default_port(scheme)
#: lib/uri.ex:27 
msgid ""
"Returns the default port for a given scheme.\n"
"\n"
"If the scheme is unknown to the `URI` module, this function returns\n"
"`nil`. The default port for any scheme can be configured globally\n"
"via `default_port/2`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> URI.default_port(\"ftp\")\n"
"    21\n"
"\n"
"    iex> URI.default_port(\"ponzi\")\n"
"    nil\n"
"\n"
msgstr ""
#. TRANSLATORS: def URI.parse(uri)
#: lib/uri.ex:361 
msgid ""
"Parses a well-formed URI reference into its components.\n"
"\n"
"Note this function expects a well-formed URI and does not perform\n"
"any validation. See the \"Examples\" section below for examples of how\n"
"`URI.parse/1` can be used to parse a wide range of URIs.\n"
"\n"
"This function uses the parsing regular expression as defined\n"
"in [RFC 3986, Appendix B](http://tools.ietf.org/html/rfc3986#appendix-B).\n"
"\n"
"When a URI is given without a port, the value returned by\n"
"`URI.default_port/1` for the URI's scheme is used for the `:port` field.\n"
"\n"
"If a `%URI{}` struct is given to this function, this function returns it\n"
"unmodified.\n"
"\n"
"## Examples\n"
"\n"
"    iex> URI.parse(\"http://elixir-lang.org/\")\n"
"    %URI{scheme: \"http\", path: \"/\", query: nil, fragment: nil,\n"
"         authority: \"elixir-lang.org\", userinfo: nil,\n"
"         host: \"elixir-lang.org\", port: 80}\n"
"\n"
"    iex> URI.parse(\"//elixir-lang.org/\")\n"
"    %URI{authority: \"elixir-lang.org\", fragment: nil, host: \"elixir-lang.org\",\n"
"         path: \"/\", port: nil, query: nil, scheme: nil, userinfo: nil}\n"
"\n"
"    iex> URI.parse(\"/foo/bar\")\n"
"    %URI{authority: nil, fragment: nil, host: nil, path: \"/foo/bar\",\n"
"         port: nil, query: nil, scheme: nil, userinfo: nil}\n"
"\n"
"    iex> URI.parse(\"foo/bar\")\n"
"    %URI{authority: nil, fragment: nil, host: nil, path: \"foo/bar\",\n"
"         port: nil, query: nil, scheme: nil, userinfo: nil}\n"
"\n"
msgstr ""
#. TRANSLATORS: def URI.merge(uri, rel)
#: lib/uri.ex:452 
msgid ""
"Merges two URIs.\n"
"\n"
"This function merges two URIs as per\n"
"[RFC 3986, section 5.2](http://tools.ietf.org/html/rfc3986#section-5.2).\n"
"\n"
"## Examples\n"
"\n"
"    iex> URI.merge(URI.parse(\"http://google.com\"), \"/query\") |> to_string\n"
"    \"http://google.com/query\"\n"
"\n"
"    iex> URI.merge(\"http://example.com\", \"http://google.com\") |> to_string\n"
"    \"http://google.com\"\n"
"\n"
msgstr ""
#. TRANSLATORS: def URI.encode_www_form(string)
#: lib/uri.ex:278 
msgid ""
"Encodes a string as \"x-www-form-urlencoded\".\n"
"\n"
"## Example\n"
"\n"
"    iex> URI.encode_www_form(\"put: it+й\")\n"
"    \"put%3A+it%2B%D0%B9\"\n"
"\n"
msgstr ""
#. TRANSLATORS: def URI.char_reserved?(char)
#: lib/uri.ex:201 
msgid ""
"Checks if the character is a \"reserved\" character in a URI.\n"
"\n"
"Reserved characters are specified in\n"
"[RFC 3986, section 2.2](http://tools.ietf.org/html/rfc3986#section-2.2).\n"
"\n"
"## Examples\n"
"\n"
"    iex> URI.char_reserved?(?+)\n"
"    true\n"
"\n"
msgstr ""
#. TRANSLATORS: def URI.query_decoder(query)
#: lib/uri.ex:164 
msgid ""
"Returns a stream of two-element tuples representing key-value pairs in the\n"
"given `query`.\n"
"\n"
"Key and value in each tuple will be binaries and will be percent-unescaped.\n"
"\n"
"## Examples\n"
"\n"
"    iex> URI.query_decoder(\"foo=1&bar=2\") |> Enum.to_list()\n"
"    [{\"foo\", \"1\"}, {\"bar\", \"2\"}]\n"
"\n"
msgstr ""
#. TRANSLATORS: def URI.char_unreserved?(char)
#: lib/uri.ex:218 
msgid ""
"Checks if the character is a \"unreserved\" character in a URI.\n"
"\n"
"Unreserved characters are specified in\n"
"[RFC 3986, section 2.3](http://tools.ietf.org/html/rfc3986#section-2.3).\n"
"\n"
"## Examples\n"
"\n"
"    iex> URI.char_unreserved?(?_)\n"
"    true\n"
"\n"
msgstr ""
#. TRANSLATORS: def URI.decode(uri)
#: lib/uri.ex:308 
msgid ""
"Percent-unescapes a URI.\n"
"\n"
"## Examples\n"
"\n"
"    iex> URI.decode(\"http%3A%2F%2Felixir-lang.org\")\n"
"    \"http://elixir-lang.org\"\n"
"\n"
msgstr ""
#. TRANSLATORS: def URI.char_unescaped?(char)
#: lib/uri.ex:238 
msgid ""
"Checks if the character is allowed unescaped in a URI.\n"
"\n"
"This is the default used by `URI.encode/2` where both\n"
"reserved and unreserved characters are kept unescaped.\n"
"\n"
"## Examples\n"
"\n"
"    iex> URI.char_unescaped?(?{)\n"
"    false\n"
"\n"
msgstr ""
#. TRANSLATORS: def URI.decode_www_form(string)
#: lib/uri.ex:325 
msgid ""
"Decodes a string as \"x-www-form-urlencoded\".\n"
"\n"
"## Examples\n"
"\n"
"    iex> URI.decode_www_form(\"%3Call+in%2F\")\n"
"    \"<all in/\"\n"
"\n"
msgstr ""
#. TRANSLATORS: def URI.encode(string, predicate \\ &char_unescaped?/1)
#: lib/uri.ex:255 
msgid ""
"Percent-escapes the given string.\n"
"\n"
"This function accepts a `predicate` function as an optional argument; if\n"
"passed, this function will be called with each character (byte) in `string` as\n"
"its argument and should return `true` if that character should not be escaped\n"
"and left as is.\n"
"\n"
"## Examples\n"
"\n"
"    iex> URI.encode(\"ftp://s-ite.tld/?value=put it+й\")\n"
"    \"ftp://s-ite.tld/?value=put%20it+%D0%B9\"\n"
"\n"
"    iex> URI.encode(\"a string\", &(&1 != ?i))\n"
"    \"a str%69ng\"\n"
"\n"
msgstr ""
