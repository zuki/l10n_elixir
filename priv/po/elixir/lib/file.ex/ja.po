msgid ""
msgstr ""
"Project-Id-Version: l 10n_elixir\n"
"POT-Creation-Date: \n"
"PO-Revision-Date: 2017-03-23 18:26+0900\n"
"Last-Translator: 小田 照敬 <EMAIL@ADDRESS>\n"
"Language-Team: Japanese\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Poedit 1.8.12\n"

#. TRANSLATORS: def File.touch(path, time \\ :calendar.universal_time())
#: lib/file.ex:363
msgid ""
"Updates modification time (mtime) and access time (atime) of\n"
"the given file.\n"
"\n"
"The file is created if it doesn’t exist. Requires datetime in UTC.\n"
msgstr ""
"指定したファイルの変更時間（mtime）とアクセス時間（atime）を更新します。\n"
"\n"
"ファイルが存在しない場合は作成されます。日時はUTCである必要があります。\n"

#. TRANSLATORS: def File.cd!(path)
#: lib/file.ex:1136
msgid "The same as `cd/1`, but raises an exception if it fails.\n"
msgstr "`cd/1`と同じですが、失敗すると例外が発生します。\n"

#. TRANSLATORS: def File.ls!(path \\ ".")
#: lib/file.ex:1182
msgid ""
"The same as `ls/1` but raises `File.Error`\n"
"in case of an error.\n"
msgstr "`ls/1`と同じですが、エラーの場合、`File.Error`例外が発生します。\n"

#. TRANSLATORS: def File.lstat(path, opts \\ [])
#: lib/file.ex:294
msgid ""
"Returns information about the `path`. If the file is a symlink, sets\n"
"the `type` to `:symlink` and returns a `File.Stat` struct for the link. For "
"any\n"
"other file, returns exactly the same values as `stat/2`.\n"
"\n"
"For more details, see [`:file.read_link_info/2`](http://www.erlang.org/doc/"
"man/file.html#read_link_info-2).\n"
"\n"
"## Options\n"
"\n"
"The accepted options are:\n"
"\n"
"  * `:time` - configures how the file timestamps are returned\n"
"\n"
"The values for `:time` can be:\n"
"\n"
"  * `:universal` - returns a `{date, time}` tuple in UTC (default)\n"
"  * `:local` - returns a `{date, time}` tuple using the machine time\n"
"  * `:posix` - returns the time as integer seconds since epoch\n"
"\n"
msgstr ""
"`path`に関する情報を返します。ファイルがシンボリックリンクの場合は、\n"
"`type`を`:symlink`にセットして、リンクについての`File.Stat`構造体を\n"
"返します。その他のファイルの場合は、`stat/2`とまったく同じ値を返します。\n"
"\n"
"詳細は、 [`:file.read_link_info/2`](http://www.erlang.org/doc/man/file."
"html#read_link_info-2) を\n"
"参照してください。\n"
"\n"
"## オプション\n"
"\n"
"以下のオプションを受け付けます。\n"
"\n"
"  * `:time` - ファイルのタイムタンプをどのように返すかを構成します\n"
"\n"
"`:time`の値には以下を指定できます。\n"
"\n"
"  * `:universal` - UTCの`{date, time}`タプルを返します（デフォルト）。\n"
"  * `:local` - マシン時間を使用して`{date, time}`タプルを返します。\n"
"  * `:posix` - エポック時からの整数秒数として時刻を返します。\n"
"\n"

#. TRANSLATORS: def File.chgrp(path, gid)
#: lib/file.ex:1294
msgid ""
"Changes the group given by the group id `gid`\n"
"for a given `file`. Returns `:ok` on success, or\n"
"`{:error, reason}` on failure.\n"
msgstr ""
"指定した`path`のグループを、グループID`gid`により指定された\n"
"グループに変更します。成功した場合は`:ok`を返し、失敗した場合は\n"
"`{:error, reason}`を返します。\n"

#. TRANSLATORS: def File.copy!(source, destination, bytes_count \\ :infinity)
#: lib/file.ex:438
msgid ""
"The same as `copy/3` but raises an `File.CopyError` if it fails.\n"
"Returns the `bytes_copied` otherwise.\n"
msgstr ""
"`copy/3`と同じですが、失敗すると`File.CopyError`が発生します。\n"
"そうでない場合は`bytes_copied`を返します。\n"

#. TRANSLATORS: def File.open(path, modes, function)
#: lib/file.ex:1018
msgid ""
"Similar to `open/2` but expects a function as its last argument.\n"
"\n"
"The file is opened, given to the function as an argument and\n"
"automatically closed after the function returns, regardless\n"
"if there was an error when executing the function.\n"
"\n"
"Returns `{:ok, function_result}` in case of success,\n"
"`{:error, reason}` otherwise.\n"
"\n"
"This function expects the file to be closed with success,\n"
"which is usually the case unless the `:delayed_write` option\n"
"is given. For this reason, we do not recommend passing\n"
"`:delayed_write` to this function.\n"
"\n"
"## Examples\n"
"\n"
"    File.open(\"file.txt\", [:read, :write], fn(file) ->\n"
"      IO.read(file, :line)\n"
"    end)\n"
"\n"
"See `open/2` for the list of available `modes`.\n"
msgstr ""
"`open/2`と同じですが、最後の引数として関数を取ります。\n"
"\n"
"ファイルはオープンされ、関数の引数として与えられます。\n"
"そして、関数の実行中にエラーがあったかどうかにかかわらず、\n"
"関数が戻るとファイルは自動的にクローズされます。\n"
"\n"
"成功した場合は`{:ok, function_result}`を返し、そうでなければ\n"
"`{:error, reason}`を返します。\n"
"\n"
"この関数は、成功時にファイルは閉じられるべきであることを期待します。\n"
"これは、`:delayed_write`オプションが指定された場合を除いて、通常\n"
"期待されることです。この理由から、この関数に`deleyed_write`を指定する\n"
"ことは薦めません。\n"
"\n"
"## 例\n"
"\n"
"    File.open(\"file.txt\", [:read, :write], fn(file) ->\n"
"      IO.read(file, :line)\n"
"    end)\n"
"\n"
"利用可能な`modes`の一覧は`open/2`を参照してください。\n"

#. TRANSLATORS: def File.mkdir_p(path)
#: lib/file.ex:160
msgid ""
"Tries to create the directory `path`. Missing parent directories are "
"created.\n"
"Returns `:ok` if successful, or `{:error, reason}` if an error occurs.\n"
"\n"
"Typical error reasons are:\n"
"\n"
"  * `:eacces`  - missing search or write permissions for the parent\n"
"    directories of `path`\n"
"  * `:enospc`  - there is no space left on the device\n"
"  * `:enotdir` - a component of `path` is not a directory\n"
msgstr ""
"`path`ディレクトリの作成を試みます。存在しない親ディレクトリは作成されま"
"す。\n"
"成功した場合は`:ok`を、エラーが発生したら`{:error, reason}`を返します。\n"
"\n"
"よくあるエラーは以下のとおりです。\n"
"\n"
"  * `:eacces`  - `path`の親ディレクトリの読み込み権限または書き込み権限がな"
"い\n"
"  * `:enospc`  - デバイスに空きスペースがない\n"
"  * `:enotdir` - `path`の一部がディレクトリでない\n"

#. TRANSLATORS: def File.stat!(path, opts \\ [])
#: lib/file.ex:280
msgid ""
"Same as `stat/2` but returns the `File.Stat` directly and\n"
"throws `File.Error` if an error is returned.\n"
msgstr ""
"`stat/2`と同じですが、直接`File.Stat`構造体を返し、\n"
"エラーが返された場合は`File.Error`を発生させます。\n"

#. TRANSLATORS: def File.read(path)
#: lib/file.ex:213
msgid ""
"Returns `{:ok, binary}`, where `binary` is a binary data object that "
"contains the contents\n"
"of `path`, or `{:error, reason}` if an error occurs.\n"
"\n"
"Typical error reasons:\n"
"\n"
"  * `:enoent`  - the file does not exist\n"
"  * `:eacces`  - missing permission for reading the file,\n"
"    or for searching one of the parent directories\n"
"  * `:eisdir`  - the named file is a directory\n"
"  * `:enotdir` - a component of the file name is not a directory;\n"
"    on some platforms, `:enoent` is returned instead\n"
"  * `:enomem`  - there is not enough memory for the contents of the file\n"
"\n"
"You can use `:file.format_error/1` to get a descriptive string of the "
"error.\n"
msgstr ""
"`{:ok, binary}`を返します。ここで、`binary`は`path`の内容を含む\n"
"バイナリデータオブジェクトです。エラーが発生した場合は、\n"
"`{:error, reason}`を返します。\n"
"\n"
"よくあるエラー理由は以下の通りです。\n"
"\n"
"  * `:enoent`  - ファイルが存在しない\n"
"  * `:eacces`  - ファイルの読み込み権限、または、\n"
"                 親ディレクトリの読み込み権限がない\n"
"  * `:eisdir`  - 指定したファイルがディレクトリである\n"
"  * `:enotdir` - ファイル名を構成する一部がディレクトリでない;\n"
"                 代わりに`:enoent`が返されるプラットフォームも存在する。\n"
"  * `:enomem`  - ファイルの内容のための十分なメモりがない\n"
"\n"
"エラーの記述文字列を得るには`:file.format_error/1`を使うことができます。\n"

#. TRANSLATORS: def File.chmod!(path, mode)
#: lib/file.ex:1281
msgid ""
"Same as `chmod/2`, but raises an exception in case of failure. Otherwise `:"
"ok`.\n"
msgstr ""
"`chmod/2`と同じですが、失敗すると例外が発生します。そうでなければ\n"
"`:ok`を返します。\n"

#. TRANSLATORS: def File.chmod(path, mode)
#: lib/file.ex:1252
msgid ""
"Changes the `mode` for a given `file`.\n"
"\n"
"Returns `:ok` on success, or `{:error, reason}` on failure.\n"
"\n"
"## Permissions\n"
"\n"
"  * 0o400 - read permission: owner\n"
"  * 0o200 - write permission: owner\n"
"  * 0o100 - execute permission: owner\n"
"\n"
"  * 0o040 - read permission: group\n"
"  * 0o020 - write permission: group\n"
"  * 0o010 - execute permission: group\n"
"\n"
"  * 0o004 - read permission: other\n"
"  * 0o002 - write permission: other\n"
"  * 0o001 - execute permission: other\n"
"\n"
"For example, setting the mode 0o755 gives it\n"
"write, read and execute permission to the owner\n"
"and both read and execute permission to group\n"
"and others.\n"
msgstr ""
"指定した`file`のモードを`mode`に変更します。\n"
"\n"
"成功した場合は`:ok`を返し、失敗した場合は`{:error, reason}`を返します。\n"
"\n"
"## パーミッション\n"
"\n"
"  * 0o400 - 読み込み権限: 所有者\n"
"  * 0o200 - 書き込み権限: 所有者\n"
"  * 0o100 - 実行権限: 所有者\n"
"\n"
"  * 0o040 - 読み込み権限: 所有グループ\n"
"  * 0o020 - 書き込み権限: 所有グループ\n"
"  * 0o010 - 実行権限: 所有グループ\n"
"\n"
"  * 0o004 - 読み込み権限: その他\n"
"  * 0o002 - 書き込み権限: その他\n"
"  * 0o001 - 実行権限: その他\n"
"\n"
"たとえば、モードを0o755に設定すると、所有者には\n"
"書き込み、読み込み、実行の権限を与え、所有グループと\n"
"その他のユーザには読み込みと実行の権限を与えます。\n"

#. TRANSLATORS: def File.rm!(path)
#: lib/file.ex:780
msgid ""
"Same as `rm/1`, but raises an exception in case of failure. Otherwise `:"
"ok`.\n"
msgstr ""
"`rm/1`と同じですが、失敗すると例外が発生します。\n"
"そうでなければ`:ok`を返します。\n"

#. TRANSLATORS: def File.open!(path, modes, function)
#: lib/file.ex:1072
msgid ""
"Similar to `open/3` but raises an error if file could not be opened.\n"
"\n"
"If it succeeds opening the file, it returns the `function` result on the IO "
"device.\n"
"\n"
"See `open/2` for the list of available `modes`.\n"
msgstr ""
"`open/3`と同じですが、ファイルがオープンできなかった場合、\n"
"エラーが発生します。\n"
"\n"
"ファイルのオープンに成功した場合、IOデバイスに`function`を適用した\n"
"結果を返します。\n"
"\n"
"利用可能な`modes`の一覧は`open/2`を参照してください。\n"
"\n"

#. TRANSLATORS: def File.rmdir!(path)
#: lib/file.ex:811
msgid ""
"Same as `rmdir/1`, but raises an exception in case of failure. Otherwise `:"
"ok`.\n"
msgstr ""
"`rmdir/1`と同じですが、失敗すると例外が発生します。\n"
"そうでなければ`:ok`を返します。\n"

#. TRANSLATORS: def File.cp_r(source, destination, callback \\ fn _, _ -> true end)
#: lib/file.ex:529
msgid ""
"Copies the contents in source to destination.\n"
"\n"
"If the source is a file, it copies `source` to\n"
"`destination`. If the source is a directory, it copies\n"
"the contents inside source into the destination.\n"
"\n"
"If a file already exists in the destination,\n"
"it invokes a callback which should return\n"
"`true` if the existing file should be overwritten,\n"
"`false` otherwise. The callback defaults to return `true`.\n"
"\n"
"If a directory already exists in the destination\n"
"where a file is meant to be (or vice versa), this\n"
"function will fail.\n"
"\n"
"This function may fail while copying files,\n"
"in such cases, it will leave the destination\n"
"directory in a dirty state, where file which have already been copied\n"
"won't be removed.\n"
"\n"
"The function returns `{:ok, files_and_directories}` in case of\n"
"success, `files_and_directories` lists all files and directories copied in "
"no\n"
"specific order. It returns `{:error, reason, file}` otherwise.\n"
"\n"
"Note: The command `cp` in Unix systems behaves differently\n"
"depending if `destination` is an existing directory or not.\n"
"We have chosen to explicitly disallow this behaviour.\n"
"\n"
"## Examples\n"
"\n"
"    # Copies file \"a.txt\" to \"b.txt\"\n"
"    File.cp_r \"a.txt\", \"b.txt\"\n"
"\n"
"    # Copies all files in \"samples\" to \"tmp\"\n"
"    File.cp_r \"samples\", \"tmp\"\n"
"\n"
"    # Same as before, but asks the user how to proceed in case of conflicts\n"
"    File.cp_r \"samples\", \"tmp\", fn(source, destination) ->\n"
"      IO.gets(\"Overwriting #{destination} by #{source}. Type y to confirm. "
"\") == \"y\\n\"\n"
"    end\n"
"\n"
msgstr ""
"`source`の内容を`destination`にコピーします。\n"
"\n"
"`source`がファイルの場合は、`source`を`destination`へコピーします。\n"
"`source`がディレクトリの場合は、`source`内のすべての内容を\n"
"`destination`にコピーします。\n"
"\n"
"デスティネーションにファイルが既に存在する場合は、\n"
"コールバックを起動します。このコールバックは、そのファイルが\n"
"上書きされるべきなら`true`を返し、そうでなければ`false`を返す\n"
"ようにします。デフォルトのコールバックはtrueを返します。\n"
"\n"
"ファイルであるはずのデスティネーションにディレクトリが存在する\n"
"（または、その逆の）場合、この関数は失敗します。\n"
"\n"
"この関数はファイルのコピー中に失敗する場合があります。そのような場合、\n"
"デスティネーションディレクトリはダーティ状態になります。そこでは\n"
"すでにコピー済のファイルは削除されません。\n"
"\n"
"この関数は、成功した場合、`{:ok, files_and_directories}`を返します。\n"
"ここで、`files_and_directories`はコピーされたすべてのファイルと\n"
"ディレクトリの順不同のリストです。そうでない場合は`{:error, reason, file}`"
"を\n"
"返します。\n"
"\n"
"注意: Unixシステムの`cp`コマンドは、`destination`が既存の\n"
"ディレクトリか否かで異なる振る舞いをします。Elixirでは、この振る舞いを\n"
"認めないことを明示的に選択しました。\n"
"\n"
"## 例\n"
"\n"
"    # ファイル\"a.txt\"を\"b.txt\"にコピー\n"
"    File.cp_r \"a.txt\", \"b.txt\"\n"
"\n"
"    # \"samples\"のすべてのファイルを\"tmp\"にコピー\n"
"\n"
"    File.cp_r \"samples\", \"tmp\"\n"
"\n"
"    # 上と同じだが、コピー先が存在する場合の対応をユーザに尋ねる\n"
"    File.cp_r \"samples\", \"tmp\", fn(source, destination) ->\n"
"      IO.gets(\"Overwriting #{destination} by #{source}. Type y to confirm. "
"\") == \"y\\n\"\n"
"    end\n"
"\n"

#. TRANSLATORS: def File.rmdir(path)
#: lib/file.ex:793
msgid ""
"Tries to delete the dir at `path`.\n"
"Returns `:ok` if successful, or `{:error, reason}` if an error occurs.\n"
"\n"
"## Examples\n"
"\n"
"    File.rmdir('tmp_dir')\n"
"    #=> :ok\n"
"\n"
"    File.rmdir('file.txt')\n"
"    #=> {:error, :enotdir}\n"
"\n"
msgstr ""
"`path`ディレクトリの削除を試みます。\n"
"成功した場合は`:ok`を、エラーが発生した場合は`{:error, reason}`を返します。\n"
"\n"
"## 例\n"
"\n"
"    File.rmdir('tmp_dir')\n"
"    #=> :ok\n"
"\n"
"    File.rmdir('file.txt')\n"
"    #=> {:error, :enotdir}\n"
"\n"

#. TRANSLATORS: def File.open(path, modes_or_function \\ [])
#: lib/file.ex:927
msgid ""
"Opens the given `path`.\n"
"\n"
"In order to write and read files, one must use the functions\n"
"in the `IO` module. By default, a file is opened in `:binary` mode,\n"
"which requires the functions `IO.binread/2` and `IO.binwrite/2`\n"
"to interact with the file. A developer may pass `:utf8` as an\n"
"option when opening the file and then all other functions from\n"
"`IO` are available, since they work directly with Unicode data.\n"
"\n"
"`modes_or_function` can either be a list of modes or a function. If it's a\n"
"list, it's considered to be a list of modes (that are documented below). If\n"
"it's a function, then it's equivalent to calling `open(path, [],\n"
"modes_or_function)`. See the documentation for `open/3` for more "
"information\n"
"on this function.\n"
"\n"
"The allowed modes:\n"
"\n"
"  * `:binary` - opens the file in binary mode, disabling special handling of "
"unicode sequences\n"
"    (default mode).\n"
"\n"
"  * `:read` - the file, which must exist, is opened for reading.\n"
"\n"
"  * `:write` - the file is opened for writing. It is created if it does not\n"
"    exist.\n"
"\n"
"    If the file does exists, and if write is not combined with read, the "
"file\n"
"    will be truncated.\n"
"\n"
"  * `:append` - the file will be opened for writing, and it will be created\n"
"    if it does not exist. Every write operation to a file opened with "
"append\n"
"    will take place at the end of the file.\n"
"\n"
"  * `:exclusive` - the file, when opened for writing, is created if it does\n"
"    not exist. If the file exists, open will return `{:error, :eexist}`.\n"
"\n"
"  * `:charlist` - when this term is given, read operations on the file will\n"
"    return charlists rather than binaries.\n"
"\n"
"  * `:compressed` - makes it possible to read or write gzip compressed "
"files.\n"
"\n"
"    The compressed option must be combined with either read or write, but "
"not\n"
"    both. Note that the file size obtained with `stat/1` will most probably\n"
"    not match the number of bytes that can be read from a compressed file.\n"
"\n"
"  * `:utf8` - this option denotes how data is actually stored in the disk\n"
"    file and makes the file perform automatic translation of characters to\n"
"    and from UTF-8.\n"
"\n"
"    If data is sent to a file in a format that cannot be converted to the\n"
"    UTF-8 or if data is read by a function that returns data in a format "
"that\n"
"    cannot cope with the character range of the data, an error occurs and "
"the\n"
"    file will be closed.\n"
"\n"
"  * `:delayed_write`, `:raw`, `:ram`, `:read_ahead`, `:sync`, `{:"
"encoding, ...}`,\n"
"    `{:read_ahead, pos_integer}`, `{:delayed_write, non_neg_integer, "
"non_neg_integer}` -\n"
"    for more information about these options see [`:file.open/2`](http://www."
"erlang.org/doc/man/file.html#open-2).\n"
"\n"
"This function returns:\n"
"\n"
"  * `{:ok, io_device}` - the file has been opened in the requested mode.\n"
"\n"
"    `io_device` is actually the PID of the process which handles the file.\n"
"    This process is linked to the process which originally opened the file.\n"
"    If any process to which the `io_device` is linked terminates, the file\n"
"    will be closed and the process itself will be terminated.\n"
"\n"
"    An `io_device` returned from this call can be used as an argument to "
"the\n"
"    `IO` module functions.\n"
"\n"
"  * `{:error, reason}` - the file could not be opened.\n"
"\n"
"## Examples\n"
"\n"
"    {:ok, file} = File.open(\"foo.tar.gz\", [:read, :compressed])\n"
"    IO.read(file, :line)\n"
"    File.close(file)\n"
"\n"
msgstr ""
"指定した`path`をオープンします。\n"
"\n"
"ファイルを読み書きするためには`IO`モジュールの関数を使わなくてはなりませ"
"ん。\n"
"ファイルはデフォルトでは、ファイルを読み書きするために関数\n"
"`IO.binread/2`と`IO.binwrite/2`を必要とする`:binary`モードで\n"
"オープされます。 開発者は、ファイルをオープンする際に、オプションとして\n"
"`:utf8`を渡すことができ、すると`IO`モジュールの他のすべての関数が\n"
"利用可能になります。それらはUnicodeデータを直接扱えるからです。\n"
"\n"
"`modes_or_function`は、モードのリストか、関数のいずかです。リストの場合、\n"
"（以下に記述する）モードのリストであるとみなされます。関数の場合は、\n"
"`open(path, [], modes_or_function)`の呼び出しと同じです。この関数の\n"
"詳細は`open/3`のドキュメントを参照してください。\n"
"\n"
"指定可能なモードは以下のとおりです。\n"
"\n"
"  * `:binary` - ファイルをバイナリモードでオープンします。unicode文字列に対す"
"る\n"
"  特別扱いは無効になります（デフォルトモード）。\n"
"\n"
"  * `:read` - ファイル（存在しなくてはならない）は読み込み用にオープンされま"
"す\n"
"\n"
"  * `:write` - ファイルは書き込み用にオープンされます。存在しない場合は作成さ"
"れます。\n"
"\n"
"    ファイルが存在し、かつ、readモードと一緒に指定されない場合、\n"
"    ファイルは切り詰めされます。\n"
"\n"
"  * `:append` - ファイルは書き込み用にオープンされ、存在しない場合は\n"
"    作成されます。appendモードでオープンされたファイルへの書込み操作は、\n"
"    常にファイルの最後尾で行われます。\n"
"\n"
"  * `:exclusive` - 書き込みの用にオープンされたファイルが存在しない場合は\n"
"    作成されます。ファイルが存在した場合は`{:error, :eexist}`を返します。\n"
"\n"
"  * `:charlist` - このモードが指定された場合、ファイルの読み込み操作は\n"
"    バイナリではなく文字のリストを返します。\n"
"\n"
"  * `:compressed` - gzip圧縮されたファイルの読み書きを可能にします。\n"
"\n"
"    compressedオプションはreadかwriteのいずれかと組合せて指定しなくては\n"
"    なりません。両方と組み合わせることはできません。\n"
"    `stat/1`で得られるファイルサイズと圧縮ファイルから読み込むことができる\n"
"     バイト数は、ほとんどの場合同じでないことに注意してください。\n"
"\n"
"  * `:utf8` - このオプションは、データが実際にどのようにディスクファイルに\n"
"    保存されるかを示します。また、ファイルの文字のUTF-8への変換、および、\n"
"    UTF-8からの変換を自動的に行います。\n"
"\n"
"    データがUTF-8に変換できない形式でファイルに送信された場合、\n"
"    または、データの文字範囲に対処できない形式でデータを返す関数に\n"
"    よりデータが読み込まれた場合は、エラーが発生し、ファイルはクローズされま"
"す。\n"
"\n"
"  * `:delayed_write`, `:raw`, `:ram`, `:read_ahead`, `:sync`, \n"
"    `{:encoding, ...}`, `{:read_ahead, pos_integer}`, \n"
"    `{:delayed_write, non_neg_integer, non_neg_integer}` - これらの\n"
"    オプションに関する詳細は\n"
"    [`:file.open/2`](http://www.erlang.org/doc/man/file.html#open-2)\n"
"    を参照してください。\n"
"\n"
"この関数は以下を返します。\n"
"\n"
"  * `{:ok, io_device}` - 要求されたモードで、ファイルはオープンされました。\n"
"\n"
"    `io_device`は、通常、ファイルを扱うプロセスのPIDです。\n"
"    このプロセスはファイルをオープンしたプロセスにリンクされています。\n"
"    `io_device`がリンクされているプロセスが終了した場合、\n"
"    ファイルはクローズされ、そのプロセス自身も終了します。\n"
"\n"
"    この関数から返された`io_device`は、`IO`モジュールの関数の引数として\n"
"    使用できます。\n"
"\n"
"  * `{:error, reason}` - ファイルはオープンできませんでした。\n"
"\n"
"## 例\n"
"\n"
"    {:ok, file} = File.open(\"foo.tar.gz\", [:read, :compressed])\n"
"    IO.read(file, :line)\n"
"    File.close(file)\n"
"\n"

#. TRANSLATORS: Elixir.File Summary
#: lib/file.ex:2
msgid ""
"This module contains functions to manipulate files.\n"
"\n"
"Some of those functions are low-level, allowing the user\n"
"to interact with files or IO devices, like `open/2`,\n"
"`copy/3` and others. This module also provides higher\n"
"level functions that work with filenames and have their naming\n"
"based on UNIX variants. For example, one can copy a file\n"
"via `cp/3` and remove files and directories recursively\n"
"via `rm_rf/1`.\n"
"\n"
"## Encoding\n"
"\n"
"In order to write and read files, one must use the functions\n"
"in the `IO` module. By default, a file is opened in binary mode,\n"
"which requires the functions `IO.binread/2` and `IO.binwrite/2`\n"
"to interact with the file. A developer may pass `:utf8` as an\n"
"option when opening the file, then the slower `IO.read/2` and\n"
"`IO.write/2` functions must be used as they are responsible for\n"
"doing the proper conversions and providing the proper data guarantees.\n"
"\n"
"Note that filenames when given as charlists in Elixir are\n"
"always treated as UTF-8. In particular, we expect that the\n"
"shell and the operating system are configured to use UTF-8\n"
"encoding. Binary filenames are considered raw and passed\n"
"to the OS as is.\n"
"\n"
"## API\n"
"\n"
"Most of the functions in this module return `:ok` or\n"
"`{:ok, result}` in case of success, `{:error, reason}`\n"
"otherwise. Those functions also have a variant\n"
"that ends with `!` which returns the result (instead of the\n"
"`{:ok, result}` tuple) in case of success or raises an\n"
"exception in case it fails. For example:\n"
"\n"
"    File.read(\"hello.txt\")\n"
"    #=> {:ok, \"World\"}\n"
"\n"
"    File.read(\"invalid.txt\")\n"
"    #=> {:error, :enoent}\n"
"\n"
"    File.read!(\"hello.txt\")\n"
"    #=> \"World\"\n"
"\n"
"    File.read!(\"invalid.txt\")\n"
"    #=> raises File.Error\n"
"\n"
"In general, a developer should use the former in case they want\n"
"to react if the file does not exist. The latter should be used\n"
"when the developer expects their software to fail in case the\n"
"file cannot be read (i.e. it is literally an exception).\n"
"\n"
"## Processes and raw files\n"
"\n"
"Every time a file is opened, Elixir spawns a new process. Writing\n"
"to a file is equivalent to sending messages to the process that\n"
"writes to the file descriptor.\n"
"\n"
"This means files can be passed between nodes and message passing\n"
"guarantees they can write to the same file in a network.\n"
"\n"
"However, you may not always want to pay the price for this abstraction.\n"
"In such cases, a file can be opened in `:raw` mode. The options `:"
"read_ahead`\n"
"and `:delayed_write` are also useful when operating on large files or\n"
"working with files in tight loops.\n"
"\n"
"Check [`:file.open/2`](http://www.erlang.org/doc/man/file.html#open-2) for "
"more information\n"
"about such options and other performance considerations.\n"
msgstr ""
"このモジュールはファイルを操作するための関数を含みます。\n"
"\n"
"それらの関数のあるものは、`open/2`や`copy/3`などのように、低レベルで\n"
"ファイルやIOデバイスと相互作用することができます。また、このモジュールは\n"
"ファイル名を扱う関数や、UNIX族に基いた名前を持つ高レベルの関数も提供しま"
"す。\n"
"たとえば、`cp/3`によりファイルのコピーができ、`rm_rf/1`により再帰的に\n"
"ファイルとディレクトリを削除できます。\n"
"\n"
"## エンコーディング\n"
"\n"
"ファイルを読み書きするためには`IO`モジュールの関数を使わなければなりま\n"
"せん。デフォルトではファイルは、ファイルを読み書きするために関数\n"
"`IO.binread/2`と`IO.binwrite/2`を必要とする、バイナリモードでオープされま"
"す。\n"
"開発者は、ファイルをオープンする際に、オプションとして`:utf8`を\n"
"渡し、これより遅い関数`IO.read/2`と`IO.write/2`を使用する必要があるでしょ"
"う。\n"
"なぜなら、これらの関数は適切な変換を行い、適切なデータ保証を提供するからで"
"す。\n"
"\n"
"Elixirでは文字のリストで指定されたファイル名は、常にUTF-8として\n"
"扱われることに注意してください。特に、シェルとオペレーティングシステムが\n"
"UTF-8エンコーディングを使用するように構成されていると仮定しています。\n"
"バイナリのファイル名はrawであるとみなされ、OSにそのまま渡されます。\n"
"\n"
"## API\n"
"\n"
"このモジュールのほとんどの関数は、成功時に`:ok`または`{:ok, result}`を\n"
"返し、そうでない場合は`{:error, reason}`を返します。それらの関数には\n"
"最後に`!`が付くバージョンもあり、成功時には（`{:ok, result}`タプルではな"
"く）\n"
"結果を返し、失敗時には例外を発生させます。たとえば、\n"
"\n"
"    File.read(\"hello.txt\")\n"
"    #=> {:ok, \"World\"}\n"
"\n"
"    File.read(\"invalid.txt\")\n"
"    #=> {:error, :enoent}\n"
"\n"
"    File.read!(\"hello.txt\")\n"
"    #=> \"World\"\n"
"\n"
"    File.read!(\"invalid.txt\")\n"
"    #=> raises File.Error\n"
"\n"
"一般に、ファイルが存在しない場合に対応したい場合には前者を使用するべきで"
"す。\n"
"後者は、ファイルを読むことができない場合はソフトウェアが失敗することを期待す"
"る\n"
"場合（すなわち、文字通り例外の場合）に使用するべきです。\n"
"\n"
"## プロセスとrawファイル\n"
"\n"
"ファイルがオープンされる度に、Elixirは新しいプロセスを生成します。ファイルへ"
"の\n"
"書き込みは、そのファイル記述子に書き込むプロセスへのメッセージの送信に\n"
"ほかなりません。\n"
"\n"
"これは、ファイルはノード間で受け渡すことができ、メッセージのやり取りは\n"
"ネットワーク内の同じファイルに書き込めることを保証することを意味します。\n"
"\n"
"しかし、必ずしも常にこの抽象概念に対する対価を支払いたくはないでしょう。そ"
"の\n"
"ような場合は、ファイルを`:raw`モードでオープンすることができます。\n"
"巨大なファイルの操作やファイルのタイトなループ処理を行う際には、\n"
"`:read_ahead`オプションや`:delayed_write`オプションも役に立つでしょう。\n"
"\n"
"オプションとその他のパフォーマンス上の考慮点についての詳細は、\n"
"[`:file.open/2`](http://www.erlang.org/doc/man/file.html#open-2) を\n"
"チェックしてください。\n"

#. TRANSLATORS: def File.write_stat(path, stat, opts \\ [])
#: lib/file.ex:339
msgid ""
"Writes the given `File.Stat` back to the filesystem at the given\n"
"path. Returns `:ok` or `{:error, reason}`.\n"
msgstr ""
"指定した`File.Stat`を指定したパスのファイルシステムに書き戻します。\n"
"`:ok`または`{:error, reason}`を返します。\n"

#. TRANSLATORS: def File.cd!(path, function)
#: lib/file.ex:1149
msgid ""
"Changes the current directory to the given `path`,\n"
"executes the given function and then reverts back\n"
"to the previous path regardless of whether there is an exception.\n"
"\n"
"Raises an error if retrieving or changing the current\n"
"directory fails.\n"
msgstr ""
"指定した`path`にカレントディレクトリを変更し、指定した関数を実行します。\n"
"そして、例外の有無に関わらず、元のパスに戻ります。\n"
"\n"
"カレントディレクトリの取得または変更に失敗した場合は、エラーが発生します。\n"

#. TRANSLATORS: def File.rename(source, destination)
#: lib/file.ex:453
msgid ""
"Renames the `source` file to `destination` file.  It can be used to move "
"files\n"
"(and directories) between directories.  If moving a file, you must fully\n"
"specify the `destination` filename, it is not sufficient to simply specify\n"
"its directory.\n"
"\n"
"Returns `:ok` in case of success, `{:error, reason}` otherwise.\n"
"\n"
"Note: The command `mv` in Unix systems behaves differently depending\n"
"if `source` is a file and the `destination` is an existing directory.\n"
"We have chosen to explicitly disallow this behaviour.\n"
"\n"
"## Examples\n"
"\n"
"    # Rename file \"a.txt\" to \"b.txt\"\n"
"    File.rename \"a.txt\", \"b.txt\"\n"
"\n"
"    # Rename directory \"samples\" to \"tmp\"\n"
"    File.rename \"samples\", \"tmp\"\n"
msgstr ""
"`source`ファイルを`destination`ファイルにリネームします。\n"
"ディレクトリ間のファイル（とディレクトリ）の移動にも使用できます。\n"
"ファイルを移動させる場合、`destination`ファイル名を完全に指定しなければ\n"
"なりません。単にディレクトリを指定するだけでは不十分です。\n"
"\n"
"成功した場合は`:ok`を返し、そうでなければ`{:error, reason}`を返します。\n"
"\n"
"注意: Unixシステムの`mv`コマンドは、`source`がファイルで、`destination`が\n"
"既存のディレクトリの場合、異なる振る舞いをします。\n"
"この振る舞いを認めないことを明示的に選択しました。\n"
"\n"
"## 例\n"
"\n"
"    # ファイル”a.txt”を\"b.txt”にリネーム\n"
"    File.rename \"a.txt\", \"b.txt\"\n"
"\n"
"    # ディレクトリ”samples”を\"tmp\"にリネーム\n"
"    File.rename \"samples\", \"tmp\"\n"

#. TRANSLATORS: def File.touch!(path, time \\ :calendar.universal_time())
#: lib/file.ex:385
msgid ""
"Same as `touch/2` but raises an exception if it fails.\n"
"\n"
"Returns `:ok` otherwise. Requires datetime in UTC.\n"
msgstr ""
"`touch/2`と同じですが、失敗すると例外が発生します。\n"
"\n"
"そうでなければ`:ok`を返します。日時はUTCである必要があります。\n"

#. TRANSLATORS: def File.copy(source, destination, bytes_count \\ :infinity)
#: lib/file.ex:411
msgid ""
"Copies the contents of `source` to `destination`.\n"
"\n"
"Both parameters can be a filename or an IO device opened\n"
"with `open/2`. `bytes_count` specifies the number of\n"
"bytes to copy, the default being `:infinity`.\n"
"\n"
"If file `destination` already exists, it is overwritten\n"
"by the contents in `source`.\n"
"\n"
"Returns `{:ok, bytes_copied}` if successful,\n"
"`{:error, reason}` otherwise.\n"
"\n"
"Compared to the `cp/3`, this function is more low-level,\n"
"allowing a copy from device to device limited by a number of\n"
"bytes. On the other hand, `cp/3` performs more extensive\n"
"checks on both source and destination and it also preserves\n"
"the file mode after copy.\n"
"\n"
"Typical error reasons are the same as in `open/2`,\n"
"`read/1` and `write/3`.\n"
msgstr ""
"`source`の内容を`destination`にコピーします。\n"
"\n"
"両パラメタはともに、ファイル名か`open/2`でオープンされたIOデバイスです。\n"
"`bytes_count`はコピーするバイト数を指定します。デフォルトは\n"
"`:infinity`です。\n"
"\n"
"ファイル`destination`が既に存在していた場合、`source`の\n"
"内容によって上書きされます。\n"
"\n"
"成功した場合は`{:ok, bytes_copied}`を返し、そうでなければ\n"
"`{:error, reason}`を返します。\n"
"\n"
"`cp/3`と比較して、この関数はより低レベルであり、デバイスから\n"
"デバイスへのコピーをバイト数で制限することができます。\n"
"一方、`cp/3`はソースとデスティネーションの双方で、より詳細な\n"
"チェックを行い、コピー後にファイルモードを維持します。\n"
"\n"
"典型的なエラー理由は、`open/2`、`read/2`、`write/3`と同じです。\n"

#. TRANSLATORS: def File.write_stat!(path, stat, opts \\ [])
#: lib/file.ex:349
msgid ""
"Same as `write_stat/3` but raises an exception if it fails.\n"
"Returns `:ok` otherwise.\n"
msgstr ""
"`write_state/3`と同じですが、失敗すると例外が発生します。\n"
"そうでなければ`:ok`を返します。\n"

#. TRANSLATORS: def File.stat(path, opts \\ [])
#: lib/file.ex:249
msgid ""
"Returns information about the `path`. If it exists, it\n"
"returns a `{:ok, info}` tuple, where info is a\n"
"`File.Stat` struct. Returns `{:error, reason}` with\n"
"the same reasons as `read/1` if a failure occurs.\n"
"\n"
"## Options\n"
"\n"
"The accepted options are:\n"
"\n"
"  * `:time` - configures how the file timestamps are returned\n"
"\n"
"The values for `:time` can be:\n"
"\n"
"  * `:universal` - returns a `{date, time}` tuple in UTC (default)\n"
"  * `:local` - returns a `{date, time}` tuple using the same time zone as "
"the\n"
"    machine\n"
"  * `:posix` - returns the time as integer seconds since epoch\n"
"\n"
msgstr ""
"`path`に関する情報を返します。パスが存在する場合は`{:ok, info}`タプルを\n"
"返します。ここで`info`は`File.Stat`構造体です。失敗した場合は\n"
"`{:error, reason}`を返します。`reason`は`read/1`と同じです。\n"
"\n"
"## オプション\n"
"\n"
"次のオプションを受け付けます。\n"
"\n"
"  * `:time` - ファイルのタイムタンプをどのように返すかを構成します\n"
"\n"
"`:time`の値には以下を指定できます。\n"
"\n"
"  * `:universal` - UTCの`{date, time}`タプルを返します（デフォルト）。\n"
"  * `:local` - マシン時間を使用して`{date, time}`タプルを返します。\n"
"  * `:posix` - エポック時からの整数秒数として時刻を返します。\n"
"\n"

#. TRANSLATORS: def File.cwd!()
#: lib/file.ex:1114
msgid "The same as `cwd/0`, but raises an exception if it fails.\n"
msgstr "`cwd/0`と同じですが、失敗すると例外が発生します。\n"

#. TRANSLATORS: def File.mkdir_p!(path)
#: lib/file.ex:200
msgid ""
"Same as `mkdir_p/1`, but raises an exception in case of failure. Otherwise `:"
"ok`.\n"
msgstr ""
"`mkdir_p/1`と同じですが、失敗すると例外が発生します。そうでなければ\n"
"`:ok`を返します。\n"

#. TRANSLATORS: def File.cp_r!(source, destination, callback \\ fn _, _ -> true end)
#: lib/file.ex:583
msgid ""
"The same as `cp_r/3`, but raises `File.CopyError` if it fails.\n"
"Returns the list of copied files otherwise.\n"
msgstr ""
"`cp_r/3`と同じですが、失敗すると`File.CopyError`が発生します。\n"
"そうでなければ、コピーされたファイルのリストを返します。\n"

#. TRANSLATORS: def File.mkdir!(path)
#: lib/file.ex:147
msgid ""
"Same as `mkdir/1`, but raises an exception in case of failure. Otherwise `:"
"ok`.\n"
msgstr ""
"`mkdir/1`と同じですが、失敗すると例外が発生します。そうでなければ\n"
"`:ok`を返します。\n"

#. TRANSLATORS: def File.write(path, content, modes \\ [])
#: lib/file.ex:676
msgid ""
"Writes `content` to the file `path`.\n"
"\n"
"The file is created if it does not exist. If it exists, the previous\n"
"contents are overwritten. Returns `:ok` if successful, or `{:error, reason}"
"`\n"
"if an error occurs.\n"
"\n"
"`content` must be `iodata` (a list of bytes or a binary). Setting the\n"
"encoding for this function has no effect.\n"
"\n"
"**Warning:** Every time this function is invoked, a file descriptor is "
"opened\n"
"and a new process is spawned to write to the file. For this reason, if you "
"are\n"
"doing multiple writes in a loop, opening the file via `File.open/2` and "
"using\n"
"the functions in `IO` to write to the file will yield much better "
"performance\n"
"than calling this function multiple times.\n"
"\n"
"Typical error reasons are:\n"
"\n"
"  * `:enoent`  - a component of the file name does not exist\n"
"  * `:enotdir` - a component of the file name is not a directory;\n"
"    on some platforms, `:enoent` is returned instead\n"
"  * `:enospc`  - there is no space left on the device\n"
"  * `:eacces`  - missing permission for writing the file or searching one "
"of\n"
"    the parent directories\n"
"  * `:eisdir`  - the named file is a directory\n"
"\n"
"Check `File.open/2` for other available options.\n"
msgstr ""
"`content`をファイル`path`に書き込みます。\n"
"\n"
"ファイルが存在しなかった場合は作成されます。存在した場合、以前の内容は\n"
"上書きされます。成功した場合は`:ok`を、エラーが起きた場合は\n"
"`{:error, reason}` を返します。\n"
"\n"
"`content`は`iodata`（バイトのリストまたはバイナリ）でなければなりません。\n"
"この関数へのエンコーディングの設定は効果がありません。\n"
"\n"
"**警告:** この関数が呼び出されるたびに、ファイルディスクプリタがオープン\n"
"され、ファイルに書き込むための新しいプロセスが生成されます。\n"
"この理由から、ループの中で複数回の書き出しを行い、`File.open/2`で\n"
"ファイルをオープンし、`IO`モジュールの関数を使ってファイルに書き込んだ\n"
"方が、この関数を複数回呼び出すよりはるかに良いパフォーマンスが得られます。\n"
"\n"
"よくあるエラー理由は以下の通りです。\n"
"\n"
"  * `:enoent`  - ファイル名の構成要素が存在しない\n"
"  * `:enotdir` - ファイル名の構成要素がディレクトリではない;\n"
"     代わりに`:enoent`が返されるプラットフォームもあります\n"
"  * `:enospc`  - デバイスに空きスペースがない\n"
"  * `:eacces`  - ファイルの書き込み権限、または、親ディレクトリの\n"
"      読み込み権限がない\n"
"  * `:eisdir`  - 指定したファイルがディレクトリである\n"
"\n"
"その他の利用可能なオプションについては`File.open/2`をチェックしてください\n"

#. TRANSLATORS: def File.ls(path \\ ".")
#: lib/file.ex:1168
msgid ""
"Returns the list of files in the given directory.\n"
"\n"
"Returns `{:ok, [files]}` in case of success,\n"
"`{:error, reason}` otherwise.\n"
msgstr ""
"指定したディレクトリのファイルのリストを返します。\n"
"\n"
"成功すした場合は`{:ok, [files]}`を、そうでなければ、\n"
"`{:error, reason}`を返します。\n"

#. TRANSLATORS: def File.chgrp!(path, gid)
#: lib/file.ex:1304
msgid ""
"Same as `chgrp/2`, but raises an exception in case of failure. Otherwise `:"
"ok`.\n"
msgstr ""
"`chgrp/2`と同じですが、失敗すると例外が発生します。\n"
"そうでなければ、`:ok`を返します。\n"

#. TRANSLATORS: def File.cp(source, destination, callback \\ fn _, _ -> true end)
#: lib/file.ex:478
msgid ""
"Copies the contents in `source` to `destination` preserving its mode.\n"
"\n"
"If a file already exists in the destination, it invokes a\n"
"callback which should return `true` if the existing file\n"
"should be overwritten, `false` otherwise. The callback defaults to return "
"`true`.\n"
"\n"
"The function returns `:ok` in case of success, returns\n"
"`{:error, reason}` otherwise.\n"
"\n"
"If you want to copy contents from an IO device to another device\n"
"or do a straight copy from a source to a destination without\n"
"preserving modes, check `copy/3` instead.\n"
"\n"
"Note: The command `cp` in Unix systems behaves differently depending\n"
"if `destination` is an existing directory or not. We have chosen to\n"
"explicitly disallow this behaviour. If destination is a directory, an\n"
"error will be returned.\n"
msgstr ""
"`source`の内容を`destination`にモードを維持してコピーします。\n"
"\n"
"デスティネーションにファイルが既に存在する場合は、\n"
"コールバックを起動します。このコールバックは、そのファイルが\n"
"上書きされるべきなら`true`を返し、そうでなければ`false`を返す\n"
"ようにします。デフォルトのコールバックは`true`を返します。\n"
"\n"
"成功した場合は`{:ok}`を返し、そうでなければ`{:error, reason}`を返します。\n"
"\n"
"IOデバイスから別のデバイスにコピーしたい場合、または、モードを維持する\n"
"ことなく、直接、ソースからデスティネーションにコピーしたい場合は、\n"
"`copy/3`をチェックしてください。\n"
"\n"
"注意: Unixシステムの`cp`コマンドは、`destination`が既存の\n"
"ディレクトリか否かで異なる振る舞いをします。Elixirでは、この振る舞いを\n"
"認めないことを明示的に選択しました。`destination`がディレクトリの場合は、\n"
"エラーを返します。\n"

#. TRANSLATORS: def File.rm_rf(path)
#: lib/file.ex:824
msgid ""
"Removes files and directories recursively at the given `path`.\n"
"Symlinks are not followed but simply removed, non-existing\n"
"files are simply ignored (i.e. doesn't make this function fail).\n"
"\n"
"Returns `{:ok, files_and_directories}` with all files and\n"
"directories removed in no specific order, `{:error, reason, file}`\n"
"otherwise.\n"
"\n"
"## Examples\n"
"\n"
"    File.rm_rf \"samples\"\n"
"    #=> {:ok, [\"samples\", \"samples/1.txt\"]}\n"
"\n"
"    File.rm_rf \"unknown\"\n"
"    #=> {:ok, []}\n"
"\n"
msgstr ""
"指定した`path`から再帰的にファイルとディレクトリを削除します。\n"
"シンボリックリンクは辿らずに単に削除します。\n"
"存在しないファイルは単に無視します（すなわち、この関数を失敗させません）。\n"
"\n"
"削除したすべてのファイルとディレクトリの順不同のリストを持つ\n"
"`{:ok, file_and_directories}`を返します。\n"
"そうでなければ、`{:error, reason, file}`を返します。\n"
"\n"
"## 例\n"
"\n"
"    File.rm_rf \"samples\"\n"
"    #=> {:ok, [\"samples\", \"samples/1.txt\"]}\n"
"\n"
"    File.rm_rf \"unknown\"\n"
"    #=> {:ok, []}\n"
"\n"

#. TRANSLATORS: def File.stream!(path, modes \\ [], line_or_bytes \\ :line)
#: lib/file.ex:1209
msgid ""
"Returns a `File.Stream` for the given `path` with the given `modes`.\n"
"\n"
"The stream implements both `Enumerable` and `Collectable` protocols,\n"
"which means it can be used both for read and write.\n"
"\n"
"The `line_or_bytes` argument configures how the file is read when\n"
"streaming, by `:line` (default) or by a given number of bytes.\n"
"\n"
"Operating the stream can fail on open for the same reasons as\n"
"`File.open!/2`. Note that the file is automatically opened each time "
"streaming\n"
"begins. There is no need to pass `:read` and `:write` modes, as those are\n"
"automatically set by Elixir.\n"
"\n"
"## Raw files\n"
"\n"
"Since Elixir controls when the streamed file is opened, the underlying\n"
"device cannot be shared and as such it is convenient to open the file\n"
"in raw mode for performance reasons. Therefore, Elixir **will** open\n"
"streams in `:raw` mode with the `:read_ahead` option unless an encoding\n"
"is specified. This means any data streamed into the file must be\n"
"converted to `t:iodata/0` type. If you pass `[:utf8]` in the modes "
"parameter,\n"
"the underlying stream will use `IO.write/2` and the `String.Chars` protocol\n"
"to convert the data. See `IO.binwrite/2` and `IO.write/2` .\n"
"\n"
"One may also consider passing the `:delayed_write` option if the stream\n"
"is meant to be written to under a tight loop.\n"
"\n"
"## Examples\n"
"\n"
"    # Read in 2048 byte chunks rather than lines\n"
"    File.stream!(\"./test/test.data\", [], 2048)\n"
"    #=> %File.Stream{line_or_bytes: 2048, modes: [:raw, :read_ahead, :"
"binary],\n"
"    #=> path: \"./test/test.data\", raw: true}\n"
"\n"
"See `Stream.run/1` for an example of streaming into a file.\n"
"\n"
msgstr ""
"指定した`path`を指定した`modes`の`File.Stream`で返します。\n"
"\n"
"ストリームは`Enumerable`プロトコルと`Collectable`プロトコルの\n"
"両方を実装しており、これは読み書きの両方に使用できることを意味します。\n"
"\n"
"`line_or_byte`引数は、ファイルをストリーミングする際にファイルを読み込む\n"
"方法、`:line`（デフォルト）か、指定したバイト数かを構成します。\n"
"\n"
"ストリーム操作は、`File.open!/2`と同じ理由でオープンに失敗する場合がありま"
"す。\n"
"ストリーミングは開始されるごとに、ファイルは自動的にオープンされることに、\n"
"注意してください。`:read`モードや`:write`モードはElixirにより自動的にセット\n"
"されるので、渡す必要はありません。\n"
"\n"
"## Rawファイル\n"
"\n"
"ストリームされるファイルが何時オープンされるかはElixirが制御するので、\n"
"下層のデバイスを共有することはできません。そのため、パフォーマンス上の\n"
"理由からファイルをrawモードでオープンすると便利です。従って、\n"
"エンコーディングが指定されない限り、Elixirは`:read_ahead`オプション付の\n"
"`:raw`モードでストリームをオープン ** します ** 。\n"
"これは、ファイルへ流し込むすべてのデータストリームは`t:iodata/0`型に\n"
"変換しなければならないことを意味します。\n"
"modeパラメタで`[:utf8]`を渡した場合、下層のストリームでは`IO.write/2`を、\n"
"データの変換には`String.Chars`プロトコルを使用します。\n"
"`IO.binwrite/2`と`IO.write/2`を参照してください。\n"
"\n"
"タイトなループ下でストリームが書き込みされる場合は、\n"
"`:delayed_write`オプションの使用も検討した方が良いかもしれません。\n"
"\n"
"## 例\n"
"\n"
"    # 行ではなく2048バイトのまとまりを読み込む\n"
"    File.stream!(\"./test/test.data\", [], 2048)\n"
"    #=> %File.Stream{line_or_bytes: 2048, modes: [:raw, :read_ahead, :"
"binary],\n"
"    #=> path: \"./test/test.data\", raw: true}\n"
"\n"
"ストリームをファイルへ書き出す例は`Stream.run/1`を参照してください。\n"
"\n"

#. TRANSLATORS: def File.write!(path, content, modes \\ [])
#: lib/file.ex:710
msgid ""
"Same as `write/3` but raises an exception if it fails, returns `:ok` "
"otherwise.\n"
msgstr ""
"`write/3`と同じですが、失敗すると例外が発生します。\n"
"そうでなければ`:ok`を返します。\n"

#. TRANSLATORS: def File.read!(path)
#: lib/file.ex:234
msgid ""
"Returns a binary with the contents of the given filename or raises\n"
"`File.Error` if an error occurs.\n"
msgstr ""
"指定したファイル名の内容をバイナリで返します。\n"
"エラーが発生した場合は`File.Error`が発生します。\n"

#. TRANSLATORS: def File.regular?(path)
#: lib/file.ex:85
msgid ""
"Returns `true` if the path is a regular file.\n"
"\n"
"## Examples\n"
"\n"
"    File.regular? __ENV__.file #=> true\n"
"\n"
msgstr ""
"pathが通常ファイルの場合、`true`を返します。\n"
"\n"
"## 例\n"
"\n"
"    File.regular? __ENV__.file #=> true\n"
"\n"

#. TRANSLATORS: def File.chown!(path, uid)
#: lib/file.ex:1327
msgid ""
"Same as `chown/2`, but raises an exception in case of failure. Otherwise `:"
"ok`.\n"
msgstr ""
"`chown/2`と同じですが、失敗すると例外が発生します。そうでなければ\n"
"`:ok`を返します。\n"

#. TRANSLATORS: def File.lstat!(path, opts \\ [])
#: lib/file.ex:325
msgid ""
"Same as `lstat/2` but returns the `File.Stat` struct directly and\n"
"throws `File.Error` if an error is returned.\n"
msgstr ""
"`stat/2`と同じですが、直接`File.Stat`構造体を返し、エラーが返された場合は\n"
"`File.Error`を発生させます。\n"

#. TRANSLATORS: def File.open!(path, modes_or_function \\ [])
#: lib/file.ex:1054
msgid ""
"Similar to `open/2` but raises an error if file could not be opened.\n"
"\n"
"Returns the IO device otherwise.\n"
"\n"
"See `open/2` for the list of available modes.\n"
msgstr ""
"`open/2`と同じですが、ファイルがオープンできなかった場合、\n"
"エラーが発生します。\n"
"\n"
"そうでなければ、`io_device`を返します。\n"
"\n"
"利用可能なモードの一覧は`open/2`を参照してください。\n"
"\n"

#. TRANSLATORS: def File.dir?(path)
#: lib/file.ex:98
msgid "Returns `true` if the path is a directory.\n"
msgstr "pathがディレクトリの場合、`true`を返します。\n"

#. TRANSLATORS: def File.cd(path)
#: lib/file.ex:1126
msgid ""
"Sets the current working directory.\n"
"\n"
"Returns `:ok` if successful, `{:error, reason}` otherwise.\n"
msgstr ""
"カレントワーキングディレクトリをセットします。\n"
"\n"
"成功したら`:ok`を、さもなければ`{:error, reason}`を返します。\n"

#. TRANSLATORS: def File.ln_s(existing, new)
#: lib/file.ex:400
msgid ""
"Creates a symbolic link `new` to the file or directory `existing`.\n"
"\n"
"Returns `:ok` if successful, `{:error, reason}` otherwise.\n"
"If the operating system does not support symlinks, returns\n"
"`{:error, :enotsup}`.\n"
msgstr ""
"ファイルまたはディレクトリである`existing`のシンボリックリンク`new`を\n"
"作成します。\n"
"\n"
"成功した場合は`:ok`を返し、そうでなければ`{:error, reason}`を返します。\n"
"オペレーティングシステムがシンボリックリンクをサポートしていない場合は\n"
"`{:error, :enotsup}`を返します。\n"

#. TRANSLATORS: def File.cwd()
#: lib/file.ex:1089
msgid ""
"Gets the current working directory.\n"
"\n"
"In rare circumstances, this function can fail on Unix. It may happen\n"
"if read permissions do not exist for the parent directories of the\n"
"current directory. For this reason, returns `{:ok, cwd}` in case\n"
"of success, `{:error, reason}` otherwise.\n"
msgstr ""
"カレントワーキングディレクトリを取得します。\n"
"\n"
"Unixではまれにこの関数が失敗することがあります。\n"
"それは、カレントディレクトリの親ディレクトリに読み込み権限がない場合に\n"
"起きる可能性があります。この理由で、成功した場合は`{:ok, cwd}`が、\n"
"そうでなければ`{:error, reason}`が返ります。\n"

#. TRANSLATORS: def File.cp!(source, destination, callback \\ fn _, _ -> true end)
#: lib/file.ex:515
msgid ""
"The same as `cp/3`, but raises `File.CopyError` if it fails.\n"
"Returns `:ok` otherwise.\n"
msgstr ""
"`copy/3`と同じですが、失敗すると`File.CopyError`が発生します。\n"
"そうでなければ`:ok`を返します。\n"

#. TRANSLATORS: def File.exists?(path)
#: lib/file.ex:106
msgid ""
"Returns `true` if the given path exists.\n"
"It can be regular file, directory, socket,\n"
"symbolic link, named pipe or device file.\n"
"\n"
"## Examples\n"
"\n"
"    File.exists?(\"test/\")\n"
"    #=> true\n"
"\n"
"    File.exists?(\"missing.txt\")\n"
"    #=> false\n"
"\n"
"    File.exists?(\"/dev/null\")\n"
"    #=> true\n"
"\n"
msgstr ""
"指定したパスが存在する場合、`true`を返します。\n"
"パスには、標準ファイル、ディレクトリ、ソケット、シンボリックリンク、\n"
"名前付きパイプ、デバイスファイルが指定できます。\n"
"\n"
"## 例\n"
"\n"
"    File.exists?(\"test/\")\n"
"    #=> true\n"
"\n"
"    File.exists?(\"missing.txt\")\n"
"    #=> false\n"
"\n"
"    File.exists?(\"/dev/null\")\n"
"    #=> true\n"
"\n"

#. TRANSLATORS: def File.chown(path, uid)
#: lib/file.ex:1317
msgid ""
"Changes the owner given by the user id `uid`\n"
"for a given `file`. Returns `:ok` on success,\n"
"or `{:error, reason}` on failure.\n"
msgstr ""
"指定した`path`の所有者を、ユーザID`uid`により指定されるユーザに\n"
"変更します。成功した場合は`:ok`を返し、失敗した場合は`{:error, reason}`を返し"
"ます。\n"

#. TRANSLATORS: def File.mkdir(path)
#: lib/file.ex:128
msgid ""
"Tries to create the directory `path`. Missing parent directories are not "
"created.\n"
"Returns `:ok` if successful, or `{:error, reason}` if an error occurs.\n"
"\n"
"Typical error reasons are:\n"
"\n"
"  * `:eacces`  - missing search or write permissions for the parent\n"
"    directories of `path`\n"
"  * `:eexist`  - there is already a file or directory named `path`\n"
"  * `:enoent`  - a component of `path` does not exist\n"
"  * `:enospc`  - there is no space left on the device\n"
"  * `:enotdir` - a component of `path` is not a directory;\n"
"    on some platforms, `:enoent` is returned instead\n"
msgstr ""
"`path`ディレクトリの作成を試みます。存在しない親ディレクトリは作成されませ"
"ん。\n"
"成功した場合は`:ok`を、エラーが発生した場合は`{:error, reason}`を返します。\n"
"\n"
"よくあるエラー理由は以下のとおりです。\n"
"\n"
"  * `:eacces`  - `path`の親ディレクトリの読み込み権限または書き込み権限がな"
"い\n"
"  * `:eexist`  - `path`という名前のファイルまたはディレクトリが既に存在する\n"
"  * `:enoent`  - `path`の一部が存在しない\n"
"  * `:enospc`  - デバイスに空きスペースがない\n"
"  * `:enotdir` - `path`の一部がディレクトリでない。\n"
"     プラットフォームのよっては代わりに`:enoent`が返されるものもある\n"

#. TRANSLATORS: def File.rm_rf!(path)
#: lib/file.ex:913
msgid ""
"Same as `rm_rf/1` but raises `File.Error` in case of failures,\n"
"otherwise the list of files or directories removed.\n"
msgstr ""
"`rm_rf/1`と同じですが、失敗した場合`File.Error`が発生します。\n"
"そうでなければ、削除されたファイルとディレクトリのリストを返します。\n"

#. TRANSLATORS: def File.close(io_device)
#: lib/file.ex:1196
msgid ""
"Closes the file referenced by `io_device`. It mostly returns `:ok`, except\n"
"for some severe errors such as out of memory.\n"
"\n"
"Note that if the option `:delayed_write` was used when opening the file,\n"
"`close/1` might return an old write error and not even try to close the "
"file.\n"
"See `open/2` for more information.\n"
msgstr ""
"`io_device`により参照されるファイルをクローズします。\n"
"\"out of memory\"のような深刻なエラーを除いて、\n"
"ほとんどの場合、`:ok`を返します。\n"
"\n"
"ファイルをオープンする際に`:delayed_write`オプションが使用されていいた場"
"合、\n"
"`close/1`は古い書き込みエラーを返し、ファイルを閉じようとしない場合がある\n"
"ことに、注意してください。詳細は`open/2`を参照してください。\n"

#. TRANSLATORS: def File.rm(path)
#: lib/file.ex:724
msgid ""
"Tries to delete the file `path`.\n"
"\n"
"Returns `:ok` if successful, or `{:error, reason}` if an error occurs.\n"
"\n"
"Note the file is deleted even if in read-only mode.\n"
"\n"
"Typical error reasons are:\n"
"\n"
"  * `:enoent`  - the file does not exist\n"
"  * `:eacces`  - missing permission for the file or one of its parents\n"
"  * `:eperm`   - the file is a directory and user is not super-user\n"
"  * `:enotdir` - a component of the file name is not a directory;\n"
"    on some platforms, `:enoent` is returned instead\n"
"  * `:einval`  - filename had an improper type, such as tuple\n"
"\n"
"## Examples\n"
"\n"
"    File.rm(\"file.txt\")\n"
"    #=> :ok\n"
"\n"
"    File.rm(\"tmp_dir/\")\n"
"    #=> {:error, :eperm}\n"
"\n"
msgstr ""
"`path`ファイルの削除を試みます。\n"
"\n"
"成功した場合は`:ok`を、エラーが発生した場合は`{:error, reason}`を返します。\n"
"\n"
"読み出し専用モードであってもファイルは削除される点に注意してください。\n"
"\n"
"よくあるエラー理由は以下の通りです:\n"
"\n"
"  * `:enoent`  - ファイルが存在しない\n"
"  * `:eacces`  - ファイルまたはその親のいずれかの権限がない\n"
"  * `:eperm`   - ファイルがディレクトリで、ユーザがスーパーユーザでない\n"
"  * `:enotdir` - ファイル名の一部がディレクトリでない;\n"
"    代わりにenoentが返されるプラットフォームも存在する\n"
"  * `:einval`  - ファイル名がタプルのような不適当なタイプであった\n"
"\n"
"## 例\n"
"\n"
"    File.rm(\"file.txt\")\n"
"    #=> :ok\n"
"\n"
"    File.rm(\"tmp_dir/\")\n"
"    #=> {:error, :eperm}\n"
"\n"
