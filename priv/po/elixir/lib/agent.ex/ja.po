msgid ""
msgstr ""
"Project-Id-Version: l 10n_elixir\n"
"POT-Creation-Date: \n"
"PO-Revision-Date: 2017-02-27 22:20+0900\n"
"Last-Translator: 小田 照敬 <EMAIL@ADDRESS>\n"
"Language-Team: Japanese\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Poedit 1.8.12\n"

#. TRANSLATORS: @type agent
#: lib/agent.ex:114
msgid "The agent reference"
msgstr "エージェントのリファレンス"

#. TRANSLATORS: @type name
#: lib/agent.ex:111
msgid "The agent name"
msgstr "エージェントの名前"

#. TRANSLATORS: def Agent.update(agent, fun, timeout \\ 5000)
#: lib/agent.ex:245
msgid ""
"Updates the agent state.\n"
"\n"
"The function `fun` is sent to the `agent` which invokes the function\n"
"passing the agent state. The function must return the new state.\n"
"\n"
"A timeout can also be specified (it has a default value of 5000).\n"
"This function always returns `:ok`.\n"
msgstr ""
"エージェントの状態を更新します。\n"
"\n"
"関数`fun`が`agent`に送られ、`agent`は状態を渡して関数を\n"
"実行します。関数は新しい状態を返さなければなりません。\n"
"\n"
"タイムアウトも指定することができます(デフォルト値は5000です)。\n"
"この関数は常に`:ok`を返します。\n"

#. TRANSLATORS: def Agent.stop(agent, reason \\ :normal, timeout \\ :infinity)
#: lib/agent.ex:297
msgid ""
"Stops the agent with the given `reason`.\n"
"\n"
"It returns `:ok` if the server terminates with the given\n"
"reason, if it terminates with another reason, the call will\n"
"exit.\n"
"\n"
"This function keeps OTP semantics regarding error reporting.\n"
"If the reason is any other than `:normal`, `:shutdown` or\n"
"`{:shutdown, _}`, an error report will be logged.\n"
msgstr ""
"指定した`reason`でエージェントを停止します。\n"
"\n"
"サーバが指定した理由で終了した場合は`:ok` を返し、\n"
"他の理由で終了した場合は、呼び出しは終了します。\n"
"\n"
"この関数はエラーレポートに関する OTPのセマンティクスを\n"
"保持します。理由が`:normal`, `:shutdown`、`{:shutdown, _}`\n"
"以外の場合は、エラーレポートはログされます。\n"

#. TRANSLATORS: def Agent.update(agent, module, fun, args, timeout \\ 5000)
#: lib/agent.ex:259
msgid ""
"Updates the agent state.\n"
"\n"
"Same as `update/3` but a module, function and args are expected\n"
"instead of an anonymous function. The state is added as first\n"
"argument to the given list of args.\n"
msgstr ""
"エージェントの状態を更新します。\n"
"\n"
"`update/3`と同じですが、無名関数の代わりに、モジュール、関数、引数を\n"
"引数に取ります。状態は、引数として指定されたリストの第1引数として\n"
"追加されます。\n"

#. TRANSLATORS: @type state
#: lib/agent.ex:117
msgid "The agent state"
msgstr "エージェントのステート"

#. TRANSLATORS: def Agent.cast(agent, fun)
#: lib/agent.ex:271
msgid ""
"Performs a cast (fire and forget) operation on the agent state.\n"
"\n"
"The function `fun` is sent to the `agent` which invokes the function\n"
"passing the agent state. The function must return the new state.\n"
"\n"
"Note that `cast` returns `:ok` immediately, regardless of whether the\n"
"destination node or agent exists.\n"
msgstr ""
"エージェントの状態に対しキャスト操作(発火して忘れる)を実行します。\n"
"\n"
"関数`fun`は`agent`に送られ、エージェントは状態を渡して関数を実行します。\n"
"関数は新しい状態を返さなければなりません。\n"
"\n"
"送信先のノードまたはエージェントの存在の有無にかかわらず、`cast`は\n"
"`:ok`を直ちに返すことに注意してください。\n"

#. TRANSLATORS: Elixir.Agent Summary
#: lib/agent.ex:2
msgid ""
"Agents are a simple abstraction around state.\n"
"\n"
"Often in Elixir there is a need to share or store state that\n"
"must be accessed from different processes or by the same process\n"
"at different points in time.\n"
"\n"
"The Agent module provides a basic server implementation that\n"
"allows state to be retrieved and updated via a simple API.\n"
"\n"
"## Examples\n"
"\n"
"For example, in the Mix tool that ships with Elixir, we need\n"
"to keep a set of all tasks executed by a given project. Since\n"
"this set is shared, we can implement it with an Agent:\n"
"\n"
"    defmodule Mix.TasksServer do\n"
"      def start_link do\n"
"        Agent.start_link(fn -> MapSet.new end, name: __MODULE__)\n"
"      end\n"
"\n"
"      @doc \"Checks if the task has already executed\"\n"
"      def executed?(task, project) do\n"
"        item = {task, project}\n"
"        Agent.get(__MODULE__, fn set ->\n"
"          item in set\n"
"        end)\n"
"      end\n"
"\n"
"      @doc \"Marks a task as executed\"\n"
"      def put_task(task, project) do\n"
"        item = {task, project}\n"
"        Agent.update(__MODULE__, &MapSet.put(&1, item))\n"
"      end\n"
"\n"
"      @doc \"Resets the executed tasks and returns the previous list of tasks"
"\"\n"
"      def take_all() do\n"
"        Agent.get_and_update(__MODULE__, fn set ->\n"
"          {Enum.into(set, []), MapSet.new}\n"
"        end)\n"
"      end\n"
"    end\n"
"\n"
"Note that agents still provide a segregation between the\n"
"client and server APIs, as seen in GenServers. In particular,\n"
"all code inside the function passed to the agent is executed\n"
"by the agent. This distinction is important because you may\n"
"want to avoid expensive operations inside the agent, as it will\n"
"effectively block the agent until the request is fulfilled.\n"
"\n"
"Consider these two examples:\n"
"\n"
"    # Compute in the agent/server\n"
"    def get_something(agent) do\n"
"      Agent.get(agent, fn state -> do_something_expensive(state) end)\n"
"    end\n"
"\n"
"    # Compute in the agent/client\n"
"    def get_something(agent) do\n"
"      Agent.get(agent, &(&1)) |> do_something_expensive()\n"
"    end\n"
"\n"
"The first function blocks the agent. The second function copies\n"
"all the state to the client and then executes the operation in the\n"
"client. The difference is whether the data is large enough to require\n"
"processing in the server, at least initially, or small enough to be\n"
"sent to the client cheaply.\n"
"\n"
"## Name Registration\n"
"\n"
"An Agent is bound to the same name registration rules as GenServers.\n"
"Read more about it in the `GenServer` docs.\n"
"\n"
"## A word on distributed agents\n"
"\n"
"It is important to consider the limitations of distributed agents. Agents\n"
"provide two APIs, one that works with anonymous functions and another\n"
"that expects an explicit module, function, and arguments.\n"
"\n"
"In a distributed setup with multiple nodes, the API that accepts anonymous\n"
"functions only works if the caller (client) and the agent have the same\n"
"version of the caller module.\n"
"\n"
"Keep in mind this issue also shows up when performing \"rolling upgrades\"\n"
"with agents. By rolling upgrades we mean the following situation: you wish\n"
"to deploy a new version of your software by *shutting down* some of your\n"
"nodes and replacing them with nodes running a new version of the software.\n"
"In this setup, part of your environment will have one version of a given\n"
"module and the other part another version (the newer one) of the same "
"module.\n"
"\n"
"The best solution is to simply use the explicit module, function, and "
"arguments\n"
"APIs when working with distributed agents.\n"
"\n"
"## Hot code swapping\n"
"\n"
"An agent can have its code hot swapped live by simply passing a module,\n"
"function, and args tuple to the update instruction. For example, imagine\n"
"you have an agent named `:sample` and you want to convert its inner state\n"
"from some dict structure to a map. It can be done with the following\n"
"instruction:\n"
"\n"
"    {:update, :sample, {:advanced, {Enum, :into, [%{}]}}}\n"
"\n"
"The agent's state will be added to the given list as the first argument.\n"
msgstr ""
"Agentは状態に関するシンプルな抽象化です。\n"
"\n"
"Elixirではしばしば、異るプロセスから、または、同じプロセスの\n"
"異る時点で、アクセスされなければならない状態を保存または共有する必要が\n"
"あります。\n"
"\n"
"Agentモジュールは、シンプルなAPIを介して状態の取り出しと更新を可能にする\n"
"基本的なサーバ実装を提供します。\n"
"\n"
"## 例\n"
"\n"
"たとえば、Elixirに同梱されているMixツールでは、指定のプロジェクトで\n"
"実行されたすべてのタスクを保持しておく必要があります。\n"
"この集合は共有されるので、それをAgentで実装できます:\n"
"\n"
"    defmodule Mix.TasksServer do\n"
"      def start_link do\n"
"        Agent.start_link(fn -> HashSet.new end, name: __MODULE__)\n"
"      end\n"
"\n"
"      @doc “タスクがすでに実行されているかチェックする\"\n"
"      def executed?(task, project) do\n"
"        item = {task, project}\n"
"        Agent.get(__MODULE__, fn set ->\n"
"          item in set\n"
"        end)\n"
"      end\n"
"\n"
"      @doc “タスクが実行されたとマークする\"\n"
"      def put_task(task, project) do\n"
"        item = {task, project}\n"
"        Agent.update(__MODULE__, &Set.put(&1, item))\n"
"      end\n"
"\n"
"      @doc “実行されたタスクをリセットして、以前のタスクリストを返す\"\n"
"      def take_all() do\n"
"        Agent.get_and_update(__MODULE__, fn set ->\n"
"          {Enum.into(set, []), HashSet.new}\n"
"        end)\n"
"      end\n"
"    end\n"
"\n"
"GenServerで見られるように、エージェントでもクライアントとサーバAPIは\n"
"区別されている点に注意してください。特に、エージェントに渡される関数の\n"
"コードはすべてエージェントによって実行されます。この区別は重要です。\n"
"なぜなら、エージェント内では高価な操作は避けたいからです。この区別は\n"
"リクエストが満されるまでエージェントを効果的にブロックします。\n"
"\n"
"二つの例を考えてみてください:\n"
"\n"
"    # エージェント/サーバで計算する\n"
"    def get_something(agent) do\n"
"      Agent.get(agent, fn state -> do_something_expensive(state) end)\n"
"    end\n"
"\n"
"    # エージェント/サーバで計算する\n"
"    def get_something(agent) do\n"
"      Agent.get(agent, &(&1)) |> do_something_expensive()\n"
"    end\n"
"\n"
"最初の関数はエージェントをブロックします。2番めの関数は状態の\n"
"すべてをクライアントにコピーした後、クライアントで操作を実行します。\n"
"違いは、少なくとも最初は、サーバでの処理が必要なほどデータが多いか、\n"
"または、クライアントに安価にコピーできるほどデータが少ないかです。\n"
"\n"
"## 名前の登録\n"
"\n"
"エージェントはGenServerと同じ名前登録規則が適用されます。\n"
"詳しくは`GenServer`のドキュメントを参照してください。\n"
"\n"
"## 分散エージェントについて\n"
"\n"
"分散されたエージェントの制限を考慮することは重要です。Agentは、\n"
"二つのAPIを提供します。一つは無名関数で動くもので、もう一つは\n"
"モジュール、関数、引数を明示的に指定するものです。\n"
"\n"
"複数のノードによる分散セットアップにおいては、無名関数を受け付けるAPIは、\n"
"呼び出し側(クライアント)とエージェントが呼び出し側と同じバージョンの\n"
"呼び出しモジュールを持っている場合のみ動作します。\n"
"\n"
"この問題は、エージェントを使って「ローリングアップグレード」を実行する時に"
"も\n"
"表れることに留意してください。ローリングアップグレードとは、次のような状況"
"を\n"
"意味します。ソフトウェアの新バージョンをノードの一部を*シャットダウン*し"
"て、\n"
"それをそのソフトウェの新バージョンを実行しているノードで置き換えることによ"
"り\n"
"デプロイしたいばあいです。このセットアップにおいて、環境の一部は指定のモ"
"ジュールの\n"
"あるバージョンを持ち、他の部分は同じモジュールの別のバージョン（新バージョ"
"ン）を\n"
"持つことになります。\n"
"\n"
"最良の解決策は、単に、分散エージェントで動かす時は、明示的にモジュール、関"
"数、引数\n"
"を指定するAPIを使うことです。\n"
"\n"
"## ホットコードスワッピング\n"
"\n"
"エージェントは、単に更新命令にモジュール、関数、引数のタプルを渡すことで、\n"
"停止することなくコードをホットスワッピングできます。たとえば、`:sample`と\n"
"いう名のエージェントがあり、その内部状態を何らかの辞書構造からマップに変換\n"
"したいとします。これは次のコードで実現できます。\n"
"\n"
"    {:update, :sample, {:advanced, {Enum, :into, [%{}]}}}\n"
"\n"
"エージェントの状態は、指定のリストに最初の引数として追加されます。\n"

#. TRANSLATORS: def Agent.start(module, fun, args, options \\ [])
#: lib/agent.ex:181
msgid ""
"Starts an agent with the given module function and arguments.\n"
"\n"
"Similar to `start/2` but a module, function and args are expected\n"
"instead of an anonymous function.\n"
msgstr ""
"指定したモジュールと関数、引数でエージェントを起動します。\n"
"\n"
"`start/2`と似ていますが、無名関数の代わりに、\n"
"モジュール、関数、引数を引数に取ります。\n"

#. TRANSLATORS: def Agent.get(agent, fun, timeout \\ 5000)
#: lib/agent.ex:192
msgid ""
"Gets an agent value via the given function.\n"
"\n"
"The function `fun` is sent to the `agent` which invokes the function\n"
"passing the agent state. The result of the function invocation is\n"
"returned.\n"
"\n"
"A timeout can also be specified (it has a default value of 5000).\n"
msgstr ""
"指定した関数を介してエージェントの値を取得します。\n"
"\n"
"関数`fun`が`agent`に送られ、`agent`は状態を渡して関数を\n"
"実行します。関数の実行結果が返されます。\n"
"\n"
"タイムアウトも指定することができます(デフォルト値は5000です)。\n"

#. TRANSLATORS: def Agent.get(agent, module, fun, args, timeout \\ 5000)
#: lib/agent.ex:206
msgid ""
"Gets an agent value via the given function.\n"
"\n"
"Same as `get/3` but a module, function and args are expected\n"
"instead of an anonymous function. The state is added as first\n"
"argument to the given list of args.\n"
msgstr ""
"指定した関数を介してエージェントの値を取得します。\n"
"\n"
"`get/3`と同じですが、無名関数の代わりに、モジュール、関数、引数を\n"
"引数に取ります。状態は、引数として指定されたリストの第1引数として\n"
"追加されます。\n"

#. TRANSLATORS: def Agent.cast(agent, module, fun, args)
#: lib/agent.ex:285
msgid ""
"Performs a cast (fire and forget) operation on the agent state.\n"
"\n"
"Same as `cast/2` but a module, function and args are expected\n"
"instead of an anonymous function. The state is added as first\n"
"argument to the given list of args.\n"
msgstr ""
"エージェントの状態に対しキャスト操作(発火して忘れる)を実行します。\n"
"\n"
"`cast/2`と同じですが、無名関数のかわりに、モジュール、関数、引数を\n"
"引数に取ります。状態は、引数として指定されたリストの第1引数として\n"
"追加されます。\n"

#. TRANSLATORS: def Agent.start_link(fun, options \\ [])
#: lib/agent.ex:120
msgid ""
"Starts an agent linked to the current process with the given function.\n"
"\n"
"This is often used to start the agent as part of a supervision tree.\n"
"\n"
"Once the agent is spawned, the given function is invoked and its return\n"
"value is used as the agent state. Note that `start_link` does not return\n"
"until the given function has returned.\n"
"\n"
"## Options\n"
"\n"
"The `:name` option is used for registration as described in the module\n"
"documentation.\n"
"\n"
"If the `:timeout` option is present, the agent is allowed to spend at most\n"
"the given number of milliseconds on initialization or it will be terminated\n"
"and the start function will return `{:error, :timeout}`.\n"
"\n"
"If the `:debug` option is present, the corresponding function in the\n"
"[`:sys` module](http://www.erlang.org/doc/man/sys.html) will be invoked.\n"
"\n"
"If the `:spawn_opt` option is present, its value will be passed as options\n"
"to the underlying process as in `Process.spawn/4`.\n"
"\n"
"## Return values\n"
"\n"
"If the server is successfully created and initialized, the function returns\n"
"`{:ok, pid}`, where `pid` is the PID of the server. If an agent with the\n"
"specified name already exists, the function returns\n"
"`{:error, {:already_started, pid}}` with the PID of that process.\n"
"\n"
"If the given function callback fails with `reason`, the function returns\n"
"`{:error, reason}`.\n"
msgstr ""
"現在のプロセスにリンクしたエージェントで指定した関数を起動します。\n"
"\n"
"これは通常、監視ツリーの一部としてエージェントを起動するために使われます。\n"
"\n"
"エージェントが生成されると、指定した関数が実行され、\n"
"その返り値がエージェントの状態として使われます。`start_link`は、\n"
"指定した関数が返るまでは、返らないことに注意してください。\n"
"\n"
"## オプション\n"
"\n"
"`:name`オプションはモジュールドキュメントで記載されているように、\n"
"登録のために使われます。\n"
"\n"
"`:timeout`オプションが指定された場合、エージェントは初期化に最大\n"
"指定のミリセカンド秒の時間をかけることが許されます。\n"
"この時間内に終了しない場合は、エージェントは終了させられ、\n"
"スタート関数は`{:error, :timeout}`を返します。\n"
"\n"
"`:debug`オプションが指定された場合、[`:sys` モジュール](http://www.erlang."
"org/doc/man/sys.html) にある対応する関数が起動されます。\n"
"\n"
"`:spawn_opt`オプションが指定された場合、その値は`Process.spawn/4`と同様に、\n"
"背後にあるプロセスにオプションとして渡されます。\n"
"\n"
"## 返り値\n"
"\n"
"サーバの作成が成功し、初期化された場合、関数は`{:ok, pid}`を返します。\n"
"ここで`pid`はサーバのプロセス識別子です。指定した名前を持つエージェントが\n"
"すでに存在する場合は、関数は、そのプロセスのPIDを持つ\n"
"`{:error, {:already_started, pid}}`を返します。\n"
"\n"
"指定したコールバック関数が`reason`で失敗した場合、\n"
"関数は`{:error, reason}`を返します。\n"

#. TRANSLATORS: def Agent.get_and_update(agent, module, fun, args, timeout \\ 5000)
#: lib/agent.ex:233
msgid ""
"Gets and updates the agent state in one operation.\n"
"\n"
"Same as `get_and_update/3` but a module, function and args are expected\n"
"instead of an anonymous function. The state is added as first\n"
"argument to the given list of args.\n"
msgstr ""
"1回の操作で、エージェントの状態を取得・更新します。\n"
"\n"
"`get_and_update/3`と同じですが、無名関数の代わりに、モジュール、関数、引数"
"を\n"
"引数に取ります。状態は、引数として指定されたリストの第1引数として\n"
"追加されます。\n"

#. TRANSLATORS: def Agent.start(fun, options \\ [])
#: lib/agent.ex:171
msgid ""
"Starts an agent process without links (outside of a supervision tree).\n"
"\n"
"See `start_link/2` for more information.\n"
msgstr ""
"エージェントプロセスをリンクなし(監視ツリーの外側)で起動します。\n"
"\n"
"詳細は `start_link/2` を参照してください。\n"

#. TRANSLATORS: def Agent.get_and_update(agent, fun, timeout \\ 5000)
#: lib/agent.ex:218
msgid ""
"Gets and updates the agent state in one operation.\n"
"\n"
"The function `fun` is sent to the `agent` which invokes the function\n"
"passing the agent state. The function must return a tuple with two\n"
"elements, the first being the value to return (i.e. the `get` value)\n"
"and the second one is the new state.\n"
"\n"
"A timeout can also be specified (it has a default value of 5000).\n"
msgstr ""
"1回の操作で、エージェントの状態を取得・更新します。\n"
"\n"
"関数`fun`が`agent`に送られ、`agent`は状態を渡して関数を\n"
"実行します。関数は2要素タプルを返さなければなりません。\n"
"第1要素は返すべき値(即ち`get`した値)であり、第2要素は新しい\n"
"状態です。\\\n"
"\n"
"タイムアウトを指定することもできます(デフォルト値は5000です)。\n"

#. TRANSLATORS: def Agent.start_link(module, fun, args, options \\ [])
#: lib/agent.ex:159
msgid ""
"Starts an agent linked to the current process with the given module\n"
"function and arguments.\n"
"\n"
"Same as `start_link/2` but a module, function and args are expected\n"
"instead of an anonymous function.\n"
msgstr ""
"現在のプロセスにリンクされたエージェントで指定したモジュール、関数、引数を\n"
"起動します。\n"
"\n"
"`start_link/2`と同じですが、無名関数の代わりに、モジュール、関数、引数\n"
"を引数として取ります。\n"
