msgid ""
msgstr ""
"Project-Id-Version: l 10n_elixir\n"
"PO-Revision-Date: 2017-03-14 21:48+0900\n"
"Last-Translator: 小田 照敬 <EMAIL@ADDRESS>\n"
"Language-Team: Japanese\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"POT-Creation-Date: \n"
"X-Generator: Poedit 1.8.12\n"

#. TRANSLATORS: def Path.split(path)
#: lib/path.ex:488
msgid ""
"Splits the path into a list at the path separator.\n"
"\n"
"If an empty string is given, returns an empty list.\n"
"\n"
"On Windows, path is split on both \"\\\" and \"/\" separators\n"
"and the driver letter, if there is one, is always returned\n"
"in lowercase.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Path.split(\"\")\n"
"    []\n"
"\n"
"    iex> Path.split(\"foo\")\n"
"    [\"foo\"]\n"
"\n"
"    iex> Path.split(\"/foo/bar\")\n"
"    [\"/\", \"foo\", \"bar\"]\n"
"\n"
msgstr ""
"パスをパスセパレータでリストに分割します。\n"
"\n"
"空文字列が指定された場合は空リストを返します。\n"
"\n"
"Windowsでは、パスは\"\\\"と\"/\"の両セパレータで分割され、\n"
"ドライブ文字は、もしあれば常に小文字で返されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> Path.split(\"\")\n"
"    []\n"
"\n"
"    iex> Path.split(\"foo\")\n"
"    [\"foo\"]\n"
"\n"
"    iex> Path.split(\"/foo/bar\")\n"
"    [\"/\", \"foo\", \"bar\"]\n"
"\n"

#. TRANSLATORS: def Path.absname(path)
#: lib/path.ex:18
msgid ""
"Converts the given path to an absolute one. Unlike\n"
"`expand/1`, no attempt is made to resolve `..`, `.` or `~`.\n"
"\n"
"## Unix examples\n"
"\n"
"    Path.absname(\"foo\")\n"
"    #=> \"/usr/local/foo\"\n"
"\n"
"    Path.absname(\"../x\")\n"
"    #=> \"/usr/local/../x\"\n"
"\n"
"## Windows\n"
"\n"
"    Path.absname(\"foo\").\n"
"    \"D:/usr/local/foo\"\n"
"    Path.absname(\"../x\").\n"
"    \"D:/usr/local/../x\"\n"
"\n"
msgstr ""
"指定したパスを絶対パスに変換します。\n"
"`expand/1`とは異なり、`..`、`.`、`~`を解決しません。\n"
"\n"
"## Unixの例\n"
"\n"
"    Path.absname(\"foo\")\n"
"    #=> \"/usr/local/foo\"\n"
"\n"
"    Path.absname(\"../x\")\n"
"    #=> \"/usr/local/../x\"\n"
"\n"
"## Windows\n"
"\n"
"    Path.absname(\"foo\").\n"
"    \"D:/usr/local/foo\"\n"
"    Path.absname(\"../x\").\n"
"    \"D:/usr/local/../x\"\n"
"\n"

#. TRANSLATORS: def Path.join(left, right)
#: lib/path.ex:454
msgid ""
"Joins two paths.\n"
"\n"
"The right path will always be expanded to its relative format\n"
"and any trailing slash is removed on join.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Path.join(\"foo\", \"bar\")\n"
"    \"foo/bar\"\n"
"\n"
msgstr ""
"2つのパスを結合します。\n"
"\n"
"右のパスは常に相対フォーマットに展開され、結合の際に\n"
"すべての末尾のスラッシュは削除されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> Path.join(\"foo\", \"bar\")\n"
"    \"foo/bar\"\n"
"\n"

#. TRANSLATORS: def Path.rootname(path)
#: lib/path.ex:395
msgid ""
"Returns the `path` with the `extension` stripped.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Path.rootname(\"/foo/bar\")\n"
"    \"/foo/bar\"\n"
"\n"
"    iex> Path.rootname(\"/foo/bar.ex\")\n"
"    \"/foo/bar\"\n"
"\n"
msgstr ""
"`extension`を取り除いた`path`を返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Path.rootname(\"/foo/bar\")\n"
"    \"/foo/bar\"\n"
"\n"
"    iex> Path.rootname(\"/foo/bar.ex\")\n"
"    \"/foo/bar\"\n"
"\n"

#. TRANSLATORS: def Path.relative(name)
#: lib/path.ex:193
msgid ""
"Forces the path to be a relative path.\n"
"\n"
"## Unix examples\n"
"\n"
"    Path.relative(\"/usr/local/bin\")   #=> \"usr/local/bin\"\n"
"    Path.relative(\"usr/local/bin\")    #=> \"usr/local/bin\"\n"
"    Path.relative(\"../usr/local/bin\") #=> \"../usr/local/bin\"\n"
"\n"
"## Windows examples\n"
"\n"
"    Path.relative(\"D:/usr/local/bin\") #=> \"usr/local/bin\"\n"
"    Path.relative(\"usr/local/bin\")    #=> \"usr/local/bin\"\n"
"    Path.relative(\"D:bar.ex\")         #=> \"bar.ex\"\n"
"    Path.relative(\"/bar/foo.ex\")      #=> \"bar/foo.ex\"\n"
"\n"
msgstr ""
"パスを強制的に相対パスにします。\n"
"\n"
"## Unixの例\n"
"\n"
"    Path.relative(\"/usr/local/bin\")   #=> \"usr/local/bin\"\n"
"    Path.relative(\"usr/local/bin\")    #=> \"usr/local/bin\"\n"
"    Path.relative(\"../usr/local/bin\") #=> \"../usr/local/bin\"\n"
"\n"
"## Windowsの例\n"
"\n"
"    Path.relative(\"D:/usr/local/bin\") #=> \"usr/local/bin\"\n"
"    Path.relative(\"usr/local/bin\")    #=> \"usr/local/bin\"\n"
"    Path.relative(\"D:bar.ex\")         #=> \"bar.ex\"\n"
"    Path.relative(\"/bar/foo.ex\")      #=> \"bar/foo.ex\"\n"
"\n"

#. TRANSLATORS: def Path.join(list)
#: lib/path.ex:430
msgid ""
"Joins a list of strings.\n"
"\n"
"This function should be used to convert a list of strings to a path.\n"
"Note that any trailing slash is removed on join.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Path.join([\"~\", \"foo\"])\n"
"    \"~/foo\"\n"
"\n"
"    iex> Path.join([\"foo\"])\n"
"    \"foo\"\n"
"\n"
"    iex> Path.join([\"/\", \"foo\", \"bar/\"])\n"
"    \"/foo/bar\"\n"
"\n"
msgstr ""
"文字列のリストを結合します。\n"
"\n"
"この関数は文字列のリストをパスに変関するために使われるべきです。結合の"
"際、\n"
"末尾のスラッシュはすべて削除されることに注意してください。\n"
"\n"
"## 例\n"
"\n"
"    iex> Path.join([\"~\", \"foo\"])\n"
"    \"~/foo\"\n"
"\n"
"    iex> Path.join([\"foo\"])\n"
"    \"foo\"\n"
"\n"
"    iex> Path.join([\"/\", \"foo\", \"bar/\"])\n"
"    \"/foo/bar\"\n"
"\n"

#. TRANSLATORS: Elixir.Path Summary
#: lib/path.ex:2
msgid ""
"This module provides conveniences for manipulating or\n"
"retrieving file system paths.\n"
"\n"
"The functions in this module may receive a chardata as\n"
"argument (i.e. a string or a list of characters / string)\n"
"and will always return a string (encoded in UTF-8).\n"
"\n"
"The majority of the functions in this module do not\n"
"interact with the file system, except for a few functions\n"
"that require it (like `wildcard/2` and `expand/1`).\n"
msgstr ""
"このモジュールはファイルシステムのパスを操作したり、\n"
"パスを取得するための便利な関数を提供します。\n"
"\n"
"このモジュールの関数は引数として文字データ（すなわち、文字列あるいは文"
"字/\n"
"文字列のリスト）を受け取ることができ、常に（UTF-8でエンコードされた）\n"
"文字列を返します。\n"
"\n"
"このモジュールの大部分の関数は、（`wildcard/2`や`expand/1`のような）\n"
"それが必要な少数の関数を除いて、ファイルシステムと相互作用しません。\n"

#. TRANSLATORS: def Path.extname(path)
#: lib/path.ex:378
msgid ""
"Returns the extension of the last component of `path`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Path.extname(\"foo.erl\")\n"
"    \".erl\"\n"
"\n"
"    iex> Path.extname(\"~/foo/bar\")\n"
"    \"\"\n"
"\n"
msgstr ""
"`path`の最後の構成要素の拡張子を返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Path.extname(\"foo.erl\")\n"
"    \".erl\"\n"
"\n"
"    iex> Path.extname(\"~/foo/bar\")\n"
"    \"\"\n"
"\n"

#. TRANSLATORS: def Path.expand(path, relative_to)
#: lib/path.ex:142
msgid ""
"Expands the path relative to the path given as the second argument\n"
"expanding any `.` and `..` characters. If the path is already an\n"
"absolute path, `relative_to` is ignored.\n"
"\n"
"Note, that this function treats `path` with a leading `~` as\n"
"an absolute one.\n"
"\n"
"The second argument is first expanded to an absolute path.\n"
"\n"
"## Examples\n"
"\n"
"    # Assuming that the absolute path to baz is /quux/baz\n"
"    Path.expand(\"foo/bar/../bar\", \"baz\")\n"
"    #=> \"/quux/baz/foo/bar\"\n"
"\n"
"    Path.expand(\"foo/bar/../bar\", \"/baz\")\n"
"    \"/baz/foo/bar\"\n"
"    Path.expand(\"/foo/bar/../bar\", \"/baz\")\n"
"    \"/foo/bar\"\n"
"\n"
msgstr ""
"すべての`.`文字と`..`文字を展開し、第2引数として指定したパスへの相対とし"
"て\n"
"パスを展開します。パスがすでに絶対パスの場合、`relative_to`は無視されま"
"す。\n"
"\n"
"この関数は、先頭に`~`を持つ`path`を絶対パスとして扱うことに\n"
"注意してください。\n"
"\n"
"第2引数がまず絶対パスに展開されます。\n"
"\n"
"## 例\n"
"\n"
"    # bazの絶対パスは /quux/bazと仮定しています。\n"
"    Path.expand(\"foo/bar/../bar\", \"baz\")\n"
"    #=> \"/quux/baz/foo/bar\"\n"
"\n"
"    Path.expand(\"foo/bar/../bar\", \"/baz\")\n"
"    \"/baz/foo/bar\"\n"
"    Path.expand(\"/foo/bar/../bar\", \"/baz\")\n"
"    \"/foo/bar\"\n"
"\n"

#. TRANSLATORS: def Path.relative_to_cwd(path)
#: lib/path.ex:305
msgid ""
"Convenience to get the path relative to the current working\n"
"directory. If, for some reason, the current working directory\n"
"cannot be retrieved, returns the full path.\n"
msgstr ""
"カレントワーキングディレクトリからの相対パスを取得する\n"
"便利な関数です。何らかの理由でカレントワーキングディレクトリが\n"
"取得できなかった場合はフルパスを返します。\n"

#. TRANSLATORS: def Path.basename(path, extension)
#: lib/path.ex:339
msgid ""
"Returns the last component of `path` with the `extension`\n"
"stripped. This function should be used to remove a specific\n"
"extension which may, or may not, be there.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Path.basename(\"~/foo/bar.ex\", \".ex\")\n"
"    \"bar\"\n"
"\n"
"    iex> Path.basename(\"~/foo/bar.exs\", \".ex\")\n"
"    \"bar.exs\"\n"
"\n"
"    iex> Path.basename(\"~/foo/bar.old.ex\", \".ex\")\n"
"    \"bar.old\"\n"
"\n"
msgstr ""
"`extension`を取り除いた`path`の最後の構成要素を返します。この関数は、\n"
"あるかないかわからない特定の拡張子を削除するために使うべきです。\n"
"\n"
"## 例\n"
"\n"
"    iex> Path.basename(\"~/foo/bar.ex\", \".ex\")\n"
"    \"bar\"\n"
"\n"
"    iex> Path.basename(\"~/foo/bar.exs\", \".ex\")\n"
"    \"bar.exs\"\n"
"\n"
"    iex> Path.basename(\"~/foo/bar.old.ex\", \".ex\")\n"
"    \"bar.old\"\n"
"\n"

#. TRANSLATORS: def Path.absname(path, relative_to)
#: lib/path.ex:43
msgid ""
"Builds a path from `relative_to` to `path`. If `path` is already\n"
"an absolute path, `relative_to` is ignored. See also `relative_to/2`.\n"
"\n"
"Unlike `expand/2`, no attempt is made to\n"
"resolve `..`, `.` or `~`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Path.absname(\"foo\", \"bar\")\n"
"    \"bar/foo\"\n"
"\n"
"    iex> Path.absname(\"../x\", \"bar\")\n"
"    \"bar/../x\"\n"
"\n"
msgstr ""
"`relative_to`から`path`へのパスを構築します。\n"
"`path`が既に絶対パスの場合、`relative_to`は無視されます。\n"
"`relative_to/2`も参照してください。\n"
"\n"
"`expand/2`とは異なり、`..`、`.`、`~`の解決をしません。\n"
"\n"
"## 例\n"
"\n"
"    iex> Path.absname(\"foo\", \"bar\")\n"
"    \"bar/foo\"\n"
"\n"
"    iex> Path.absname(\"../x\", \"bar\")\n"
"    \"bar/../x\"\n"
"\n"

#. TRANSLATORS: def Path.type(name)
#: lib/path.ex:169
msgid ""
"Returns the path type.\n"
"\n"
"## Unix examples\n"
"\n"
"    Path.type(\"/\")                #=> :absolute\n"
"    Path.type(\"/usr/local/bin\")   #=> :absolute\n"
"    Path.type(\"usr/local/bin\")    #=> :relative\n"
"    Path.type(\"../usr/local/bin\") #=> :relative\n"
"    Path.type(\"~/file\")           #=> :relative\n"
"\n"
"## Windows examples\n"
"\n"
"    Path.type(\"D:/usr/local/bin\") #=> :absolute\n"
"    Path.type(\"usr/local/bin\")    #=> :relative\n"
"    Path.type(\"D:bar.ex\")         #=> :volumerelative\n"
"    Path.type(\"/bar/foo.ex\")      #=> :volumerelative\n"
"\n"
msgstr ""
"パスの種類を返します。\n"
"\n"
"## Unixの例\n"
"\n"
"    Path.type(\"/\")                #=> :absolute\n"
"    Path.type(\"/usr/local/bin\")   #=> :absolute\n"
"    Path.type(\"usr/local/bin\")    #=> :relative\n"
"    Path.type(\"../usr/local/bin\") #=> :relative\n"
"    Path.type(\"~/file\")           #=> :relative\n"
"\n"
"## Windowsの例\n"
"\n"
"    Path.type(\"D:/usr/local/bin\") #=> :absolute\n"
"    Path.type(\"usr/local/bin\")    #=> :relative\n"
"    Path.type(\"D:bar.ex\")         #=> :volumerelative\n"
"    Path.type(\"/bar/foo.ex\")      #=> :volumerelative\n"
"\n"

#. TRANSLATORS: def Path.relative_to(path, from)
#: lib/path.ex:265
msgid ""
"Returns the given `path` relative to the given `from` path.\n"
"In other words, it tries to strip the `from` prefix from `path`.\n"
"\n"
"This function does not query the file system, so it assumes\n"
"no symlinks between the paths.\n"
"\n"
"In case a direct relative path cannot be found, it returns\n"
"the original path.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Path.relative_to(\"/usr/local/foo\", \"/usr/local\")\n"
"    \"foo\"\n"
"\n"
"    iex> Path.relative_to(\"/usr/local/foo\", \"/\")\n"
"    \"usr/local/foo\"\n"
"\n"
"    iex> Path.relative_to(\"/usr/local/foo\", \"/etc\")\n"
"    \"/usr/local/foo\"\n"
"\n"
msgstr ""
"指定した`path`の指定した`from`パスからの相対パスを返します。\n"
"言い替えると、`from`接頭辞を`path`から取り除こうとします。\n"
"\n"
"この関数はファイルシステムに問合せをしないので、\n"
"パスの間にシンボリックリンクはないものと仮定します。\n"
"\n"
"直接的な相対パスが見付からない場合はオリジナルパスを返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Path.relative_to(\"/usr/local/foo\", \"/usr/local\")\n"
"    \"foo\"\n"
"\n"
"    iex> Path.relative_to(\"/usr/local/foo\", \"/\")\n"
"    \"usr/local/foo\"\n"
"\n"
"    iex> Path.relative_to(\"/usr/local/foo\", \"/etc\")\n"
"    \"/usr/local/foo\"\n"
"\n"

#. TRANSLATORS: def Path.basename(path)
#: lib/path.ex:318
msgid ""
"Returns the last component of the path or the path\n"
"itself if it does not contain any directory separators.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Path.basename(\"foo\")\n"
"    \"foo\"\n"
"\n"
"    iex> Path.basename(\"foo/bar\")\n"
"    \"bar\"\n"
"\n"
"    iex> Path.basename(\"/\")\n"
"    \"\"\n"
"\n"
msgstr ""
"パスの最後の構成要素、またはディレクトリセパレータを含んでいない場合は\n"
"パス自体を返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Path.basename(\"foo\")\n"
"    \"foo\"\n"
"\n"
"    iex> Path.basename(\"foo/bar\")\n"
"    \"bar\"\n"
"\n"
"    iex> Path.basename(\"/\")\n"
"    \"\"\n"
"\n"

#. TRANSLATORS: def Path.dirname(path)
#: lib/path.ex:361
msgid ""
"Returns the directory component of `path`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Path.dirname(\"/foo/bar.ex\")\n"
"    \"/foo\"\n"
"\n"
"    iex> Path.dirname(\"/foo/bar/baz.ex\")\n"
"    \"/foo/bar\"\n"
"\n"
msgstr ""
"`path`のディレクトリ部分を返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Path.dirname(\"/foo/bar.ex\")\n"
"    \"/foo\"\n"
"\n"
"    iex> Path.dirname(\"/foo/bar/baz.ex\")\n"
"    \"/foo/bar\"\n"
"\n"

#. TRANSLATORS: def Path.wildcard(glob, opts \\ [])
#: lib/path.ex:544
msgid ""
"Traverses paths according to the given `glob` expression, and returns a\n"
"list of matches.\n"
"\n"
"The wildcard looks like an ordinary path, except that certain\n"
"\"wildcard characters\" are interpreted in a special way. The\n"
"following characters are special:\n"
"\n"
"  * `?` - matches one character\n"
"\n"
"  * `*` - matches any number of characters up to the end of the filename, "
"the\n"
"    next dot, or the next slash\n"
"\n"
"  * `**` - two adjacent `*`'s used as a single pattern will match all\n"
"    files and zero or more directories and subdirectories\n"
"\n"
"  * `[char1,char2,...]` - matches any of the characters listed; two\n"
"    characters separated by a hyphen will match a range of characters.\n"
"    Do not add spaces before and after the comma as it would then match\n"
"    paths containing the space character itself.\n"
"\n"
"  * `{item1,item2,...}` - matches one of the alternatives\n"
"    Do not add spaces before and after the comma as it would then match\n"
"    paths containing the space character itself.\n"
"\n"
"Other characters represent themselves. Only paths that have\n"
"exactly the same character in the same position will match. Note\n"
"that matching is case-sensitive; i.e. \"a\" will not match \"A\".\n"
"\n"
"By default, the patterns `*` and `?` do not match files starting\n"
"with a dot `.` unless `match_dot: true` is given in `opts`.\n"
"\n"
"## Examples\n"
"\n"
"Imagine you have a directory called `projects` with three Elixir "
"projects\n"
"inside of it: `elixir`, `ex_doc` and `dynamo`. You can find all `.beam` "
"files\n"
"inside the `ebin` directory of each project as follows:\n"
"\n"
"    Path.wildcard(\"projects/*/ebin/**/*.beam\")\n"
"\n"
"If you want to search for both `.beam` and `.app` files, you could do:\n"
"\n"
"    Path.wildcard(\"projects/*/ebin/**/*.{beam,app}\")\n"
"\n"
msgstr ""
"指定した`glob`式でパスを走査し、マッチしたパスのリストを\n"
"返します。\n"
"\n"
"ワイルドカードは普通のパスのように見えますが、特定の\"ワイルドカード文字"
"\"は\n"
"特別な方法で解釈されます。以下が特別なワイルドカード文字です。\n"
"\n"
"  * `?` - 1文字にマッチします\n"
"\n"
"  * `*` - ファイル名の終わり、次のドット、次のスラッシュまでの\n"
"    任意の数の文字にマッチします\n"
"\n"
"  * `**` - 1つのパターンとして使われる2つの隣接した`*`は\n"
"    すべてのファイル、0個以上のディレクトリとサブディレクトリにマッチしま"
"す\n"
"\n"
"  * `[char1, char2,...]` - リストにある文字のいずれかにマッチします;。\n"
"     ハイフンで区切られた2つの文字は文字の範囲にマッチします。\n"
"     カンマの前後に空白を入れないでください。なぜなら、空白文字を\n"
"     含むパスにマッチするようになるからです。\n"
"\n"
"  * `{item1, item2,...}` - 選択肢のいずれか1つにマッチします。\n"
"    カンマの前後に空白を入れないでください。なぜなら、空白文字を\n"
"     含むパスにマッチするようになるからです。\n"
"\n"
"その他の文字はその文字自信を表します。正確に同じ場所に同じ文字を\n"
"持つパスのみがマッチします。マッチングは大文字小文字を区別することに\n"
"注意してください。すなわち、\"a\"は\"A\"にマッチしません。\n"
"\n"
"デフォルトでは、`opts`に`matuch_dot: true`が指定されていない限り、\n"
"パターン`*`と`?`はドット`.`で始まるファイルにはマッチしません。\n"
"\n"
"## 例\n"
"\n"
"`elixir`, `ex_doc`, `dynamo`という3つのElixirプロジェクトを含む\n"
"`projects`と呼ばれるディレクトリがあるとします。各プロジェクトの\n"
"`ebin`ディレクトリにあるすべての`.beam`ファイルは次のようにして\n"
"見つけることができます。\n"
"\n"
"    Path.wildcard(\"projects/*/ebin/**/*.beam\")\n"
"\n"
"`.beam`ファイルと`.app`ファイルの両方を探したい場合は、\n"
"次のように実行できます。\n"
"\n"
"    Path.wildcard(\"projects/*/ebin/**/*.{beam,app}\")\n"
"\n"

#. TRANSLATORS: def Path.rootname(path, extension)
#: lib/path.ex:412
msgid ""
"Returns the `path` with the `extension` stripped. This function should be "
"used to\n"
"remove a specific extension which might, or might not, be there.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Path.rootname(\"/foo/bar.erl\", \".erl\")\n"
"    \"/foo/bar\"\n"
"\n"
"    iex> Path.rootname(\"/foo/bar.erl\", \".ex\")\n"
"    \"/foo/bar.erl\"\n"
"\n"
msgstr ""
"`extension`を取り除いた`path`を返します。\n"
"この関数は、そこにあるかないかわからない特定の拡張子を\n"
"削除するために使われるべきです。\n"
"\n"
"## 例\n"
"\n"
"    iex> Path.rootname(\"/foo/bar.erl\", \".erl\")\n"
"    \"/foo/bar\"\n"
"\n"
"    iex> Path.rootname(\"/foo/bar.erl\", \".ex\")\n"
"    \"/foo/bar.erl\"\n"
"\n"

#. TRANSLATORS: def Path.expand(path)
#: lib/path.ex:127
msgid ""
"Converts the path to an absolute one and expands\n"
"any `.` and `..` characters and a leading `~`.\n"
"\n"
"## Examples\n"
"\n"
"    Path.expand(\"/foo/bar/../bar\")\n"
"    #=> \"/foo/bar\"\n"
"\n"
msgstr ""
"`.`文字と`..`文字、および、先頭の`~`を展開し、パスを絶対パスに変換しま"
"す。\n"
"\n"
"## 例\n"
"\n"
"    iex> Path.expand(\"/foo/bar/../bar\")\n"
"    \"/foo/bar\"\n"
"\n"
