msgid ""
msgstr ""
"Project-Id-Version: elixir 1.4.0\n"
"POT-Creation-Date: \n"
"PO-Revision-Date: 2017-01-25 12:22+0900\n"
"Last-Translator: Keiji Suzuki <EMAIL@ADDRESS>\n"
"Language-Team: Japanese\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Poedit 1.8.11\n"

#. TRANSLATORS: def Code.get_docs(module, kind)
#: lib/code.ex:589
msgid ""
"Returns the docs for the given module.\n"
"\n"
"When given a module name, it finds its BEAM code and reads the docs from "
"it.\n"
"\n"
"When given a path to a .beam file, it will load the docs directly from that\n"
"file.\n"
"\n"
"The return value depends on the `kind` value:\n"
"\n"
"  * `:docs` - list of all docstrings attached to functions and macros\n"
"    using the `@doc` attribute\n"
"\n"
"  * `:moduledoc` - tuple `{<line>, <doc>}` where `line` is the line on\n"
"    which module definition starts and `doc` is the string\n"
"    attached to the module using the `@moduledoc` attribute\n"
"\n"
"  * `:callback_docs` - list of all docstrings attached to\n"
"    `@callbacks` using the `@doc` attribute\n"
"\n"
"  * `:type_docs` - list of all docstrings attached to\n"
"    `@type` callbacks using the `@typedoc` attribute\n"
"\n"
"  * `:all` - a keyword list with `:docs` and `:moduledoc`, `:"
"callback_docs`,\n"
"    and `:type_docs`.\n"
"\n"
"If the module cannot be found, it returns `nil`.\n"
"\n"
"## Examples\n"
"\n"
"    # Get the module documentation\n"
"    iex> {_line, text} = Code.get_docs(Atom, :moduledoc)\n"
"    iex> String.split(text, \"\\n\") |> Enum.at(0)\n"
"    \"Convenience functions for working with atoms.\"\n"
"\n"
"    # Module doesn't exist\n"
"    iex> Code.get_docs(ModuleNotGood, :all)\n"
"    nil\n"
"\n"
msgstr ""
"指定したモジュールのドキュメントを返します。\n"
"\n"
"モジュール名が指定された場合は、そのBEAMコードを探してドキュメントを読み込み"
"ます。\n"
"\n"
".beamファイルのパスが指定された場合は、そのファイルから直接ドキュメントを\n"
"ロードします。\n"
"\n"
"返り値は`kind`値によります。\n"
"\n"
"  * `:docs` - `@doc`属性を使って関数やマクロにひも付けされたすべてのドキュメ"
"ント\n"
"    文字列のリスト\n"
"\n"
"  * `:moduledoc` - タプル `{<line>, <doc>}`。ここで、`line`はモジュール定義"
"が\n"
"    開始する行であり、`doc`は`@moduledoc`属性を使ってモジュールにひも付けされ"
"た\n"
"    文字列です\n"
"\n"
"  * `:callback_docs` - `@doc`属性を使って`@callbacks` にひも付けされた\n"
"    すべてのドキュメント文字列のリスト\n"
"\n"
"  * `:type_docs` -  `@typedoc`属性を使って`@type`コールバック にひも付けされ"
"た\n"
"    すべてのドキュメント文字列のリスト\n"
"\n"
"  * `:all` - `:docs`と`:moduledoc`、`:callback_docs`\n"
"    `:type_docs`を持つキーワードリスト\n"
"\n"
"モジュールを見つけることができなかった場合は、`nil`を返します。\n"
"\n"
"## 例\n"
"\n"
"    # Get the module documentation\n"
"    iex> {_line, text} = Code.get_docs(Atom, :moduledoc)\n"
"    iex> String.split(text, \"\\n\") |> Enum.at(0)\n"
"    \"Convenience functions for working with atoms.\"\n"
"\n"
"    # モジュールが存在しない\n"
"    iex> Code.get_docs(ModuleNotGood, :all)\n"
"    nil\n"
"\n"

#. TRANSLATORS: def Code.require_file(file, relative_to \\ nil)
#: lib/code.ex:333
msgid ""
"Requires the given `file`.\n"
"\n"
"Accepts `relative_to` as an argument to tell where the file is located.\n"
"The return value is the same as that of `load_file/2`. If the file was "
"already\n"
"required/loaded, doesn't do anything and returns `nil`.\n"
"\n"
"Notice that if `require_file` is invoked by different processes "
"concurrently,\n"
"the first process to invoke `require_file` acquires a lock and the "
"remaining\n"
"ones will block until the file is available. I.e. if `require_file` is "
"called\n"
"N times with a given file, it will be loaded only once. The first process "
"to\n"
"call `require_file` will get the list of loaded modules, others will get "
"`nil`.\n"
"\n"
"Check `load_file/2` if you want a file to be loaded multiple times. See "
"also\n"
"`unload_files/1`\n"
"\n"
"## Examples\n"
"\n"
"If the code is already loaded, it returns `nil`:\n"
"\n"
"    Code.require_file(\"eex_test.exs\", \"../eex/test\") #=> nil\n"
"\n"
"If the code is not loaded yet, it returns the same as `load_file/2`:\n"
"\n"
"    Code.require_file(\"eex_test.exs\", \"../eex/test\") |> List.first\n"
"    #=> {EExTest.Compiled, <<70, 79, 82, 49, ...>>}\n"
"\n"
msgstr ""
"指定した`file`をrequireします。\n"
"\n"
"ファイルが置かれた位置を知らせるための引数として、`relative_to`を受け付けま"
"す。\n"
"返り値は`load_file/2`と同じです。ファイルが既にrequirまたはロードされていた\n"
"場合は、何もせず`nil`を返します。\n"
"\n"
"`require_file`が異なるプロセスで並行して実行される場合、最初のプロセスは\n"
"`require_file`を実行するためにロックを要求し、他のプロセスはファイルが利用\n"
"可能になるまでブロックされます。すなわち、`require_file`が指定したファイル"
"で\n"
"N回呼び出された場合、ファイルは1回しかロードされません。`require_file`を呼び"
"出す最初の\n"
"プロセスはロードされたモジュールのリストを受取り、その他のプロセスは`nil`を受"
"取ります。\n"
"\n"
"ファイルを複数回ロードしたい場合は、`load_file/2`をチェックしてください。ま"
"た、\n"
"`unload_files/1`も参照してください。\n"
"\n"
"## 例\n"
"\n"
"コードがすでにロードされている場合は`nil`を返します:\n"
"\n"
"    Code.require_file(\"eex_test.exs\", \"../eex/test\") #=> nil\n"
"\n"
"コードがまだロードされていない場合は、`load_file/2`と同じものを返します:\n"
"\n"
"    Code.require_file(\"eex_test.exs\", \"../eex/test\") |> List.first\n"
"    #=> {EExTest.Compiled, <<70, 79, 82, 49, ...>>}\n"
"\n"

#. TRANSLATORS: def Code.eval_string(string, binding \\ [], opts \\ [])
#: lib/code.ex:101
msgid ""
"Evaluates the contents given by `string`.\n"
"\n"
"The `binding` argument is a keyword list of variable bindings.\n"
"The `opts` argument is a keyword list of environment options.\n"
"\n"
"## Options\n"
"\n"
"Options can be:\n"
"\n"
"  * `:file` - the file to be considered in the evaluation\n"
"  * `:line` - the line on which the script starts\n"
"\n"
"Additionally, the following scope values can be configured:\n"
"\n"
"  * `:aliases` - a list of tuples with the alias and its target\n"
"\n"
"  * `:requires` - a list of modules required\n"
"\n"
"  * `:functions` - a list of tuples where the first element is a module\n"
"    and the second a list of imported function names and arity; the list\n"
"    of function names and arity must be sorted\n"
"\n"
"  * `:macros` - a list of tuples where the first element is a module\n"
"    and the second a list of imported macro names and arity; the list\n"
"    of function names and arity must be sorted\n"
"\n"
"Notice that setting any of the values above overrides Elixir's default\n"
"values. For example, setting `:requires` to `[]`, will no longer\n"
"automatically require the `Kernel` module; in the same way setting\n"
"`:macros` will no longer auto-import `Kernel` macros like `if/2`, `case/2`,\n"
"etc.\n"
"\n"
"Returns a tuple of the form `{value, binding}`,\n"
"where `value` is the value returned from evaluating `string`.\n"
"If an error occurs while evaluating `string` an exception will be raised.\n"
"\n"
"`binding` is a keyword list with the value of all variable bindings\n"
"after evaluating `string`. The binding key is usually an atom, but it\n"
"may be a tuple for variables defined in a different context.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Code.eval_string(\"a + b\", [a: 1, b: 2], file: __ENV__.file, line: "
"__ENV__.line)\n"
"    {3, [a: 1, b: 2]}\n"
"\n"
"    iex> Code.eval_string(\"c = a + b\", [a: 1, b: 2], __ENV__)\n"
"    {3, [a: 1, b: 2, c: 3]}\n"
"\n"
"    iex> Code.eval_string(\"a = a + b\", [a: 1, b: 2])\n"
"    {3, [a: 3, b: 2]}\n"
"\n"
"For convenience, you can pass `__ENV__/0` as the `opts` argument and\n"
"all imports, requires and aliases defined in the current environment\n"
"will be automatically carried over:\n"
"\n"
"    iex> Code.eval_string(\"a + b\", [a: 1, b: 2], __ENV__)\n"
"    {3, [a: 1, b: 2]}\n"
"\n"
msgstr ""
"`string`として指定されたコンテンツを評価します。\n"
"\n"
"`binding`引数は変数バインディングのキーワードリストです。\n"
"`opts`引数は環境オプションのキーワードリストです。\n"
"\n"
"## オプション\n"
"\n"
"オプションには以下が指定できます:\n"
"\n"
"  * `:file` - 評価の際に考慮されるファイル\n"
"  * `:line` - スクリプトが始まる行\n"
"\n"
"さらに、次のスコープ値も構成できます。\n"
"\n"
" * `:aliases` - エイリアスとその対象を持つタプルのリスト\n"
"\n"
"  * `:requires` - 必要なモジュールのリスト\n"
"\n"
"  * `:functions` - 第1要素がモジュール、第2要素がインポートされる関数名とアリ"
"ティの\n"
"    リストであるタプルのリスト。関数名とアリティのリストは\n"
"    ソート済みでなければならない\n"
"\n"
"  * `:macros` - 第1要素がモジュール、第2要素がインポートされるマクロ名とアリ"
"ティの\n"
"    リストであるタプルのリスト。マクロ名とアリティのリストは\n"
"    ソート済みでなければならない\n"
"\n"
"上記の値の設定により、Elixirのデフォルト値を上書きすることに注意して くださ"
"い。\n"
"たとえば、`:requires`を`[]`に設定するとKernelモジュー ルが自動的にrequire\n"
"されなくなります。同じように`:macros`を設定すると、`if/2`や`case/2`などの\n"
"`Kernel`マクロが自動的にインポートされなく\n"
"なります。\n"
"\n"
" `{value, binding}`形式のタプルを返します。ここで`value`は`string`の評価によ"
"り\n"
"返された値です。`string`の評価中にエラーが発生した場合は、例外が発生しま"
"す。\n"
"\n"
"`binding`は、`string`評価後のすべての変数バインディングの値を持つ\n"
"キーワードリストです。バインディングキーは通常アトムですが、異なるコンテキス"
"トで\n"
"定義された変数のタプルである場合もあります。\n"
"## Examples\n"
"\n"
"    iex> Code.eval_string(\"a + b\", [a: 1, b: 2], file: __ENV__.file, line: "
"__ENV__.line)\n"
"    {3, [a: 1, b: 2]}\n"
"\n"
"    iex> Code.eval_string(\"c = a + b\", [a: 1, b: 2], __ENV__)\n"
"    {3, [a: 1, b: 2, c: 3]}\n"
"\n"
"    iex> Code.eval_string(\"a = a + b\", [a: 1, b: 2])\n"
"    {3, [a: 3, b: 2]}\n"
"\n"
"便利なように、`opts`引数として`__ENV__/0`を渡すことができます。\n"
"こうすると、現在の環境で定義されたすべてのimport, require, aliaseを\n"
"自動的に引き継ぎます。\n"
"\n"
"    iex> Code.eval_string(\"a + b\", [a: 1, b: 2], __ENV__)\n"
"    {3, [a: 1, b: 2]}\n"
"\n"

#. TRANSLATORS: def Code.ensure_compiled(module)
#: lib/code.ex:549
msgid ""
"Ensures the given module is compiled and loaded.\n"
"\n"
"If the module is already loaded, it works as no-op. If the module was\n"
"not loaded yet, it checks if it needs to be compiled first and then\n"
"tries to load it.\n"
"\n"
"If it succeeds loading the module, it returns `{:module, module}`.\n"
"If not, returns `{:error, reason}` with the error reason.\n"
"\n"
"Check `ensure_loaded/1` for more information on module loading\n"
"and when to use `ensure_loaded/1` or `ensure_compiled/1`.\n"
msgstr ""
"指定したモジュールがコンパイルされ、ロードされていることを保証します。\n"
"\n"
"モジュールがすでにロードされている場合は、no-opとして作用します。\n"
"モジュールがまだロードされていない場合は、まずコンパイルが必要であるか\n"
"チェックし、その後ロードを試みます。\n"
"\n"
"モジュールのロードに成功した場合は、`{:module, module}`を返します。\n"
"失敗した場合は、エラーの理由を添えて`{:error, reason}` を返します。\n"
"\n"
"モジュールのローディングや`ensure_loaded/1`または`ensure_compiled/1`を\n"
"使う際の詳しい情報は`ensure_loaded/1` をチェックしてください。\n"

#. TRANSLATORS: def Code.compiler_options()
#: lib/code.ex:376
msgid ""
"Gets the compilation options from the code server.\n"
"\n"
"Check `compiler_options/1` for more information.\n"
"\n"
"## Examples\n"
"\n"
"    Code.compiler_options\n"
"    #=> %{debug_info: true, docs: true,\n"
"          warnings_as_errors: false, ignore_module_conflict: false}\n"
"\n"
msgstr ""
"コードサーバからコンパイルオプションを取得します。\n"
"\n"
"詳細な情報は`compiler_options/1`をチェックしてください。\n"
"\n"
"## 例\n"
"\n"
"    Code.compiler_options\n"
"    #=> %{debug_info: true, docs: true,\n"
"          warnings_as_errors: false, ignore_module_conflict: false}\n"
"\n"

#. TRANSLATORS: def Code.string_to_quoted(string, opts \\ [])
#: lib/code.ex:248
msgid ""
"Converts the given string to its quoted form.\n"
"\n"
"Returns `{:ok, quoted_form}`\n"
"if it succeeds, `{:error, {line, error, token}}` otherwise.\n"
"\n"
"## Options\n"
"\n"
"  * `:file` - the filename to be used in stacktraces\n"
"    and the file reported in the `__ENV__/0` macro\n"
"\n"
"  * `:line` - the line reported in the `__ENV__/0` macro\n"
"\n"
"  * `:existing_atoms_only` - when `true`, raises an error\n"
"    when non-existing atoms are found by the tokenizer\n"
"\n"
"## Macro.to_string/2\n"
"\n"
"The opposite of converting a string to its quoted form is\n"
"`Macro.to_string/2`, which converts a quoted form to a string/binary\n"
"representation.\n"
msgstr ""
"指定した文字列をquoteされた形式に変換します。\n"
"\n"
"成功した場合は、`{:ok, quoted_form}`を返します。\n"
"そうでない場合は、`{:error, {line, error, token}}`を返します。\n"
"\n"
"## オプション\n"
"\n"
"  * `:file` - スタックトレースで使用されるファイル名と\n"
"    `__ENV__/0`マクロで報告されるファイル\n"
"\n"
"  * `:line` - `__ENV__/0` マクロで報告される行\n"
"\n"
"  * `:existing_atoms_only` - `true`の場合、トークナイザーが\n"
"    存在しないアトムを発見した場合エラーをはっせいします\n"
"\n"
"## Macro.to_string/2\n"
"\n"
"文字列からquateされたされた形式への変換の逆が`Macro.to_string/2`です。\n"
"これはquateされたされた形式を文字列/バイナリ表現に\n"
"変換します。\n"

#. TRANSLATORS: def Code.loaded_files()
#: lib/code.ex:10
msgid ""
"Lists all loaded files.\n"
"\n"
"## Examples\n"
"\n"
"    Code.require_file(\"../eex/test/eex_test.exs\")\n"
"    List.first(Code.loaded_files) =~ \"eex_test.exs\" #=> true\n"
"\n"
msgstr ""
"ロードされているすべてのファイルをリストします。\n"
"\n"
"## 例\n"
"\n"
"    Code.require_file(\"../eex/test/eex_test.exs\")\n"
"    List.first(Code.loaded_files) =~ \"eex_test.exs\" #=> true\n"
"\n"

#. TRANSLATORS: def Code.unload_files(files)
#: lib/code.ex:23
msgid ""
"Removes files from the loaded files list.\n"
"\n"
"The modules defined in the file are not removed;\n"
"calling this function only removes them from the list,\n"
"allowing them to be required again.\n"
"\n"
"## Examples\n"
"\n"
"    # Load EEx test code, unload file, check for functions still available\n"
"    Code.load_file(\"../eex/test/eex_test.exs\")\n"
"    Code.unload_files(Code.loaded_files)\n"
"    function_exported?(EExTest.Compiled, :before_compile, 0) #=> true\n"
"\n"
msgstr ""
"ロード済みファイルリストからファイルを削除します。\n"
"\n"
"ファイル内で定義されているモジュールは削除されません。\n"
"この関数の呼び出しはリストからファイルを削除するだけで、\n"
"それらを再びrequireできるようにします。\n"
"## 例\n"
"\n"
"    # EEx テストコードをロードし、ファイルをアンロードし、関数がまだ利用でき"
"るかチェックする\n"
"    Code.load_file(\"../eex/test/eex_test.exs\")\n"
"    Code.unload_files(Code.loaded_files)\n"
"    function_exported?(EExTest.Compiled, :before_compile, 0) #=> true\n"
"\n"

#. TRANSLATORS: def Code.ensure_loaded(module)
#: lib/code.ex:479
msgid ""
"Ensures the given module is loaded.\n"
"\n"
"If the module is already loaded, this works as no-op. If the module\n"
"was not yet loaded, it tries to load it.\n"
"\n"
"If it succeeds loading the module, it returns `{:module, module}`.\n"
"If not, returns `{:error, reason}` with the error reason.\n"
"\n"
"## Code loading on the Erlang VM\n"
"\n"
"Erlang has two modes to load code: interactive and embedded.\n"
"\n"
"By default, the Erlang VM runs in interactive mode, where modules\n"
"are loaded as needed. In embedded mode the opposite happens, as all\n"
"modules need to be loaded upfront or explicitly.\n"
"\n"
"Therefore, this function is used to check if a module is loaded\n"
"before using it and allows one to react accordingly. For example, the `URI`\n"
"module uses this function to check if a specific parser exists for a given\n"
"URI scheme.\n"
"\n"
"## Code.ensure_compiled/1\n"
"\n"
"Elixir also contains an `ensure_compiled/1` function that is a\n"
"superset of `ensure_loaded/1`.\n"
"\n"
"Since Elixir's compilation happens in parallel, in some situations\n"
"you may need to use a module that was not yet compiled, therefore\n"
"it can't even be loaded.\n"
"\n"
"`ensure_compiled/1` halts the current process until the\n"
"module we are depending on is available.\n"
"\n"
"In most cases, `ensure_loaded/1` is enough. `ensure_compiled/1`\n"
"must be used in rare cases, usually involving macros that need to\n"
"invoke a module for callback information.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Code.ensure_loaded(Atom)\n"
"    {:module, Atom}\n"
"\n"
"    iex> Code.ensure_loaded(DoesNotExist)\n"
"    {:error, :nofile}\n"
"\n"
msgstr ""
"指定したモジュールがロードされていることを保証します。\n"
"\n"
"モジュールがすでにロードされている場合は、no-opとして作用します。\n"
"モジュールがまだロードされていない場合は、ロードを試みます。\n"
"\n"
"モジュールのロードに成功した場合は、`{:module, module}`を返します。\n"
"失敗した場合は、エラーの理由を添えて`{:error, reason}` を返します。\n"
"\n"
"## Erlang VMでのコードのローディング\n"
"\n"
"Erlangはコードのロードに関して2つのモードを持っています: インタラクティブとエ"
"ンベデッドです。\n"
"\n"
"デフォルトでは、Erlang VMはインタラクティブモードで動作し、モ ジュールは\n"
"必要に応じてロードされます。エンベデッドモードでは、その反対です。すべての\n"
"モジュールは事前に、または明示的にロードされる必要があります。\n"
"\n"
"そのため、モジュールを使う前にそれがロードされているかチェックするためにこ"
"の\n"
"関数が使用されます。たとえば、`URI`モジュールはこの関数を使って、指定した\n"
"URIスキームに対応した特定のパーサーが存在するかチェックしています。\n"
"\n"
"## Code.ensure_compiled/1\n"
"\n"
"Elixirは`ensure_loaded/1`のスーパーセットである`ensure_compiled/1`関数も\n"
"持っています。\n"
"\n"
"Elixirのコンパイルは並列で行われるので、状況によってはまだコンパイルされてお"
"らず、\n"
"ロードできないモジュールが必要になる場合があります。\n"
"\n"
"`ensure_compiled/1`は依存しているモジュールが利用可能になるまでカレントプロセ"
"スを\n"
"停止します。\n"
"\n"
"ほとんどの場合、`ensure_loaded/1` で十分です。`ensure_compiled/1`は\n"
"通常、コールバック情報のためにモジュールを起動する必要があるマクロの起動など"
"の\n"
"稀なケースで使用されなければなりません。\n"
"\n"
"## 例\n"
"\n"
"    iex> Code.ensure_loaded(Atom)\n"
"    {:module, Atom}\n"
"\n"
"    iex> Code.ensure_loaded(DoesNotExist)\n"
"    {:error, :nofile}\n"
"\n"

#. TRANSLATORS: def Code.string_to_quoted!(string, opts \\ [])
#: lib/code.ex:276
msgid ""
"Converts the given string to its quoted form.\n"
"\n"
"It returns the ast if it succeeds,\n"
"raises an exception otherwise. The exception is a `TokenMissingError`\n"
"in case a token is missing (usually because the expression is incomplete),\n"
"`SyntaxError` otherwise.\n"
"\n"
"Check `string_to_quoted/2` for options information.\n"
msgstr ""
"指定した文字列をquoteされた形式に変換します。\n"
"\n"
"成功した場合はASTを返します。\n"
"そうでない場合は、例外を発生します。tokenが欠けている場合の\n"
"例外は`TokenMissingError`です（通常、式が不完全な場合です）。\n"
"それ以外の例外は`SyntaxError`です。\n"
"\n"
"オプションに関する情報は`string_to_quoted/2`をチェックしてください。\n"

#. TRANSLATORS: def Code.compiler_options(opts)
#: lib/code.ex:407
msgid ""
"Sets compilation options.\n"
"\n"
"These options are global since they are stored by Elixir's Code Server.\n"
"\n"
"Available options are:\n"
"\n"
"  * `:docs` - when `true`, retain documentation in the compiled module,\n"
"    `true` by default\n"
"\n"
"  * `:debug_info` - when `true`, retain debug information in the compiled\n"
"    module; this allows a developer to reconstruct the original source\n"
"    code, `false` by default\n"
"\n"
"  * `:ignore_module_conflict` - when `true`, override modules that were\n"
"    already defined without raising errors, `false` by default\n"
"\n"
"  * `:relative_paths` - when `true`, use relative paths in quoted nodes,\n"
"    warnings and errors generated by the compiler, `true` by default.\n"
"    Note disabling this option won't affect runtime warnings and errors.\n"
"\n"
"  * `:warnings_as_errors` - causes compilation to fail when warnings are\n"
"    generated\n"
"\n"
"It returns the new list of compiler options.\n"
"\n"
"## Examples\n"
"\n"
"    Code.compiler_options(debug_info: true)\n"
"    #=> %{debug_info: true, docs: true,\n"
"          warnings_as_errors: false, ignore_module_conflict: false}\n"
"\n"
msgstr ""
"コンパイルオプションを設定します。\n"
"\n"
"これらのオプションはElixirのコードサーバに保管されるのでグローバルです。\n"
"\n"
"利用可能なオプションは次の通り:\n"
"\n"
"  * `:docs` - `true`の場合、コンパイルされたモジュールにドキュメントを保持し"
"ます。\n"
"    デフォルトは`true`です\n"
"\n"
"  * `:debug_info` - `true`の場合、コンパイルされたモジュールにデバッグ情報を"
"保持します。\n"
"    これにより開発者はオリジナルのソースコードを再構築することができます。\n"
"    デフォルトは`false`です\n"
"\n"
"  * `:ignore_module_conflict` - `true`の場合、すでに定義差rていたモジュールを"
"エラーを\n"
"    発生することなく上書きします。デフォルトは`false`です\n"
"\n"
"  * `:relative_paths` - `true`の場合、when `true`, quoteされたノード、コンパ"
"イラにより\n"
"    生成される警告やエラーの中で相対パスを使用します。デフォルトは`true`で"
"す\n"
"    このオプションを無効にしても実行時の警告やエラーには影響を与えないことに"
"注意してください。\n"
"\n"
"  * `:warnings_as_errors` - 警告が発生された際にコンパイラを\n"
"    失敗させます。\n"
"\n"
"新しいコンパイラオプションのリストを返します。\n"
"\n"
"## 例\n"
"\n"
"    Code.compiler_options(debug_info: true)\n"
"    #=> %{debug_info: true, docs: true,\n"
"          warnings_as_errors: false, ignore_module_conflict: false}\n"
"\n"

#. TRANSLATORS: def Code.delete_path(path)
#: lib/code.ex:82
msgid ""
"Deletes a path from the Erlang VM code path list. This is the list of\n"
"directories the Erlang VM uses for finding module code.\n"
"\n"
"The path is expanded with `Path.expand/1` before being deleted. If the\n"
"path does not exist it returns `false`.\n"
"\n"
"## Examples\n"
"\n"
"    Code.prepend_path(\".\")\n"
"    Code.delete_path(\".\") #=> true\n"
"\n"
"    Code.delete_path(\"/does_not_exist\") #=> false\n"
"\n"
msgstr ""
"Erlang VMコードパスリストからパスを削除します。これはErlang VMが\n"
"モジュールコードを探すために使用するディレクトリのリストです。\n"
"\n"
"パスは追加される前に`Path.expand/1` で展開されます。\n"
"パスが存在しない場合は`false`を返します。\n"
"\n"
"## 例\n"
"\n"
"    Code.prepend_path(\".\")\n"
"    Code.delete_path(\".\") #=> true\n"
"\n"
"    Code.delete_path(\"/does_not_exist\") #=> false\n"
"\n"

#. TRANSLATORS: def Code.ensure_loaded?(module)
#: lib/code.ex:532
msgid ""
"Ensures the given module is loaded.\n"
"\n"
"Similar to `ensure_loaded/1`, but returns `true` if the module\n"
"is already loaded or was successfully loaded. Returns `false`\n"
"otherwise.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Code.ensure_loaded?(Atom)\n"
"    true\n"
"\n"
msgstr ""
"指定したモジュールがロードされていることを保証します。\n"
"\n"
"`ensure_loaded/1`と同じですが、モジュールがすでにロードされている、\n"
"または、ロードしてコンパイルに成功した場合は、`true`を返します。\n"
"そうでない場合は`false`を返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Code.ensure_loaded?(Atom)\n"
"    true\n"
"\n"

#. TRANSLATORS: def Code.eval_quoted(quoted, binding \\ [], opts \\ [])
#: lib/code.ex:174
msgid ""
"Evaluates the quoted contents.\n"
"\n"
"**Warning**: Calling this function inside a macro is considered bad\n"
"practice as it will attempt to evaluate runtime values at compile time.\n"
"Macro arguments are typically transformed by unquoting them into the\n"
"returned quoted expressions (instead of evaluated).\n"
"\n"
"See `eval_string/3` for a description of bindings and options.\n"
"\n"
"## Examples\n"
"\n"
"    iex> contents = quote(do: var!(a) + var!(b))\n"
"    iex> Code.eval_quoted(contents, [a: 1, b: 2], file: __ENV__.file, line: "
"__ENV__.line)\n"
"    {3, [a: 1, b: 2]}\n"
"\n"
"For convenience, you can pass `__ENV__/0` as the `opts` argument and\n"
"all options will be automatically extracted from the current environment:\n"
"\n"
"    iex> contents = quote(do: var!(a) + var!(b))\n"
"    iex> Code.eval_quoted(contents, [a: 1, b: 2], __ENV__)\n"
"    {3, [a: 1, b: 2]}\n"
"\n"
msgstr ""
"quoteされたコンテンツを評価します。\n"
"\n"
"**警告**: マクロ内でのこの関数の呼び出しは悪い行いだと考えられます。\n"
"それはコンパイル時に実行時の値を評価しようとすることだからです。\n"
"マクロの引数は、通常それらをunquoteすることにより（評価されるのはなく）\n"
"返り値であるquoteされた式に変換されます。\n"
"\n"
"バインディングとオプションの説明については`eval_string/3`を参照してくださ"
"い。\n"
"\n"
"## 例\n"
"\n"
"    iex> contents = quote(do: var!(a) + var!(b))\n"
"    iex> Code.eval_quoted(contents, [a: 1, b: 2], file: __ENV__.file, line: "
"__ENV__.line)\n"
"    {3, [a: 1, b: 2]}\n"
"\n"
"便利なように、`opts`引数として`__ENV__/0`を渡すことができます。こうすると\n"
"すべてのオプションが現在の環境から自動的に抽出されます。\n"
"\n"
"    iex> contents = quote(do: var!(a) + var!(b))\n"
"    iex> Code.eval_quoted(contents, [a: 1, b: 2], __ENV__)\n"
"    {3, [a: 1, b: 2]}\n"
"\n"

#. TRANSLATORS: Elixir.Code Summary
#: lib/code.ex:2
msgid ""
"Utilities for managing code compilation, code evaluation and code loading.\n"
"\n"
"This module complements Erlang's [`:code` module](http://www.erlang.org/doc/"
"man/code.html)\n"
"to add behaviour which is specific to Elixir. Almost all of the functions in "
"this module\n"
"have global side effects on the behaviour of Elixir.\n"
msgstr ""
"コードのコンパイル、コードの評価、コードのロードを管理するユーティリティで"
"す。\n"
"\n"
"このモジュールはErlangの [`:code` module](http://www.erlang.org/doc/man/code."
"html)を\n"
"補完するもので、Elixirに固有のふるまいを追加します。このモジュールのほとんど"
"すべての関数は\n"
"Elixirのふるまいにおいてグローバルな副作用を持っています。\n"

#. TRANSLATORS: def Code.load_file(file, relative_to \\ nil)
#: lib/code.ex:306
msgid ""
"Loads the given file.\n"
"\n"
"Accepts `relative_to` as an argument to tell where the file is located.\n"
"If the file was already required/loaded, loads it again.\n"
"\n"
"It returns a list of tuples `{ModuleName, <<byte_code>>}`, one tuple for\n"
"each module defined in the file.\n"
"\n"
"Notice that if `load_file` is invoked by different processes concurrently,\n"
"the target file will be loaded concurrently many times. Check "
"`require_file/2`\n"
"if you don't want a file to be loaded concurrently.\n"
"\n"
"## Examples\n"
"\n"
"    Code.load_file(\"eex_test.exs\", \"../eex/test\") |> List.first\n"
"    #=> {EExTest.Compiled, <<70, 79, 82, 49, ...>>}\n"
"\n"
msgstr ""
"指定したファイルをロードします。\n"
"\n"
"ファイルがどこに置かれているかを知らせる引数として`relative_to`を受け付けま"
"す。\n"
"ファイルがすでにrequireまたはロードされていた場合は、再度ロードします。\n"
"\n"
"タプル`{ModuleName, <<byte_code>>}`,のリストを返します。\n"
"そのファイルで定義されているモジュールごとにタプルが作成されます。\n"
"\n"
"`load_file`が異なるプロセスで並行して実行された場合、対象となるファイルは\n"
"並行して何度もロードされることに注意してください。ファイルを並行して\n"
"ロードしたくない場合は、`require_file/2`をチェックしてください。\n"
"\n"
"## 例\n"
"\n"
"    Code.load_file(\"eex_test.exs\", \"../eex/test\") |> List.first\n"
"    #=> {EExTest.Compiled, <<70, 79, 82, 49, ...>>}\n"
"\n"

#. TRANSLATORS: def Code.eval_file(file, relative_to \\ nil)
#: lib/code.ex:292
msgid ""
"Evals the given file.\n"
"\n"
"Accepts `relative_to` as an argument to tell where the file is located.\n"
"\n"
"While `load_file` loads a file and returns the loaded modules and their\n"
"byte code, `eval_file` simply evaluates the file contents and returns the\n"
"evaluation result and its bindings.\n"
msgstr ""
"指定したファイルを評価します。\n"
"\n"
"ファイルがどこに置かれているかを知らせる引数として`relative_to`を受け付けま"
"す。\n"
"\n"
"`load_file`はファイルをロードして、ロードしたモジュールとそのバイトコードを\n"
"返しますが、`eval_file`は単にファイル内容を評価し、評価結果とそのバインディン"
"グを\n"
"返します。\n"

#. TRANSLATORS: def Code.compile_string(string, file \\ "nofile")
#: lib/code.ex:457
msgid ""
"Compiles the given string.\n"
"\n"
"Returns a list of tuples where the first element is the module name\n"
"and the second one is its byte code (as a binary).\n"
"\n"
"For compiling many files at once, check `Kernel.ParallelCompiler.files/2`.\n"
msgstr ""
"指定した文字列をコンパイルします。\n"
"\n"
"タプルのリストを返します。タプルの最初の要素はモジュール名で\n"
"2番目の要素はそのバイトコード（バイナリ）です。\n"
"\n"
"複数のファイルを同時にコンパイルするには`Kernel.ParallelCompiler.files/2`を"
"チェックしてください。\n"

#. TRANSLATORS: def Code.prepend_path(path)
#: lib/code.ex:62
msgid ""
"Prepends a path to the beginning of the Erlang VM code path list.\n"
"\n"
"This is the list of directories the Erlang VM uses for finding\n"
"module code.\n"
"\n"
"The path is expanded with `Path.expand/1` before being prepended.\n"
"If this path does not exist, an error is returned.\n"
"\n"
"## Examples\n"
"\n"
"    Code.prepend_path(\".\") #=> true\n"
"\n"
"    Code.prepend_path(\"/does_not_exist\") #=> {:error, :bad_directory}\n"
"\n"
msgstr ""
"Erlang VMコードパスリストの先頭にpathを追加します。\n"
"\n"
"これはErlang VMがモジュールコードを探すために使用する\n"
"ディレクトリのリストです。\n"
"\n"
"パスは追加される前に`Path.expand/1 `で展開されます。\n"
"このパスが存在しない場合はエラーが返されます。\n"
"\n"
"## 例\n"
"\n"
"    Code.prepend_path(\".\") #=> true\n"
"\n"
"    Code.prepend_path(\"/does_not_exist\") #=> {:error, :bad_directory}\n"
"\n"
"\n"
"\n"

#. TRANSLATORS: def Code.available_compiler_options()
#: lib/code.ex:392
msgid ""
"Returns a list with the available compiler options.\n"
"\n"
"See `Code.compiler_options/1` for more info.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Code.available_compiler_options\n"
"    [:docs, :debug_info, :ignore_module_conflict, :relative_paths, :"
"warnings_as_errors]\n"
"\n"
msgstr ""
"利用可能なコンパイラオプションのリストを返します。\n"
"\n"
"詳細は`Code.compiler_options/1`を参照してください。\n"
"\n"
"## 例\n"
"\n"
"    iex> Code.available_compiler_options\n"
"    [:docs, :debug_info, :ignore_module_conflict, :relative_paths, :"
"warnings_as_errors]\n"
"\n"

#. TRANSLATORS: def Code.ensure_compiled?(module)
#: lib/code.ex:577
msgid ""
"Ensures the given module is compiled and loaded.\n"
"\n"
"Similar to `ensure_compiled/1`, but returns `true` if the module\n"
"is already loaded or was successfully loaded and compiled.\n"
"Returns `false` otherwise.\n"
msgstr ""
"指定したモジュールがコンパイルされ、ロードされていることを保証します。\n"
"\n"
"`ensure_compiled/1`と同じですが、モジュールがすでにロードされている、\n"
"または、ロードしてコンパイルに成功した場合は、`true`を返します。\n"
"そうでない場合は`false`を返します。\n"
"\n"

#. TRANSLATORS: def Code.compile_quoted(quoted, file \\ "nofile")
#: lib/code.ex:469
msgid ""
"Compiles the quoted expression.\n"
"\n"
"Returns a list of tuples where the first element is the module name and\n"
"the second one is its byte code (as a binary).\n"
msgstr ""
"quoteされた式をコンパイルします。\n"
"\n"
"タプルのリストを返します。タプルの最初の要素はモジュール名で\n"
"2番目の要素はそのバイトコード（バイナリ）です。\n"

#. TRANSLATORS: def Code.append_path(path)
#: lib/code.ex:42
msgid ""
"Appends a path to the end of the Erlang VM code path list.\n"
"\n"
"This is the list of directories the Erlang VM uses for\n"
"finding module code.\n"
"\n"
"The path is expanded with `Path.expand/1` before being appended.\n"
"If this path does not exist, an error is returned.\n"
"\n"
"## Examples\n"
"\n"
"    Code.append_path(\".\") #=> true\n"
"\n"
"    Code.append_path(\"/does_not_exist\") #=> {:error, :bad_directory}\n"
"\n"
msgstr ""
"Erlang VMコードパスリストの最後にパスを追加します。\n"
"\n"
"これはErlang VMがモジュールコードを探すために使用する\n"
"ディレクトリのリストです。\n"
"\n"
"パスは追加される前に`Path.expand/1` で展開されます。\n"
"このパスが存在しない場合はエラーが返されます。\n"
"\n"
"## 例\n"
"\n"
"    Code.append_path(\".\") #=> true\n"
"\n"
"    Code.append_path(\"/does_not_exist\") #=> {:error, :bad_directory}\n"
"\n"
