msgid ""
msgstr ""
"Project-Id-Version: l 10n_elixir\n"
"POT-Creation-Date: \n"
"PO-Revision-Date: 2017-03-16 15:43+0900\n"
"Last-Translator: 小田 照敬 <EMAIL@ADDRESS>\n"
"Language-Team: Japanese\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Poedit 1.8.12\n"

#. TRANSLATORS: def Inspect.Algebra.glue(doc1, break_string, doc2)
#: lib/inspect/algebra.ex:399
msgid ""
"Glues two documents (`doc1` and `doc2`) together inserting the given\n"
"break `break_string` between them.\n"
"\n"
"For more information on how the break is inserted, see `break/1`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> doc = Inspect.Algebra.glue(\"hello\", \"\t\", \"world\")\n"
"    iex> Inspect.Algebra.format(doc, 80)\n"
"    [\"hello\", \"\t\", \"world\"]\n"
"\n"
msgstr ""
"2つのドキュメント（`doc1`と`doc2`）を間に指定したブレーク文字\n"
"`break_string`を挿入して、つなげます。\n"
"\n"
"どのようにブレーク文字が挿入されるかに関する詳細は`break/1`を\n"
"参照してください。\n"
"\n"
"## 例\n"
"\n"
"    iex> doc = Inspect.Algebra.glue(\"hello\", \"\t\", \"world\")\n"
"    iex> Inspect.Algebra.format(doc, 80)\n"
"    [\"hello\", \"\t\", \"world\"]\n"
"\n"

#. TRANSLATORS: def Inspect.Algebra.break(string)
#: lib/inspect/algebra.ex:346
msgid ""
"Returns a document entity representing a break based on the given\n"
"`string`.\n"
"\n"
"This break can be rendered as a linebreak or as the given `string`,\n"
"depending on the `mode` of the chosen layout or the provided\n"
"separator.\n"
"\n"
"## Examples\n"
"\n"
"Let's create a document by concatenating two strings with a break between\n"
"them:\n"
"\n"
"    iex> doc = Inspect.Algebra.concat([\"a\", Inspect.Algebra.break(\"\\t"
"\"), \"b\"])\n"
"    iex> Inspect.Algebra.format(doc, 80)\n"
"    [\"a\", \"\\t\", \"b\"]\n"
"\n"
"Notice the break was represented with the given string, because we didn't\n"
"reach a line limit. Once we do, it is replaced by a newline:\n"
"\n"
"    iex> break = Inspect.Algebra.break(\"\\t\")\n"
"    iex> doc = Inspect.Algebra.concat([String.duplicate(\"a\", 20), break, "
"\"b\"])\n"
"    iex> Inspect.Algebra.format(doc, 10)\n"
"    [\"aaaaaaaaaaaaaaaaaaaa\", \"\\n\", \"b\"]\n"
"\n"
msgstr ""
"指定した`string`に基づきブレーク文字を表すドキュメント実体を返します。\n"
"\n"
"このブレーク文字は、選ばれたレイアウトのモード、または、提供されたセパレータ"
"に\n"
"より、改行か指定した`string`のいずれかでレンダリングされます。\n"
"\n"
"\n"
"## 例\n"
"\n"
"ブレーク文字を間に挟んで2つの文字列を連結してドキュメントを作成しましょう。\n"
"\n"
"    iex> doc = Inspect.Algebra.concat([\"a\", Inspect.Algebra.break(\"\\t"
"\"), \"b\"])\n"
"    iex> Inspect.Algebra.format(doc, 80)\n"
"    [\"a\", \"\\t\", \"b\"]\n"
"\n"
"ブレークが指定した文字列のまま現れていることに注目してください。行の制限に\n"
"到達しなかったからです。もう一度やってみましょう。今度は改行に置き換えられま"
"す。\n"
"\n"
"    iex> break = Inspect.Algebra.break(\"\\t\")\n"
"    iex> doc = Inspect.Algebra.concat([String.duplicate(\"a\", 20), break, "
"\"b\"])\n"
"    iex> Inspect.Algebra.format(doc, 10)\n"
"    [\"aaaaaaaaaaaaaaaaaaaa\", \"\\n\", \"b\"]\n"
"\n"

#. TRANSLATORS: def Inspect.Algebra.glue(doc1, doc2)
#: lib/inspect/algebra.ex:383
msgid ""
"Glues two documents together inserting the default break between them.\n"
"\n"
"The break that is inserted between `left` and `right` is the one returned "
"by\n"
"`break/0`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> doc = Inspect.Algebra.glue(\"hello\", \"world\")\n"
"    iex> Inspect.Algebra.format(doc, 80)\n"
"    [\"hello\", \" \", \"world\"]\n"
"\n"
msgstr ""
"2つのドキュメントを間にデフォルトブレーク文字を挿入して、つなげます。\n"
"\n"
"`doc1`と`doc2`の間に挿入されるブレーク文字は`break/0`が返す文字です。\n"
"\n"
"## 例\n"
"\n"
"    iex> doc = Inspect.Algebra.glue(\"hello\", \"world\")\n"
"    iex> Inspect.Algebra.format(doc, 80)\n"
"    [\"hello\", \" \", \"world\"]\n"
"\n"

#. TRANSLATORS: def Inspect.Algebra.group(doc)
#: lib/inspect/algebra.ex:416
msgid ""
"Returns a group containing the specified document `doc`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> doc = Inspect.Algebra.group(\n"
"    ...>   Inspect.Algebra.concat(\n"
"    ...>     Inspect.Algebra.group(\n"
"    ...>       Inspect.Algebra.concat(\n"
"    ...>         \"Hello,\",\n"
"    ...>         Inspect.Algebra.concat(\n"
"    ...>           Inspect.Algebra.break,\n"
"    ...>           \"A\"\n"
"    ...>         )\n"
"    ...>       )\n"
"    ...>     ),\n"
"    ...>     Inspect.Algebra.concat(\n"
"    ...>       Inspect.Algebra.break,\n"
"    ...>       \"B\"\n"
"    ...>     )\n"
"    ...> ))\n"
"    iex> Inspect.Algebra.format(doc, 80)\n"
"    [\"Hello,\", \" \", \"A\", \" \", \"B\"]\n"
"    iex> Inspect.Algebra.format(doc, 6)\n"
"    [\"Hello,\", \"\\n\", \"A\", \" \", \"B\"]\n"
"\n"
msgstr ""
"指定したドキュメント`doc`を含むグループを返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> doc = Inspect.Algebra.group(\n"
"    ...>   Inspect.Algebra.concat(\n"
"    ...>     Inspect.Algebra.group(\n"
"    ...>       Inspect.Algebra.concat(\n"
"    ...>         \"Hello,\",\n"
"    ...>         Inspect.Algebra.concat(\n"
"    ...>           Inspect.Algebra.break,\n"
"    ...>           \"A\"\n"
"    ...>         )\n"
"    ...>       )\n"
"    ...>     ),\n"
"    ...>     Inspect.Algebra.concat(\n"
"    ...>       Inspect.Algebra.break,\n"
"    ...>       \"B\"\n"
"    ...>     )\n"
"    ...> ))\n"
"    iex> Inspect.Algebra.format(doc, 80)\n"
"    [\"Hello,\", \" \", \"A\", \" \", \"B\"]\n"
"    iex> Inspect.Algebra.format(doc, 6)\n"
"    [\"Hello,\", \"\\n\", \"A\", \" \", \"B\"]\n"
"\n"

#. TRANSLATORS: def Inspect.Algebra.concat(doc1, doc2)
#: lib/inspect/algebra.ex:280
msgid ""
"Concatenates two document entities returning a new document.\n"
"\n"
"## Examples\n"
"\n"
"    iex> doc = Inspect.Algebra.concat(\"hello\", \"world\")\n"
"    iex> Inspect.Algebra.format(doc, 80)\n"
"    [\"hello\", \"world\"]\n"
"\n"
msgstr ""
"2つのドキュメント実体を連結し、新しいドキュメントを返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> doc = Inspect.Algebra.concat(\"hello\", \"world\")\n"
"    iex> Inspect.Algebra.format(doc, 80)\n"
"    [\"hello\", \"world\"]\n"
"\n"

#. TRANSLATORS: def Inspect.Algebra.color(doc, color_key, opts)
#: lib/inspect/algebra.ex:310
msgid "Colors a document if the `color_key` has a color in the options.\n"
msgstr ""
"オプションに`color_key`のカラーがある場合、ドキュメントを色づけます。\n"

#. TRANSLATORS: def Inspect.Algebra.surround_many(left, docs, right, opts, fun, separator \\ ",")
#: lib/inspect/algebra.ex:522
msgid ""
"Maps and glues a collection of items.\n"
"\n"
"It uses the given `left` and `right` documents as surrounding and the\n"
"separator document `separator` to separate items in `docs`. A limit can be\n"
"passed: when this limit is reached, this function stops gluing and outputs\n"
"`\"...\"` instead.\n"
"\n"
"## Examples\n"
"\n"
"    iex> doc = Inspect.Algebra.surround_many(\"[\", Enum.to_list(1..5), "
"\"]\",\n"
"    ...>         %Inspect.Opts{limit: :infinity}, fn i, _opts -> "
"to_string(i) end)\n"
"    iex> Inspect.Algebra.format(doc, 5) |> IO.iodata_to_binary\n"
"    \"[1,\\n 2,\\n 3,\\n 4,\\n 5]\"\n"
"\n"
"    iex> doc = Inspect.Algebra.surround_many(\"[\", Enum.to_list(1..5), "
"\"]\",\n"
"    ...>         %Inspect.Opts{limit: 3}, fn i, _opts -> to_string(i) end)\n"
"    iex> Inspect.Algebra.format(doc, 20) |> IO.iodata_to_binary\n"
"    \"[1, 2, 3, ...]\"\n"
"\n"
"    iex> doc = Inspect.Algebra.surround_many(\"[\", Enum.to_list(1..5), "
"\"]\",\n"
"    ...>         %Inspect.Opts{limit: 3}, fn i, _opts -> to_string(i) end, "
"\"!\")\n"
"    iex> Inspect.Algebra.format(doc, 20) |> IO.iodata_to_binary\n"
"    \"[1! 2! 3! ...]\"\n"
"\n"
msgstr ""
"項目のコレクションをマップしてつなげます。\n"
"\n"
"指定した2つのドキュメント`left`と`right`を周囲に置き、指定したセパレータ\n"
"ドキュメント`separator`を`docs`の項目間の区切りとして使用します。\n"
"表示の制限数を渡すことができ、この制限数に達すると、この関数は連結を停止"
"し、\n"
"代わりに`\"...\"`を出力します。\n"
"\n"
"## 例\n"
"\n"
"    iex> doc = Inspect.Algebra.surround_many(\"[\", Enum.to_list(1..5), "
"\"]\",\n"
"    ...>         %Inspect.Opts{limit: :infinity}, fn i, _opts -> "
"to_string(i) end)\n"
"    iex> Inspect.Algebra.format(doc, 5) |> IO.iodata_to_binary\n"
"    \"[1,\\n 2,\\n 3,\\n 4,\\n 5]\"\n"
"\n"
"    iex> doc = Inspect.Algebra.surround_many(\"[\", Enum.to_list(1..5), "
"\"]\",\n"
"    ...>         %Inspect.Opts{limit: 3}, fn i, _opts -> to_string(i) end)\n"
"    iex> Inspect.Algebra.format(doc, 20) |> IO.iodata_to_binary\n"
"    \"[1, 2, 3, ...]\"\n"
"\n"
"    iex> doc = Inspect.Algebra.surround_many(\"[\", Enum.to_list(1..5), "
"\"]\",\n"
"    ...>         %Inspect.Opts{limit: 3}, fn i, _opts -> to_string(i) end, "
"\"!\")\n"
"    iex> Inspect.Algebra.format(doc, 20) |> IO.iodata_to_binary\n"
"    \"[1! 2! 3! ...]\"\n"
"\n"

#. TRANSLATORS: def Inspect.Algebra.fold_doc(docs, folder_fun)
#: lib/inspect/algebra.ex:474
msgid ""
"Folds a list of documents into a document using the given folder function.\n"
"\n"
"The list of documents is folded \"from the right\"; in that, this function "
"is\n"
"similar to `List.foldr/3`, except that it doesn't expect an initial\n"
"accumulator and uses the last element of `docs` as the initial accumulator.\n"
"\n"
"## Examples\n"
"\n"
"    iex> docs = [\"A\", \"B\", \"C\"]\n"
"    iex> docs = Inspect.Algebra.fold_doc(docs, fn(doc, acc) ->\n"
"    ...>   Inspect.Algebra.concat([doc, \"!\", acc])\n"
"    ...> end)\n"
"    iex> Inspect.Algebra.format(docs, 80)\n"
"    [\"A\", \"!\", \"B\", \"!\", \"C\"]\n"
"\n"
msgstr ""
"指定したfolder関数を使用して、ドキュメントのリストを1つのドキュメントに\n"
"折りたたみます。\n"
"\n"
"ドキュメントのリストは「右から」折りたたまれます。実際、この関数は、\n"
"初期アキュムレータを必要とせず、`docs`の最後の要素を初期アキュムレータと\n"
"する点を除いて、`List.foldr/3`と同じです。\n"
"\n"
"## 例\n"
"\n"
"    iex> docs = [\"A\", \"B\", \"C\"]\n"
"    iex> docs = Inspect.Algebra.fold_doc(docs, fn(doc, acc) ->\n"
"    ...>   Inspect.Algebra.concat([doc, \"!\", acc])\n"
"    ...> end)\n"
"    iex> Inspect.Algebra.format(docs, 80)\n"
"    [\"A\", \"!\", \"B\", \"!\", \"C\"]\n"
"\n"

#. TRANSLATORS: def Inspect.Algebra.break()
#: lib/inspect/algebra.ex:375
msgid ""
"Returns a document entity representing the default break.\n"
"\n"
"Same as calling `break/1` with the default break.\n"
msgstr ""
"デフォルトブレーク文字を表すドキュメント実体を返します。\n"
"\n"
"デフォルトブレークを引数に`break/1`を呼び出すのと同じです。\n"

#. TRANSLATORS: def Inspect.Algebra.format(doc, width)
#: lib/inspect/algebra.ex:596
msgid ""
"Formats a given document for a given width.\n"
"\n"
"Takes the maximum width and a document to print as its arguments\n"
"and returns an IO data representation of the best layout for the\n"
"document to fit in the given width.\n"
"\n"
"## Examples\n"
"\n"
"    iex> doc = Inspect.Algebra.glue(\"hello\", \" \", \"world\")\n"
"    iex> Inspect.Algebra.format(doc, 30) |> IO.iodata_to_binary()\n"
"    \"hello world\"\n"
"    iex> Inspect.Algebra.format(doc, 10) |> IO.iodata_to_binary()\n"
"    \"hello\\nworld\"\n"
"\n"
msgstr ""
"指定したドキュメントを指定した幅でフォーマットします。\n"
"\n"
"印刷する最大幅とドキュメントを引数として取り、指定した幅に\n"
"収まるドキュメントの最適レイアウトのIOデータ表現を返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> doc = Inspect.Algebra.glue(\"hello\", \" \", \"world\")\n"
"    iex> Inspect.Algebra.format(doc, 30) |> IO.iodata_to_binary()\n"
"    \"hello world\"\n"
"    iex> Inspect.Algebra.format(doc, 10) |> IO.iodata_to_binary()\n"
"    \"hello\\nworld\"\n"
"\n"

#. TRANSLATORS: def Inspect.Algebra.concat(docs)
#: lib/inspect/algebra.ex:295
msgid ""
"Concatenates a list of documents returning a new document.\n"
"\n"
"## Examples\n"
"\n"
"    iex> doc = Inspect.Algebra.concat([\"a\", \"b\", \"c\"])\n"
"    iex> Inspect.Algebra.format(doc, 80)\n"
"    [\"a\", \"b\", \"c\"]\n"
"\n"
msgstr ""
"ドキュメントのリストを連結して、新しいドキュメントを返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> doc = Inspect.Algebra.concat([\"a\", \"b\", \"c\"])\n"
"    iex> Inspect.Algebra.format(doc, 80)\n"
"    [\"a\", \"b\", \"c\"]\n"
"\n"

#. TRANSLATORS: def Inspect.Algebra.line(doc1, doc2)
#: lib/inspect/algebra.ex:461
msgid ""
"Inserts a mandatory linebreak between two documents.\n"
"\n"
"## Examples\n"
"\n"
"    iex> doc = Inspect.Algebra.line(\"Hughes\", \"Wadler\")\n"
"    iex> Inspect.Algebra.format(doc, 80)\n"
"    [\"Hughes\", \"\\n\", \"Wadler\"]\n"
"\n"
msgstr ""
"2つのドキュメントの間に強制的に改行を挿入します。\n"
"\n"
"## 例\n"
"\n"
"    iex> doc = Inspect.Algebra.line(\"Hughes\", \"Wadler\")\n"
"    iex> Inspect.Algebra.format(doc, 80)\n"
"    [\"Hughes\", \"\\n\", \"Wadler\"]\n"
"\n"

#. TRANSLATORS: def Inspect.Algebra.nest(doc, level)
#: lib/inspect/algebra.ex:323
msgid ""
"Nests the given document at the given `level`.\n"
"\n"
"Nesting will be appended to the line breaks.\n"
"\n"
"## Examples\n"
"\n"
"    iex> doc = Inspect.Algebra.nest(Inspect.Algebra.glue(\"hello\", \"world"
"\"), 5)\n"
"    iex> Inspect.Algebra.format(doc, 5)\n"
"    [\"hello\", \"\\n     \", \"world\"]\n"
"\n"
msgstr ""
"指定したドキュメントを指定の`level`だけネストします。\n"
"\n"
"ネスティングは改行の後に追加されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> doc = Inspect.Algebra.nest(Inspect.Algebra.glue(\"hello\", \"world"
"\"), 5)\n"
"    iex> Inspect.Algebra.format(doc, 5)\n"
"    [\"hello\", \"\\n     \", \"world\"]\n"
"\n"

#. TRANSLATORS: Elixir.Inspect.Algebra Summary
#: lib/inspect/algebra.ex:89
msgid ""
"A set of functions for creating and manipulating algebra\n"
"documents.\n"
"\n"
"This module implements the functionality described in\n"
"[\"Strictly Pretty\" (2000) by Christian Lindig][0] with small\n"
"additions, like support for String nodes, and a custom\n"
"rendering function that maximises horizontal space use.\n"
"\n"
"    iex> Inspect.Algebra.empty\n"
"    :doc_nil\n"
"\n"
"    iex> \"foo\"\n"
"    \"foo\"\n"
"\n"
"With the functions in this module, we can concatenate different\n"
"elements together and render them:\n"
"\n"
"    iex> doc = Inspect.Algebra.concat(Inspect.Algebra.empty, \"foo\")\n"
"    iex> Inspect.Algebra.format(doc, 80)\n"
"    [\"foo\"]\n"
"\n"
"The functions `nest/2`, `space/2` and `line/2` help you put the\n"
"document together into a rigid structure. However, the document\n"
"algebra gets interesting when using functions like `break/1`, which\n"
"converts the given string into a line break depending on how much space\n"
"there is to print. Let's glue two docs together with a break and then\n"
"render it:\n"
"\n"
"    iex> doc = Inspect.Algebra.glue(\"a\", \" \", \"b\")\n"
"    iex> Inspect.Algebra.format(doc, 80)\n"
"    [\"a\", \" \", \"b\"]\n"
"\n"
"Notice the break was represented as is, because we haven't reached\n"
"a line limit. Once we do, it is replaced by a newline:\n"
"\n"
"    iex> doc = Inspect.Algebra.glue(String.duplicate(\"a\", 20), \" \", \"b"
"\")\n"
"    iex> Inspect.Algebra.format(doc, 10)\n"
"    [\"aaaaaaaaaaaaaaaaaaaa\", \"\\n\", \"b\"]\n"
"\n"
"Finally, this module also contains Elixir related functions, a bit\n"
"tied to Elixir formatting, namely `surround/3` and `surround_many/5`.\n"
"\n"
"## Implementation details\n"
"\n"
"The original Haskell implementation of the algorithm by [Wadler][1]\n"
"relies on lazy evaluation to unfold document groups on two alternatives:\n"
"`:flat` (breaks as spaces) and `:break` (breaks as newlines).\n"
"Implementing the same logic in a strict language such as Elixir leads\n"
"to an exponential growth of possible documents, unless document groups\n"
"are encoded explicitly as `:flat` or `:break`. Those groups are then "
"reduced\n"
"to a simple document, where the layout is already decided, per [Lindig][0].\n"
"\n"
"This implementation slightly changes the semantic of Lindig's algorithm\n"
"to allow elements that belong to the same group to be printed together\n"
"in the same line, even if they do not fit the line fully. This was achieved\n"
"by changing `:break` to mean a possible break and `:flat` to force a flat\n"
"structure. Then deciding if a break works as a newline is just a matter\n"
"of checking if we have enough space until the next break that is not\n"
"inside a group (which is still flat).\n"
"\n"
"Custom pretty printers can be implemented using the documents returned\n"
"by this module and by providing their own rendering functions.\n"
"\n"
"  [0]: http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.34.2200\n"
"  [1]: http://homepages.inf.ed.ac.uk/wadler/papers/prettier/prettier.pdf\n"
"\n"
msgstr ""
"代数ドキュメントを作成・操作するための関数です。\n"
"\n"
"このモジュールは、[Christian Lindigの「Strictly Pretty」(2000)][0]\n"
"に記載されている機能実装し、さらに、文字列ノードのサポートや水平方向の\n"
"スペースを最大限に使用するカスタムレンダリング関数などの小さな拡張を\n"
"加えています。\n"
"\n"
"    iex> Inspect.Algebra.empty\n"
"    :doc_nil\n"
"\n"
"    iex> \"foo\"\n"
"    \"foo\"\n"
"\n"
"このモジュールの関数を使うことで、異なる要素を連結し、レンダリングする\n"
"ことができます。\n"
"\n"
"    iex> doc = Inspect.Algebra.concat(Inspect.Algebra.empty, \"foo\")\n"
"    iex> Inspect.Algebra.format(doc, 80)\n"
"    [\"foo\"]\n"
"\n"
"関数`nest/2`、`space/2`、`line/2`は、ドキュメントを1つの固定した\n"
"構造にまとめることを助けます。しかし、ドキュメント代数は、指定した文字列を\n"
"プリントするスペースに合わせて改行する`break/1`のような関数を使うと\n"
"面白いものになります。2つのドキュメントとブレーク文字をつなげて、\n"
"レンダリングしてみましょう。\n"
"\n"
"    iex> doc = Inspect.Algebra.glue(\"a\", \" \", \"b\")\n"
"    iex> Inspect.Algebra.format(doc, 80)\n"
"    [\"a\", \" \", \"b\"]\n"
"\n"
"ブレーク文字がそのまま表現されたことに注目してください。\n"
"行制限に達していなかったからです。もう一度やってみましょう。\n"
"今回は改行に置き換えられています。\n"
"\n"
"    iex> doc = Inspect.Algebra.glue(String.duplicate(\"a\", 20), \" \", \"b"
"\")\n"
"    iex> Inspect.Algebra.format(doc, 10)\n"
"    [\"aaaaaaaaaaaaaaaaaaaa\", \"\\n\", \"b\"]\n"
"\n"
"最後に、このモジュールには`surround/3`と`surround_many/5`という名前の\n"
"若干Elixirの書式に結びついたElixir関連の関数も含まれています。\n"
"\n"
"## 実装の詳細\n"
"\n"
"[Wadler][1]によるこのアルゴリズムのHaskelによるオジリナル実装は、\n"
"`:flat`（スペースで分割）と`:break`(改行で分割）という2つの選択肢で\n"
"ドキュメントグループを展開する際に遅延評価に頼っています。Elixirのような\n"
"厳格な言語で同じロジックを実装すると、ドキュメントグループが明示的に\n"
"`:flat`か`:break`でエンコードされていない限り、可能なドキュメントが\n"
"指数関数的に増加します。それらのグループはその後、レイアウトが既に\n"
"決定されている簡単なドキュメントに集約されます（[Lindig][0]）。\n"
"\n"
"この実装は、Lindigのアルゴリズムの意味を少し変更して、たとえ行に完全に\n"
"収まらなくても、同じグループに所属する要素は同じ行に一緒に印刷できるように\n"
"しています。これは、`:break`は可能なブレーク文字を意味する、`:flat`はフラット"
"構造を\n"
"強制する、というように変更することにより実現しています。ブレーク文字が\n"
"改行として機能するか否かの判断は、（まだフラットな）グループ内にはない\n"
"次のブレーク文字まで十分なスペースがあるか否かをチェックするだけで済みま"
"す。\n"
"\n"
"カスタムプリティプリントは、このモジュールにより返されるドキュメントを\n"
"使用し、独自のレンダリング関数を提供することにより実装することができます。\n"
"\n"
"  [0]: http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.34.2200\n"
"  [1]: http://homepages.inf.ed.ac.uk/wadler/papers/prettier/prettier.pdf\n"
"\n"

#. TRANSLATORS: def Inspect.Algebra.space(doc1, doc2)
#: lib/inspect/algebra.ex:448
msgid ""
"Inserts a mandatory single space between two documents.\n"
"\n"
"## Examples\n"
"\n"
"    iex> doc = Inspect.Algebra.space(\"Hughes\", \"Wadler\")\n"
"    iex> Inspect.Algebra.format(doc, 5)\n"
"    [\"Hughes\", \" \", \"Wadler\"]\n"
"\n"
msgstr ""
"2つのドキュメントの間に強制的に空白を1つ挿入します。\n"
"\n"
"## 例\n"
"\n"
"    iex> doc = Inspect.Algebra.space(\"Hughes\", \"Wadler\")\n"
"    iex> Inspect.Algebra.format(doc, 5)\n"
"    [\"Hughes\", \" \", \"Wadler\"]\n"
"\n"

#. TRANSLATORS: def Inspect.Algebra.surround(left, doc, right)
#: lib/inspect/algebra.ex:503
msgid ""
"Surrounds a document with characters.\n"
"\n"
"Puts the given document `doc` between the `left` and `right` documents "
"enclosing\n"
"and nesting it. The document is marked as a group, to show the maximum as\n"
"possible concisely together.\n"
"\n"
"## Examples\n"
"\n"
"    iex> doc = Inspect.Algebra.surround(\"[\", Inspect.Algebra.glue(\"a\", "
"\"b\"), \"]\")\n"
"    iex> Inspect.Algebra.format(doc, 3)\n"
"    [\"[\", \"a\", \"\\n \", \"b\", \"]\"]\n"
"\n"
msgstr ""
"ドキュメントを文字で囲みます。\n"
"\n"
"指定したドキュメント`doc`を2つのドキュメント`left`と`right`の間に\n"
"置いて入れ子にします。可能な限り最大限簡潔に表示するために、\n"
"ドキュメントはグループとしてマークされます。\n"
"\n"
"## 例\n"
"\n"
"    iex> doc = Inspect.Algebra.surround(\"[\", Inspect.Algebra.glue(\"a\", "
"\"b\"), \"]\")\n"
"    iex> Inspect.Algebra.format(doc, 3)\n"
"    [\"[\", \"a\", \"\\n \", \"b\", \"]\"]\n"
"\n"

#. TRANSLATORS: def Inspect.Algebra.empty()
#: lib/inspect/algebra.ex:268
msgid ""
"Returns a document entity used to represent nothingness.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Inspect.Algebra.empty\n"
"    :doc_nil\n"
"\n"
msgstr ""
"何もないことを表す際に使用されるドキュメント実体を返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Inspect.Algebra.empty\n"
"    :doc_nil\n"
"\n"

#. TRANSLATORS: Elixir.Inspect.Opts Summary
#: lib/inspect/algebra.ex:2
msgid ""
"Defines the Inspect.Opts used by the Inspect protocol.\n"
"\n"
"The following fields are available:\n"
"\n"
"  * `:structs` - when `false`, structs are not formatted by the inspect\n"
"    protocol, they are instead printed as maps, defaults to `true`.\n"
"\n"
"  * `:binaries` - when `:as_strings` all binaries will be printed as "
"strings,\n"
"    non-printable bytes will be escaped.\n"
"\n"
"    When `:as_binaries` all binaries will be printed in bit syntax.\n"
"\n"
"    When the default `:infer`, the binary will be printed as a string if it\n"
"    is printable, otherwise in bit syntax.\n"
"\n"
"  * `:charlists` - when `:as_charlists` all lists will be printed as char\n"
"    lists, non-printable elements will be escaped.\n"
"\n"
"    When `:as_lists` all lists will be printed as lists.\n"
"\n"
"    When the default `:infer`, the list will be printed as a charlist if it\n"
"    is printable, otherwise as list.\n"
"\n"
"  * `:limit` - limits the number of items that are printed for tuples,\n"
"    bitstrings, and lists, does not apply to strings nor charlists, "
"defaults\n"
"    to 50.\n"
"\n"
"  * `:pretty` - if set to `true` enables pretty printing, defaults to "
"`false`.\n"
"\n"
"  * `:width` - defaults to 80 characters, used when pretty is `true` or "
"when\n"
"    printing to IO devices. Set to 0 to force each item to be printed on "
"its\n"
"    own line.\n"
"\n"
"  * `:base` - prints integers as `:binary`, `:octal`, `:decimal`, or `:hex`, "
"defaults\n"
"    to `:decimal`. When inspecting binaries any `:base` other than `:"
"decimal`\n"
"    implies `binaries: :as_binaries`.\n"
"\n"
"  * `:safe` - when `false`, failures while inspecting structs will be "
"raised\n"
"    as errors instead of being wrapped in the `Inspect.Error` exception. "
"This\n"
"    is useful when debugging failures and crashes for custom inspect\n"
"    implementations\n"
"\n"
"  * `:syntax_colors` - when set to a keyword list of colors the output will\n"
"    be colorized. The keys are types and the values are the colors to use "
"for\n"
"    each type. e.g. `[number: :red, atom: :blue]`. Types can include\n"
"    `:number`, `:atom`, `regex`, `:tuple`, `:map`, `:list`, and `:reset`.\n"
"    Colors can be any `t:IO.ANSI.ansidata/0` as accepted by `IO.ANSI."
"format/1`.\n"
msgstr ""
"Inspectプロトコルで使用されるInspect.Optsを定義します。\n"
"\n"
"以下のフィールドが利用できます。\n"
"\n"
"  * `:structs` -  `false`の時、構造体はinspectプロトコルで\n"
"    フォーマットされません。代りにマップとして表示されます。\n"
"    デフォルトは`true`です。\n"
"\n"
"  * `:binaries` -  `:as_strings`の時、全てのバイナリは文字列として\n"
"    表示され、印字不能なバイトはエスケープされます。\n"
"\n"
"    `:as_binaries`の時、すべてのバイナリはビット構文で表示されます。\n"
"\n"
"    デフォルトの`:infer`の時、バイナリはそれが印字可能なら\n"
"    文字列として表示され、不可能であればビット構文になります。\n"
"\n"
"  * `:char_lists` -  `:as_char_lists`の時、すべてのリストは文字のリストとし"
"て\n"
"    表示され、印字不能な要素はエスケープされます。\n"
"\n"
"    `:as_lists`の時、すべてのリストは、リストとして表示されます。\n"
"\n"
"    デフォルトの`:infer`の時、リストはそれが印字可能なら文字のリストして\n"
"    表示され、不可能であればリストとして表示されます。\n"
"\n"
"  * `:limit` - タプル、ビットストリング、リストにおいて表示する\n"
"    要素の数を制限します。文字列と文字のリストには適用されません。\n"
"    デフォルトは50です。\n"
"\n"
"  * `:pretty` -  `true`にセットすると、プリティプリンティングを\n"
"     有効にします。デフォルトは`false`です。\n"
"\n"
"  * `:width` -  デフォルトは80文字です。prettyが`true`か、\n"
"    IOデバイスへのプリント時に使われます。0をセットすると、強制的に\n"
"    1項目1行で表示します。\n"
"\n"
"  * `:base` -  整数を:binary、:octal、:decimal、:hexで表示します。\n"
"    デフォルトは:decimalです。`:decimal`以外の`:base`でバイナリをインスペク"
"ト\n"
"    する場合は、`binaries: :as_binaries`を意味します。\n"
"\n"
"  * `:safe` - `false`の時、構造体をインスペクト中の失敗は、\n"
"    `Inspect.Error`例外でラッピングするかわりに、エラーが発生します。\n"
"    これはカスタムinspect実装の失敗とクラッシュをデバッグする際に便利です。\n"
"\n"
"  * `:syntax_colors` - 色のキーワードリストをセットすると、出力が色付けされま"
"す。\n"
"    キーは型で、値はその型に使用する色です。たとえば、\n"
"    `[number: :red, atom: :blue]`。型には、`:number`, `:atom`, `regex`, \n"
"    `:tuple`, `:map`, `:list`, `:reset`が指定できます。色には、\n"
"    `IO.ANSI.format/1`が受け付ける任意の`t:IO.ANSI.ansidata/0`が指定できま"
"す。\n"

#. TRANSLATORS: def Inspect.Algebra.to_doc(term, opts)
#: lib/inspect/algebra.ex:214
msgid ""
"Converts an Elixir term to an algebra document\n"
"according to the `Inspect` protocol.\n"
msgstr ""
"`Inspect`プロトコルに従って、Elixirの項を代数ドキュメントに変換します。\n"

#. TRANSLATORS: Elixir.Inspect.Error Summary
#: lib/inspect/algebra.ex:82
msgid "Raised when a struct cannot be inspected.\n"
msgstr "構造体のinspectが出来無かった時に上ります。\n"

#~ msgid "Concatenates a list of documents.\n"
#~ msgstr "ドキュメントのリストを連結します。\n"

#~ msgid ""
#~ "The formatting function.\n"
#~ "\n"
#~ "Takes the maximum width and a document to print as its arguments\n"
#~ "and returns an IO data representation of the best layout for the\n"
#~ "document to fit in the given width.\n"
#~ msgstr ""
#~ "フォーマット関数です。\n"
#~ "\n"
#~ "最大幅とその引数で表示するドキュメントをとり、その幅にフィットするドキュ\n"
#~ "メントのためのベストレイアウトのIOデータ表現を返します。\n"

#~ msgid ""
#~ "Inserts a break, passed as the second argument, between two docs,\n"
#~ "the first and the third arguments.\n"
#~ msgstr ""
#~ "1番目と3番目の引数で示された二つのドキュメントの間に、2番目の引数として\n"
#~ "パスされたブレークを挿入します。\n"

#~ msgid "Inserts a break between two docs. See `break/1` for more info.\n"
#~ msgstr ""
#~ "二つのドキュメントの間にブレークを挿入します。\n"
#~ "詳細は`break/1`を参照してください。\n"
