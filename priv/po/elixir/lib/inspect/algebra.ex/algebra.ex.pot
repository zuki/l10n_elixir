#. TRANSLATORS: def Inspect.Algebra.glue(doc1, break_string, doc2)
#: lib/inspect/algebra.ex:399 
msgid ""
"Glues two documents (`doc1` and `doc2`) together inserting the given\n"
"break `break_string` between them.\n"
"\n"
"For more information on how the break is inserted, see `break/1`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> doc = Inspect.Algebra.glue(\"hello\", \"\t\", \"world\")\n"
"    iex> Inspect.Algebra.format(doc, 80)\n"
"    [\"hello\", \"\t\", \"world\"]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Inspect.Algebra.break(string)
#: lib/inspect/algebra.ex:346 
msgid ""
"Returns a document entity representing a break based on the given\n"
"`string`.\n"
"\n"
"This break can be rendered as a linebreak or as the given `string`,\n"
"depending on the `mode` of the chosen layout or the provided\n"
"separator.\n"
"\n"
"## Examples\n"
"\n"
"Let's create a document by concatenating two strings with a break between\n"
"them:\n"
"\n"
"    iex> doc = Inspect.Algebra.concat([\"a\", Inspect.Algebra.break(\"\\t\"), \"b\"])\n"
"    iex> Inspect.Algebra.format(doc, 80)\n"
"    [\"a\", \"\\t\", \"b\"]\n"
"\n"
"Notice the break was represented with the given string, because we didn't\n"
"reach a line limit. Once we do, it is replaced by a newline:\n"
"\n"
"    iex> break = Inspect.Algebra.break(\"\\t\")\n"
"    iex> doc = Inspect.Algebra.concat([String.duplicate(\"a\", 20), break, \"b\"])\n"
"    iex> Inspect.Algebra.format(doc, 10)\n"
"    [\"aaaaaaaaaaaaaaaaaaaa\", \"\\n\", \"b\"]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Inspect.Algebra.glue(doc1, doc2)
#: lib/inspect/algebra.ex:383 
msgid ""
"Glues two documents together inserting the default break between them.\n"
"\n"
"The break that is inserted between `left` and `right` is the one returned by\n"
"`break/0`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> doc = Inspect.Algebra.glue(\"hello\", \"world\")\n"
"    iex> Inspect.Algebra.format(doc, 80)\n"
"    [\"hello\", \" \", \"world\"]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Inspect.Algebra.group(doc)
#: lib/inspect/algebra.ex:416 
msgid ""
"Returns a group containing the specified document `doc`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> doc = Inspect.Algebra.group(\n"
"    ...>   Inspect.Algebra.concat(\n"
"    ...>     Inspect.Algebra.group(\n"
"    ...>       Inspect.Algebra.concat(\n"
"    ...>         \"Hello,\",\n"
"    ...>         Inspect.Algebra.concat(\n"
"    ...>           Inspect.Algebra.break,\n"
"    ...>           \"A\"\n"
"    ...>         )\n"
"    ...>       )\n"
"    ...>     ),\n"
"    ...>     Inspect.Algebra.concat(\n"
"    ...>       Inspect.Algebra.break,\n"
"    ...>       \"B\"\n"
"    ...>     )\n"
"    ...> ))\n"
"    iex> Inspect.Algebra.format(doc, 80)\n"
"    [\"Hello,\", \" \", \"A\", \" \", \"B\"]\n"
"    iex> Inspect.Algebra.format(doc, 6)\n"
"    [\"Hello,\", \"\\n\", \"A\", \" \", \"B\"]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Inspect.Algebra.concat(doc1, doc2)
#: lib/inspect/algebra.ex:280 
msgid ""
"Concatenates two document entities returning a new document.\n"
"\n"
"## Examples\n"
"\n"
"    iex> doc = Inspect.Algebra.concat(\"hello\", \"world\")\n"
"    iex> Inspect.Algebra.format(doc, 80)\n"
"    [\"hello\", \"world\"]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Inspect.Algebra.color(doc, color_key, opts)
#: lib/inspect/algebra.ex:310 
msgid ""
"Colors a document if the `color_key` has a color in the options.\n"
msgstr ""
#. TRANSLATORS: def Inspect.Algebra.surround_many(left, docs, right, opts, fun, separator \\ ",")
#: lib/inspect/algebra.ex:522 
msgid ""
"Maps and glues a collection of items.\n"
"\n"
"It uses the given `left` and `right` documents as surrounding and the\n"
"separator document `separator` to separate items in `docs`. A limit can be\n"
"passed: when this limit is reached, this function stops gluing and outputs\n"
"`\"...\"` instead.\n"
"\n"
"## Examples\n"
"\n"
"    iex> doc = Inspect.Algebra.surround_many(\"[\", Enum.to_list(1..5), \"]\",\n"
"    ...>         %Inspect.Opts{limit: :infinity}, fn i, _opts -> to_string(i) end)\n"
"    iex> Inspect.Algebra.format(doc, 5) |> IO.iodata_to_binary\n"
"    \"[1,\\n 2,\\n 3,\\n 4,\\n 5]\"\n"
"\n"
"    iex> doc = Inspect.Algebra.surround_many(\"[\", Enum.to_list(1..5), \"]\",\n"
"    ...>         %Inspect.Opts{limit: 3}, fn i, _opts -> to_string(i) end)\n"
"    iex> Inspect.Algebra.format(doc, 20) |> IO.iodata_to_binary\n"
"    \"[1, 2, 3, ...]\"\n"
"\n"
"    iex> doc = Inspect.Algebra.surround_many(\"[\", Enum.to_list(1..5), \"]\",\n"
"    ...>         %Inspect.Opts{limit: 3}, fn i, _opts -> to_string(i) end, \"!\")\n"
"    iex> Inspect.Algebra.format(doc, 20) |> IO.iodata_to_binary\n"
"    \"[1! 2! 3! ...]\"\n"
"\n"
msgstr ""
#. TRANSLATORS: def Inspect.Algebra.fold_doc(docs, folder_fun)
#: lib/inspect/algebra.ex:474 
msgid ""
"Folds a list of documents into a document using the given folder function.\n"
"\n"
"The list of documents is folded \"from the right\"; in that, this function is\n"
"similar to `List.foldr/3`, except that it doesn't expect an initial\n"
"accumulator and uses the last element of `docs` as the initial accumulator.\n"
"\n"
"## Examples\n"
"\n"
"    iex> docs = [\"A\", \"B\", \"C\"]\n"
"    iex> docs = Inspect.Algebra.fold_doc(docs, fn(doc, acc) ->\n"
"    ...>   Inspect.Algebra.concat([doc, \"!\", acc])\n"
"    ...> end)\n"
"    iex> Inspect.Algebra.format(docs, 80)\n"
"    [\"A\", \"!\", \"B\", \"!\", \"C\"]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Inspect.Algebra.break()
#: lib/inspect/algebra.ex:375 
msgid ""
"Returns a document entity representing the default break.\n"
"\n"
"Same as calling `break/1` with the default break.\n"
msgstr ""
#. TRANSLATORS: def Inspect.Algebra.format(doc, width)
#: lib/inspect/algebra.ex:596 
msgid ""
"Formats a given document for a given width.\n"
"\n"
"Takes the maximum width and a document to print as its arguments\n"
"and returns an IO data representation of the best layout for the\n"
"document to fit in the given width.\n"
"\n"
"## Examples\n"
"\n"
"    iex> doc = Inspect.Algebra.glue(\"hello\", \" \", \"world\")\n"
"    iex> Inspect.Algebra.format(doc, 30) |> IO.iodata_to_binary()\n"
"    \"hello world\"\n"
"    iex> Inspect.Algebra.format(doc, 10) |> IO.iodata_to_binary()\n"
"    \"hello\\nworld\"\n"
"\n"
msgstr ""
#. TRANSLATORS: def Inspect.Algebra.concat(docs)
#: lib/inspect/algebra.ex:295 
msgid ""
"Concatenates a list of documents returning a new document.\n"
"\n"
"## Examples\n"
"\n"
"    iex> doc = Inspect.Algebra.concat([\"a\", \"b\", \"c\"])\n"
"    iex> Inspect.Algebra.format(doc, 80)\n"
"    [\"a\", \"b\", \"c\"]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Inspect.Algebra.line(doc1, doc2)
#: lib/inspect/algebra.ex:461 
msgid ""
"Inserts a mandatory linebreak between two documents.\n"
"\n"
"## Examples\n"
"\n"
"    iex> doc = Inspect.Algebra.line(\"Hughes\", \"Wadler\")\n"
"    iex> Inspect.Algebra.format(doc, 80)\n"
"    [\"Hughes\", \"\\n\", \"Wadler\"]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Inspect.Algebra.nest(doc, level)
#: lib/inspect/algebra.ex:323 
msgid ""
"Nests the given document at the given `level`.\n"
"\n"
"Nesting will be appended to the line breaks.\n"
"\n"
"## Examples\n"
"\n"
"    iex> doc = Inspect.Algebra.nest(Inspect.Algebra.glue(\"hello\", \"world\"), 5)\n"
"    iex> Inspect.Algebra.format(doc, 5)\n"
"    [\"hello\", \"\\n     \", \"world\"]\n"
"\n"
msgstr ""
#. TRANSLATORS: Elixir.Inspect.Algebra Summary
#: lib/inspect/algebra.ex:89 
msgid ""
"A set of functions for creating and manipulating algebra\n"
"documents.\n"
"\n"
"This module implements the functionality described in\n"
"[\"Strictly Pretty\" (2000) by Christian Lindig][0] with small\n"
"additions, like support for String nodes, and a custom\n"
"rendering function that maximises horizontal space use.\n"
"\n"
"    iex> Inspect.Algebra.empty\n"
"    :doc_nil\n"
"\n"
"    iex> \"foo\"\n"
"    \"foo\"\n"
"\n"
"With the functions in this module, we can concatenate different\n"
"elements together and render them:\n"
"\n"
"    iex> doc = Inspect.Algebra.concat(Inspect.Algebra.empty, \"foo\")\n"
"    iex> Inspect.Algebra.format(doc, 80)\n"
"    [\"foo\"]\n"
"\n"
"The functions `nest/2`, `space/2` and `line/2` help you put the\n"
"document together into a rigid structure. However, the document\n"
"algebra gets interesting when using functions like `break/1`, which\n"
"converts the given string into a line break depending on how much space\n"
"there is to print. Let's glue two docs together with a break and then\n"
"render it:\n"
"\n"
"    iex> doc = Inspect.Algebra.glue(\"a\", \" \", \"b\")\n"
"    iex> Inspect.Algebra.format(doc, 80)\n"
"    [\"a\", \" \", \"b\"]\n"
"\n"
"Notice the break was represented as is, because we haven't reached\n"
"a line limit. Once we do, it is replaced by a newline:\n"
"\n"
"    iex> doc = Inspect.Algebra.glue(String.duplicate(\"a\", 20), \" \", \"b\")\n"
"    iex> Inspect.Algebra.format(doc, 10)\n"
"    [\"aaaaaaaaaaaaaaaaaaaa\", \"\\n\", \"b\"]\n"
"\n"
"Finally, this module also contains Elixir related functions, a bit\n"
"tied to Elixir formatting, namely `surround/3` and `surround_many/5`.\n"
"\n"
"## Implementation details\n"
"\n"
"The original Haskell implementation of the algorithm by [Wadler][1]\n"
"relies on lazy evaluation to unfold document groups on two alternatives:\n"
"`:flat` (breaks as spaces) and `:break` (breaks as newlines).\n"
"Implementing the same logic in a strict language such as Elixir leads\n"
"to an exponential growth of possible documents, unless document groups\n"
"are encoded explicitly as `:flat` or `:break`. Those groups are then reduced\n"
"to a simple document, where the layout is already decided, per [Lindig][0].\n"
"\n"
"This implementation slightly changes the semantic of Lindig's algorithm\n"
"to allow elements that belong to the same group to be printed together\n"
"in the same line, even if they do not fit the line fully. This was achieved\n"
"by changing `:break` to mean a possible break and `:flat` to force a flat\n"
"structure. Then deciding if a break works as a newline is just a matter\n"
"of checking if we have enough space until the next break that is not\n"
"inside a group (which is still flat).\n"
"\n"
"Custom pretty printers can be implemented using the documents returned\n"
"by this module and by providing their own rendering functions.\n"
"\n"
"  [0]: http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.34.2200\n"
"  [1]: http://homepages.inf.ed.ac.uk/wadler/papers/prettier/prettier.pdf\n"
"\n"
msgstr ""
#. TRANSLATORS: def Inspect.Algebra.space(doc1, doc2)
#: lib/inspect/algebra.ex:448 
msgid ""
"Inserts a mandatory single space between two documents.\n"
"\n"
"## Examples\n"
"\n"
"    iex> doc = Inspect.Algebra.space(\"Hughes\", \"Wadler\")\n"
"    iex> Inspect.Algebra.format(doc, 5)\n"
"    [\"Hughes\", \" \", \"Wadler\"]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Inspect.Algebra.surround(left, doc, right)
#: lib/inspect/algebra.ex:503 
msgid ""
"Surrounds a document with characters.\n"
"\n"
"Puts the given document `doc` between the `left` and `right` documents enclosing\n"
"and nesting it. The document is marked as a group, to show the maximum as\n"
"possible concisely together.\n"
"\n"
"## Examples\n"
"\n"
"    iex> doc = Inspect.Algebra.surround(\"[\", Inspect.Algebra.glue(\"a\", \"b\"), \"]\")\n"
"    iex> Inspect.Algebra.format(doc, 3)\n"
"    [\"[\", \"a\", \"\\n \", \"b\", \"]\"]\n"
"\n"
msgstr ""
#. TRANSLATORS: def Inspect.Algebra.empty()
#: lib/inspect/algebra.ex:268 
msgid ""
"Returns a document entity used to represent nothingness.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Inspect.Algebra.empty\n"
"    :doc_nil\n"
"\n"
msgstr ""
#. TRANSLATORS: Elixir.Inspect.Opts Summary
#: lib/inspect/algebra.ex:2 
msgid ""
"Defines the Inspect.Opts used by the Inspect protocol.\n"
"\n"
"The following fields are available:\n"
"\n"
"  * `:structs` - when `false`, structs are not formatted by the inspect\n"
"    protocol, they are instead printed as maps, defaults to `true`.\n"
"\n"
"  * `:binaries` - when `:as_strings` all binaries will be printed as strings,\n"
"    non-printable bytes will be escaped.\n"
"\n"
"    When `:as_binaries` all binaries will be printed in bit syntax.\n"
"\n"
"    When the default `:infer`, the binary will be printed as a string if it\n"
"    is printable, otherwise in bit syntax.\n"
"\n"
"  * `:charlists` - when `:as_charlists` all lists will be printed as char\n"
"    lists, non-printable elements will be escaped.\n"
"\n"
"    When `:as_lists` all lists will be printed as lists.\n"
"\n"
"    When the default `:infer`, the list will be printed as a charlist if it\n"
"    is printable, otherwise as list.\n"
"\n"
"  * `:limit` - limits the number of items that are printed for tuples,\n"
"    bitstrings, and lists, does not apply to strings nor charlists, defaults\n"
"    to 50.\n"
"\n"
"  * `:pretty` - if set to `true` enables pretty printing, defaults to `false`.\n"
"\n"
"  * `:width` - defaults to 80 characters, used when pretty is `true` or when\n"
"    printing to IO devices. Set to 0 to force each item to be printed on its\n"
"    own line.\n"
"\n"
"  * `:base` - prints integers as `:binary`, `:octal`, `:decimal`, or `:hex`, defaults\n"
"    to `:decimal`. When inspecting binaries any `:base` other than `:decimal`\n"
"    implies `binaries: :as_binaries`.\n"
"\n"
"  * `:safe` - when `false`, failures while inspecting structs will be raised\n"
"    as errors instead of being wrapped in the `Inspect.Error` exception. This\n"
"    is useful when debugging failures and crashes for custom inspect\n"
"    implementations\n"
"\n"
"  * `:syntax_colors` - when set to a keyword list of colors the output will\n"
"    be colorized. The keys are types and the values are the colors to use for\n"
"    each type. e.g. `[number: :red, atom: :blue]`. Types can include\n"
"    `:number`, `:atom`, `regex`, `:tuple`, `:map`, `:list`, and `:reset`.\n"
"    Colors can be any `t:IO.ANSI.ansidata/0` as accepted by `IO.ANSI.format/1`.\n"
msgstr ""
#. TRANSLATORS: def Inspect.Algebra.to_doc(term, opts)
#: lib/inspect/algebra.ex:214 
msgid ""
"Converts an Elixir term to an algebra document\n"
"according to the `Inspect` protocol.\n"
msgstr ""
#. TRANSLATORS: Elixir.Inspect.Error Summary
#: lib/inspect/algebra.ex:82 
msgid ""
"Raised when a struct cannot be inspected.\n"
msgstr ""
