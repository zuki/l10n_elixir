msgid ""
msgstr ""
"Project-Id-Version: l 10n_elixir\n"
"POT-Creation-Date: \n"
"PO-Revision-Date: 2017-03-16 11:14+0900\n"
"Last-Translator: 小田 照敬 <EMAIL@ADDRESS>\n"
"Language-Team: Japanese\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Poedit 1.8.12\n"

#. TRANSLATORS: Elixir.Inspect Summary
#: lib/inspect.ex:5
msgid ""
"The `Inspect` protocol is responsible for converting any Elixir\n"
"data structure into an algebra document. This document is then\n"
"formatted, either in pretty printing format or a regular one.\n"
"\n"
"The `inspect/2` function receives the entity to be inspected\n"
"followed by the inspecting options, represented by the struct\n"
"`Inspect.Opts`.\n"
"\n"
"Inspection is done using the functions available in `Inspect.Algebra`.\n"
"\n"
"## Examples\n"
"\n"
"Many times, inspecting a structure can be implemented in function\n"
"of existing entities. For example, here is `MapSet`'s `inspect`\n"
"implementation:\n"
"\n"
"    defimpl Inspect, for: MapSet do\n"
"      import Inspect.Algebra\n"
"\n"
"      def inspect(dict, opts) do\n"
"        concat [\"#MapSet<\", to_doc(MapSet.to_list(dict), opts), \">\"]\n"
"      end\n"
"    end\n"
"\n"
"The `concat/1` function comes from `Inspect.Algebra` and it\n"
"concatenates algebra documents together. In the example above,\n"
"it is concatenating the string `\"MapSet<\"` (all strings are\n"
"valid algebra documents that keep their formatting when pretty\n"
"printed), the document returned by `Inspect.Algebra.to_doc/2` and the\n"
"other string `\">\"`.\n"
"\n"
"Since regular strings are valid entities in an algebra document,\n"
"an implementation of inspect may simply return a string,\n"
"although that will devoid it of any pretty-printing.\n"
"\n"
"## Error handling\n"
"\n"
"In case there is an error while your structure is being inspected,\n"
"Elixir will raise an `ArgumentError` error and will automatically fall back\n"
"to a raw representation for printing the structure.\n"
"\n"
"You can however access the underlying error by invoking the Inspect\n"
"implementation directly. For example, to test Inspect.MapSet above,\n"
"you can invoke it as:\n"
"\n"
"    Inspect.MapSet.inspect(MapSet.new, %Inspect.Opts{})\n"
"\n"
msgstr ""
"`Inspect`プロトコルは、任意のElixirデータ構造を代数ドキュメントに\n"
"変換する役割りを果します。代数ドキュメントは、その後、プリティ\n"
"プリンティング書式、または、標準書式のいずれかにフォーマットされます。\n"
"\n"
"`inspect/2`関数は、インスペクトされる実体と`Inspect.Opts`\n"
"構造体で表現されたインスペクトオプションを受け取ります。\n"
"\n"
"インスペクションは`Inspect.Algebra`モジュールの関数を使用して\n"
"行われます。\n"
"\n"
"## 例\n"
"\n"
"多くの場合、構造体のインスペクションは、その実体の関数の中で\n"
"実装することができます。たとえば、以下は`MapSet`の`inspect`実装です。\n"
"\n"
"    defimpl Inspect, for: MapSet do\n"
"      import Inspect.Algebra\n"
"\n"
"      def inspect(dict, opts) do\n"
"        concat [\"#MapSet<\", to_doc(MapSet.to_list(dict), opts), \">\"]\n"
"      end\n"
"    end\n"
"\n"
"`concat`関数は、`Inspect.Algebra`モジュールの関数であり、代数ドキュメントを\n"
"連結します。上の例では、文字列`\"MapSet<“`（すべての文字列はプリティ\n"
"プリントされる際に書式を保持する妥当な代数ドキュメントです）、\n"
"`Inspect.Algebra.to_doc/2`関数が返すドキュメント、文字列`\">\"`を\n"
"連結しています。\n"
"\n"
"通常の文字列は代数ドキュメントとして妥当な実体ですので、inspect関数の実装は\n"
"プリティプリンティング用の書式を持っていませんが、単に文字列を返すだけで"
"す。\n"
"\n"
"## エラー処理\n"
"\n"
"構造体のインスペクト中にエラーがあった場合、Elixirは\n"
"`ArgumentError`エラーを発生させ、構造体を出力するために\n"
"自動的に構造体のraw表現にフォールバックします。\n"
"\n"
"しかし、Inspect実装を直接実行することにより、発生したエラーにアクセス\n"
"することができます。たとえば、上のInspect.MapSetをテストするために、\n"
"次のように実行することができます。\n"
"\n"
"    Inspect.MapSet.inspect(MapSet.new, %Inspect.Opts{})\n"
"\n"
