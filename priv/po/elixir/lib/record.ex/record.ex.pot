#. TRANSLATORS: defmacro Record.defrecordp(name, tag \\ nil, kv)
#: lib/record.ex:272 
msgid ""
"Same as `defrecord/3` but generates private macros.\n"
msgstr ""
#. TRANSLATORS: Elixir.Record Summary
#: lib/record.ex:2 
msgid ""
"Module to work with, define, and import records.\n"
"\n"
"Records are simply tuples where the first element is an atom:\n"
"\n"
"    iex> Record.is_record {User, \"john\", 27}\n"
"    true\n"
"\n"
"This module provides conveniences for working with records at\n"
"compilation time, where compile-time field names are used to\n"
"manipulate the tuples, providing fast operations on top of\n"
"the tuples' compact structure.\n"
"\n"
"In Elixir, records are used mostly in two situations:\n"
"\n"
"  1. to work with short, internal data\n"
"  2. to interface with Erlang records\n"
"\n"
"The macros `defrecord/3` and `defrecordp/3` can be used to create records\n"
"while `extract/2` and `extract_all/1` can be used to extract records from\n"
"Erlang files.\n"
"\n"
"## Types\n"
"\n"
"Types can be defined for tuples with the `record/2` macro (only available in\n"
"typespecs). This macro will expand to a tuple as seen in the example below:\n"
"\n"
"    defmodule MyModule do\n"
"      require Record\n"
"      Record.defrecord :user, name: \"john\", age: 25\n"
"\n"
"      @type user :: record(:user, name: String.t, age: integer)\n"
"      # expands to: \"@type user :: {:user, String.t, integer}\"\n"
"    end\n"
"\n"
msgstr ""
#. TRANSLATORS: def Record.extract(name, opts)
#: lib/record.ex:39 
msgid ""
"Extracts record information from an Erlang file.\n"
"\n"
"Returns a quoted expression containing the fields as a list\n"
"of tuples.\n"
"\n"
"`name`, which is the name of the extracted record, is expected to be an atom\n"
"*at compile time*.\n"
"\n"
"## Options\n"
"\n"
"This function accepts the following options, which are exclusive to each other\n"
"(i.e., only one of them can be used in the same call):\n"
"\n"
"  * `:from` - (binary representing a path to a file) path to the Erlang file\n"
"    that contains the record definition to extract; with this option, this\n"
"    function uses the same path lookup used by the `-include` attribute used in\n"
"    Erlang modules.\n"
"  * `:from_lib` - (binary representing a path to a file) path to the Erlang\n"
"    file that contains the record definition to extract; with this option,\n"
"    this function uses the same path lookup used by the `-include_lib`\n"
"    attribute used in Erlang modules.\n"
"\n"
"These options are expected to be literals (including the binary values) at\n"
"compile time.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Record.extract(:file_info, from_lib: \"kernel/include/file.hrl\")\n"
"    [size: :undefined, type: :undefined, access: :undefined, atime: :undefined,\n"
"     mtime: :undefined, ctime: :undefined, mode: :undefined, links: :undefined,\n"
"     major_device: :undefined, minor_device: :undefined, inode: :undefined,\n"
"     uid: :undefined, gid: :undefined]\n"
"\n"
msgstr ""
#. TRANSLATORS: defmacro Record.defrecord(name, tag \\ nil, kv)
#: lib/record.ex:164 
msgid ""
"Defines a set of macros to create, access, and pattern match\n"
"on a record.\n"
"\n"
"The name of the generated macros will be `name` (which has to be an\n"
"atom). `tag` is also an atom and is used as the \"tag\" for the record (i.e.,\n"
"the first element of the record tuple); by default (if `nil`), it's the same\n"
"as `name`. `kv` is a keyword list of `name: default_value` fields for the\n"
"new record.\n"
"\n"
"The following macros are generated:\n"
"\n"
"  * `name/0` to create a new record with default values for all fields\n"
"  * `name/1` to create a new record with the given fields and values,\n"
"    to get the zero-based index of the given field in a record or to\n"
"    convert the given record to a keyword list\n"
"  * `name/2` to update an existing record with the given fields and values\n"
"    or to access a given field in a given record\n"
"\n"
"All these macros are public macros (as defined by `defmacro`).\n"
"\n"
"See the \"Examples\" section for examples on how to use these macros.\n"
"\n"
"## Examples\n"
"\n"
"    defmodule User do\n"
"      require Record\n"
"      Record.defrecord :user, [name: \"meg\", age: \"25\"]\n"
"    end\n"
"\n"
"In the example above, a set of macros named `user` but with different\n"
"arities will be defined to manipulate the underlying record.\n"
"\n"
"    # Import the module to make the user macros locally available\n"
"    import User\n"
"\n"
"    # To create records\n"
"    record = user()        #=> {:user, \"meg\", 25}\n"
"    record = user(age: 26) #=> {:user, \"meg\", 26}\n"
"\n"
"    # To get a field from the record\n"
"    user(record, :name) #=> \"meg\"\n"
"\n"
"    # To update the record\n"
"    user(record, age: 26) #=> {:user, \"meg\", 26}\n"
"\n"
"    # To get the zero-based index of the field in record tuple\n"
"    # (index 0 is occupied by the record \"tag\")\n"
"    user(:name) #=> 1\n"
"\n"
"    # Convert a record to a keyword list\n"
"    user(record) #=> [name: \"meg\", age: 26]\n"
"\n"
"The generated macros can also be used in order to pattern match on records and\n"
"to bind variables during the match:\n"
"\n"
"    record = user() #=> {:user, \"meg\", 25}\n"
"\n"
"    user(name: name) = record\n"
"    name #=> \"meg\"\n"
"\n"
"By default, Elixir uses the record name as the first element of the tuple (the\n"
"\"tag\"). However, a different tag can be specified when defining a record:\n"
"\n"
"    defmodule User do\n"
"      require Record\n"
"      Record.defrecord :user, User, name: nil\n"
"    end\n"
"\n"
"    require User\n"
"    User.user() #=> {User, nil}\n"
"\n"
"## Defining extracted records with anonymous functions in the values\n"
"\n"
"If a record defines an anonymous function in the default values, an\n"
"`ArgumentError` will be raised. This can happen unintentionally when defining\n"
"a record after extracting it from an Erlang library that uses anonymous\n"
"functions for defaults.\n"
"\n"
"    Record.defrecord :my_rec, Record.extract(...)\n"
"    #=> ** (ArgumentError) invalid value for record field fun_field,\n"
"    cannot escape #Function<12.90072148/2 in :erl_eval.expr/5>.\n"
"\n"
"To work around this error, redefine the field with your own &M.f/a function,\n"
"like so:\n"
"\n"
"    defmodule MyRec do\n"
"      require Record\n"
"      Record.defrecord :my_rec, Record.extract(...) |> Keyword.merge(fun_field: &__MODULE__.foo/2)\n"
"      def foo(bar, baz), do: IO.inspect({bar, baz})\n"
"    end\n"
"\n"
msgstr ""
#. TRANSLATORS: def Record.extract_all(opts)
#: lib/record.ex:78 
msgid ""
"Extracts all records information from an Erlang file.\n"
"\n"
"Returns a keyword list of `{record_name, fields}` tuples where `record_name`\n"
"is the name of an extracted record and `fields` is a list of `{field, value}`\n"
"tuples representing the fields for that record.\n"
"\n"
"## Options\n"
"\n"
"This function accepts the following options, which are exclusive to each other\n"
"(i.e., only one of them can be used in the same call):\n"
"\n"
"  * `:from` - (binary representing a path to a file) path to the Erlang file\n"
"    that contains the record definitions to extract; with this option, this\n"
"    function uses the same path lookup used by the `-include` attribute used in\n"
"    Erlang modules.\n"
"  * `:from_lib` - (binary representing a path to a file) path to the Erlang\n"
"    file that contains the record definitions to extract; with this option,\n"
"    this function uses the same path lookup used by the `-include_lib`\n"
"    attribute used in Erlang modules.\n"
"\n"
"These options are expected to be literals (including the binary values) at\n"
"compile time.\n"
msgstr ""
#. TRANSLATORS: defmacro Record.is_record(data)
#: lib/record.ex:134 
msgid ""
"Checks if the given `data` is a record.\n"
"\n"
"This is implemented as a macro so it can be used in guard clauses.\n"
"\n"
"## Examples\n"
"\n"
"    iex> record = {User, \"john\", 27}\n"
"    iex> Record.is_record(record)\n"
"    true\n"
"    iex> tuple = {}\n"
"    iex> Record.is_record(tuple)\n"
"    false\n"
"\n"
msgstr ""
#. TRANSLATORS: defmacro Record.is_record(data, kind)
#: lib/record.ex:106 
msgid ""
"Checks if the given `data` is a record of kind `kind`.\n"
"\n"
"This is implemented as a macro so it can be used in guard clauses.\n"
"\n"
"## Examples\n"
"\n"
"    iex> record = {User, \"john\", 27}\n"
"    iex> Record.is_record(record, User)\n"
"    true\n"
"\n"
msgstr ""
