msgid ""
msgstr ""
"Project-Id-Version: l 10n_elixir\n"
"POT-Creation-Date: \n"
"PO-Revision-Date: 2017-01-29 21:03+0900\n"
"Last-Translator: 小田 照敬 <EMAIL@ADDRESS>\n"
"Language-Team: Japanese\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Poedit 1.8.11\n"

#. TRANSLATORS: defmacro Record.defrecordp(name, tag \\ nil, kv)
#: lib/record.ex:272
msgid "Same as `defrecord/3` but generates private macros.\n"
msgstr "`defrecord/3`と同じですが、プライベートマクロを生成します。\n"

#. TRANSLATORS: Elixir.Record Summary
#: lib/record.ex:2
msgid ""
"Module to work with, define, and import records.\n"
"\n"
"Records are simply tuples where the first element is an atom:\n"
"\n"
"    iex> Record.is_record {User, \"john\", 27}\n"
"    true\n"
"\n"
"This module provides conveniences for working with records at\n"
"compilation time, where compile-time field names are used to\n"
"manipulate the tuples, providing fast operations on top of\n"
"the tuples' compact structure.\n"
"\n"
"In Elixir, records are used mostly in two situations:\n"
"\n"
"  1. to work with short, internal data\n"
"  2. to interface with Erlang records\n"
"\n"
"The macros `defrecord/3` and `defrecordp/3` can be used to create records\n"
"while `extract/2` and `extract_all/1` can be used to extract records from\n"
"Erlang files.\n"
"\n"
"## Types\n"
"\n"
"Types can be defined for tuples with the `record/2` macro (only available "
"in\n"
"typespecs). This macro will expand to a tuple as seen in the example below:\n"
"\n"
"    defmodule MyModule do\n"
"      require Record\n"
"      Record.defrecord :user, name: \"john\", age: 25\n"
"\n"
"      @type user :: record(:user, name: String.t, age: integer)\n"
"      # expands to: \"@type user :: {:user, String.t, integer}\"\n"
"    end\n"
"\n"
msgstr ""
"レコードを扱い、定義し、インポートするためのモジュールです。\n"
"\n"
"レコードは、最初の要素がアトムである、単なるタプルです:\n"
"\n"
"    iex> Record.record? {User, \"john\", 27}\n"
"    true\n"
"\n"
"このモジュールはコンパイル時にレコードを扱うための利便性を提供します。\n"
"ここではコンパイル時にフィールド名を使用してタプルを操作し、タブルの\n"
"コンプアクトな構造による素早い操作を提供します。\n"
"\n"
"Elixirでは、レコードは主に2つの状況で使用されます。\n"
"\n"
"  1. 短い内部データを扱うため\n"
"  2. Erlangレコードとインタフェースをとるため\n"
"\n"
"レコードを作成するにはマクロ`defrecord/3`と`defrecordp/3`を使用することがで"
"き、\n"
"Erlangファイルからレコードを抽出するには`extract/2`と`extract_all/1`を\n"
"使用することができます。\n"
"\n"
"## タイプ\n"
"\n"
"タプルのタイプは`record/2`マクロで定義することができます（型仕様にのみ利用可"
"能です）。\n"
"このマクロは下の例でわかるようにタプルを展開します。\n"
"\n"
"    defmodule MyModule do\n"
"      require Record\n"
"      Record.defrecord :user name: \"john\", age: 25\n"
"\n"
"      @type user :: record(:user, name: String.t, age: integer)\n"
"      # 次に展開します: \"@type user :: {:user, String.t, integer}\"\n"
"    end\n"

#. TRANSLATORS: def Record.extract(name, opts)
#: lib/record.ex:39
msgid ""
"Extracts record information from an Erlang file.\n"
"\n"
"Returns a quoted expression containing the fields as a list\n"
"of tuples.\n"
"\n"
"`name`, which is the name of the extracted record, is expected to be an "
"atom\n"
"*at compile time*.\n"
"\n"
"## Options\n"
"\n"
"This function accepts the following options, which are exclusive to each "
"other\n"
"(i.e., only one of them can be used in the same call):\n"
"\n"
"  * `:from` - (binary representing a path to a file) path to the Erlang "
"file\n"
"    that contains the record definition to extract; with this option, this\n"
"    function uses the same path lookup used by the `-include` attribute used "
"in\n"
"    Erlang modules.\n"
"  * `:from_lib` - (binary representing a path to a file) path to the Erlang\n"
"    file that contains the record definition to extract; with this option,\n"
"    this function uses the same path lookup used by the `-include_lib`\n"
"    attribute used in Erlang modules.\n"
"\n"
"These options are expected to be literals (including the binary values) at\n"
"compile time.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Record.extract(:file_info, from_lib: \"kernel/include/file.hrl\")\n"
"    [size: :undefined, type: :undefined, access: :undefined, atime: :"
"undefined,\n"
"     mtime: :undefined, ctime: :undefined, mode: :undefined, links: :"
"undefined,\n"
"     major_device: :undefined, minor_device: :undefined, inode: :undefined,\n"
"     uid: :undefined, gid: :undefined]\n"
"\n"
msgstr ""
"Erlangファイルからレコード情報を抽出します。\n"
"\n"
"タプルのリストとしてフィールドを含むquoted式を\n"
"返します。\n"
"\n"
"抽出されたレコード名である`name`は*コンパイル時には*アトムである\n"
"ことが想定されます。\n"
"\n"
"## オプション\n"
"\n"
"この関数は次のオプションを受け付けます。これらは互いに排他的です\n"
"（すなわち、1つの呼び出しにはこれらの1つしか使用できません）。\n"
"\n"
"  * `:from` - （ファイルのパスを表すバイナリ）抽出するレコード\n"
"    定義を含むErlangファイルのパス。このオプションでは、この関数は\n"
"    Erlangモジュールで使用されている`-include`属性で使用されるのと\n"
"    同じパス検索を使用します。\n"
"  * `:from_lib` - （ファイルのパスを表すバイナリ）抽出するレコード\n"
"    定義を含むErlangファイルのパス。このオプションでは、この関数は\n"
"    Erlangモジュールで使用されている`-include_lib`属性で使用されるのと\n"
"    同じパス検索を使用します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Record.extract(:file_info, from_lib: \"kernel/include/file.hrl\")\n"
"    [size: :undefined, type: :undefined, access: :undefined, atime: :"
"undefined,\n"
"     mtime: :undefined, ctime: :undefined, mode: :undefined, links: :"
"undefined,\n"
"     major_device: :undefined, minor_device: :undefined, inode: :undefined,\n"
"     uid: :undefined, gid: :undefined]\n"
"\n"
"\n"

#. TRANSLATORS: defmacro Record.defrecord(name, tag \\ nil, kv)
#: lib/record.ex:164
msgid ""
"Defines a set of macros to create, access, and pattern match\n"
"on a record.\n"
"\n"
"The name of the generated macros will be `name` (which has to be an\n"
"atom). `tag` is also an atom and is used as the \"tag\" for the record (i."
"e.,\n"
"the first element of the record tuple); by default (if `nil`), it's the "
"same\n"
"as `name`. `kv` is a keyword list of `name: default_value` fields for the\n"
"new record.\n"
"\n"
"The following macros are generated:\n"
"\n"
"  * `name/0` to create a new record with default values for all fields\n"
"  * `name/1` to create a new record with the given fields and values,\n"
"    to get the zero-based index of the given field in a record or to\n"
"    convert the given record to a keyword list\n"
"  * `name/2` to update an existing record with the given fields and values\n"
"    or to access a given field in a given record\n"
"\n"
"All these macros are public macros (as defined by `defmacro`).\n"
"\n"
"See the \"Examples\" section for examples on how to use these macros.\n"
"\n"
"## Examples\n"
"\n"
"    defmodule User do\n"
"      require Record\n"
"      Record.defrecord :user, [name: \"meg\", age: \"25\"]\n"
"    end\n"
"\n"
"In the example above, a set of macros named `user` but with different\n"
"arities will be defined to manipulate the underlying record.\n"
"\n"
"    # Import the module to make the user macros locally available\n"
"    import User\n"
"\n"
"    # To create records\n"
"    record = user()        #=> {:user, \"meg\", 25}\n"
"    record = user(age: 26) #=> {:user, \"meg\", 26}\n"
"\n"
"    # To get a field from the record\n"
"    user(record, :name) #=> \"meg\"\n"
"\n"
"    # To update the record\n"
"    user(record, age: 26) #=> {:user, \"meg\", 26}\n"
"\n"
"    # To get the zero-based index of the field in record tuple\n"
"    # (index 0 is occupied by the record \"tag\")\n"
"    user(:name) #=> 1\n"
"\n"
"    # Convert a record to a keyword list\n"
"    user(record) #=> [name: \"meg\", age: 26]\n"
"\n"
"The generated macros can also be used in order to pattern match on records "
"and\n"
"to bind variables during the match:\n"
"\n"
"    record = user() #=> {:user, \"meg\", 25}\n"
"\n"
"    user(name: name) = record\n"
"    name #=> \"meg\"\n"
"\n"
"By default, Elixir uses the record name as the first element of the tuple "
"(the\n"
"\"tag\"). However, a different tag can be specified when defining a record:\n"
"\n"
"    defmodule User do\n"
"      require Record\n"
"      Record.defrecord :user, User, name: nil\n"
"    end\n"
"\n"
"    require User\n"
"    User.user() #=> {User, nil}\n"
"\n"
"## Defining extracted records with anonymous functions in the values\n"
"\n"
"If a record defines an anonymous function in the default values, an\n"
"`ArgumentError` will be raised. This can happen unintentionally when "
"defining\n"
"a record after extracting it from an Erlang library that uses anonymous\n"
"functions for defaults.\n"
"\n"
"    Record.defrecord :my_rec, Record.extract(...)\n"
"    #=> ** (ArgumentError) invalid value for record field fun_field,\n"
"    cannot escape #Function<12.90072148/2 in :erl_eval.expr/5>.\n"
"\n"
"To work around this error, redefine the field with your own &M.f/a "
"function,\n"
"like so:\n"
"\n"
"    defmodule MyRec do\n"
"      require Record\n"
"      Record.defrecord :my_rec, Record.extract(...) |> Keyword."
"merge(fun_field: &__MODULE__.foo/2)\n"
"      def foo(bar, baz), do: IO.inspect({bar, baz})\n"
"    end\n"
"\n"
msgstr ""
"レコードを作成、アクセス、パターン照合するための一連の\n"
"マクロを定義します。\n"
"\n"
"生成されるマクロの名前は`name`（アトムでなければなりません）になります。\n"
"`tag`もアトムでレコードの「タグ」として使用されます（すなわち、レコード\n"
"タプルの最初の要素）。デフォルト（`nil`の場合）ではそれは`name`と同じで、\n"
"`kv`は新たなレコードの`name: default_value`フィールドのキーワードリスト\n"
"です。\n"
"\n"
"次のマクロが生成されます。\n"
"\n"
"  * `name/0` すべてのフィールドにデフォルト値を持つ新たなレコードを作成しま"
"す\n"
"  * `name/1` 指定されたフィールドと値を持つ新たなレコードを作成、\n"
"    または、レコードの指定されたフィールドの0はじまりのインデックスを取得、\n"
"    または、指定されたレコードをキーワードリストに変換します。\n"
"  * `name/2` 既存のレコードを指定されたフィールドと値で更新、\n"
"    または指定されたレコードの指定されたフィールドにアクセスします。\n"
"\n"
"これらすべてのマクロは公開マクロです（`defmacro`で定義されているからで"
"す）。\n"
"\n"
"これらのマクロの使用法に関する例は「例」のセクションを参照してください。\n"
"\n"
"## 例\n"
"\n"
"    defmodule User do\n"
"      require Record\n"
"      Record.defrecord :user, [name: \"meg\", age: \"25\"]\n"
"    end\n"
"\n"
"上の例では、`user`と名付けられた、異なるアリティを持つ一組のマクロが\n"
"定義され、レコードの操作に使用されます。\n"
"\n"
"    # userマクロをローカルで利用可能にするためにモジュールをインポートする\n"
"    import User\n"
"\n"
"    # レコードを作成する\n"
"    record = user()        #=> {:user, \"meg\", 25}\n"
"    record = user(age: 26) #=> {:user, \"meg\", 26}\n"
"\n"
"    # レコードからフィールを取得する\n"
"    user(record, :name) #=> \"meg\"\n"
"\n"
"    # レコードを更新する\n"
"    user(record, age: 26) #=> {:user, \"meg\", 26}\n"
"\n"
"    # レコードをキーワードリストに変換する\n"
"    user(record) #=> [name: \"meg\", age: 26]\n"
"\n"
"生成されたマクロはレコードのパターン照合や照合時の変数束縛にもマ\n"
"使用することができます。\n"
"\n"
"    record = user() #=> {:user, \"meg\", 25}\n"
"\n"
"    user(name: name) = record\n"
"    name #=> \"meg\"\n"
"\n"
"\n"
"デフォルトでは、Elixirはレコード名をタプルの最初の要素（「タグ」）として\n"
"使用します。しかし、レコードを定義する際に別のタグを指定することもできま"
"す。\n"
"\n"
"    defmodule User do\n"
"      require Record\n"
"      Record.defrecord :user, User, name: nil\n"
"    end\n"
"\n"
"    require User\n"
"    User.user() #=> {User, nil}\n"
"\n"
"## 値中の無名関数による抽出レコードの定義\n"
"\n"
"レコードがデフォルト値の中で無名関数を定義すると、`ArgumentError`が\n"
"発生します。これはデフォルトとして無名関数を使用するErlangライブラリから\n"
"抽出後にレコードを定義する際に意図せず起きる場合\n"
"があります。\n"
"\n"
"    Record.defrecord :my_rec, Record.extract(...)\n"
"    #=> ** (ArgumentError) invalid value for record field fun_field,\n"
"    cannot escape #Function<12.90072148/2 in :erl_eval.expr/5>.\n"
"\n"
"このエラーを回避するには、次のように独自の&M.f/a関数でフィールドを\n"
"再定義します。\n"
"\n"
"    defmodule MyRec do\n"
"      require Record\n"
"      Record.defrecord :my_rec, Record.extract(...) |> Keyword."
"merge(fun_field: &__MODULE__.foo/2)\n"
"      def foo(bar, baz), do: IO.inspect({bar, baz})\n"
"    end\n"

#. TRANSLATORS: def Record.extract_all(opts)
#: lib/record.ex:78
msgid ""
"Extracts all records information from an Erlang file.\n"
"\n"
"Returns a keyword list of `{record_name, fields}` tuples where "
"`record_name`\n"
"is the name of an extracted record and `fields` is a list of `{field, value}"
"`\n"
"tuples representing the fields for that record.\n"
"\n"
"## Options\n"
"\n"
"This function accepts the following options, which are exclusive to each "
"other\n"
"(i.e., only one of them can be used in the same call):\n"
"\n"
"  * `:from` - (binary representing a path to a file) path to the Erlang "
"file\n"
"    that contains the record definitions to extract; with this option, this\n"
"    function uses the same path lookup used by the `-include` attribute used "
"in\n"
"    Erlang modules.\n"
"  * `:from_lib` - (binary representing a path to a file) path to the Erlang\n"
"    file that contains the record definitions to extract; with this option,\n"
"    this function uses the same path lookup used by the `-include_lib`\n"
"    attribute used in Erlang modules.\n"
"\n"
"These options are expected to be literals (including the binary values) at\n"
"compile time.\n"
msgstr ""
"Erlangファイルからすべてのレコード情報を抽出します。\n"
"\n"
"タプル`{record_name, fields}`のキーワードリストを返します。\n"
"ここで`record_name`は抽出されるレコードの名前で、`fields`は\n"
"レコードのフィールドを表すタプル`{field, value}`のリストです。\n"
"\n"
"## オプション\n"
"\n"
"この関数は次のオプションを受け付けます。これらは互いに排他的です\n"
"（すなわち、1つの呼び出しにはこれらの1つしか使用できません）。\n"
"\n"
"  * `:from` - （ファイルのパスを表すバイナリ）抽出するレコード\n"
"    定義を含むErlangファイルのパス。このオプションでは、この関数は\n"
"    Erlangモジュールで使用されている`-include`属性で使用されるのと\n"
"    同じパス検索を使用します。\n"
"  * `:from_lib` - （ファイルのパスを表すバイナリ）抽出するレコード\n"
"    定義を含むErlangファイルのパス。このオプションでは、この関数は\n"
"    Erlangモジュールで使用されている`-include_lib`属性で使用されるのと\n"
"    同じパス検索を使用します。\n"
"\n"
"これらのオプションはコンパイル時にリテラル（バイナリ値を含む）である\n"
"ことが想定されています。\n"

#. TRANSLATORS: defmacro Record.is_record(data)
#: lib/record.ex:134
msgid ""
"Checks if the given `data` is a record.\n"
"\n"
"This is implemented as a macro so it can be used in guard clauses.\n"
"\n"
"## Examples\n"
"\n"
"    iex> record = {User, \"john\", 27}\n"
"    iex> Record.is_record(record)\n"
"    true\n"
"    iex> tuple = {}\n"
"    iex> Record.is_record(tuple)\n"
"    false\n"
"\n"
msgstr ""
"指定された`data`がレコードか否かをチェックします。\n"
"\n"
"これはガード節で使うことができるようにマクロとして実装されています。\n"
"\n"
"## 例\n"
"\n"
"    iex> record = {User, \"john\", 27}\n"
"    iex> Record.is_record(record)\n"
"    true\n"
"    iex> tuple = {}\n"
"    iex> Record.is_record(tuple)\n"
"    false\n"
"\n"

#. TRANSLATORS: defmacro Record.is_record(data, kind)
#: lib/record.ex:106
msgid ""
"Checks if the given `data` is a record of kind `kind`.\n"
"\n"
"This is implemented as a macro so it can be used in guard clauses.\n"
"\n"
"## Examples\n"
"\n"
"    iex> record = {User, \"john\", 27}\n"
"    iex> Record.is_record(record, User)\n"
"    true\n"
"\n"
msgstr ""
"指定された`data`が種別`kind`のレコードか否かをチェックします。\n"
"\n"
"これはガード節で使うことができるようにマクロとして実装されています。\n"
"\n"
"## 例\n"
"\n"
"    iex> record = {User, \"john\", 27}\n"
"    iex> Record.is_record(record, User)\n"
"    true\n"
"\n"

#~ msgid ""
#~ "Extracts record information from an Erlang file.\n"
#~ "\n"
#~ "Returns a quoted expression containing the fields as a list\n"
#~ "of tuples. It expects the record name to be an atom and the\n"
#~ "library path to be a string at expansion time.\n"
#~ "\n"
#~ "## Examples\n"
#~ "\n"
#~ "    iex> Record.extract(:file_info, from_lib: \"kernel/include/file.hrl"
#~ "\")\n"
#~ "    [size: :undefined, type: :undefined, access: :undefined, atime: :"
#~ "undefined,\n"
#~ "     mtime: :undefined, ctime: :undefined, mode: :undefined, links: :"
#~ "undefined,\n"
#~ "     major_device: :undefined, minor_device: :undefined, inode: :"
#~ "undefined,\n"
#~ "     uid: :undefined, gid: :undefined]\n"
#~ "\n"
#~ msgstr ""
#~ "Erlangファイルからレコード情報を抽出します。\n"
#~ "\n"
#~ "タプルのリストとしてのフィールドを含む、quoteされた式を返します。レコー\n"
#~ "ド名としてアトムを期待し、ライブラリパスは展開時に文字列として期待しま\n"
#~ "す。\n"
#~ "\n"
#~ "## 例\n"
#~ "\n"
#~ "    iex> Record.extract(:file_info, from_lib: \"kernel/include/file.hrl"
#~ "\")\n"
#~ "    [size: :undefined, type: :undefined, access: :undefined, atime: :"
#~ "undefined,\n"
#~ "     mtime: :undefined, ctime: :undefined, mode: :undefined, links: :"
#~ "undefined,\n"
#~ "     major_device: :undefined, minor_device: :undefined, inode: :"
#~ "undefined,\n"
#~ "     uid: :undefined, gid: :undefined]\n"
#~ "\n"

#~ msgid ""
#~ "Extracts all records information from an Erlang file.\n"
#~ "\n"
#~ "Returns a keyword list containing extracted record names as keys, and\n"
#~ "lists of tuples describing the fields as values. It expects a named\n"
#~ "argument :from or :from_lib, which correspond to *include* or\n"
#~ "*include_lib* attribute from Erlang modules, respectively.\n"
#~ "\n"
#~ msgstr ""
#~ "Erlangファイルからレコード情報を全て抽出します。\n"
#~ "\n"
#~ "キーとして抽出されたレコード名で、値として\n"
#~ "フィールドを記述したタプルのリストとなる、\n"
#~ "キーワードリストを返します。\n"
#~ "Erlangモジュールからの *include* あるいは\n"
#~ "*include_lib* 属性に由来する、 名前付き引数 :from または \n"
#~ ":from_lib を期待します。\n"
#~ "\n"
