msgid ""
msgstr ""
"Project-Id-Version: l 10n_elixir\n"
"PO-Revision-Date: 2017-03-15 18:46+0900\n"
"Last-Translator: 小田 照敬 <EMAIL@ADDRESS>\n"
"Language-Team: Japanese\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"POT-Creation-Date: \n"
"X-Generator: Poedit 1.8.12\n"

#. TRANSLATORS: def Enum.chunk(enumerable, count)
#: lib/enum.ex:319
msgid "Shortcut to `chunk(enumerable, count, count)`.\n"
msgstr "`chunk(enumerable, count, count)`へのショートカットです。\n"

#. TRANSLATORS: def Enum.reduce(enumerable, fun)
#: lib/enum.ex:1690
msgid ""
"Invokes `fun` for each element in the `enumerable`, passing that\n"
"element and the accumulator as arguments. `fun`'s return value\n"
"is stored in the accumulator.\n"
"\n"
"The first element of the enumerable is used as the initial value of\n"
"the accumulator.\n"
"If you wish to use another value for the accumulator, use\n"
"`Enumerable.reduce/3`.\n"
"This function won't call the specified function for enumerables that\n"
"are one-element long.\n"
"\n"
"Returns the accumulator.\n"
"\n"
"Note that since the first element of the enumerable is used as the\n"
"initial value of the accumulator, `fun` will only be executed `n - 1`\n"
"times where `n` is the length of the enumerable.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.reduce([1, 2, 3, 4], fn(x, acc) -> x * acc end)\n"
"    24\n"
"\n"
msgstr ""
"`enumerable`のそれぞれの要素について、その要素とアキュムレー\n"
"タを引数として、`fun`を起動します。`fun`の戻り値は、アキュム\n"
"レータに保存されます。\n"
"\n"
"`enumerable`の最初の要素は、アキュムレータの初期値として使わ\n"
"れます。もしアキュムレータの初期値として他の値を使いたい場合、\n"
"`Enumerable.reduce/3`を使ってください。この関数は数え上げのた\n"
"めに指定した関数を要素数-1回数呼出します。アキュムレータを\n"
"返します。\n"
"\n"
"最初の要素がアキュムレータの初期値として使われるので、\n"
"enumerableの要素数が`n`なら`fun`は`n - 1`回だけ呼び出されるこ\n"
"とに注意してください。\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.reduce([1, 2, 3, 4], fn(x, acc) -> x * acc end)\n"
"    24\n"
"\n"

#. TRANSLATORS: def Enum.random(enumerable)
#: lib/enum.ex:1639
#, fuzzy
msgid ""
"Returns a random element of an enumerable.\n"
"\n"
"Raises `Enum.EmptyError` if `enumerable` is empty.\n"
"\n"
"This function uses Erlang's `:rand` module to calculate\n"
"the random value. Check its documentation for setting a\n"
"different random algorithm or a different seed.\n"
"\n"
"The implementation is based on the\n"
"[reservoir sampling](https://en.wikipedia.org/wiki/"
"Reservoir_sampling#Relation_to_Fisher-Yates_shuffle)\n"
"algorithm.\n"
"It assumes that the sample being returned can fit into memory;\n"
"the input `enumerable` doesn't have to, as it is traversed just once.\n"
"\n"
"If a range is passed into the function, this function will pick a\n"
"random value between the range limits, without traversing the whole\n"
"range (thus executing in constant time and constant memory).\n"
"\n"
"## Examples\n"
"\n"
"    # Although not necessary, let's seed the random algorithm\n"
"    iex> :rand.seed(:exsplus, {101, 102, 103})\n"
"    iex> Enum.random([1, 2, 3])\n"
"    2\n"
"    iex> Enum.random([1, 2, 3])\n"
"    1\n"
"    iex> Enum.random(1..1_000)\n"
"    776\n"
"\n"
msgstr ""
"enumerableの要素をランダム化して返します。\n"
"\n"
"もし`enumerable`が空なら、`EmptyError`が上ります。\n"
"\n"
"この関数は乱数の計算にErlangの `:rand` モジュールを\n"
"使っています。異る乱数アルゴリズムのセッティングや\n"
"seedについてはそのドキュメントを参照してください。\n"
"\n"
"実装は、\n"
"[reservoir sampling](http://en.wikipedia.org/wiki/\n"
"Reservoir_sampling#Relation_to_Fisher-Yates_shuffle)\n"
"アルゴリズムに基いています。\n"
"それは返されるサンプルがメモリに収まると仮定します; 入力の\n"
"コレクションはその必要はありません。それは丁度一度だけトラバース\n"
"されます。\n"
"\n"
"## 例\n"
"\n"
"    # Although not necessary, let's seed the random algorithm\n"
"    iex> :rand.seed(:exsplus, {1, 2, 3})\n"
"    iex> Enum.random([1, 2, 3])\n"
"    1\n"
"    iex> Enum.random([1, 2, 3])\n"
"    2\n"
"\n"

#. TRANSLATORS: def Enum.join(enumerable, joiner \\ "")
#: lib/enum.ex:1177
msgid ""
"Joins the given enumerable into a binary using `joiner` as a\n"
"separator.\n"
"\n"
"If `joiner` is not passed at all, it defaults to the empty binary.\n"
"\n"
"All items in the enumerable must be convertible to a binary,\n"
"otherwise an error is raised.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.join([1, 2, 3])\n"
"    \"123\"\n"
"\n"
"    iex> Enum.join([1, 2, 3], \" = \")\n"
"    \"1 = 2 = 3\"\n"
"\n"
msgstr ""
"指定したenumerableをセパレータとして`joiner`を使って結合してバイナリにしま"
"す。\n"
"\n"
"`joiner`が指定されなかった場合、デフォルトは空のバイナリになります。\n"
"\n"
"コレクションのすべてのアイテムはバイナリに変換可能なものでなければなりませ"
"ん。\n"
"そうでない場合はエラーが発生します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.join([1, 2, 3])\n"
"    \"123\"\n"
"\n"
"    iex> Enum.join([1, 2, 3], \" = \")\n"
"    \"1 = 2 = 3\"\n"
"\n"

#. TRANSLATORS: def Enum.count(enumerable, fun)
#: lib/enum.ex:477
msgid ""
"Returns the count of items in the enumerable for which `fun` returns\n"
"a truthy value.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.count([1, 2, 3, 4, 5], fn(x) -> rem(x, 2) == 0 end)\n"
"    2\n"
"\n"
msgstr ""
"`fun`がtruthy値を返すEnumerableの要素の数を\n"
"返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.count([1, 2, 3, 4, 5], fn(x) -> rem(x, 2) == 0 end)\n"
"    2\n"
"\n"

#. TRANSLATORS: def Enum.dedup(enumerable)
#: lib/enum.ex:494
msgid ""
"Enumerates the `enumerable`, returning a list where all consecutive\n"
"duplicated elements are collapsed to a single element.\n"
"\n"
"Elements are compared using `===`.\n"
"\n"
"If you want to remove all duplicated elements, regardless of order,\n"
"see `uniq/1`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.dedup([1, 2, 3, 3, 2, 1])\n"
"    [1, 2, 3, 2, 1]\n"
"\n"
"    iex> Enum.dedup([1, 1, 2, 2.0, :three, :\"three\"])\n"
"    [1, 2, 2.0, :three]\n"
"\n"
msgstr ""
"`enumerable`を列挙して、すべての連続して重複する要素を1つの要素に\n"
"したリストを返します。\n"
"\n"
"要素は`===`を使って比較されます。\n"
"\n"
"順序に関係なく、すべての重複要素を削除したい場合は、`uniq/1`を\n"
"参照してください。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.dedup([1, 2, 3, 3, 2, 1])\n"
"    [1, 2, 3, 2, 1]\n"
"\n"
"    iex> Enum.dedup([1, 1, 2, 2.0, :three, :\"three\"])\n"
"    [1, 2, 2.0, :three]\n"
"\n"

#. TRANSLATORS: def Enum.drop(enumerable, amount)
#: lib/enum.ex:539
msgid ""
"Drops the `amount` of items from the enumerable.\n"
"\n"
"If a negative `amount` is given, the `amount` of last values will be "
"dropped.\n"
"\n"
"The `enumerable` is enumerated once to retrieve the proper index and\n"
"the remaining calculation is performed from the end.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.drop([1, 2, 3], 2)\n"
"    [3]\n"
"\n"
"    iex> Enum.drop([1, 2, 3], 10)\n"
"    []\n"
"\n"
"    iex> Enum.drop([1, 2, 3], 0)\n"
"    [1, 2, 3]\n"
"\n"
"    iex> Enum.drop([1, 2, 3], -1)\n"
"    [1, 2]\n"
"\n"
msgstr ""
"`enumerable`から最初の`n`個の項目を削除します。\n"
"\n"
"負の`n`が指定した場合は、末尾の`n`個が削除されます。\n"
"\n"
"適切なインデックスを取り出すために`enumerable`が一旦列挙され、\n"
"残りの計算は末尾から実行されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.drop([1, 2, 3], 2)\n"
"    [3]\n"
"\n"
"    iex> Enum.drop([1, 2, 3], 10)\n"
"    []\n"
"\n"
"    iex> Enum.drop([1, 2, 3], 0)\n"
"    [1, 2, 3]\n"
"\n"
"    iex> Enum.drop([1, 2, 3], -1)\n"
"    [1, 2]\n"
"\n"

#. TRANSLATORS: def Enum.min_max(enumerable, empty_fallback \\ fn -> raise(Enum.EmptyError) end)
#: lib/enum.ex:1491
#, fuzzy
msgid ""
"Returns a tuple with the minimal and the maximal elements in the\n"
"enumerable according to Erlang's term ordering.\n"
"\n"
"If multiple elements are considered maximal or minimal, the first one\n"
"that was found is returned.\n"
"\n"
"Calls the provided `empty_fallback` function and returns its value if\n"
"`enumerable` is empty. The default `empty_fallback` raises `Enum."
"EmptyError`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.min_max([2, 3, 1])\n"
"    {1, 3}\n"
"\n"
"    iex> Enum.min_max([], fn -> {nil, nil} end)\n"
"    {nil, nil}\n"
"\n"
msgstr ""
"Erlangのtermの順序に従って、最小と最大の値のタプルを返します。\n"
"\n"
"もし同じ要素が複数あったら、最初に見付かったものを採用します。\n"
"\n"
"もし`enumerable`が空なら、`EmptyError`を上げます。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.minmax([2, 3, 1])\n"
"    {1, 3}\n"
"\n"

#. TRANSLATORS: def Enum.shuffle(enumerable)
#: lib/enum.ex:1939
msgid ""
"Returns a list with the elements of `enumerable` shuffled.\n"
"\n"
"This function uses Erlang's `:rand` module to calculate\n"
"the random value. Check its documentation for setting a\n"
"different random algorithm or a different seed.\n"
"\n"
"## Examples\n"
"\n"
"    # Although not necessary, let's seed the random algorithm\n"
"    iex> :rand.seed(:exsplus, {1, 2, 3})\n"
"    iex> Enum.shuffle([1, 2, 3])\n"
"    [2, 1, 3]\n"
"    iex> Enum.shuffle([1, 2, 3])\n"
"    [2, 3, 1]\n"
"\n"
msgstr ""
"`enumerable`の要素をシャッフルしたリストを返します。\n"
"\n"
"この関数は乱数の計算にErlangの`:rand`モジュールを使っています。\n"
"異なる乱数アルゴリズムや異なるseedについては\n"
"そのドキュメントを参照してください。\n"
"\n"
"## 例\n"
"\n"
"    # 必須ではないが、乱数アルゴリズムにシードを与える\n"
"    iex> :rand.seed(:exsplus, {1, 2, 3})\n"
"    iex> Enum.shuffle([1, 2, 3])\n"
"    [2, 1, 3]\n"
"    iex> Enum.shuffle([1, 2, 3])\n"
"    [2, 3, 1]\n"
"\n"

#. TRANSLATORS: def Enum.member?(enumerable, element)
#: lib/enum.ex:1395
msgid ""
"Checks if `element` exists within the enumerable.\n"
"\n"
"Membership is tested with the match (`===`) operator.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.member?(1..10, 5)\n"
"    true\n"
"    iex> Enum.member?(1..10, 5.0)\n"
"    false\n"
"\n"
"    iex> Enum.member?([1.0, 2.0, 3.0], 2)\n"
"    false\n"
"    iex> Enum.member?([1.0, 2.0, 3.0], 2.000)\n"
"    true\n"
"\n"
"    iex> Enum.member?([:a, :b, :c], :d)\n"
"    false\n"
"\n"
msgstr ""
"`element`がenumerableに存在するかチェックします。\n"
"\n"
"メンバーであるか否かはマッチオペレータ(`===`)でテストされます。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.member?(1..10, 5)\n"
"    true\n"
"    iex> Enum.member?(1..10, 5.0)\n"
"    false\n"
"\n"
"    iex> Enum.member?([1.0, 2.0, 3.0], 2)\n"
"    false\n"
"    iex> Enum.member?([1.0, 2.0, 3.0], 2.000)\n"
"    true\n"
"\n"
"    iex> Enum.member?([:a, :b, :c], :d)\n"
"    false\n"
"\n"

#. TRANSLATORS: def Enum.sort(enumerable, fun)
#: lib/enum.ex:2119
msgid ""
"Sorts the enumerable by the given function.\n"
"\n"
"This function uses the merge sort algorithm. The given function should "
"compare\n"
"two arguments, and return `true` if the first argument precedes the second "
"one.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.sort([1, 2, 3], &(&1 >= &2))\n"
"    [3, 2, 1]\n"
"\n"
"The sorting algorithm will be stable as long as the given function\n"
"returns `true` for values considered equal:\n"
"\n"
"    iex> Enum.sort [\"some\", \"kind\", \"of\", \"monster\"], "
"&(byte_size(&1) <= byte_size(&2))\n"
"    [\"of\", \"some\", \"kind\", \"monster\"]\n"
"\n"
"If the function does not return `true` for equal values, the sorting\n"
"is not stable and the order of equal terms may be shuffled.\n"
"For example:\n"
"\n"
"    iex> Enum.sort [\"some\", \"kind\", \"of\", \"monster\"], "
"&(byte_size(&1) < byte_size(&2))\n"
"    [\"of\", \"kind\", \"some\", \"monster\"]\n"
"\n"
msgstr ""
"指定した関数でenumerableをソートします。\n"
"\n"
"この関数はマージソートアルゴリズムを使います。指定した関数は、\n"
"2つの引数を比較し、第1引数が第2引数より小さい場合、`true`を\n"
"返す必要があります。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.sort([1, 2, 3], &(&1 > &2))\n"
"    [3, 2, 1]\n"
"\n"
"\n"
"ソートアルゴリズムは、指定した関数が2つの値が等しい場合に`true`を\n"
"返す場合に限り安定します。\n"
"\n"
"    iex> Enum.sort [\"some\", \"kind\", \"of\", \"monster\"], "
"&(byte_size(&1) <= byte_size(&2))\n"
"    [\"of\", \"some\", \"kind\", \"monster\"]\n"
"\n"
"関数が値が等しい場合に`true`を返さないと、ソートは不安定となり、\n"
"等しい要素の順番はシャッフルされます。\n"
"\n"
"    iex> Enum.sort [\"some\", \"kind\", \"of\", \"monster\"], "
"&(byte_size(&1) < byte_size(&2))\n"
"    [\"of\", \"kind\", \"some\", \"monster\"]\n"
"\n"

#. TRANSLATORS: def Enum.scan(enumerable, acc, fun)
#: lib/enum.ex:1922
msgid ""
"Applies the given function to each element in the enumerable,\n"
"storing the result in a list and passing it as the accumulator\n"
"for the next computation. Uses the given `acc` as the starting value.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.scan(1..5, 0, &(&1 + &2))\n"
"    [1, 3, 6, 10, 15]\n"
"\n"
msgstr ""
"指定した関数を、enumerableのそれぞれの要素に適用し、\n"
"リストに結果を保存し、次の計算のためのアキュムレータとして\n"
"渡します。指定した`acc`は、初期値として使います。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.scan(1..5, 0, &(&1 + &2))\n"
"    [1, 3, 6, 10, 15]\n"
"\n"

#. TRANSLATORS: def Enum.scan(enumerable, fun)
#: lib/enum.ex:1905
msgid ""
"Applies the given function to each element in the enumerable,\n"
"storing the result in a list and passing it as the accumulator\n"
"for the next computation.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.scan(1..5, &(&1 + &2))\n"
"    [1, 3, 6, 10, 15]\n"
"\n"
msgstr ""
"指定した関数を、enumerableのそれぞれの要素に適用し、\n"
"リストに結果を保存し、次の計算のためのアキュムレータとして\n"
"渡します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.scan(1..5, &(&1 + &2))\n"
"    [1, 3, 6, 10, 15]\n"
"\n"

#. TRANSLATORS: def Enum.uniq_by(enumerable, fun)
#: lib/enum.ex:2551
msgid ""
"Enumerates the `enumerable`, by removing the elements for which\n"
"function `fun` returned duplicate items.\n"
"\n"
"The function `fun` maps every element to a term which is used to\n"
"determine if two elements are duplicates.\n"
"\n"
"The first occurrence of each element is kept.\n"
"\n"
"## Example\n"
"\n"
"    iex> Enum.uniq_by([{1, :x}, {2, :y}, {1, :z}], fn {x, _} -> x end)\n"
"    [{1, :x}, {2, :y}]\n"
"\n"
"    iex> Enum.uniq_by([a: {:tea, 2}, b: {:tea, 2}, c: {:coffee, 1}], fn {_, "
"y} -> y end)\n"
"    [a: {:tea, 2}, c: {:coffee, 1}]\n"
"\n"
msgstr ""
"関数`fun`が重複したアイテムを返した要素を削除しながら、\n"
"`enumerable`を列挙します。\n"
"\n"
"関数`fun`はすべての要素を処理して、2つの要素が重複しているか\n"
"否かを決めるために使用される項に変換します。\n"
"\n"
"各要素の最初に現れた項は保持されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.uniq_by([{1, :x}, {2, :y}, {1, :z}], fn {x, _} -> x end)\n"
"    [{1, :x}, {2, :y}]\n"
"\n"
"    iex> Enum.uniq_by([a: {:tea, 2}, b: {:tea, 2}, c: {:coffee, 1}],  fn {_, "
"y} -> y end)\n"
"    [a: {:tea, 2}, c: {:coffee, 1}]\n"
"\n"

#. TRANSLATORS: def Enum.take_random(enumerable, count)
#: lib/enum.ex:2414
msgid ""
"Takes `count` random items from `enumerable`.\n"
"\n"
"Notice this function will traverse the whole `enumerable` to\n"
"get the random sublist.\n"
"\n"
"See `random/1` for notes on implementation and random seed.\n"
"\n"
"## Examples\n"
"\n"
"    # Although not necessary, let's seed the random algorithm\n"
"    iex> :rand.seed(:exsplus, {1, 2, 3})\n"
"    iex> Enum.take_random(1..10, 2)\n"
"    [5, 4]\n"
"    iex> Enum.take_random(?a..?z, 5)\n"
"    'ipybz'\n"
"\n"
msgstr ""
"`enumerable`から`count`個の項目をランダムに返します。\n"
"\n"
"ランダムなサブリストを取得するために、この関数は\n"
"`enumerable`全体を走査することに注意してください。\n"
"\n"
"実装とランダムシードに関しては`random/1`を参照してください。\n"
"\n"
"## 例\n"
"\n"
"    # 必須ではないが、ランダムアルゴリズムのシードを与える\n"
"    iex> :rand.seed(:exsplus, {1, 2, 3})\n"
"    iex> Enum.take_random(1..10, 2)\n"
"    [5, 4]\n"
"    iex> Enum.take_random(?a..?z, 5)\n"
"    'ipybz'\n"
"\n"

#. TRANSLATORS: def Enum.find_index(enumerable, fun)
#: lib/enum.ex:873
msgid ""
"Similar to `find/3`, but returns the index (zero-based)\n"
"of the element instead of the element itself.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.find_index([2, 4, 6], fn(x) -> rem(x, 2) == 1 end)\n"
"    nil\n"
"\n"
"    iex> Enum.find_index([2, 3, 4], fn(x) -> rem(x, 2) == 1 end)\n"
"    1\n"
"\n"
msgstr ""
"`find/3`と似ていますが、要素自身の替わりに要素のインデックス(ゼロ始ま\n"
"り)を返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.find_index([2, 4, 6], fn(x) -> rem(x, 2) == 1 end)\n"
"    nil\n"
"\n"
"    iex> Enum.find_index([2, 3, 4], fn(x) -> rem(x, 2) == 1 end)\n"
"    1\n"
"\n"

#. TRANSLATORS: def Enum.take(enumerable, count)
#: lib/enum.ex:2307
msgid ""
"Takes the first `count` items from the enumerable.\n"
"\n"
"`count` must be an integer. If a negative `count` is given, the last\n"
"`count` values will be taken.\n"
"For such, the enumerable is fully enumerated keeping up\n"
"to `2 * count` elements in memory. Once the end of the enumerable is\n"
"reached, the last `count` elements are returned.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.take([1, 2, 3], 2)\n"
"    [1, 2]\n"
"\n"
"    iex> Enum.take([1, 2, 3], 10)\n"
"    [1, 2, 3]\n"
"\n"
"    iex> Enum.take([1, 2, 3], 0)\n"
"    []\n"
"\n"
"    iex> Enum.take([1, 2, 3], -1)\n"
"    [3]\n"
"\n"
msgstr ""
"enumerableの最初の`count`個の項目を取り出します。\n"
"\n"
"`count`は整数でなくてはなりません。負の`count`が指定された場合は、\n"
"最後の`count`個が取り出されます。そのため、enumerableはメモリ内に\n"
"最大`2 * count`個の要素を保持して完全に列挙されます。enumerableの\n"
"終わりに到達すると、最後の`count`個の要素が返されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.take([1, 2, 3], 2)\n"
"    [1, 2]\n"
"\n"
"    iex> Enum.take([1, 2, 3], 10)\n"
"    [1, 2, 3]\n"
"\n"
"    iex> Enum.take([1, 2, 3], 0)\n"
"    []\n"
"\n"
"    iex> Enum.take([1, 2, 3], -1)\n"
"    [3]\n"
"\n"

#. TRANSLATORS: def Enum.reduce(enumerable, acc, fun)
#: lib/enum.ex:1740
msgid ""
"Invokes `fun` for each element in the `enumerable`, passing that\n"
"element and the accumulator `acc` as arguments. `fun`'s return value\n"
"is stored in `acc`.\n"
"\n"
"Returns the accumulator.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.reduce([1, 2, 3], 0, fn(x, acc) -> x + acc end)\n"
"    6\n"
"\n"
msgstr ""
"`enumerable`のそれぞれの要素について、その要素とアキュムレータを引数とし\n"
"て、`fun`を起動します。`fun`の戻り値は、`acc`に保存されます。\n"
"\n"
"アキュムレータを返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.reduce([1, 2, 3], 0, fn(x, acc) -> x + acc end)\n"
"    6\n"
"\n"

#. TRANSLATORS: def Enum.max_by(enumerable, fun, empty_fallback \\ fn -> raise(Enum.EmptyError) end)
#: lib/enum.ex:1363
msgid ""
"Returns the maximal element in the enumerable as calculated\n"
"by the given function.\n"
"\n"
"If multiple elements are considered maximal, the first one that was found\n"
"is returned.\n"
"\n"
"Calls the provided `empty_fallback` function and returns its value if\n"
"`enumerable` is empty. The default `empty_fallback` raises `Enum."
"EmptyError`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.max_by([\"a\", \"aa\", \"aaa\"], fn(x) -> String.length(x) "
"end)\n"
"    \"aaa\"\n"
"\n"
"    iex> Enum.max_by([\"a\", \"aa\", \"aaa\", \"b\", \"bbb\"], &String."
"length/1)\n"
"    \"aaa\"\n"
"\n"
"    iex> Enum.max_by([], &String.length/1, fn -> nil end)\n"
"    nil\n"
"\n"
msgstr ""
"enumerableの各要素を指定した関数で計算した値が最大となる要素を返します。\n"
"\n"
"複数の要素が最大となった場合は、最初に見つかった要素を返します。\n"
"\n"
"`enumerabel`が空の場合、指定した関数`empty_fallback`を実行して、\n"
"その値を返します。デフォルトの`empty_fallback`は`Enum.EmptyError`を\n"
"発生させます。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.max_by([\"a\", \"aa\", \"aaa\"], fn(x) -> String.length(x) "
"end)\n"
"    \"aaa\"\n"
"\n"
"    iex> Enum.max_by([\"a\", \"aa\", \"aaa\", \"b\", \"bbb\"], &String."
"length/1)\n"
"    \"aaa\"\n"
"\n"
"    iex> Enum.max_by([], &String.length/1, fn -> nil end)\n"
"    nil\n"
"\n"

#. TRANSLATORS: def Enum.intersperse(enumerable, element)
#: lib/enum.ex:1053
msgid ""
"Intersperses `element` between each element of the enumeration.\n"
"\n"
"Complexity: O(n).\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.intersperse([1, 2, 3], 0)\n"
"    [1, 0, 2, 0, 3]\n"
"\n"
"    iex> Enum.intersperse([1], 0)\n"
"    [1]\n"
"\n"
"    iex> Enum.intersperse([], 0)\n"
"    []\n"
"\n"
msgstr ""
"enumerableの各要素の間に`element`をはさみます。\n"
"\n"
"計算量は:O(n)です。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.intersperse([1, 2, 3], 0)\n"
"    [1, 0, 2, 0, 3]\n"
"\n"
"    iex> Enum.intersperse([1], 0)\n"
"    [1]\n"
"\n"
"    iex> Enum.intersperse([], 0)\n"
"    []\n"
"\n"

#. TRANSLATORS: def Enum.all?(enumerable, fun \\ fn x -> x end)
#: lib/enum.ex:207
msgid ""
"Returns true if the given `fun` evaluates to true on all of the items in the "
"enumerable.\n"
"\n"
"It stops the iteration at the first invocation that returns `false` or "
"`nil`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.all?([2, 4, 6], fn(x) -> rem(x, 2) == 0 end)\n"
"    true\n"
"\n"
"    iex> Enum.all?([2, 3, 4], fn(x) -> rem(x, 2) == 0 end)\n"
"    false\n"
"\n"
"If no function is given, it defaults to checking if\n"
"all items in the enumerable are truthy values.\n"
"\n"
"    iex> Enum.all?([1, 2, 3])\n"
"    true\n"
"\n"
"    iex> Enum.all?([1, nil, 3])\n"
"    false\n"
"\n"
msgstr ""
"Enumerableのすべての項目に対して指定した関数`fun`が真の評価を\n"
"した場合、`true`を返します。\n"
"\n"
"`false`または`nil`を返す最初の呼び出しで繰り返しを停止します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.all?([2, 4, 6], fn(x) -> rem(x, 2) == 0 end)\n"
"    true\n"
"\n"
"    iex> Enum.all?([2, 3, 4], fn(x) -> rem(x, 2) == 0 end)\n"
"    false\n"
"\n"
"関数が指定されない場合、デフォルトでEnumerableのすべての項目が\n"
"truthy値であるかチェックします。\n"
"\n"
"    iex> Enum.all?([1, 2, 3])\n"
"    true\n"
"\n"
"    iex> Enum.all?([1, nil, 3])\n"
"    false\n"
"\n"

#. TRANSLATORS: def Enum.unzip(enumerable)
#: lib/enum.ex:2580
msgid ""
"Opposite of `Enum.zip/2`; extracts a two-element tuples from the\n"
"enumerable and groups them together.\n"
"\n"
"It takes an enumerable with items being two-element tuples and returns\n"
"a tuple with two lists, each of which is formed by the first and\n"
"second element of each tuple, respectively.\n"
"\n"
"This function fails unless `enumerable` is or can be converted into a\n"
"list of tuples with *exactly* two elements in each tuple.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.unzip([{:a, 1}, {:b, 2}, {:c, 3}])\n"
"    {[:a, :b, :c], [1, 2, 3]}\n"
"\n"
"    iex> Enum.unzip(%{a: 1, b: 2})\n"
"    {[:a, :b], [1, 2]}\n"
"\n"
msgstr ""
"`Enum.zip/2`とは反対に、enumerableから2要素タプルを抽出して、\n"
"グループ化します。\n"
"\n"
"この関数は2要素タプルである項目を持つenumerableを引数にとり、\n"
"2つのリストからなるタプルを返します。第1リストは各タプルの\n"
"第1要素から、第2リストは各タプルの第2要素から各々作成されます。\n"
"\n"
"`enumerable`が各タプルが *完全に*2要素のタプルのリストであるか、\n"
"それに変換できない限り、この関数は失敗します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.unzip([{:a, 1}, {:b, 2}, {:c, 3}])\n"
"    {[:a, :b, :c], [1, 2, 3]}\n"
"\n"
"    iex> Enum.unzip(%{a: 1, b: 2})\n"
"    {[:a, :b], [1, 2]}\n"
"\n"

#. TRANSLATORS: def Enum.concat(enumerables)
#: lib/enum.ex:404
msgid ""
"Given an enumerable of enumerables, concatenates the enumerables into\n"
"a single list.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.concat([1..3, 4..6, 7..9])\n"
"    [1, 2, 3, 4, 5, 6, 7, 8, 9]\n"
"\n"
"    iex> Enum.concat([[1, [2], 3], [4], [5, 6]])\n"
"    [1, [2], 3, 4, 5, 6]\n"
"\n"
msgstr ""
"EnumerableのEnumerableが指定された場合、それらのEnumerableを\n"
"一つのリストに連結します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.concat([1..3, 4..6, 7..9])\n"
"    [1, 2, 3, 4, 5, 6, 7, 8, 9]\n"
"\n"
"    iex> Enum.concat([[1, [2], 3], [4], [5, 6]])\n"
"    [1, [2], 3, 4, 5, 6]\n"
"\n"

#. TRANSLATORS: @type result
#: lib/enum.ex:65
msgid ""
"The result of the reduce operation.\n"
"\n"
"It may be *done* when the enumeration is finished by reaching\n"
"its end, or *halted*/*suspended* when the enumeration was halted\n"
"or suspended by the `t:reducer/0` function.\n"
"\n"
"In case a `t:reducer/0` function returns the `:suspend` accumulator, the\n"
"`:suspended` tuple must be explicitly handled by the caller and\n"
"never leak. In practice, this means regular enumeration functions\n"
"just need to be concerned about `:done` and `:halted` results.\n"
"\n"
"Furthermore, a `:suspend` call must always be followed by another call,\n"
"eventually halting or continuing until the end.\n"
msgstr ""
"reduceオペレーションの結果です。\n"
"\n"
"終りに到達することで数え上げ(enumeration)が終了したときに\n"
"*done* になり、`t:reducer/0`関数により数え上げ(enumeration)が中止\n"
"(halted)や中断(suspend)された時に *halted*/*suspended* になり\n"
"ます。\n"
"\n"
"`t:reducer/0`関数が`:suspend`アキュムレータを返した場合、呼出し側に\n"
"より、`:suspended`タプルは漏れ無く明示的にハンドルされなけれ\n"
"ばなりません。実際には、これは標準の数え上げ(enumeration)関数\n"
"は`:done`と`:halted`についてだけ心配する必要があることを意味\n"
"します。\n"
"\n"
"さらに、`:suspend`呼出しは、常にもう一つの呼出しがつづき、結\n"
"局中止(halting)するか、終りまで続け(continuing)ます。\n"

#. TRANSLATORS: def Enum.take_while(enumerable, fun)
#: lib/enum.ex:2485
msgid ""
"Takes the items from the beginning of the enumerable while `fun` returns\n"
"a truthy value.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.take_while([1, 2, 3], fn(x) -> x < 3 end)\n"
"    [1, 2]\n"
"\n"
msgstr ""
"`fun`がtruthy値を返す間、enumerableの先頭から項目を取り出します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.take_while([1, 2, 3], fn(x) -> x < 3 end)\n"
"    [1, 2]\n"
"\n"

#. TRANSLATORS: def Enumerable.count(enumerable)
#: lib/enum.ex:133
msgid ""
"Retrieves the enumerable's size.\n"
"\n"
"It should return `{:ok, size}`.\n"
"\n"
"If `{:error, __MODULE__}` is returned a default algorithm using\n"
"`reduce` and the match (`===`) operator is used. This algorithm runs\n"
"in linear time.\n"
"\n"
"_Please force use of the default algorithm unless you can implement an\n"
"algorithm that is significantly faster._\n"
msgstr ""
"enumerableのサイズを取り出します。\n"
"\n"
"通常は`{:ok, size}`を返すべきです。\n"
"\n"
"もし`{:error, __MODULE__}`を返したら、デフォルトアルゴリズムの\n"
"`reduce`とマッチ(`===`)オペレータが使われます。このアルゴリズムは実行に\n"
"線形時間がかかります。\n"
"\n"
"_あなたがより速いアルゴリズムを実装することができない限り、デフォルトの\n"
"アルゴリズムの使用を強制してください。_\n"

#. TRANSLATORS: def Enum.into(enumerable, collectable, transform)
#: lib/enum.ex:1139
msgid ""
"Inserts the given `enumerable` into a `collectable` according to the\n"
"transformation function.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.into([2, 3], [3], fn x -> x * 3 end)\n"
"    [3, 6, 9]\n"
"\n"
msgstr ""
"変換関数に従って、指定した`enumerable`を`collectable`に挿入します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.into([2, 3], [3], fn x -> x * 3 end)\n"
"    [3, 6, 9]\n"
"\n"

#. TRANSLATORS: def Enum.slice(enumerable, start, amount)
#: lib/enum.ex:2017
msgid ""
"Returns a subset list of the given enumerable, from `start` position with "
"`amount` of elements if available.\n"
"\n"
"Given `enumerable`, it drops elements until element position `start`,\n"
"then takes `amount` of elements until the end of the enumerable.\n"
"\n"
"If `start` is out of bounds, it returns `[]`.\n"
"\n"
"If `amount` is greater than `enumerable` length, it returns as many elements "
"as possible.\n"
"If `amount` is zero, then `[]` is returned.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.slice(1..100, 5, 10)\n"
"    [6, 7, 8, 9, 10, 11, 12, 13, 14, 15]\n"
"\n"
"    # amount to take is greater than the number of elements\n"
"    iex> Enum.slice(1..10, 5, 100)\n"
"    [6, 7, 8, 9, 10]\n"
"\n"
"    iex> Enum.slice(1..10, 5, 0)\n"
"    []\n"
"\n"
"    # out of bound start position\n"
"    iex> Enum.slice(1..10, 10, 5)\n"
"    []\n"
"\n"
"    # out of bound start position (negative)\n"
"    iex> Enum.slice(1..10, -11, 5)\n"
"    []\n"
"\n"
msgstr ""
"指定したenumerableの、（もしあれば）`start`位置から`amount`個の\n"
"要素からなるサブセットのリストを返します。\n"
"\n"
"`enumerable`の要素位置`range.first`までの要素が削除され、enumerableが\n"
"終わるまで`amount`個の要素を取得します。\n"
"\n"
"`amount`が`enumerable`の長さより大きい場合は、できるだけ多くの要素を\n"
"返します。`amount`が0の場合は`[]`が返されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.slice(1..100, 5, 10)\n"
"    [6, 7, 8, 9, 10, 11, 12, 13, 14, 15]\n"
"\n"
"    # 取得する数が要素数より多い\n"
"    iex> Enum.slice(1..10, 5, 100)\n"
"    [6, 7, 8, 9, 10]\n"
"\n"
"    iex> Enum.slice(1..10, 5, 0)\n"
"    []\n"
"\n"
"    # 開始位置が範囲外\n"
"    iex> Enum.slice(1..10, 10, 5)\n"
"    []\n"
"\n"
"    # 開始位置が範囲外（負の位置）\n"
"    iex> Enum.slice(1..10, -11, 5)\n"
"    []\n"
"\n"

#. TRANSLATORS: def Enum.count(enumerable)
#: lib/enum.ex:452
msgid ""
"Returns the size of the enumerable.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.count([1, 2, 3])\n"
"    3\n"
"\n"
msgstr ""
"enumerableのサイズを返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.count([1, 2, 3])\n"
"    3\n"
"\n"

#. TRANSLATORS: def Enum.sort(enumerable)
#: lib/enum.ex:2099
msgid ""
"Sorts the enumerable according to Erlang's term ordering.\n"
"\n"
"Uses the merge sort algorithm.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.sort([3, 2, 1])\n"
"    [1, 2, 3]\n"
"\n"
msgstr ""
"Erlangの項順でenumerableをソートします。\n"
"\n"
"マージソートアルゴリズムを使います。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.sort([3, 2, 1])\n"
"    [1, 2, 3]\n"
"\n"

#. TRANSLATORS: def Enum.with_index(enumerable, offset \\ 0)
#: lib/enum.ex:2610
msgid ""
"Returns the enumerable with each element wrapped in a tuple\n"
"alongside its index.\n"
"\n"
"If an `offset` is given, we will index from the given offset instead of from "
"zero.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.with_index([:a, :b, :c])\n"
"    [a: 0, b: 1, c: 2]\n"
"\n"
"    iex> Enum.with_index([:a, :b, :c], 3)\n"
"    [a: 3, b: 4, c: 5]\n"
"\n"
msgstr ""
"各要素をそのインデックスと共にタプルで包んだenumerableを返します。\n"
"\n"
"`offset`が指定された場合は、インデックスを0ではなく指定の`offset`から\n"
"始めます。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.with_index([:a, :b, :c])\n"
"    [a: 0, b: 1, c: 2]\n"
"\n"
"    iex> Enum.with_index([:a, :b, :c], 3)\n"
"    [a: 3, b: 4, c: 5]\n"
"\n"

#. TRANSLATORS: def Enum.reverse_slice(enumerable, start, count)
#: lib/enum.ex:1878
msgid ""
"Reverses the enumerable in the range from initial position `start`\n"
"through `count` elements.\n"
"\n"
"If `count` is greater than the size of the rest of the enumerable,\n"
"then this function will reverse the rest of the enumerable.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.reverse_slice([1, 2, 3, 4, 5, 6], 2, 4)\n"
"    [1, 2, 6, 5, 4, 3]\n"
"\n"
msgstr ""
"初期位置が`first`からの`count`要素の範囲(range)のenumerableを\n"
"逆転させます。\n"
"\n"
"もし`count`がenumerableの残りの大きさより大きい場合、\n"
"この関数はenumerableの残り全部を逆転させます。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.reverse_slice([1, 2, 3, 4, 5, 6], 2, 4)\n"
"    [1, 2, 6, 5, 4, 3]\n"
"\n"

#. TRANSLATORS: def Enum.filter_map(enumerable, filter, mapper)
#: lib/enum.ex:821
msgid ""
"Filters the enumerable and maps its elements in one pass.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.filter_map([1, 2, 3], fn(x) -> rem(x, 2) == 0 end, &(&1 * 2))\n"
"    [4]\n"
"\n"
msgstr ""
"一回の操作で、enumerableにフィルタをかけ、マップします。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.filter_map([1, 2, 3], fn(x) -> rem(x, 2) == 0 end, &(&1 * 2))\n"
"    [4]\n"
"\n"

#. TRANSLATORS: def Enum.reject(enumerable, fun)
#: lib/enum.ex:1819
#, fuzzy
msgid ""
"Returns elements of `enumerable` for which the function `fun` returns\n"
"`false` or `nil`.\n"
"\n"
"See also `filter/2`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.reject([1, 2, 3], fn(x) -> rem(x, 2) == 0 end)\n"
"    [1, 3]\n"
"\n"
msgstr ""
"`fun`が`false`または`nil`となる`enumerable`の要素を返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.reject([1, 2, 3], fn(x) -> rem(x, 2) == 0 end)\n"
"    [1, 3]\n"
"\n"

#. TRANSLATORS: @type acc
#: lib/enum.ex:37
msgid ""
"The accumulator value for each step.\n"
"\n"
"It must be a tagged tuple with one of the following \"tags\":\n"
"\n"
"  * `:cont`    - the enumeration should continue\n"
"  * `:halt`    - the enumeration should halt immediately\n"
"  * `:suspend` - the enumeration should be suspended immediately\n"
"\n"
"Depending on the accumulator value, the result returned by\n"
"`Enumerable.reduce/3` will change. Please check the `t:result/0`\n"
"type documentation for more information.\n"
"\n"
"In case a `t:reducer/0` function returns a `:suspend` accumulator,\n"
"it must be explicitly handled by the caller and never leak.\n"
msgstr ""
"それぞれのステップのアキュムレータの値。\n"
"\n"
"以下の\"タグ\"の何れかにタグ付けられたタプルでなければなりません:\n"
"\n"
"  * `:cont`    - 数え上げ(enumeration)を続けなければならない\n"
"  * `:halt`    - 数え上げ(enumeration)は直ちに中止されなければならない\n"
"  * `:suspend` - 数え上げ(enumeration)は直ちに中断されなければならない\n"
"\n"
"アキュムレータ値に依存して`Enumerable.reduce/3`の戻値は変わり\n"
"ます。詳細は `t:result/0` type ドキュメントをチェックしてください。\n"
"\n"
"`t:reducer/0`関数が`:suspend`アキュムレータを返す場合、呼出し側で明\n"
"示的にハンドルされなければならず、決して漏れてはなりません。\n"

#. TRANSLATORS: def Enum.flat_map(enumerable, fun)
#: lib/enum.ex:933
msgid ""
"Returns a new enumerable appending the result of invoking `fun` on\n"
"each corresponding item of `enumerable`.\n"
"\n"
"The given function must return an enumerable.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.flat_map([:a, :b, :c], fn(x) -> [x, x] end)\n"
"    [:a, :a, :b, :b, :c, :c]\n"
"\n"
"    iex> Enum.flat_map([{1, 3}, {4, 6}], fn({x, y}) -> x..y end)\n"
"    [1, 2, 3, 4, 5, 6]\n"
"\n"
"    iex> Enum.flat_map([:a, :b, :c], fn(x) -> [[x]] end)\n"
"    [[:a], [:b], [:c]]\n"
"\n"
msgstr ""
"`enumerable`の対応する各項目に対して`fun`を実行した結果を\n"
"追加した、新しいenumerableを返します。\n"
"\n"
"指定した関数はenumerableを返さなければなりません。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.flat_map([:a, :b, :c], fn(x) -> [x, x] end)\n"
"    [:a, :a, :b, :b, :c, :c]\n"
"\n"
"    iex> Enum.flat_map([{1, 3}, {4, 6}], fn({x, y}) -> x..y end)\n"
"    [1, 2, 3, 4, 5, 6]\n"
"\n"

#. TRANSLATORS: def Enum.empty?(enumerable)
#: lib/enum.ex:657
msgid ""
"Determines if the enumerable is empty.\n"
"\n"
"Returns `true` if `enumerable` is empty, otherwise `false`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.empty?([])\n"
"    true\n"
"\n"
"    iex> Enum.empty?([1, 2, 3])\n"
"    false\n"
"\n"
msgstr ""
"enumerableが空か否かを決定します。\n"
"\n"
"`enumerable`が空の場合は`true`を、それ以外は`false`を返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.empty?([])\n"
"    true\n"
"\n"
"    iex> Enum.empty?([1, 2, 3])\n"
"    false\n"
"\n"

#. TRANSLATORS: def Enum.min_max_by(enumerable, fun, empty_fallback \\ fn -> raise(Enum.EmptyError) end)
#: lib/enum.ex:1519
#, fuzzy
msgid ""
"Returns a tuple with the minimal and the maximal elements in the\n"
"enumerable as calculated by the given function.\n"
"\n"
"If multiple elements are considered maximal or minimal, the first one\n"
"that was found is returned.\n"
"\n"
"Calls the provided `empty_fallback` function and returns its value if\n"
"`enumerable` is empty. The default `empty_fallback` raises `Enum."
"EmptyError`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.min_max_by([\"aaa\", \"bb\", \"c\"], fn(x) -> String.length(x) "
"end)\n"
"    {\"c\", \"aaa\"}\n"
"\n"
"    iex> Enum.min_max_by([\"aaa\", \"a\", \"bb\", \"c\", \"ccc\"], &String."
"length/1)\n"
"    {\"a\", \"aaa\"}\n"
"\n"
"    iex> Enum.min_max_by([], &String.lenth/1, fn -> {nil, nil} end)\n"
"    {nil, nil}\n"
"\n"
msgstr ""
"enumerableについて、指定した関数により計算した値が\n"
"最小と最大となる要素のタプルを返します。\n"
"\n"
"同じ値が複数の場合、最初に見付かったものが使われます。\n"
"\n"
"もし`enumerable`が空なら、`EmptyError`を上げます。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.min_max_by([\"aaa\", \"bb\", \"c\"], fn(x) -> String.length(x) "
"end)\n"
"    {\"c\", \"aaa\"}\n"
"\n"

#. TRANSLATORS: def Enum.sum(enumerable)
#: lib/enum.ex:2279
msgid ""
"Returns the sum of all elements.\n"
"\n"
"Raises `ArithmeticError` if `enumerable` contains a non-numeric value.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.sum([1, 2, 3])\n"
"    6\n"
"\n"
msgstr ""
"すべての要素の合計を返します。\n"
"\n"
"`enumerable`が非数値を含んでいる場合は`ArithmeticError`を発生させます。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.sum([1, 2, 3])\n"
"    6\n"
"\n"

#. TRANSLATORS: def Enum.split(enumerable, count)
#: lib/enum.ex:2200
msgid ""
"Splits the `enumerable` into two enumerables, leaving `count`\n"
"elements in the first one.\n"
"\n"
"If `count` is a negative number, it starts counting from the\n"
"back to the beginning of the enumerable.\n"
"\n"
"Be aware that a negative `count` implies the `enumerable`\n"
"will be enumerated twice: once to calculate the position, and\n"
"a second time to do the actual splitting.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.split([1, 2, 3], 2)\n"
"    {[1, 2], [3]}\n"
"\n"
"    iex> Enum.split([1, 2, 3], 10)\n"
"    {[1, 2, 3], []}\n"
"\n"
"    iex> Enum.split([1, 2, 3], 0)\n"
"    {[], [1, 2, 3]}\n"
"\n"
"    iex> Enum.split([1, 2, 3], -1)\n"
"    {[1, 2], [3]}\n"
"\n"
"    iex> Enum.split([1, 2, 3], -5)\n"
"    {[], [1, 2, 3]}\n"
"\n"
msgstr ""
"`enumerable`を2つのenumerableに分割し、最初のenumerableに\n"
"`count`個の要素を入れます。\n"
"\n"
"`count`が負の数の場合は、enumerableの最後から最初に向って\n"
"数えます。\n"
"\n"
"負の`count`は`enumerable`が2回列挙されることを意味する\n"
"ことに注意してください: 1回目は位置を計算するため、2回目は\n"
"実際の分割をするためです。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.split([1, 2, 3], 2)\n"
"    {[1, 2], [3]}\n"
"\n"
"    iex> Enum.split([1, 2, 3], 10)\n"
"    {[1, 2, 3], []}\n"
"\n"
"    iex> Enum.split([1, 2, 3], 0)\n"
"    {[], [1, 2, 3]}\n"
"\n"
"    iex> Enum.split([1, 2, 3], -1)\n"
"    {[1, 2], [3]}\n"
"\n"
"    iex> Enum.split([1, 2, 3], -5)\n"
"    {[], [1, 2, 3]}\n"
"\n"

#. TRANSLATORS: def Enum.map(enumerable, fun)
#: lib/enum.ex:1210
msgid ""
"Returns a list where each item is the result of invoking\n"
"`fun` on each corresponding item of `enumerable`.\n"
"\n"
"For maps, the function expects a key-value tuple.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.map([1, 2, 3], fn(x) -> x * 2 end)\n"
"    [2, 4, 6]\n"
"\n"
"    iex> Enum.map([a: 1, b: 2], fn({k, v}) -> {k, -v} end)\n"
"    [a: -1, b: -2]\n"
"\n"
msgstr ""
"各アイテムが`enumerable`の対応する各項目に対して`fun`を実行した結果で\n"
"あるリストを返します。\n"
"\n"
"マップ場合、関数はKey-valueタプルを引数とします。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.map([1, 2, 3], fn(x) -> x * 2 end)\n"
"    [2, 4, 6]\n"
"\n"
"    iex> Enum.map([a: 1, b: 2], fn({k, v}) -> {k, -v} end)\n"
"    [a: -1, b: -2]\n"
"\n"

#. TRANSLATORS: def Enum.uniq(enumerable)
#: lib/enum.ex:2531
msgid ""
"Enumerates the `enumerable`, removing all duplicated elements.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.uniq([1, 2, 3, 3, 2, 1])\n"
"    [1, 2, 3]\n"
"\n"
msgstr ""
"重複するすべての要素を削除しながら`enumerable`を列挙します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.uniq([1, 2, 3, 2, 1])\n"
"    [1, 2, 3]\n"
"\n"

#. TRANSLATORS: def Enum.slice(enumerable, range)
#: lib/enum.ex:1964
msgid ""
"Returns a subset list of the given enumerable, from `range.first` to `range."
"last` positions.\n"
"\n"
"Given `enumerable`, it drops elements until element position `range.first`,\n"
"then takes elements until element position `range.last` (inclusive).\n"
"\n"
"Positions are normalized, meaning that negative positions will be counted "
"from the end\n"
"(e.g. `-1` means the last element of the enumerable).\n"
"If `range.last` is out of bounds, then it is assigned as the position of the "
"last element.\n"
"\n"
"If the normalized `range.first` position is out of bounds of the given "
"enumerable,\n"
"or this one is greater than the normalized `range.last` position, then `[]` "
"is returned.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.slice(1..100, 5..10)\n"
"    [6, 7, 8, 9, 10, 11]\n"
"\n"
"    iex> Enum.slice(1..10, 5..20)\n"
"    [6, 7, 8, 9, 10]\n"
"\n"
"    # last five elements (negative positions)\n"
"    iex> Enum.slice(1..30, -5..-1)\n"
"    [26, 27, 28, 29, 30]\n"
"\n"
"    # last five elements (mixed positive and negative positions)\n"
"    iex> Enum.slice(1..30, 25..-1)\n"
"    [26, 27, 28, 29, 30]\n"
"\n"
"    # out of bounds\n"
"    iex> Enum.slice(1..10, 11..20)\n"
"    []\n"
"\n"
"    # range.first is greater than range.last\n"
"    iex> Enum.slice(1..10, 6..5)\n"
"    []\n"
"\n"
msgstr ""
"指定した`enumerable`の`range.first`から`range.last`の範囲のサブセットの\n"
"リストを返します。\n"
"\n"
"`enumerable`の要素位置`range.first`までの要素が削除され、要素位置\n"
"`range.last`（この位置の要素を含む）までの要素を取得します。\n"
"\n"
"位置は正規化されます。これは負の位置は最後から数えられることを意味します\n"
"（たとえば、-1はenumerableの最後の要素を意味します）。`range.last`が\n"
"範囲外の場合、最後の要素の位置が割り当てられます。\n"
"\n"
"最初の位置(カウントに負の位置を加えた後)は最後の位置と同じか小くなけれ\n"
"ばなりません。\n"
"\n"
"正規化された`range.first`が指定したenumerableの範囲外の場合、または、\n"
"正規化した`range.last`より大きい場合は、`[]`が返ります。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.slice(1..100, 5..10)\n"
"    [6, 7, 8, 9, 10, 11]\n"
"\n"
"    iex> Enum.slice(1..10, 5..20)\n"
"    [6, 7, 8, 9, 10]\n"
"\n"
"    iex> Enum.slice(1..10, 11..20)\n"
"    []\n"
"\n"
"    iex> Enum.slice(1..10, 6..5)\n"
"    []\n"
"\n"

#. TRANSLATORS: def Enum.map_join(enumerable, joiner \\ "", mapper)
#: lib/enum.ex:1269
msgid ""
"Maps and joins the given enumerable in one pass.\n"
"\n"
"`joiner` can be either a binary or a list and the result will be of\n"
"the same type as `joiner`.\n"
"If `joiner` is not passed at all, it defaults to an empty binary.\n"
"\n"
"All items in the enumerable must be convertible to a binary,\n"
"otherwise an error is raised.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.map_join([1, 2, 3], &(&1 * 2))\n"
"    \"246\"\n"
"\n"
"    iex> Enum.map_join([1, 2, 3], \" = \", &(&1 * 2))\n"
"    \"2 = 4 = 6\"\n"
"\n"
msgstr ""
"一回の処理で指定したenumerableをmapしてjoinします。\n"
"\n"
"`joiner`はバイナリまたはリストのいずれかが指定でき、結果は\n"
"`joiner`と同じタイプになります。`joiner`が指定されなかった場合、\n"
"デフォルトの空のバイナリになります。\n"
"\n"
"enumerableのすべての項目はバイナリに変換可能なものでなければ\n"
"なりません。そうでないとエラーが発生します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.map_join([1, 2, 3], &(&1 * 2))\n"
"    \"246\"\n"
"\n"
"    iex> Enum.map_join([1, 2, 3], \" = \", &(&1 * 2))\n"
"    \"2 = 4 = 6\"\n"
"\n"

#. TRANSLATORS: def Enum.sort_by(enumerable, mapper, sorter \\ &<=/2)
#: lib/enum.ex:2154
msgid ""
"Sorts the mapped results of the enumerable according to the provided "
"`sorter`\n"
"function.\n"
"\n"
"This function maps each element of the enumerable using the provided "
"`mapper`\n"
"function.  The enumerable is then sorted by the mapped elements\n"
"using the `sorter` function, which defaults to `Kernel.<=/2`\n"
"\n"
"`sort_by/3` differs from `sort/2` in that it only calculates the\n"
"comparison value for each element in the enumerable once instead of\n"
"once for each element in each comparison.\n"
"If the same function is being called on both element, it's also more\n"
"compact to use `sort_by/3`.\n"
"\n"
"This technique is also known as a\n"
"_[Schwartzian Transform](https://en.wikipedia.org/wiki/"
"Schwartzian_transform)_,\n"
"or the _Lisp decorate-sort-undecorate idiom_ as the `mapper`\n"
"is decorating the original `enumerable`; then `sorter` is sorting the\n"
"decorations; and finally the enumerable is being undecorated so only\n"
"the original elements remain, but now in sorted order.\n"
"\n"
"## Examples\n"
"\n"
"Using the default `sorter` of `<=/2`:\n"
"\n"
"    iex> Enum.sort_by [\"some\", \"kind\", \"of\", \"monster\"], "
"&byte_size/1\n"
"    [\"of\", \"some\", \"kind\", \"monster\"]\n"
"\n"
"Using a custom `sorter` to override the order:\n"
"\n"
"    iex> Enum.sort_by [\"some\", \"kind\", \"of\", \"monster\"], "
"&byte_size/1, &>=/2\n"
"    [\"monster\", \"some\", \"kind\", \"of\"]\n"
"\n"
msgstr ""
"enumerableをmap処理した結果を、指定した`sorter`関数でソートします。\n"
"\n"
"この関数は、まず指定した`mapper`関数でenumerableの各要素をmap処理します。\n"
"そして、map処理された結果が指定した`sorter`関数でソートされます。\n"
"`sorter`関数のデフォルトは`Kernel.<=/2`です。\n"
"\n"
"`sort_by/3`はenumerableの各要素について比較のための値を一度しか計算しない\n"
"点が、比較の度に各要素が一度計算される`sort/2`とは異なります。両方の要素で\n"
"同じ関数が呼ばれる場合、`sort_by/3`を使用する方がコンパクトになります。\n"
"\n"
"この技術は [シュワルツ変換](https://en.wikipedia.org/wiki/"
"Schwartzian_transform)\n"
"または、Lispの_デコレート-ソート-アンデコレート・イディオム_ として知られてい"
"ます。\n"
"なぜなら、`mapper`が元の`enumerable`をデコレートし、次に、`sorter`が\n"
"デコレーションをソートし、最後にenumerableがアンデコレートされることで、\n"
"元のenumerableだけが残りますが、ソート順になっているからです。\n"
"\n"
"## 例\n"
"\n"
"デフォルト `sorter` である `<=/2` を使用します。\n"
"\n"
"    iex> Enum.sort_by [\"some\", \"kind\", \"of\", \"monster\"], "
"&byte_size/1\n"
"    [\"of\", \"some\", \"kind\", \"monster\"]\n"
"\n"
"カスタム`sorter`を使用してソート順を変えます。\n"
"\n"
"    iex> Enum.sort_by [\"some\", \"kind\", \"of\", \"monster\"], "
"&byte_size/1, &>=/2\n"
"    [\"monster\", \"some\", \"kind\", \"of\"]\n"
"\n"

#. TRANSLATORS: def Enumerable.member?(enumerable, element)
#: lib/enum.ex:118
msgid ""
"Checks if an element exists within the enumerable.\n"
"\n"
"It should return `{:ok, boolean}`.\n"
"\n"
"If `{:error, __MODULE__}` is returned a default algorithm using\n"
"`reduce` and the match (`===`) operator is used. This algorithm runs\n"
"in linear time.\n"
"\n"
"_Please force use of the default algorithm unless you can implement an\n"
"algorithm that is significantly faster._\n"
msgstr ""
"要素がenumerableに存在するかチェックします。\n"
"\n"
"`{:ok, boolean}`を返す必要があります。\n"
"\n"
"`{:error, __MODULE__}`が返された場合、`reduce`とマッチオペレータ(`===`)を使用"
"する\n"
"デフォルトアルゴリズムが使われます。このアルゴリズムは線形時間で実行されま"
"す。\n"
"\n"
"_明らかに速いアルゴリズムを実装できない場合は、デフォルトのアルゴリズムの使用"
"してください。_\n"

#. TRANSLATORS: def Enum.flat_map_reduce(enumerable, acc, fun)
#: lib/enum.ex:975
msgid ""
"Maps and reduces an enumerable, flattening the given results (only one level "
"deep).\n"
"\n"
"It expects an accumulator and a function that receives each enumerable\n"
"item, and must return a tuple containing a new enumerable (often a list)\n"
"with the new accumulator or a tuple with `:halt` as first element and\n"
"the accumulator as second.\n"
"\n"
"## Examples\n"
"\n"
"    iex> enum = 1..100\n"
"    iex> n = 3\n"
"    iex> Enum.flat_map_reduce(enum, 0, fn i, acc ->\n"
"    ...>   if acc < n, do: {[i], acc + 1}, else: {:halt, acc}\n"
"    ...> end)\n"
"    {[1, 2, 3], 3}\n"
"\n"
"    iex> Enum.flat_map_reduce(1..5, 0, fn(i, acc) -> {[[i]], acc + i} end)\n"
"    {[[1], [2], [3], [4], [5]], 15}\n"
"\n"
msgstr ""
"enumerableをmapしてreduceし、結果をflattenします（深さは1レベルのみ）。\n"
"\n"
"アキュムレータと関数を引数に取ります。関数は、各列挙項目を受け取り、新たな\n"
"enumerable（通常はリスト）と新たなアキュムレータからなるタプルか、第1要素に\n"
"`:halt`、アキュムレータを第2要素に持つタプルのいずれかを返さなければ\n"
"なりません。\n"
"\n"
"## 例\n"
"\n"
"    iex> enum = 1..100\n"
"    iex> n = 3\n"
"    iex> Enum.flat_map_reduce(enum, 0, fn i, acc ->\n"
"    ...>   if acc < n, do: {[i], acc + 1}, else: {:halt, acc}\n"
"    ...> end)\n"
"    {[1, 2, 3], 3}\n"
"\n"

#. TRANSLATORS: def Enum.fetch!(enumerable, index)
#: lib/enum.ex:771
msgid ""
"Finds the element at the given `index` (zero-based).\n"
"\n"
"Raises `OutOfBoundsError` if the given `index` is outside the range of\n"
"the enumerable.\n"
"\n"
"Note this operation takes linear time. In order to access the element\n"
"at index `index`, it will need to traverse `index` previous elements.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.fetch!([2, 4, 6], 0)\n"
"    2\n"
"\n"
"    iex> Enum.fetch!([2, 4, 6], 2)\n"
"    6\n"
"\n"
"    iex> Enum.fetch!([2, 4, 6], 4)\n"
"    ** (Enum.OutOfBoundsError) out of bounds error\n"
"\n"
msgstr ""
"指定した(0始まりの)`index`の要素を探します。\n"
"\n"
"指定した`index`がEnumerableの範囲外の場合、\n"
"`OutOfBoundsError`を発生させます。\n"
"\n"
"この操作は線形時間を要することに気を付けてください。インデックス`index`の要素"
"へ\n"
"アクセスするためには、それ以前の`index`個の要素を走査する必要があります。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.fetch!([2, 4, 6], 0)\n"
"    2\n"
"\n"
"    iex> Enum.fetch!([2, 4, 6], 2)\n"
"    6\n"
"\n"
"    iex> Enum.fetch!([2, 4, 6], 4)\n"
"    ** (Enum.OutOfBoundsError) out of bounds error\n"
"\n"

#. TRANSLATORS: def Enum.zip(enumerables)
#: lib/enum.ex:2658
msgid ""
"Zips corresponding elements from a collection of enumerables\n"
"into one list of tuples.\n"
"\n"
"The zipping finishes as soon as any enumerable completes.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.zip([[1, 2, 3], [:a, :b, :c], [\"foo\", \"bar\", \"baz\"]])\n"
"    [{1, :a, \"foo\"}, {2, :b, \"bar\"}, {3, :c, \"baz\"}]\n"
"\n"
"    iex> Enum.zip([[1, 2, 3, 4, 5], [:a, :b, :c]])\n"
"    [{1, :a}, {2, :b}, {3, :c}]\n"
"\n"
msgstr ""
"enumerableのコレクションから対応する要素を取り、1つのタプルのリストに\n"
"zipします。\n"
"\n"
"いずれかのenumerableが完了するとzip処理を終了します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.zip([[1, 2, 3], [:a, :b, :c], [\"foo\", \"bar\", \"baz\"]])\n"
"    [{1, :a, \"foo\"}, {2, :b, \"bar\"}, {3, :c, \"baz\"}]\n"
"\n"
"    iex> Enum.zip([[1, 2, 3, 4, 5], [:a, :b, :c]])\n"
"    [{1, :a}, {2, :b}, {3, :c}]\n"
"\n"

#. TRANSLATORS: def Enum.each(enumerable, fun)
#: lib/enum.ex:630
msgid ""
"Invokes the given `fun` for each item in the enumerable.\n"
"\n"
"Returns `:ok`.\n"
"\n"
"## Examples\n"
"\n"
"    Enum.each([\"some\", \"example\"], fn(x) -> IO.puts x end)\n"
"    \"some\"\n"
"    \"example\"\n"
"    #=> :ok\n"
"\n"
msgstr ""
"enumerableの各項目に対して、指定した`fun`を呼び出します。\n"
"\n"
"`:ok`を返します。\n"
"\n"
"## 例\n"
"\n"
"    Enum.each([\"some\", \"example\"], fn(x) -> IO.puts x end)\n"
"    \"some\"\n"
"    \"example\"\n"
"    #=> :ok\n"
"\n"

#. TRANSLATORS: def Enum.split_while(enumerable, fun)
#: lib/enum.ex:2252
msgid ""
"Splits enumerable in two at the position of the element for which\n"
"`fun` returns `false` for the first time.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.split_while([1, 2, 3, 4], fn(x) -> x < 3 end)\n"
"    {[1, 2], [3, 4]}\n"
"\n"
msgstr ""
"`fun`が最初に`false`を返す要素位置でenumerableを\n"
"2つに分割します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.split_while([1, 2, 3, 4], fn(x) -> x < 3 end)\n"
"    {[1, 2], [3, 4]}\n"
"\n"

#. TRANSLATORS: def Enum.zip(enumerable1, enumerable2)
#: lib/enum.ex:2633
msgid ""
"Zips corresponding elements from two enumerables into one list\n"
"of tuples.\n"
"\n"
"The zipping finishes as soon as any enumerable completes.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.zip([1, 2, 3], [:a, :b, :c])\n"
"    [{1, :a}, {2, :b}, {3, :c}]\n"
"\n"
"    iex> Enum.zip([1, 2, 3, 4, 5], [:a, :b, :c])\n"
"    [{1, :a}, {2, :b}, {3, :c}]\n"
"\n"
msgstr ""
"2つのenumerableから対応する要素を取り、1つのタプルのリストにzipします。\n"
"\n"
"どちらかのenumerableが完了するとzip処理は終了します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.zip([1, 2, 3], [:a, :b, :c])\n"
"    [{1, :a}, {2, :b}, {3, :c}]\n"
"\n"
"    iex> Enum.zip([1, 2, 3, 4, 5], [:a, :b, :c])\n"
"    [{1, :a}, {2, :b}, {3, :c}]\n"
"\n"

#. TRANSLATORS: Elixir.Enumerable Summary
#: lib/enum.ex:2
#, fuzzy
msgid ""
"Enumerable protocol used by `Enum` and `Stream` modules.\n"
"\n"
"When you invoke a function in the `Enum` module, the first argument\n"
"is usually a collection that must implement this protocol.\n"
"For example, the expression:\n"
"\n"
"    Enum.map([1, 2, 3], &(&1 * 2))\n"
"\n"
"invokes `Enumerable.reduce/3` to perform the reducing\n"
"operation that builds a mapped list by calling the mapping function\n"
"`&(&1 * 2)` on every element in the collection and consuming the\n"
"element with an accumulated list.\n"
"\n"
"Internally, `Enum.map/2` is implemented as follows:\n"
"\n"
"    def map(enum, fun) do\n"
"      reducer = fn x, acc -> {:cont, [fun.(x) | acc]} end\n"
"      Enumerable.reduce(enum, {:cont, []}, reducer) |> elem(1) |> :lists."
"reverse()\n"
"    end\n"
"\n"
"Notice the user-supplied function is wrapped into a `t:reducer/0` function.\n"
"The `t:reducer/0` function must return a tagged tuple after each step,\n"
"as described in the `t:acc/0` type.\n"
"\n"
"The reason the accumulator requires a tagged tuple is to allow the\n"
"`t:reducer/0` function to communicate the end of enumeration to the "
"underlying\n"
"enumerable, allowing any open resources to be properly closed.\n"
"It also allows suspension of the enumeration, which is useful when\n"
"interleaving between many enumerables is required (as in zip).\n"
"\n"
"Finally, `Enumerable.reduce/3` will return another tagged tuple,\n"
"as represented by the `t:result/0` type.\n"
msgstr ""
"`Enum`と`Stream`モジュールで使われる、Enumerableプロトコルです。\n"
"\n"
"`Enum`モジュールの関数を起動したとき、最初の引数は通常はコレクションで、\n"
"このプロトコルを実装していなければなりません。\n"
"例えば、式\n"
"\n"
"    Enum.map([1, 2, 3], &(&1 * 2))\n"
"\n"
"は、コレクションのそれぞれのアイテムに関数`&(&1 * 2)`を呼び出し、その結\n"
"果を累積リストにコンシングすることにより、マップされたリストを構築する、\n"
"reduceオペレーションを実行するために、下層にある`Enumerable.reduce/3`を\n"
"起動します。\n"
"\n"
"内部的に、`Enum.map/2`は、以下のように実装されています:\n"
"\n"
"    def map(enum, fun) do\n"
"      reducer = fn x, acc -> {:cont, [fun.(x)|acc]} end\n"
"      Enumerable.reduce(enum, {:cont, []}, reducer) |> elem(1) |> :lists."
"reverse()\n"
"    end\n"
"\n"
"ユーザに指定した関数は、`t:reducer/0`関数にラップされていることに、注意し\n"
"てください。`t:reducer/0`関数は、それぞれのステップの後で、`t:acc/0`タイプ"
"で\n"
"記述されるタグづけされたタプルを返さなければなりません。\n"
"\n"
"アキュムレータがタグづけされたタプルを要求する理由は、\n"
"`t:reducer/0`関数に、下層のenumerableと列挙の終わりを知らせ、\n"
"オープンした任意のリソースをクローズさせるることを許すためです。\n"
"列挙の中断も許します。それは、\n"
"多くのenumerable間のインターリーブが必要とされる時(zipの時のような)に\n"
"便利です。\n"
"\n"
"最後に、`Enumerable.reduce/3`は、`t:result/0`タイプにより表現される、\n"
"もう一つのタグづけされたタプルを返します。\n"

#. TRANSLATORS: def Enum.find(enumerable, default \\ nil, fun)
#: lib/enum.ex:844
msgid ""
"Returns the first item for which `fun` returns a truthy value.\n"
"If no such item is found, returns `default`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.find([2, 4, 6], fn(x) -> rem(x, 2) == 1 end)\n"
"    nil\n"
"\n"
"    iex> Enum.find([2, 4, 6], 0, fn(x) -> rem(x, 2) == 1 end)\n"
"    0\n"
"\n"
"    iex> Enum.find([2, 3, 4], fn(x) -> rem(x, 2) == 1 end)\n"
"    3\n"
"\n"
msgstr ""
"`fun`がtruthy値を返す最初の項目を返します。そのような項目が\n"
"見つからなかった場合は`default`を返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.find([2, 4, 6], fn(x) -> rem(x, 2) == 1 end)\n"
"    nil\n"
"\n"
"    iex> Enum.find([2, 4, 6], 0, fn(x) -> rem(x, 2) == 1 end)\n"
"    0\n"
"\n"
"    iex> Enum.find([2, 3, 4], fn(x) -> rem(x, 2) == 1 end)\n"
"    3\n"
"\n"

#. TRANSLATORS: def Enum.reduce_while(enumerable, acc, fun)
#: lib/enum.ex:1796
#, fuzzy
msgid ""
"Reduces the enumerable until `fun` returns `{:halt, term}`.\n"
"\n"
"The return value for `fun` is expected to be\n"
"\n"
"  * `{:cont, acc}` to continue the reduction with `acc` as the new\n"
"    accumulator or\n"
"  * `{:halt, acc}` to halt the reduction and return `acc` as the return\n"
"    value of this function\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.reduce_while(1..100, 0, fn i, acc ->\n"
"    ...>   if i < 3, do: {:cont, acc + i}, else: {:halt, acc}\n"
"    ...> end)\n"
"    3\n"
"\n"
msgstr ""
"`halt`となるまでenumerableをreduce(簡約)します。\n"
"\n"
"`fun`の戻値は、`{:cont, acc}`、あるいは、\n"
"reduce(簡約)を途中で終了するために`{:halt, acc}`が\n"
"期待されています。\n"
"\n"
"アキュムレータを返します。\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.reduce_while(1..100, 0, fn i, acc ->\n"
"    ...>   if i < 3, do: {:cont, acc + i}, else: {:halt, acc}\n"
"    ...> end)\n"
"    3\n"
"\n"

#. TRANSLATORS: def Enum.filter(enumerable, fun)
#: lib/enum.ex:800
msgid ""
"Filters the enumerable, i.e. returns only those elements\n"
"for which `fun` returns a truthy value.\n"
"\n"
"See also `reject/2`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.filter([1, 2, 3], fn(x) -> rem(x, 2) == 0 end)\n"
"    [2]\n"
"\n"
msgstr ""
"enumerableをフィルタにかけます。すなわち、`fun`がtruthy値を返す\n"
"要素のみを返します。\n"
"\n"
"`reject/2`も参照してください。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.filter([1, 2, 3], fn(x) -> rem(x, 2) == 0 end)\n"
"    [2]\n"
"\n"

#. TRANSLATORS: def Enum.chunk_by(enumerable, fun)
#: lib/enum.ex:380
msgid ""
"Splits enumerable on every element for which `fun` returns a new\n"
"value.\n"
"\n"
"Returns a list of lists.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.chunk_by([1, 2, 2, 3, 4, 4, 6, 7, 7], &(rem(&1, 2) == 1))\n"
"    [[1], [2, 2], [3], [4, 4, 6], [7, 7]]\n"
"\n"
msgstr ""
"Enumerableの各要素を`fun`が新しい値を返すごとに分割します。\n"
"\n"
"リストのリストを返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.chunk_by([1, 2, 2, 3, 4, 4, 6, 7, 7], &(rem(&1, 2) == 1))\n"
"    [[1], [2, 2], [3], [4, 4, 6], [7, 7]]\n"
"\n"

#. TRANSLATORS: def Enum.split_with(enumerable, fun)
#: lib/enum.ex:1591
msgid ""
"Splits the `enumerable` in two lists according to the given function `fun`.\n"
"\n"
"Splits the given `enumerable` in two lists by calling `fun` with each "
"element\n"
"in the `enumerable` as its only argument. Returns a tuple with the first "
"list\n"
"containing all the elements in `enumerable` for which applying `fun` "
"returned\n"
"a truthy value, and a second list with all the elements for which applying\n"
"`fun` returned a falsey value (`false` or `nil`).\n"
"\n"
"The elements in both the returned lists are in the same relative order as "
"they\n"
"were in the original enumerable (if such enumerable was ordered, e.g., a\n"
"list); see the examples below.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.split_with([5, 4, 3, 2, 1, 0], fn(x) -> rem(x, 2) == 0 end)\n"
"    {[4, 2, 0], [5, 3, 1]}\n"
"\n"
"    iex> Enum.split_with(%{a: 1, b: -2, c: 1, d: -3}, fn({_k, v}) -> v < 0 "
"end)\n"
"    {[b: -2, d: -3], [a: 1, c: 1]}\n"
"\n"
"    iex> Enum.split_with(%{a: 1, b: -2, c: 1, d: -3}, fn({_k, v}) -> v > 50 "
"end)\n"
"    {[], [a: 1, b: -2, c: 1, d: -3]}\n"
"\n"
"    iex> Enum.split_with(%{}, fn({_k, v}) -> v > 50 end)\n"
"    {[], []}\n"
"\n"
msgstr ""
"指定した関数`fun`で`enumerable`を2つのリストに分割します。\n"
"\n"
"指定した`enumerable`の各要素を唯一の引数として`fun`を呼び出すことにより、\n"
"`enumerable`を2つのリストに分割します。`fun`の適用により\n"
"truthy値を返した`enumerable`のすべての要素を含む第1リストと、`fun`の\n"
"適用によりfalsey値（`false`または`nil`）を返した`enumerable`のすべての\n"
"要素を含む第2リストからなるタプルを返します。\n"
"\n"
"返される両リスト内の要素は（リストのようにEnumerableに順序がある場合）、\n"
"元のEnumerableと相対的に同じ順番に並びます。以下の例を\n"
"参照してください。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.split_with([5, 4, 3, 2, 1, 0], fn(x) -> rem(x, 2) == 0 end)\n"
"    {[4, 2, 0], [5, 3, 1]}\n"
"\n"
"    iex> Enum.split_with(%{a: 1, b: -2, c: 1, d: -3}, fn({_k, v}) -> v < 0 "
"end)\n"
"    {[b: -2, d: -3], [a: 1, c: 1]}\n"
"\n"
"    iex> Enum.split_with(%{a: 1, b: -2, c: 1, d: -3}, fn({_k, v}) -> v > 50 "
"end)\n"
"    {[], [a: 1, b: -2, c: 1, d: -3]}\n"
"\n"
"    iex> Enum.split_with(%{}, fn({_k, v}) -> v > 50 end)\n"
"    {[], []}\n"
"\n"

#. TRANSLATORS: def Enum.drop_while(enumerable, fun)
#: lib/enum.ex:610
msgid ""
"Drops items at the beginning of the enumerable while `fun` returns a\n"
"truthy value.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.drop_while([1, 2, 3, 2, 1], fn(x) -> x < 3 end)\n"
"    [3, 2, 1]\n"
"\n"
msgstr ""
"enumerableの先頭から、`fun`がtruthy値を返す間、項目を削除します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.drop_while([1, 2, 3, 4, 5], fn(x) -> x < 3 end)\n"
"    [3, 4, 5]\n"
"\n"

#. TRANSLATORS: def Enum.find_value(enumerable, default \\ nil, fun)
#: lib/enum.ex:903
msgid ""
"Similar to `find/3`, but returns the value of the function\n"
"invocation instead of the element itself.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.find_value([2, 4, 6], fn(x) -> rem(x, 2) == 1 end)\n"
"    nil\n"
"\n"
"    iex> Enum.find_value([2, 3, 4], fn(x) -> rem(x, 2) == 1 end)\n"
"    true\n"
"\n"
"    iex> Enum.find_value([1, 2, 3], \"no bools!\", &is_boolean/1)\n"
"    \"no bools!\"\n"
"\n"
msgstr ""
"`find/3`と似ていますが、要素ではなく、呼び出した関数の値を返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.find_value([2, 4, 6], fn(x) -> rem(x, 2) == 1 end)\n"
"    nil\n"
"\n"
"    iex> Enum.find_value([2, 3, 4], fn(x) -> rem(x, 2) == 1 end)\n"
"    true\n"
"\n"
"    iex> Enum.find_value([1, 2, 3], \"no bools!\", &is_boolean/1)\n"
"    \"no bools!\"\n"
"\n"

#. TRANSLATORS: @type reducer
#: lib/enum.ex:55
msgid ""
"The reducer function.\n"
"\n"
"Should be called with the enumerable element and the\n"
"accumulator contents.\n"
"\n"
"Returns the accumulator for the next enumeration step.\n"
msgstr ""
"reducer関数\n"
"\n"
"enumerableの要素とアキュムレータコンテンツを伴って呼び出さ\n"
"れなければなりません。\n"
"\n"
"次の数え上げ(enumeration)ステップのためのアキュムレータを返します。\n"

#. TRANSLATORS: @type continuation
#: lib/enum.ex:84
msgid ""
"A partially applied reduce function.\n"
"\n"
"The continuation is the closure returned as a result when\n"
"the enumeration is suspended. When invoked, it expects\n"
"a new accumulator and it returns the result.\n"
"\n"
"A continuation is easily implemented as long as the reduce\n"
"function is defined in a tail recursive fashion. If the function\n"
"is tail recursive, all the state is passed as arguments, so\n"
"the continuation would simply be the reducing function partially\n"
"applied.\n"
msgstr ""
"reduce関数の部分適用です。\n"
"\n"
"continuation(継続)は数え上げ(enumeration)が中断(suspended)\n"
"された時に結果として返されるクロージャです。起動されるとき、\n"
"新しいアキュムレータを期待して、結果を返します。\n"
"\n"
"継続はreduce関数が末尾再帰様式で定義されているかぎり、簡単\n"
"に実装されます。もし関数が末尾再帰なら、全てのステートは引\n"
"数としてパスされ、継続は単に部分的に適用されるreduce関数に\n"
"なるでしょう。\n"

#. TRANSLATORS: def Enum.into(enumerable, collectable)
#: lib/enum.ex:1083
msgid ""
"Inserts the given `enumerable` into a `collectable`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.into([1, 2], [0])\n"
"    [0, 1, 2]\n"
"\n"
"    iex> Enum.into([a: 1, b: 2], %{})\n"
"    %{a: 1, b: 2}\n"
"\n"
"    iex> Enum.into(%{a: 1}, %{b: 2})\n"
"    %{a: 1, b: 2}\n"
"\n"
"    iex> Enum.into([a: 1, a: 2], %{})\n"
"    %{a: 2}\n"
"\n"
msgstr ""
"指定した`enumerable`を`collectable`に挿入します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.into([1, 2], [0])\n"
"    [0, 1, 2]\n"
"\n"
"    iex> Enum.into([a: 1, b: 2], %{})\n"
"    %{a: 1, b: 2}\n"
"\n"
"    iex> Enum.into(%{a: 1}, %{b: 2})\n"
"    %{a: 1, b: 2}\n"
"\n"
"    iex> Enum.into([a: 1, a: 2], %{})\n"
"    %{a: 2}\n"
"\n"

#. TRANSLATORS: def Enum.chunk(enumerable, count, step, leftover \\ nil)
#: lib/enum.ex:325
msgid ""
"Returns list of lists containing `count` items each, where\n"
"each new chunk starts `step` elements into the enumerable.\n"
"\n"
"`step` is optional and, if not passed, defaults to `count`, i.e.\n"
"chunks do not overlap.\n"
"\n"
"If the final chunk does not have `count` elements to fill the chunk,\n"
"elements are taken as necessary from `leftover` if it was passed.\n"
"\n"
"If `leftover` is passed and does not have enough elements to fill the\n"
"chunk, then a partial chunk is returned with less than `count`\n"
"elements. If `leftover` is not passed at all or is `nil`, then the\n"
"partial chunk is discarded from the result.\n"
"\n"
"If `count` is greater than the number of elements in the enumerable\n"
"and `leftover` is not passed, empty list will be returned.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.chunk([1, 2, 3, 4, 5, 6], 2)\n"
"    [[1, 2], [3, 4], [5, 6]]\n"
"\n"
"    iex> Enum.chunk([1, 2, 3, 4, 5, 6], 3, 2)\n"
"    [[1, 2, 3], [3, 4, 5]]\n"
"\n"
"    iex> Enum.chunk([1, 2, 3, 4, 5, 6], 3, 2, [7])\n"
"    [[1, 2, 3], [3, 4, 5], [5, 6, 7]]\n"
"\n"
"    iex> Enum.chunk([1, 2, 3, 4], 3, 3, [])\n"
"    [[1, 2, 3], [4]]\n"
"\n"
"    iex> Enum.chunk([1, 2, 3, 4], 10)\n"
"    []\n"
"\n"
"    iex> Enum.chunk([1, 2, 3, 4], 10, 10, [])\n"
"    [[1, 2, 3, 4]]\n"
"\n"
msgstr ""
"各々`count`個の項目を含むリストのリストを返します。新たなチャンクは\n"
"Enumerableの`step`毎の要素から開始します。\n"
"\n"
"`step`はオプションで、指定されない場合は、デフォルトは`count`になります。\n"
"即ち、チャンクは重なりません。\n"
"\n"
"最後のチャンクがチャンクを満す`count`個の要素を持っていない場合は、\n"
"もし渡されていれば`leftover`から必要に応じて要素が取られます。\n"
"\n"
"`leftover`は指定されているがチャンクを満す十分な要素を持っていない場合は、\n"
"要素が`count`個に満たない不完全なチャンクが返ります。`leftover`がまったく\n"
"指定されていないか、`nil`の場合は、不完全なチャンクは破棄され結果には\n"
"含まれません。\n"
"`count`がEnumerableの要素数より大きく、`leftover`が指定されなかった\n"
"場合は、カラのリストが返ります。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.chunk([1, 2, 3, 4, 5, 6], 2)\n"
"    [[1, 2], [3, 4], [5, 6]]\n"
"\n"
"    iex> Enum.chunk([1, 2, 3, 4, 5, 6], 3, 2)\n"
"    [[1, 2, 3], [3, 4, 5]]\n"
"\n"
"    iex> Enum.chunk([1, 2, 3, 4, 5, 6], 3, 2, [7])\n"
"    [[1, 2, 3], [3, 4, 5], [5, 6, 7]]\n"
"\n"
"    iex> Enum.chunk([1, 2, 3, 4], 3, 3, [])\n"
"    [[1, 2, 3], [4]]\n"
"\n"
"    iex> Enum.chunk([1, 2, 3, 4], 10)\n"
"    []\n"
"\n"
"    iex> Enum.chunk([1, 2, 3, 4], 10, 10, [])\n"
"    [[1, 2, 3, 4]]\n"
"\n"

#. TRANSLATORS: def Enum.at(enumerable, index, default \\ nil)
#: lib/enum.ex:283
msgid ""
"Finds the element at the given `index` (zero-based).\n"
"\n"
"Returns `default` if `index` is out of bounds.\n"
"\n"
"A negative `index` can be passed, which means the `enumerable` is\n"
"enumerated once and the `index` is counted from the end (e.g.\n"
"`-1` finds the last element).\n"
"\n"
"Note this operation takes linear time. In order to access\n"
"the element at index `index`, it will need to traverse `index`\n"
"previous elements.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.at([2, 4, 6], 0)\n"
"    2\n"
"\n"
"    iex> Enum.at([2, 4, 6], 2)\n"
"    6\n"
"\n"
"    iex> Enum.at([2, 4, 6], 4)\n"
"    nil\n"
"\n"
"    iex> Enum.at([2, 4, 6], 4, :none)\n"
"    :none\n"
"\n"
msgstr ""
"指定した(0始まりの)`index`の要素を探します。\n"
"\n"
"`index`が範囲外の場合は`default`を返します。\n"
"\n"
"負の`index`を渡すことができます。これは、`enumerable`が一度列挙され、\n"
"`index`は末尾から数えられる(たとえば、`-1`は最後の要素を探します）\n"
"ことを意味します。\n"
"\n"
"この操作は線形時間を要することに気を付けてください。`index`の要素に\n"
"アクセスするためには、それ以前の`index`個の要素を走査する必要があります。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.at([2, 4, 6], 0)\n"
"    2\n"
"\n"
"    iex> Enum.at([2, 4, 6], 2)\n"
"    6\n"
"\n"
"    iex> Enum.at([2, 4, 6], 4)\n"
"    nil\n"
"\n"
"    iex> Enum.at([2, 4, 6], 4, :none)\n"
"    :none\n"
"\n"

#. TRANSLATORS: Elixir.Enum Summary
#: lib/enum.ex:152
msgid ""
"Provides a set of algorithms that enumerate over enumerables according\n"
"to the `Enumerable` protocol.\n"
"\n"
"    iex> Enum.map([1, 2, 3], fn(x) -> x * 2 end)\n"
"    [2, 4, 6]\n"
"\n"
"Some particular types, like maps, yield a specific format on enumeration.\n"
"For example, the argument is always a `{key, value}` tuple for maps:\n"
"\n"
"    iex> map = %{a: 1, b: 2}\n"
"    iex> Enum.map(map, fn {k, v} -> {k, v * 2} end)\n"
"    [a: 2, b: 4]\n"
"\n"
"Note that the functions in the `Enum` module are eager: they always\n"
"start the enumeration of the given enumerable. The `Stream` module\n"
"allows lazy enumeration of enumerables and provides infinite streams.\n"
"\n"
"Since the majority of the functions in `Enum` enumerate the whole\n"
"enumerable and return a list as result, infinite streams need to\n"
"be carefully used with such functions, as they can potentially run\n"
"forever. For example:\n"
"\n"
"    Enum.each Stream.cycle([1, 2, 3]), &IO.puts(&1)\n"
"\n"
msgstr ""
"`Enumerable`プロトコルに従ってEnumerableを列挙する一連の\n"
"アルゴリズムを提供します:\n"
"\n"
"    iex> Enum.map([1, 2, 3], fn(x) -> x * 2 end)\n"
"    [2, 4, 6]\n"
"\n"
"マップのように、ある種のタイプの中には、列挙する際に特定の形式を\n"
"与えるものがあります。たとえば、マップでは引数は常に`{key, value}`タプルで"
"す:\n"
"\n"
"    iex> map = %{a: 1, b: 2}\n"
"    iex> Enum.map(map, fn {k, v} -> {k, v * 2} end)\n"
"    [a: 2, b: 4]\n"
"\n"
"`Enum`モジュールの関数は先行処理（eager）であることに注意してください。\n"
"指定したenumerableの列挙を常に開始します。`Stream`モジュールは\n"
"enumerableの遅延列挙を可能にし、無限ストリームを提供します。\n"
"\n"
"`Enum`の関数の大部分は、enumerable全体を列挙して、\n"
"結果としてリストを返すため、そのような関数で無限ストリームを\n"
"使用する場合は注意が必要です。永久に実行する可能性があるからです。\n"
"たとえば、\n"
"\n"
"    Enum.each Stream.cycle([1, 2, 3]), &IO.puts(&1)\n"
"\n"

#. TRANSLATORS: def Enum.any?(enumerable, fun \\ fn x -> x end)
#: lib/enum.ex:245
msgid ""
"Returns true if the given `fun` evaluates to true on any of the items in the "
"enumerable.\n"
"\n"
"It stops the iteration at the first invocation that returns a truthy value "
"(not `false` or `nil`).\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.any?([2, 4, 6], fn(x) -> rem(x, 2) == 1 end)\n"
"    false\n"
"\n"
"    iex> Enum.any?([2, 3, 4], fn(x) -> rem(x, 2) == 1 end)\n"
"    true\n"
"\n"
"If no function is given, it defaults to checking if at least one item\n"
"in the enumerable is a truthy value.\n"
"\n"
"    iex> Enum.any?([false, false, false])\n"
"    false\n"
"\n"
"    iex> Enum.any?([false, true, false])\n"
"    true\n"
"\n"
msgstr ""
"Enumerableのいずれかの項目に対して指定した関数`fun`が真の評価を\n"
"した場合、`true`を返します。\n"
"\n"
"truthy値（`false`と`nil`以外）を返す最初の呼び出しで繰り返しを中止\n"
"します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.any?([2, 4, 6], fn(x) -> rem(x, 2) == 1 end)\n"
"    false\n"
"\n"
"    iex> Enum.any?([2, 3, 4], fn(x) -> rem(x, 2) == 1 end)\n"
"    true\n"
"\n"
"関数が指定されない場合、デフォルトでEnumerable内に少なくとも\n"
"1つはtruthy値があるかチェックします。\n"
"\n"
"    iex> Enum.any?([false, false, false])\n"
"    false\n"
"\n"
"    iex> Enum.any?([false, true, false])\n"
"    true\n"
"\n"

#. TRANSLATORS: def Enum.reverse(enumerable, tail)
#: lib/enum.ex:1854
msgid ""
"Reverses the elements in `enumerable`, appends the tail, and returns\n"
"it as a list.\n"
"\n"
"This is an optimization for\n"
"`Enum.concat(Enum.reverse(enumerable), tail)`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.reverse([1, 2, 3], [4, 5, 6])\n"
"    [3, 2, 1, 4, 5, 6]\n"
"\n"
msgstr ""
"`enumerable`を逆順にしてtailを追加したものをリストとして返します。\n"
"\n"
"これは`Enum.concat(Enum.reverse(collection), tail)`の最適化です。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.reverse([1, 2, 3], [4, 5, 6])\n"
"    [3, 2, 1, 4, 5, 6]\n"
"\n"

#. TRANSLATORS: def Enum.dedup_by(enumerable, fun)
#: lib/enum.ex:517
msgid ""
"Enumerates the `enumerable`, returning a list where all consecutive\n"
"duplicated elements are collapsed to a single element.\n"
"\n"
"The function `fun` maps every element to a term which is used to\n"
"determine if two elements are duplicates.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.dedup_by([{1, :a}, {2, :b}, {2, :c}, {1, :a}], fn {x, _} -> x "
"end)\n"
"    [{1, :a}, {2, :b}, {1, :a}]\n"
"\n"
"    iex> Enum.dedup_by([5, 1, 2, 3, 2, 1], fn x -> x > 2 end)\n"
"    [5, 1, 3, 2]\n"
"\n"
msgstr ""
"`enumerable`を列挙して、すべての連続して重複する要素を1つの要素に\n"
"したリストを返します。\n"
"\n"
"関数`fun`はすべての要素を、2つの要素が重複するかを決めるために\n"
"使用される1つの項目に対応させます。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.dedup_by([{1, :x}, {2, :y}, {2, :z}, {1, :x}], fn {x, _} -> x "
"end)\n"
"    [{1, :x}, {2, :y}, {1, :x}]\n"
"\n"
"    iex> Enum.dedup_by([5, 1, 2, 3, 2, 1], fn x -> x > 2 end)\n"
"    [5, 1, 3, 2]\n"
"\n"

#. TRANSLATORS: def Enum.group_by(enumerable, key_fun, value_fun \\ fn x -> x end)
#: lib/enum.ex:1018
msgid ""
"Splits the enumerable into groups based on `key_fun`.\n"
"\n"
"The result is a map where each key is given by `key_fun` and each\n"
"value is a list of elements given by `value_fun`. Ordering is preserved.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.group_by(~w{ant buffalo cat dingo}, &String.length/1)\n"
"    %{3 => [\"ant\", \"cat\"], 7 => [\"buffalo\"], 5 => [\"dingo\"]}\n"
"\n"
"    iex> Enum.group_by(~w{ant buffalo cat dingo}, &String.length/1, &String."
"first/1)\n"
"    %{3 => [\"a\", \"c\"], 7 => [\"b\"], 5 => [\"d\"]}\n"
"\n"
msgstr ""
"`key_fun`に基いて、enumerableをブループに分割します。\n"
"\n"
"結果はマップです。ここで、各キーは`key_fun`により指定されるグループで、\n"
"値は`value_fun`により指定される要素のリストです。順序は保存されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.group_by(~w{ant buffalo cat dingo}, &String.length/1)\n"
"    %{3 => [\"ant\", \"cat\"], 7 => [\"buffalo\"], 5 => [\"dingo\"]}\n"
"\n"
"    iex> Enum.group_by(~w{ant buffalo cat dingo}, &String.length/1, &String."
"first/1)\n"
"    %{3 => [\"a\", \"c\"], 7 => [\"b\"], 5 => [\"d\"]}\n"
"\n"

#. TRANSLATORS: def Enum.min(enumerable, empty_fallback \\ fn -> raise(Enum.EmptyError) end)
#: lib/enum.ex:1433
msgid ""
"Returns the minimal element in the enumerable according\n"
"to Erlang's term ordering.\n"
"\n"
"If multiple elements are considered minimal, the first one that was found\n"
"is returned.\n"
"\n"
"Calls the provided `empty_fallback` function and returns its value if\n"
"`enumerable` is empty. The default `empty_fallback` raises `Enum."
"EmptyError`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.min([1, 2, 3])\n"
"    1\n"
"\n"
"    iex> Enum.min([], fn -> 0 end)\n"
"    0\n"
"\n"
msgstr ""
"Erlangの項順に基づいたenumerableの最小要素を返します。\n"
"\n"
"複数の要素が最小となった場合は、最初に見つかった要素を返します。\n"
"\n"
"`enumerabe`が空の場合は、指定した関数`empty_fallback`を実行して\n"
"その値を返します。デフォルトの`empty_fallback`は`Enum.EmptyError`を\n"
"発生させます。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.min([1, 2, 3])\n"
"    1\n"
"\n"
"    iex> Enum.min([], fn -> 0 end)\n"
"    0\n"
"\n"

#. TRANSLATORS: def Enum.fetch(enumerable, index)
#: lib/enum.ex:687
msgid ""
"Finds the element at the given `index` (zero-based).\n"
"\n"
"Returns `{:ok, element}` if found, otherwise `:error`.\n"
"\n"
"A negative `index` can be passed, which means the `enumerable` is\n"
"enumerated once and the `index` is counted from the end (e.g.\n"
"`-1` fetches the last element).\n"
"\n"
"Note this operation takes linear time. In order to access\n"
"the element at index `index`, it will need to traverse `index`\n"
"previous elements.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.fetch([2, 4, 6], 0)\n"
"    {:ok, 2}\n"
"\n"
"    iex> Enum.fetch([2, 4, 6], -3)\n"
"    {:ok, 2}\n"
"\n"
"    iex> Enum.fetch([2, 4, 6], 2)\n"
"    {:ok, 6}\n"
"\n"
"    iex> Enum.fetch([2, 4, 6], 4)\n"
"    :error\n"
"\n"
msgstr ""
"指定した(0始まりの) `index`の要素を探します。\n"
"\n"
"見つかった場合は`{:ok, element}`を、それ以外は`:error`を返します。\n"
"\n"
"負の`index`を渡すことができます。これは、`enumerable`が一度列挙され、\n"
"`index`は末尾から数えられる(たとえば、`-1`は最後の要素を探します）\n"
"ことを意味します。\n"
"\n"
"この操作は線形時間を要することに気を付けてください。`index`の要素に\n"
"アクセスするためには、それ以前の`index`個の要素を走査する必要があります。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.fetch([2, 4, 6], 0)\n"
"    {:ok, 2}\n"
"\n"
"    iex> Enum.fetch([2, 4, 6], 2)\n"
"    {:ok, 6}\n"
"\n"
"    iex> Enum.fetch([2, 4, 6], 4)\n"
"    :error\n"
"\n"

#. TRANSLATORS: def Enum.concat(left, right)
#: lib/enum.ex:422
msgid ""
"Concatenates the enumerable on the right with the enumerable on the\n"
"left.\n"
"\n"
"This function produces the same result as the `Kernel.++/2` operator\n"
"for lists.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.concat(1..3, 4..6)\n"
"    [1, 2, 3, 4, 5, 6]\n"
"\n"
"    iex> Enum.concat([1, 2, 3], [4, 5, 6])\n"
"    [1, 2, 3, 4, 5, 6]\n"
"\n"
msgstr ""
"左辺のEnumerableを右辺のEnumerableに連結します。\n"
"\n"
"この関数はリストのための`Kernel.++/2`演算子と同じ結果を\n"
"返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.concat(1..3, 4..6)\n"
"    [1, 2, 3, 4, 5, 6]\n"
"\n"
"    iex> Enum.concat([1, 2, 3], [4, 5, 6])\n"
"    [1, 2, 3, 4, 5, 6]\n"
"\n"

#. TRANSLATORS: def Enum.drop_every(enumerable, nth)
#: lib/enum.ex:577
msgid ""
"Returns a list of every `nth` item in the enumerable dropped,\n"
"starting with the first element.\n"
"\n"
"The first item is always dropped, unless `nth` is 0.\n"
"\n"
"The second argument specifying every `nth` item must be a non-negative\n"
"integer.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.drop_every(1..10, 2)\n"
"    [2, 4, 6, 8, 10]\n"
"\n"
"    iex> Enum.drop_every(1..10, 0)\n"
"    [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n"
"\n"
"    iex> Enum.drop_every([1, 2, 3], 1)\n"
"    []\n"
"\n"
msgstr ""
"enumerableの`nth`番目ごとの要素を削除したリストを返します。\n"
"最初の要素からスタートします。\n"
"\n"
"`nth`が0でない限り、最初のアイテムは常に削除します。\n"
"\n"
"`nth`番目ごとを指定する第2引数は、非負の整数でなくてはなりません。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.drop_every(1..10, 2)\n"
"    [2, 4, 6, 8, 10]\n"
"\n"
"    iex> Enum.drop_every(1..10, 0)\n"
"    [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n"
"\n"
"    iex> Enum.drop_every([1, 2, 3], 1)\n"
"    []\n"
"\n"

#. TRANSLATORS: def Enum.map_every(enumerable, nth, fun)
#: lib/enum.ex:1236
msgid ""
"Returns a list of results of invoking `fun` on every `nth`\n"
"item of `enumerable`, starting with the first element.\n"
"\n"
"The first item is always passed to the given function.\n"
"\n"
"The second argument specifying every `nth` item must be a non-negative\n"
"integer.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.map_every(1..10, 2, fn(x) -> x * 2 end)\n"
"    [2, 2, 6, 4, 10, 6, 14, 8, 18, 10]\n"
"\n"
"    iex> Enum.map_every(1..5, 0, fn(x) -> x * 2 end)\n"
"    [1, 2, 3, 4, 5]\n"
"\n"
"    iex> Enum.map_every([1, 2, 3], 1, fn(x) -> x * 2 end)\n"
"    [2, 4, 6]\n"
"\n"
msgstr ""
"`enumerable`の最初の要素から始めて`nth`番目ごとの項目に対して`fun`を実行し"
"た\n"
"結果のリストを返します。\n"
"\n"
"最初の項目は常に指定した関数に渡されます。\n"
"\n"
"`nth`番目毎を指定する2番目の引数は、非負の整数でなくてはなりません。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.map_every(1..10, 2, fn(x) -> x * 2 end)\n"
"    [2, 2, 6, 4, 10, 6, 14, 8, 18, 10]\n"
"\n"
"    iex> Enum.map_every(1..5, 0, fn(x) -> x * 2 end)\n"
"    [1, 2, 3, 4, 5]\n"
"\n"
"    iex> Enum.map_every([1, 2, 3], 1, fn(x) -> x * 2 end)\n"
"    [2, 4, 6]\n"
"\n"

#. TRANSLATORS: def Enum.min_by(enumerable, fun, empty_fallback \\ fn -> raise(Enum.EmptyError) end)
#: lib/enum.ex:1459
msgid ""
"Returns the minimal element in the enumerable as calculated\n"
"by the given function.\n"
"\n"
"If multiple elements are considered minimal, the first one that was found\n"
"is returned.\n"
"\n"
"Calls the provided `empty_fallback` function and returns its value if\n"
"`enumerable` is empty. The default `empty_fallback` raises `Enum."
"EmptyError`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.min_by([\"a\", \"aa\", \"aaa\"], fn(x) -> String.length(x) "
"end)\n"
"    \"a\"\n"
"\n"
"    iex> Enum.min_by([\"a\", \"aa\", \"aaa\", \"b\", \"bbb\"], &String."
"length/1)\n"
"    \"a\"\n"
"\n"
"    iex> Enum.min_by([], &String.length/1, fn -> nil end)\n"
"    nil\n"
"\n"
msgstr ""
"enumerableの各要素を指定した関数で計算した値が最小となる要素を返します。\n"
"\n"
"複数の要素が最小となった場合は、最初に見つかった要素を返します。\n"
"\n"
"`enumerabe`が空の場合、指定した関数`empty_fallback`を実行して\n"
"その値を返します。デフォルトの`empty_fallback`は`Enum.EmptyError`を\n"
"発生させます。\n"
"\n"
"## 例\n"
"n\n"
"    iex> Enum.min_by([\"a\", \"aa\", \"aaa\"], fn(x) -> String.length(x) "
"end)\n"
"    \"a\"\n"
"\n"
"    iex> Enum.min_by([\"a\", \"aa\", \"aaa\", \"b\", \"bbb\"], &String."
"length/1)\n"
"    \"a\"\n"
"\n"
"    iex> Enum.min_by([], &String.length/1, fn -> nil end)\n"
"    nil\n"
"\n"

#. TRANSLATORS: def Enum.to_list(enumerable)
#: lib/enum.ex:2513
msgid ""
"Converts `enumerable` to a list.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.to_list(1..3)\n"
"    [1, 2, 3]\n"
"\n"
msgstr ""
"`enumerable`をリストに変換します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.to_list(1 .. 3)\n"
"    [1, 2, 3]\n"
"\n"

#. TRANSLATORS: def Enumerable.reduce(enumerable, acc, fun)
#: lib/enum.ex:99
msgid ""
"Reduces the enumerable into an element.\n"
"\n"
"Most of the operations in `Enum` are implemented in terms of reduce.\n"
"This function should apply the given `t:reducer/0` function to each\n"
"item in the enumerable and proceed as expected by the returned\n"
"accumulator.\n"
"\n"
"As an example, here is the implementation of `reduce` for lists:\n"
"\n"
"    def reduce(_,       {:halt, acc}, _fun),   do: {:halted, acc}\n"
"    def reduce(list,    {:suspend, acc}, fun), do: {:suspended, acc, "
"&reduce(list, &1, fun)}\n"
"    def reduce([],      {:cont, acc}, _fun),   do: {:done, acc}\n"
"    def reduce([h | t], {:cont, acc}, fun),    do: reduce(t, fun.(h, acc), "
"fun)\n"
"\n"
msgstr ""
"enumerableを1つの要素に集約します。\n"
"\n"
"`Enum`のほとんどのオペレーションはreduceで実装されています。この関数は\n"
"指定した`t:reducer/0`関数をenumerableのそれぞれのアイテムに適用して、返\n"
"されたアキュムレータにより、繰返し累積しなくてはなりません。\n"
"\n"
"例として、リストの`reduce`の実装です:\n"
"\n"
"    def reduce(_,     {:halt, acc}, _fun),   do: {:halted, acc}\n"
"    def reduce(list,  {:suspend, acc}, fun), do: {:suspended, acc, "
"&reduce(list, &1, fun)}\n"
"    def reduce([],    {:cont, acc}, _fun),   do: {:done, acc}\n"
"    def reduce([h|t], {:cont, acc}, fun),    do: reduce(t, fun.(h, acc), "
"fun)\n"
"\n"

#. TRANSLATORS: def Enum.max(enumerable, empty_fallback \\ fn -> raise(Enum.EmptyError) end)
#: lib/enum.ex:1337
msgid ""
"Returns the maximal element in the enumerable according\n"
"to Erlang's term ordering.\n"
"\n"
"If multiple elements are considered maximal, the first one that was found\n"
"is returned.\n"
"\n"
"Calls the provided `empty_fallback` function and returns its value if\n"
"`enumerable` is empty. The default `empty_fallback` raises `Enum."
"EmptyError`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.max([1, 2, 3])\n"
"    3\n"
"\n"
"    iex> Enum.max([], fn -> 0 end)\n"
"    0\n"
"\n"
msgstr ""
"Erlangの項順序に基いて、enumerableの最大の要素を返します。\n"
"\n"
"最大の要素が複数ある場合は最初に見つかった要素が返されます。\n"
"\n"
"`enumerable`が空の場合、指定した関数`empty_fallback`を呼び出し、その\n"
"値を返します。デフォルトの`empty_fallback`は`Enum.EmptyError`を発生させま"
"す。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.max([1, 2, 3])\n"
"    3\n"
"\n"
"    iex> Enum.max([], fn -> 0 end)\n"
"    0\n"
"\n"

#. TRANSLATORS: def Enum.map_reduce(enumerable, acc, fun)
#: lib/enum.ex:1304
msgid ""
"Invokes the given function to each item in the enumerable to reduce\n"
"it to a single element, while keeping an accumulator.\n"
"\n"
"Returns a tuple where the first element is the mapped enumerable and\n"
"the second one is the final accumulator.\n"
"\n"
"The function, `fun`, receives two arguments: the first one is the\n"
"element, and the second one is the accumulator. `fun` must return\n"
"a tuple with two elements in the form of `{result, accumulator}`.\n"
"\n"
"For maps, the first tuple element must be a `{key, value}` tuple.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.map_reduce([1, 2, 3], 0, fn(x, acc) -> {x * 2, x + acc} end)\n"
"    {[2, 4, 6], 6}\n"
"\n"
msgstr ""
"アキュムレータを保持しながら、enumerableの各項目に対して指定した関数を実行"
"し、\n"
"単一の要素に還元します。\n"
"\n"
"第1要素がマップした結果のenumerableで、第2要素が最終的なアキュムレータであ"
"る\n"
"タプルを返します。\n"
"\n"
"関数`fun`は2つの引数を取ります。第1引数は要素で、第2引数はアキュムレータ\n"
"です。`fun`は`{result, accumulator}`の形の2要素タプルを返さなければなりませ"
"ん。\n"
"\n"
"マップについては、タプルの第1要素は`{key, value}`タプルでなくてはなりませ"
"ん。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.map_reduce([1, 2, 3], 0, fn(x, acc) -> {x * 2, x + acc} end)\n"
"    {[2, 4, 6], 6}\n"
"\n"

#. TRANSLATORS: def Enum.reverse(enumerable)
#: lib/enum.ex:1840
msgid ""
"Returns a list of elements in `enumerable` in reverse order.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.reverse([1, 2, 3])\n"
"    [3, 2, 1]\n"
"\n"
msgstr ""
"`enumerable`を逆順にしたリストを返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.reverse([1, 2, 3])\n"
"    [3, 2, 1]\n"
"\n"

#. TRANSLATORS: def Enum.take_every(enumerable, nth)
#: lib/enum.ex:2381
msgid ""
"Returns a list of every `nth` item in the enumerable,\n"
"starting with the first element.\n"
"\n"
"The first item is always included, unless `nth` is 0.\n"
"\n"
"The second argument specifying every `nth` item must be a non-negative\n"
"integer.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Enum.take_every(1..10, 2)\n"
"    [1, 3, 5, 7, 9]\n"
"\n"
"    iex> Enum.take_every(1..10, 0)\n"
"    []\n"
"\n"
"    iex> Enum.take_every([1, 2, 3], 1)\n"
"    [1, 2, 3]\n"
"\n"
msgstr ""
"最初の要素からスタートして、enumerableの`nth`番目ごとの\n"
"要素からなるリストを返します。\n"
"\n"
"`nth`が0でない限り、最初のアイテムは常に含まれます。\n"
"\n"
"`nth`番目ごとを指定する第2引数は、非負の整数でなくてはなりません。\n"
"\n"
"## 例\n"
"\n"
"    iex> Enum.take_every(1..10, 2)\n"
"    [1, 3, 5, 7, 9]\n"
"\n"
"    iex> Enum.take_every(1..10, 0)\n"
"    []\n"
"\n"
"    iex> Enum.take_every([1, 2, 3], 1)\n"
"    [1, 2, 3]\n"
"\n"
