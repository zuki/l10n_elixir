msgid ""
msgstr ""
"Project-Id-Version: l 10n_elixir\n"
"PO-Revision-Date: 2016-02-27 10:34+0900\n"
"Last-Translator: 小田 照敬 <EMAIL@ADDRESS>\n"
"Language-Team: Japanese\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#. TRANSLATORS: def Access.at(index)
#: lib/access.ex:581
msgid ""
"Returns a function that accesses the element at `index` (zero based) of a "
"list.\n"
"\n"
"The returned function is typically passed as an accessor to `Kernel."
"get_in/2`,\n"
"`Kernel.get_and_update_in/3`, and friends.\n"
"\n"
"## Examples\n"
"\n"
"    iex> list = [%{name: \"john\"}, %{name: \"mary\"}]\n"
"    iex> get_in(list, [Access.at(1), :name])\n"
"    \"mary\"\n"
"    iex> get_and_update_in(list, [Access.at(0), :name], fn\n"
"    ...>   prev -> {prev, String.upcase(prev)}\n"
"    ...> end)\n"
"    {\"john\", [%{name: \"JOHN\"}, %{name: \"mary\"}]}\n"
"\n"
"`at/1` can also be used to pop elements out of a list or\n"
"a key inside of a list:\n"
"\n"
"    iex> list = [%{name: \"john\"}, %{name: \"mary\"}]\n"
"    iex> pop_in(list, [Access.at(0)])\n"
"    {%{name: \"john\"}, [%{name: \"mary\"}]}\n"
"    iex> pop_in(list, [Access.at(0), :name])\n"
"    {\"john\", [%{}, %{name: \"mary\"}]}\n"
"\n"
"When the index is out of bounds, `nil` is returned and the update function "
"is never called:\n"
"\n"
"    iex> list = [%{name: \"john\"}, %{name: \"mary\"}]\n"
"    iex> get_in(list, [Access.at(10), :name])\n"
"    nil\n"
"    iex> get_and_update_in(list, [Access.at(10), :name], fn\n"
"    ...>   prev -> {prev, String.upcase(prev)}\n"
"    ...> end)\n"
"    {nil, [%{name: \"john\"}, %{name: \"mary\"}]}\n"
"\n"
"An error is raised for negative indexes:\n"
"\n"
"    iex> get_in([], [Access.at(-1)])\n"
"    ** (FunctionClauseError) no function clause matching in Access.at/1\n"
"\n"
"An error is raised if the accessed structure is not a list:\n"
"\n"
"    iex> get_in(%{}, [Access.at(1)])\n"
"    ** (RuntimeError) Access.at/1 expected a list, got: %{}\n"
msgstr ""

#. TRANSLATORS: def Access.fetch(container, key)
#: lib/access.ex:232
msgid ""
"Fetches the value for the given key in a container (a map, keyword\n"
"list, or struct that implements the `Access` behaviour).\n"
msgstr ""

#. TRANSLATORS: @callback pop/2
#: lib/access.ex:204
msgid ""
"Invoked to \"pop\" the value under `key` out of the given term.\n"
"\n"
"When the key `key` exists in the given `term`, the implementation should\n"
"return a `{value, new_term}` tuple where `value` is the value that was "
"under\n"
"`key` and `new_term` is `term` without `key`.\n"
"\n"
"When the key `key` is not present in the given `term`, a tuple `{value, term}"
"`\n"
"should be returned, where `value` is implementation-defined.\n"
"\n"
"See the implementations for `Map.pop/3` or `Keyword.pop/3` for more "
"examples.\n"
msgstr ""

#. TRANSLATORS: def Access.get(container, key, default \\ nil)
#: lib/access.ex:263
msgid ""
"Gets the value for the given key in a container (a map, keyword\n"
"list, or struct that implements the `Access` behaviour).\n"
msgstr ""

#. TRANSLATORS: def Access.key!(key)
#: lib/access.ex:435
msgid ""
"Returns a function that accesses the given key in a map/struct.\n"
"\n"
"The returned function is typically passed as an accessor to `Kernel."
"get_in/2`,\n"
"`Kernel.get_and_update_in/3`, and friends.\n"
"\n"
"Raises if the key does not exist.\n"
"\n"
"## Examples\n"
"\n"
"    iex> map = %{user: %{name: \"john\"}}\n"
"    iex> get_in(map, [Access.key!(:user), Access.key!(:name)])\n"
"    \"john\"\n"
"    iex> get_and_update_in(map, [Access.key!(:user), Access.key!(:name)], "
"fn\n"
"    ...>   prev -> {prev, String.upcase(prev)}\n"
"    ...> end)\n"
"    {\"john\", %{user: %{name: \"JOHN\"}}}\n"
"    iex> pop_in(map, [Access.key!(:user), Access.key!(:name)])\n"
"    {\"john\", %{user: %{}}}\n"
"    iex> get_in(map, [Access.key!(:user), Access.key!(:unknown)])\n"
"    ** (KeyError) key :unknown not found in: %{name: \"john\"}\n"
"\n"
"An error is raised if the accessed structure is not a map/struct:\n"
"\n"
"    iex> get_in([], [Access.key!(:foo)])\n"
"    ** (RuntimeError) Access.key!/1 expected a map/struct, got: []\n"
"\n"
msgstr ""

#. TRANSLATORS: Elixir.Access Summary
#: lib/access.ex:2
#, fuzzy
msgid ""
"Key-based access to data structures using the `data[key]` syntax.\n"
"\n"
"Elixir provides two syntaxes for accessing values. `user[:name]`\n"
"is used by dynamic structures, like maps and keywords, while\n"
"`user.name` is used by structs. The main difference is that\n"
"`user[:name]` won't raise if the key `:name` is missing but\n"
"`user.name` will raise if there is no `:name` key.\n"
"\n"
"Besides the cases above, this module provides convenience\n"
"functions for accessing other structures, like `at/1` for\n"
"lists and `elem/1` for tuples. Those functions can be used\n"
"by the nested update functions in `Kernel`, such as\n"
"`Kernel.get_in/2`, `Kernel.put_in/3`, `Kernel.update_in/3`,\n"
"`Kernel.get_and_update_in/3` and friends.\n"
"\n"
"## Dynamic lookups\n"
"\n"
"Out of the box, `Access` works with `Keyword` and `Map`:\n"
"\n"
"    iex> keywords = [a: 1, b: 2]\n"
"    iex> keywords[:a]\n"
"    1\n"
"\n"
"    iex> map = %{a: 1, b: 2}\n"
"    iex> map[:a]\n"
"    1\n"
"\n"
"    iex> star_ratings = %{1.0 => \"★\", 1.5 => \"★☆\", 2.0 => \"★★\"}\n"
"    iex> star_ratings[1.5]\n"
"    \"★☆\"\n"
"\n"
"Note that the dynamic lookup syntax (`term[key]`) roughly translates to\n"
"`Access.get(term, key, nil)`.\n"
"\n"
"`Access` can be combined with `Kernel.put_in/3` to put a value\n"
"in a given key:\n"
"\n"
"    iex> map = %{a: 1, b: 2}\n"
"    iex> put_in map[:a], 3\n"
"    %{a: 3, b: 2}\n"
"\n"
"This syntax is very convenient as it can be nested arbitrarily:\n"
"\n"
"    iex> users = %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}\n"
"    iex> put_in users[\"john\"][:age], 28\n"
"    %{\"john\" => %{age: 28}, \"meg\" => %{age: 23}}\n"
"\n"
"Furthermore, `Access` transparently ignores `nil` values:\n"
"\n"
"    iex> keywords = [a: 1, b: 2]\n"
"    iex> keywords[:c][:unknown]\n"
"    nil\n"
"\n"
"Since `Access` is a behaviour, it can be implemented for key-value\n"
"data structures. The implementation should be added to the\n"
"module that defines the struct being accessed. `Access` requires the\n"
"key comparison to be implemented using the `===` operator.\n"
"\n"
"## Static lookups\n"
"\n"
"The `Access` syntax (`foo[bar]`) cannot be used to access fields in\n"
"structs, since structs do not implement the `Access` behaviour by\n"
"default. It is also a design decision: the dynamic access lookup\n"
"is meant to be used for dynamic key-value structures, like maps\n"
"and keywords, and not by static ones like structs (where fields are\n"
"known and not dynamic).\n"
"\n"
"Therefore Elixir provides a static lookup for struct fields and for atom\n"
"fields in maps. Imagine a struct named `User` with a `:name` field.\n"
"The following would raise:\n"
"\n"
"    user = %User{name: \"John\"}\n"
"    user[:name]\n"
"    # ** (UndefinedFunctionError) undefined function User.fetch/2\n"
"    #    (User does not implement the Access behaviour)\n"
"\n"
"Structs instead use the `user.name` syntax to access fields:\n"
"\n"
"    user.name\n"
"    #=> \"John\"\n"
"\n"
"The same `user.name` syntax can also be used by `Kernel.put_in/2`\n"
"to for updating structs fields:\n"
"\n"
"    put_in user.name, \"Mary\"\n"
"    #=> %User{name: \"Mary\"}\n"
"\n"
"Differently from `user[:name]`, `user.name` is not extensible via\n"
"a behaviour and is restricted only to structs and atom keys in maps.\n"
"\n"
"As mentioned above, this works for atom keys in maps as well. Refer to the\n"
"`Map` module for more information on this.\n"
"\n"
"Summing up:\n"
"\n"
"  * `user[:name]` is used by dynamic structures, is extensible and\n"
"    does not raise on missing keys\n"
"  * `user.name` is used by static structures, it is not extensible\n"
"    and it will raise on missing keys\n"
"\n"
"## Accessors\n"
"\n"
"While Elixir provides built-in syntax only for traversing dynamic\n"
"and static key-value structures, this module provides convenience\n"
"functions for traversing other structures, like tuples and lists,\n"
"to be used alongside `Kernel.put_in/2` in others.\n"
"\n"
"For instance, given a user with a list of languages, here is how to\n"
"deeply traverse the map and convert all language names to uppercase:\n"
"\n"
"    iex> user = %{name: \"john\",\n"
"    ...>          languages: [%{name: \"elixir\", type: :functional},\n"
"    ...>                      %{name: \"c\", type: :procedural}]}\n"
"    iex> update_in user, [:languages, Access.all(), :name], &String."
"upcase/1\n"
"    %{name: \"john\",\n"
"      languages: [%{name: \"ELIXIR\", type: :functional},\n"
"                  %{name: \"C\", type: :procedural}]}\n"
"\n"
"See the functions `key/1`, `key!/1`, `elem/1`, and `all/0` for some of the\n"
"available accessors.\n"
"\n"
"## Implementing the Access behaviour for custom data structures\n"
"\n"
"In order to be able to use the `Access` protocol with custom data "
"structures\n"
"(which have to be structs), such structures have to implement the `Access`\n"
"behaviour. For example, for a `User` struct, this would have to be done:\n"
"\n"
"    defmodule User do\n"
"      defstruct [:name, :email]\n"
"\n"
"      @behaviour Access\n"
"      # Implementation of the Access callbacks...\n"
"    end\n"
"\n"
msgstr ""
"`foo[bar]`シンタックスを介した辞書ライクなデータ構造へのアクセス\n"
"\n"
"Elixirは値へのアクセスの為に二つのシンタックスを提供します。\n"
"`user[:name]`はmapやkeywordのような動的な構造により使われ、\n"
"`user.name`はstructにより使われます。主な違いは`user[:name]`はキー\n"
"`:name`が無くても例外を上げないのに対して、`user.name`は`:name`キーが無\n"
"いと例外をあげる点です。\n"
"\n"
"上記のケースの他に、このモジュールは、listのための`at/1`やtupleのための\n"
"`elem/1`のような、他の構造へアクセスするための便利な関数を提供します。\n"
"それらの関数は`Kernel.get_in/2`, `Kernel.put_in/3`,\n"
"`Kernel.update_in/3`, `Kernel.get_and_update_in/3`などの\n"
"`Kernel`のネストされた更新関数によっても\n"
"使われます。\n"
"\n"
"## Key-based lookups\n"
"\n"
"Accessは`Keyword`と`Map`ではすぐに使えます:\n"
"\n"
"    iex> keywords = [a: 1, b: 2]\n"
"    iex> keywords[:a]\n"
"    1\n"
"\n"
"    iex> map = %{a: 1, b: 2}\n"
"    iex> map[:a]\n"
"    1\n"
"\n"
"    iex> star_ratings = %{1.0 => \"★\", 1.5 => \"★☆\", 2.0 => \"★★\"}\n"
"    iex> star_ratings[1.5]\n"
"    \"★☆\"\n"
"\n"
"Accessは与えられたキーの値をputするために`Kernel.put_in/3`と結合するこ\n"
"ともできます:\n"
"\n"
"    iex> map = %{a: 1, b: 2}\n"
"    iex> put_in map[:a], 3\n"
"    %{a: 3, b: 2}\n"
"\n"
"このシンタックスは任意にネスト出来るので非常に便利です:\n"
"\n"
"    iex> users = %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}\n"
"    iex> put_in users[\"john\"][:age], 28\n"
"    %{\"john\" => %{age: 28}, \"meg\" => %{age: 23}}\n"
"\n"
"さらにまた、Accessは`nil`値を透過的に無視します:\n"
"\n"
"    iex> keywords = [a: 1, b: 2]\n"
"    iex> keywords[:c][:unknown]\n"
"    nil\n"
"\n"
"Accessはbehaviourなので、key-valueデータ構造のために実装することが\n"
"できます。Accessはキーの比較を`===`オペレータを使って実装されることを\n"
"要求します。\n"
"\n"
"## Field-based lookups\n"
"\n"
"Accessシンタックス(`foo[bar]`)はstructのフィールドのアクセスには使うこ\n"
"とができません。Accessはmapやkeywordのような、動的なkey-value構造のため\n"
"に使われることを意味し、structのような静的な構造のためではないという、\n"
"設計によるものです。\n"
"\n"
"しかしながら、Elixirは既にstructのためのフィールドベース参照を\n"
"提供しています。nameとageフィールドを持つ`User`というstructを\n"
"想像してください。以下のようにすると例外が上ります:\n"
"\n"
"    user = %User{name: \"john\"}\n"
"    user[:name]\n"
"    ** (UndefinedFunctionError) undefined function User.fetch/2\n"
"       (User does not implement the Access behaviour)\n"
"\n"
"structは`user.name`シンタックスを代りに使います:\n"
"\n"
"    user.name\n"
"    #=> \"john\"\n"
"\n"
"`user.name`シンタックスはstructのフィールドを更新するために、\n"
"`Kernel.put_in/2`により使われることも同じです:\n"
"\n"
"    put_in user.name, \"mary\"\n"
"    %User{name: \"mary\"}\n"
"\n"
"`user[:name]`に対する、`user.name`の相違点は、デベロッパによる拡張がで\n"
"きない点と、常にmapとstructだけに制限される点です。\n"
"\n"
"要約すると:\n"
"\n"
"  * `user[:name]` は動的構造に使い、拡張可能で、キーがなくても例外を上\n"
"    げません\n"
"  * `user.name` は静的構造に使い、拡張不可能で、キーがないと\n"
"    例外を上げます\n"
"\n"
"## Accessors\n"
"\n"
"Elixirが動的、静的なkey-value構造をトラバースするためだけにビルトインシ\n"
"ンタックスを提供する一方、このモジュールは`Kernel.put_in/2`その他と一緒\n"
"に使われる、tupleやlistといった他の構造のトラバースする便利な関数も提供し\n"
"ます。\n"
"\n"
"**TODO: implement `field/1`, `key/1`, `at/1`, `elem/1`.**\n"
"\n"

#. TRANSLATORS: def Access.pop(container, key)
#: lib/access.ex:313
msgid ""
"Removes the entry with a given key from a container (a map, keyword\n"
"list, or struct that implements the `Access` behaviour).\n"
"\n"
"Returns a tuple containing the value associated with the key and the\n"
"updated container. `nil` is returned for the value if the key isn't\n"
"in the container.\n"
"\n"
"## Examples\n"
"\n"
"With a map:\n"
"\n"
"    iex> Access.pop(%{name: \"Elixir\", creator: \"Valim\"}, :name)\n"
"    {\"Elixir\", %{creator: \"Valim\"}}\n"
"\n"
"A keyword list:\n"
"\n"
"    iex> Access.pop([name: \"Elixir\", creator: \"Valim\"], :name)\n"
"    {\"Elixir\", [creator: \"Valim\"]}\n"
"\n"
"An unknown key:\n"
"\n"
"    iex> Access.pop(%{name: \"Elixir\", creator: \"Valim\"}, :year)\n"
"    {nil, %{creator: \"Valim\", name: \"Elixir\"}}\n"
"\n"
msgstr ""

#. TRANSLATORS: def Access.key(key, default)
#: lib/access.ex:383
msgid ""
"Returns a function that accesses the given key in a map/struct.\n"
"\n"
"The returned function is typically passed as an accessor to `Kernel."
"get_in/2`,\n"
"`Kernel.get_and_update_in/3`, and friends.\n"
"\n"
"The returned function uses the default value if the key does not exist.\n"
"This can be used to specify defaults and safely traverse missing keys:\n"
"\n"
"    iex> get_in(%{}, [Access.key(:user, %{}), Access.key(:name, nil)])\n"
"    nil\n"
"\n"
"Such is also useful when using update functions, allowing us to introduce\n"
"values as we traverse the data-structure for updates:\n"
"\n"
"    iex> put_in(%{}, [Access.key(:user, %{}), Access.key(:name, nil)], \"Mary"
"\")\n"
"    %{user: %{name: \"Mary\"}}\n"
"\n"
"## Examples\n"
"\n"
"    iex> map = %{user: %{name: \"john\"}}\n"
"    iex> get_in(map, [Access.key(:unknown, %{}), Access.key(:name, \"john"
"\")])\n"
"    \"john\"\n"
"    iex> get_and_update_in(map, [Access.key!(:user), Access.key!(:name)], "
"fn\n"
"    ...>   prev -> {prev, String.upcase(prev)}\n"
"    ...> end)\n"
"    {\"john\", %{user: %{name: \"JOHN\"}}}\n"
"    iex> pop_in(map, [Access.key!(:user), Access.key!(:name)])\n"
"    {\"john\", %{user: %{}}}\n"
"\n"
"An error is raised if the accessed structure is not a map or a struct:\n"
"\n"
"    iex> get_in(nil, [Access.key(:foo, nil)])\n"
"    ** (BadMapError) expected a map, got: nil\n"
"\n"
"    iex> get_in([], [Access.key(:foo, nil)])\n"
"    ** (BadMapError) expected a map, got: []\n"
"\n"
msgstr ""

#. TRANSLATORS: def Access.get_and_update(container, key, fun)
#: lib/access.ex:275
msgid ""
"Gets and updates the given key in a container (a map, keyword\n"
"list, or struct that implements the `Access` behaviour).\n"
"\n"
"This `fun` argument receives the value of `key` (or `nil` if `key`\n"
"is not present) and must return a two-element tuple: the \"get\" value\n"
"(the retrieved value, which can be operated on before being returned)\n"
"and the new value to be stored under `key`. The `fun` may also\n"
"return `:pop`, implying the current value shall be removed\n"
"from the container and returned.\n"
"\n"
"The returned value is a two-element tuple with the \"get\" value returned "
"by\n"
"`fun` and a new container with the updated value under `key`.\n"
msgstr ""

#. TRANSLATORS: def Access.elem(index)
#: lib/access.ex:478
msgid ""
"Returns a function that accesses the element at the given index in a tuple.\n"
"\n"
"The returned function is typically passed as an accessor to `Kernel."
"get_in/2`,\n"
"`Kernel.get_and_update_in/3`, and friends.\n"
"\n"
"Raises if the index is out of bounds.\n"
"\n"
"## Examples\n"
"\n"
"    iex> map = %{user: {\"john\", 27}}\n"
"    iex> get_in(map, [:user, Access.elem(0)])\n"
"    \"john\"\n"
"    iex> get_and_update_in(map, [:user, Access.elem(0)], fn\n"
"    ...>   prev -> {prev, String.upcase(prev)}\n"
"    ...> end)\n"
"    {\"john\", %{user: {\"JOHN\", 27}}}\n"
"    iex> pop_in(map, [:user, Access.elem(0)])\n"
"    ** (RuntimeError) cannot pop data from a tuple\n"
"\n"
"An error is raised if the accessed structure is not a tuple:\n"
"\n"
"    iex> get_in(%{}, [Access.elem(0)])\n"
"    ** (RuntimeError) Access.elem/1 expected a tuple, got: %{}\n"
"\n"
msgstr ""

#. TRANSLATORS: @callback fetch/2
#: lib/access.ex:143
msgid ""
"Invoked in order to access the value stored under `key` in the given term "
"`term`.\n"
"\n"
"This function should return `{:ok, value}` where `value` is the value under\n"
"`key` if it succeeded, or `:error` if the key does not exist in the "
"structure.\n"
"\n"
"Many of the functions defined in the `Access` module internally call this\n"
"function. This function is also used when the square-brackets access syntax\n"
"(`structure[key]`) is used: the `fetch/2` callback implemented by the "
"module\n"
"that defines the `structure` struct is invoked and if it returns `{:ok,\n"
"value}` then `value` is returned, or if it returns `:error` then `nil` is\n"
"returned.\n"
"\n"
"\n"
"See the `Map.fetch/2` and `Keyword.fetch/2` implementations for examples of\n"
"how to implement this callback.\n"
msgstr ""

#. TRANSLATORS: def Access.all()
#: lib/access.ex:521
msgid ""
"Returns a function that accesses all the elements in a list.\n"
"\n"
"The returned function is typically passed as an accessor to `Kernel."
"get_in/2`,\n"
"`Kernel.get_and_update_in/3`, and friends.\n"
"\n"
"## Examples\n"
"\n"
"    iex> list = [%{name: \"john\"}, %{name: \"mary\"}]\n"
"    iex> get_in(list, [Access.all(), :name])\n"
"    [\"john\", \"mary\"]\n"
"    iex> get_and_update_in(list, [Access.all(), :name], fn\n"
"    ...>   prev -> {prev, String.upcase(prev)}\n"
"    ...> end)\n"
"    {[\"john\", \"mary\"], [%{name: \"JOHN\"}, %{name: \"MARY\"}]}\n"
"    iex> pop_in(list, [Access.all(), :name])\n"
"    {[\"john\", \"mary\"], [%{}, %{}]}\n"
"\n"
"Here is an example that traverses the list dropping even\n"
"numbers and multipling odd numbers by 2:\n"
"\n"
"    iex> require Integer\n"
"    iex> get_and_update_in([1, 2, 3, 4, 5], [Access.all], fn\n"
"    ...>   num -> if Integer.is_even(num), do: :pop, else: {num, num * 2}\n"
"    ...> end)\n"
"    {[1, 2, 3, 4, 5], [2, 6, 10]}\n"
"\n"
"An error is raised if the accessed structure is not a list:\n"
"\n"
"    iex> get_in(%{}, [Access.all()])\n"
"    ** (RuntimeError) Access.all/0 expected a list, got: %{}\n"
"\n"
msgstr ""

#. TRANSLATORS: @callback get/3
#: lib/access.ex:162
msgid ""
"Invoked in order to access the value stored under `key` in the given term "
"`term`,\n"
"defaulting to `default` if not present.\n"
"\n"
"This function should return the value under the key `key` in `term` if "
"there's\n"
"such key, otherwise `default`.\n"
"\n"
"For most data structures, this can be implemented using `fetch/2` "
"internally;\n"
"for example:\n"
"\n"
"    def get(structure, key, default) do\n"
"      case fetch(structure, key) do\n"
"        {:ok, value} -> value\n"
"        :error       -> default\n"
"      end\n"
"    end\n"
"\n"
"See the `Map.get/3` and `Keyword.get/3` implementations for more examples.\n"
msgstr ""

#. TRANSLATORS: @callback get_and_update/3
#: lib/access.ex:183
msgid ""
"Invoked in order to access the value under `key` and update it at the same "
"time.\n"
"\n"
"The implementation of this callback should invoke the passed function with "
"the\n"
"value under key `key` in the passed structure, or `nil` if the key is not\n"
"present. This function should return either `{value_to_return, new_value}` "
"or\n"
"`:pop`.\n"
"\n"
"If it returns `{value_to_return, new_value}`, the return value of this\n"
"callback should be `{value_to_return, new_term}` where `new_term` is `term`\n"
"after updating the value of `key` with `new_value`.\n"
"\n"
"If it returns `:pop`, the return value of this callback should be `{value,\n"
"new_term}` where `value` is the value under `key` or `nil` if not present, "
"and\n"
"`new_term` is `term` without the key `key`.\n"
"\n"
"See the implementations of `Map.get_and_update/3` or `Keyword."
"get_and_update/3`\n"
"for more examples.\n"
msgstr ""

#~ msgid "Fetches the container's value for the given key.\n"
#~ msgstr "与えられたキーに対するコンテナの値を取得します。\n"

#~ msgid ""
#~ "Gets and updates the container's value for the given key, in a single "
#~ "pass.\n"
#~ "\n"
#~ "The argument function `fun` must receive the value for the given `key` "
#~ "(or\n"
#~ "`nil` if the key doesn't exist in `container`). It must return a tuple\n"
#~ "containing the `get` value and the new value to be stored in the "
#~ "`container`.\n"
#~ "\n"
#~ "This function returns a two-element tuple.\n"
#~ "The first element is the `get` value, as returned by `fun`.\n"
#~ "The second element is the container, updated with the value returned by "
#~ "`fun`.\n"
#~ msgstr ""
#~ "一度のパスで、与えられたkeyの値を取得し、コンテナを更新します。\n"
#~ "\n"
#~ "引数の関数`fun`は、与えられた`key`の値(`container`にキーが\n"
#~ "存在しない場合は、`nil`)を受け取り、`get`した値と、\n"
#~ "`container`に保存された新しい値を含むタプルを返さなくてはなりません。\n"
#~ "\n"
#~ "この関数は2要素のタプルを返します。\n"
#~ "最初の要素は、`fun`から返された`get`した値です。\n"
#~ "二つめの要素は、`fun`から返された値で更新されたコンテナです。\n"

#~ msgid "Gets the container's value for the given key.\n"
#~ msgstr "与えられたキーに対するコンテナの値を取得します。\n"
