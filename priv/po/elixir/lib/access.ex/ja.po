msgid ""
msgstr ""
"Project-Id-Version: l 10n_elixir\n"
"PO-Revision-Date: 2017-01-28 18:20+0900\n"
"Last-Translator: 小田 照敬 <EMAIL@ADDRESS>\n"
"Language-Team: Japanese\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"POT-Creation-Date: \n"
"X-Generator: Poedit 1.8.11\n"

#. TRANSLATORS: def Access.at(index)
#: lib/access.ex:581
msgid ""
"Returns a function that accesses the element at `index` (zero based) of a "
"list.\n"
"\n"
"The returned function is typically passed as an accessor to `Kernel."
"get_in/2`,\n"
"`Kernel.get_and_update_in/3`, and friends.\n"
"\n"
"## Examples\n"
"\n"
"    iex> list = [%{name: \"john\"}, %{name: \"mary\"}]\n"
"    iex> get_in(list, [Access.at(1), :name])\n"
"    \"mary\"\n"
"    iex> get_and_update_in(list, [Access.at(0), :name], fn\n"
"    ...>   prev -> {prev, String.upcase(prev)}\n"
"    ...> end)\n"
"    {\"john\", [%{name: \"JOHN\"}, %{name: \"mary\"}]}\n"
"\n"
"`at/1` can also be used to pop elements out of a list or\n"
"a key inside of a list:\n"
"\n"
"    iex> list = [%{name: \"john\"}, %{name: \"mary\"}]\n"
"    iex> pop_in(list, [Access.at(0)])\n"
"    {%{name: \"john\"}, [%{name: \"mary\"}]}\n"
"    iex> pop_in(list, [Access.at(0), :name])\n"
"    {\"john\", [%{}, %{name: \"mary\"}]}\n"
"\n"
"When the index is out of bounds, `nil` is returned and the update function "
"is never called:\n"
"\n"
"    iex> list = [%{name: \"john\"}, %{name: \"mary\"}]\n"
"    iex> get_in(list, [Access.at(10), :name])\n"
"    nil\n"
"    iex> get_and_update_in(list, [Access.at(10), :name], fn\n"
"    ...>   prev -> {prev, String.upcase(prev)}\n"
"    ...> end)\n"
"    {nil, [%{name: \"john\"}, %{name: \"mary\"}]}\n"
"\n"
"An error is raised for negative indexes:\n"
"\n"
"    iex> get_in([], [Access.at(-1)])\n"
"    ** (FunctionClauseError) no function clause matching in Access.at/1\n"
"\n"
"An error is raised if the accessed structure is not a list:\n"
"\n"
"    iex> get_in(%{}, [Access.at(1)])\n"
"    ** (RuntimeError) Access.at/1 expected a list, got: %{}\n"
msgstr ""
"リストの`index`位置（0ベース）の要素にアクセスする関数を返します。\n"
"\n"
"返される関数は通常`Kernel.get_in/2`や`Kernel.get_and_update_in/3`などのアクセ"
"サに渡されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> list = [%{name: \"john\"}, %{name: \"mary\"}]\n"
"    iex> get_in(list, [Access.at(1), :name])\n"
"    \"mary\"\n"
"    iex> get_and_update_in(list, [Access.at(0), :name], fn\n"
"    ...>   prev -> {prev, String.upcase(prev)}\n"
"    ...> end)\n"
"    {\"john\", [%{name: \"JOHN\"}, %{name: \"mary\"}]}\n"
"\n"
"`at/1`は、リストまたはリストの中のキーから要素を取り出すことにも使用できま"
"す。\n"
"\n"
"    iex> list = [%{name: \"john\"}, %{name: \"mary\"}]\n"
"    iex> pop_in(list, [Access.at(0)])\n"
"    {%{name: \"john\"}, [%{name: \"mary\"}]}\n"
"    iex> pop_in(list, [Access.at(0), :name])\n"
"    {\"john\", [%{}, %{name: \"mary\"}]}\n"
"\n"
"インデックスが範囲外の場合は、`nil`が返され、更新関数は呼ばれません:\n"
"\n"
"    iex> list = [%{name: \"john\"}, %{name: \"mary\"}]\n"
"    iex> get_in(list, [Access.at(10), :name])\n"
"    nil\n"
"    iex> get_and_update_in(list, [Access.at(10), :name], fn\n"
"    ...>   prev -> {prev, String.upcase(prev)}\n"
"    ...> end)\n"
"    {nil, [%{name: \"john\"}, %{name: \"mary\"}]}\n"
"\n"
"負のインデックスを指定するとエラーが発生します:\n"
"\n"
"    iex> get_in([], [Access.at(-1)])\n"
"    ** (FunctionClauseError) no function clause matching in Access.at/1\n"
"\n"
"アクセスされるデータ構造がリストでない場合はエラーが発生します:\n"
"\n"
"    iex> get_in(%{}, [Access.at(1)])\n"
"    ** (RuntimeError) Access.at/1 expected a list, got: %{}\n"

#. TRANSLATORS: def Access.fetch(container, key)
#: lib/access.ex:232
msgid ""
"Fetches the value for the given key in a container (a map, keyword\n"
"list, or struct that implements the `Access` behaviour).\n"
msgstr ""
"コンテナ（マップ、キーワードリスト、または、`Access`ビヘイビアを\n"
"実装している構造体）中の指定されたキーの値をフェッチします。\n"

#. TRANSLATORS: @callback pop/2
#: lib/access.ex:204
msgid ""
"Invoked to \"pop\" the value under `key` out of the given term.\n"
"\n"
"When the key `key` exists in the given `term`, the implementation should\n"
"return a `{value, new_term}` tuple where `value` is the value that was "
"under\n"
"`key` and `new_term` is `term` without `key`.\n"
"\n"
"When the key `key` is not present in the given `term`, a tuple `{value, term}"
"`\n"
"should be returned, where `value` is implementation-defined.\n"
"\n"
"See the implementations for `Map.pop/3` or `Keyword.pop/3` for more "
"examples.\n"
msgstr ""
"指定された項の`key`の値を「pop」するために呼び出されます。\n"
"\n"
"キー`key`が指定された`term`に存在する場合は、実装は`{value, new_term}` \n"
"タプルを返さなければなりません。ここで、`value`は`key`の値で、`new_term`は\n"
"`key`の無い`term`です。\n"
"\n"
"キー`key`が指定された`term`に存在しない場合は、`{value, erm}` タプルを\n"
"返さなければなりません。ここで、`value`は実装依存です。\n"
"\n"
"他の例は、`Map.pop/3`か`Keyword.pop/3`の実装を参照してください。\n"

#. TRANSLATORS: def Access.get(container, key, default \\ nil)
#: lib/access.ex:263
msgid ""
"Gets the value for the given key in a container (a map, keyword\n"
"list, or struct that implements the `Access` behaviour).\n"
msgstr ""
"コンテナ（マップ、キーワードリスト、または、`Access`ビヘイビアを\n"
"実装している構造体）中の指定されたキーの値を取り出します。\n"

#. TRANSLATORS: def Access.key!(key)
#: lib/access.ex:435
msgid ""
"Returns a function that accesses the given key in a map/struct.\n"
"\n"
"The returned function is typically passed as an accessor to `Kernel."
"get_in/2`,\n"
"`Kernel.get_and_update_in/3`, and friends.\n"
"\n"
"Raises if the key does not exist.\n"
"\n"
"## Examples\n"
"\n"
"    iex> map = %{user: %{name: \"john\"}}\n"
"    iex> get_in(map, [Access.key!(:user), Access.key!(:name)])\n"
"    \"john\"\n"
"    iex> get_and_update_in(map, [Access.key!(:user), Access.key!(:name)], "
"fn\n"
"    ...>   prev -> {prev, String.upcase(prev)}\n"
"    ...> end)\n"
"    {\"john\", %{user: %{name: \"JOHN\"}}}\n"
"    iex> pop_in(map, [Access.key!(:user), Access.key!(:name)])\n"
"    {\"john\", %{user: %{}}}\n"
"    iex> get_in(map, [Access.key!(:user), Access.key!(:unknown)])\n"
"    ** (KeyError) key :unknown not found in: %{name: \"john\"}\n"
"\n"
"An error is raised if the accessed structure is not a map/struct:\n"
"\n"
"    iex> get_in([], [Access.key!(:foo)])\n"
"    ** (RuntimeError) Access.key!/1 expected a map/struct, got: []\n"
"\n"
msgstr ""
"マップまたは構造体の指定されたキーにアクセスする関数を返します。\n"
"\n"
"返される関数は通常`Kernel.get_in/2`や`Kernel.get_and_update_in/3`などのアクセ"
"サに渡されます。\n"
"\n"
"キーが存在しない場合は例外を発生します。\n"
"\n"
"## 例\n"
"\n"
"    iex> map = %{user: %{name: \"john\"}}\n"
"    iex> get_in(map, [Access.key!(:user), Access.key!(:name)])\n"
"    \"john\"\n"
"    iex> get_and_update_in(map, [Access.key!(:user), Access.key!(:name)], "
"fn\n"
"    ...>   prev -> {prev, String.upcase(prev)}\n"
"    ...> end)\n"
"    {\"john\", %{user: %{name: \"JOHN\"}}}\n"
"    iex> pop_in(map, [Access.key!(:user), Access.key!(:name)])\n"
"    {\"john\", %{user: %{}}}\n"
"    iex> get_in(map, [Access.key!(:user), Access.key!(:unknown)])\n"
"    ** (KeyError) key :unknown not found in: %{name: \"john\"}\n"
"\n"
"アクセスされるデータ構造がマップまたは構造体でない場合はエラーが発生しま"
"す。\n"
"\n"
"    iex> get_in([], [Access.key!(:foo)])\n"
"    ** (RuntimeError) Access.key!/1 expected a map/struct, got: []\n"
"\n"

#. TRANSLATORS: Elixir.Access Summary
#: lib/access.ex:2
msgid ""
"Key-based access to data structures using the `data[key]` syntax.\n"
"\n"
"Elixir provides two syntaxes for accessing values. `user[:name]`\n"
"is used by dynamic structures, like maps and keywords, while\n"
"`user.name` is used by structs. The main difference is that\n"
"`user[:name]` won't raise if the key `:name` is missing but\n"
"`user.name` will raise if there is no `:name` key.\n"
"\n"
"Besides the cases above, this module provides convenience\n"
"functions for accessing other structures, like `at/1` for\n"
"lists and `elem/1` for tuples. Those functions can be used\n"
"by the nested update functions in `Kernel`, such as\n"
"`Kernel.get_in/2`, `Kernel.put_in/3`, `Kernel.update_in/3`,\n"
"`Kernel.get_and_update_in/3` and friends.\n"
"\n"
"## Dynamic lookups\n"
"\n"
"Out of the box, `Access` works with `Keyword` and `Map`:\n"
"\n"
"    iex> keywords = [a: 1, b: 2]\n"
"    iex> keywords[:a]\n"
"    1\n"
"\n"
"    iex> map = %{a: 1, b: 2}\n"
"    iex> map[:a]\n"
"    1\n"
"\n"
"    iex> star_ratings = %{1.0 => \"★\", 1.5 => \"★☆\", 2.0 => \"★★\"}\n"
"    iex> star_ratings[1.5]\n"
"    \"★☆\"\n"
"\n"
"Note that the dynamic lookup syntax (`term[key]`) roughly translates to\n"
"`Access.get(term, key, nil)`.\n"
"\n"
"`Access` can be combined with `Kernel.put_in/3` to put a value\n"
"in a given key:\n"
"\n"
"    iex> map = %{a: 1, b: 2}\n"
"    iex> put_in map[:a], 3\n"
"    %{a: 3, b: 2}\n"
"\n"
"This syntax is very convenient as it can be nested arbitrarily:\n"
"\n"
"    iex> users = %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}\n"
"    iex> put_in users[\"john\"][:age], 28\n"
"    %{\"john\" => %{age: 28}, \"meg\" => %{age: 23}}\n"
"\n"
"Furthermore, `Access` transparently ignores `nil` values:\n"
"\n"
"    iex> keywords = [a: 1, b: 2]\n"
"    iex> keywords[:c][:unknown]\n"
"    nil\n"
"\n"
"Since `Access` is a behaviour, it can be implemented for key-value\n"
"data structures. The implementation should be added to the\n"
"module that defines the struct being accessed. `Access` requires the\n"
"key comparison to be implemented using the `===` operator.\n"
"\n"
"## Static lookups\n"
"\n"
"The `Access` syntax (`foo[bar]`) cannot be used to access fields in\n"
"structs, since structs do not implement the `Access` behaviour by\n"
"default. It is also a design decision: the dynamic access lookup\n"
"is meant to be used for dynamic key-value structures, like maps\n"
"and keywords, and not by static ones like structs (where fields are\n"
"known and not dynamic).\n"
"\n"
"Therefore Elixir provides a static lookup for struct fields and for atom\n"
"fields in maps. Imagine a struct named `User` with a `:name` field.\n"
"The following would raise:\n"
"\n"
"    user = %User{name: \"John\"}\n"
"    user[:name]\n"
"    # ** (UndefinedFunctionError) undefined function User.fetch/2\n"
"    #    (User does not implement the Access behaviour)\n"
"\n"
"Structs instead use the `user.name` syntax to access fields:\n"
"\n"
"    user.name\n"
"    #=> \"John\"\n"
"\n"
"The same `user.name` syntax can also be used by `Kernel.put_in/2`\n"
"to for updating structs fields:\n"
"\n"
"    put_in user.name, \"Mary\"\n"
"    #=> %User{name: \"Mary\"}\n"
"\n"
"Differently from `user[:name]`, `user.name` is not extensible via\n"
"a behaviour and is restricted only to structs and atom keys in maps.\n"
"\n"
"As mentioned above, this works for atom keys in maps as well. Refer to the\n"
"`Map` module for more information on this.\n"
"\n"
"Summing up:\n"
"\n"
"  * `user[:name]` is used by dynamic structures, is extensible and\n"
"    does not raise on missing keys\n"
"  * `user.name` is used by static structures, it is not extensible\n"
"    and it will raise on missing keys\n"
"\n"
"## Accessors\n"
"\n"
"While Elixir provides built-in syntax only for traversing dynamic\n"
"and static key-value structures, this module provides convenience\n"
"functions for traversing other structures, like tuples and lists,\n"
"to be used alongside `Kernel.put_in/2` in others.\n"
"\n"
"For instance, given a user with a list of languages, here is how to\n"
"deeply traverse the map and convert all language names to uppercase:\n"
"\n"
"    iex> user = %{name: \"john\",\n"
"    ...>          languages: [%{name: \"elixir\", type: :functional},\n"
"    ...>                      %{name: \"c\", type: :procedural}]}\n"
"    iex> update_in user, [:languages, Access.all(), :name], &String."
"upcase/1\n"
"    %{name: \"john\",\n"
"      languages: [%{name: \"ELIXIR\", type: :functional},\n"
"                  %{name: \"C\", type: :procedural}]}\n"
"\n"
"See the functions `key/1`, `key!/1`, `elem/1`, and `all/0` for some of the\n"
"available accessors.\n"
"\n"
"## Implementing the Access behaviour for custom data structures\n"
"\n"
"In order to be able to use the `Access` protocol with custom data "
"structures\n"
"(which have to be structs), such structures have to implement the `Access`\n"
"behaviour. For example, for a `User` struct, this would have to be done:\n"
"\n"
"    defmodule User do\n"
"      defstruct [:name, :email]\n"
"\n"
"      @behaviour Access\n"
"      # Implementation of the Access callbacks...\n"
"    end\n"
"\n"
msgstr ""
"`foo[bar]`構文を使用するデータ構造へのキーベースのアクセスです。\n"
"\n"
"Elixirは値にアクセスする2つの構文を提供しています。\n"
"`user[:name]`は、マップやキーワードのような動的なデータ構造で、\n"
"`user.name`は構造体で使われます。主な違いは、`user[:name]`はキー\n"
"`:name`が無くても例外を発生しないのに対して、`user.name`は\n"
"`:name`キーが無いと例外を発生する点です。\n"
"\n"
"上記以外にも、このモジュールは他のデータ構造にアクセスる便利な\n"
"関数を提供しています。リストのための`at/1`やタプルのための`elem/1`\n"
"などです。これらの関数は、`Kernel.get_in/2`, `Kernel.put_in/3`,\n"
"`Kernel.update_in/3`, `Kernel.get_and_update_in/3`などの\n"
"`Kernel`モジュールの入れ子の更新関数でも使うことができます。\n"
"\n"
"## 動的検索\n"
"\n"
"インストールするとすぐに`Access`は`Keyword`と`Map`で使えます:\n"
"\n"
"    iex> keywords = [a: 1, b: 2]\n"
"    iex> keywords[:a]\n"
"    1\n"
"\n"
"    iex> map = %{a: 1, b: 2}\n"
"    iex> map[:a]\n"
"    1\n"
"\n"
"    iex> star_ratings = %{1.0 => \"★\", 1.5 => \"★☆\", 2.0 => \"★★\"}\n"
"    iex> star_ratings[1.5]\n"
"    \"★☆\"\n"
"\n"
"動的検索構文（`term[key]`）はおおよそ`Access.get(term, key, nil)`に\n"
"翻訳されます。\n"
"\n"
"`Access`は指定されたキーに値をputするために`Kernel.put_in/3`と組み合わせる\n"
"ことができます:\n"
"\n"
"    iex> map = %{a: 1, b: 2}\n"
"    iex> put_in map[:a], 3\n"
"    %{a: 3, b: 2}\n"
"\n"
"この構文は自由に入れ子にすることができるので非常に便利です:\n"
"\n"
"    iex> users = %{\"john\" => %{age: 27}, \"meg\" => %{age: 23}}\n"
"    iex> put_in users[\"john\"][:age], 28\n"
"    %{\"john\" => %{age: 28}, \"meg\" => %{age: 23}}\n"
"\n"
"さらに、`Access`は`nil`値を透過的に無視します:\n"
"\n"
"    iex> keywords = [a: 1, b: 2]\n"
"    iex> keywords[:c][:unknown]\n"
"    nil\n"
"\n"
"`Access`はビヘイビアなので、key-valueデータ構造のために実装することが\n"
"できます。実装はアクセスされる構造体を定義するモジュールに追加されなければ\n"
"なりません。`Access`はキーの比較を`===`演算子を使って実装することを\n"
"要求します。\n"
"\n"
"## 静的検索\n"
"\n"
"`Access`構文（`foo[bar]`）は構造体のフィールにアクセスすることには\n"
"使用できません。構造体はデフォルトでは`Access`ビヘイビアを実装して\n"
"いないからです。また、設計上の判断もあります。動的アクセス検索は、\n"
"マップやキーワードのような動的なkey-valueデータ構造で使用されることを\n"
"意図しており、構造体（フィールドは既知であり動的なものではありません）\n"
"のような静的データ構造で使用されることは意図していません。\n"
"\n"
"それゆえ、Elixirは構造体のフィールドとマップのアトムフィールド向けに\n"
"静的検索を提供しています。`:name`フィールドを持つ`User`という\n"
"名前の構造体を考えます。次は例外が発生します:\n"
"\n"
"    user = %User{name: \"John\"}\n"
"    user[:name]\n"
"    # ** (UndefinedFunctionError) undefined function User.fetch/2\n"
"    #    (User does not implement the Access behaviour)\n"
"\n"
"構造体ではフィールドにアクセスするには`user.name`構文を代わりに使います:\n"
"\n"
"    user.name\n"
"    #=> \"John\"\n"
"\n"
"同じ`user.name`構文を、構造体のフィールドを更新する\n"
"`Kernel.put_in/2`でも使用することができます:\n"
"\n"
"    put_in user.name, \"Mary\"\n"
"    #=> %User{name: \"Mary\"}\n"
"\n"
"`user[:name]`とは異なり`user.name`はビヘイビアによる拡張ができません。\n"
"また、構造体とマップのアトムキーに制限されています。\n"
"\n"
"上で述べたように、これはマップのアトムキーでも動作します。これの詳細は\n"
"`Map`モジュールのを参照してください。\n"
"\n"
"要約すると:\n"
"\n"
"  * `user[:name]` は動的データ構造で使い、拡張可能で、キーがなくても\n"
"    例外が発生しません\n"
"  * `user.name` は静的データ構造で使い、拡張不可能で、キーがないと\n"
"    例外が発生します\n"
"\n"
"## アクセサ\n"
"\n"
"Elixirは、動的および静的なkey-valueデータ構造のトラバース用にしか\n"
"組み込み構文を提供していませんが、このモジュールは、`Kernel.put_in/2`\n"
"などと一緒に使用される、リストやタプルなどの他のデータ構造をトラバース\n"
"するための便利な関数を提供しています。\n"
"\n"
"たとえば、言語のリストを持つユーザがあるとして、以下はマップを深く\n"
"深くトラバースして、すべての言語名を大文字化する方法です。\n"
"\n"
"    iex> user = %{name: \"john\",\n"
"    ...>          languages: [%{name: \"elixir\", type: :functional},\n"
"    ...>                      %{name: \"c\", type: :procedural}]}\n"
"    iex> update_in user, [:languages, Access.all(), :name], &String."
"upcase/1\n"
"    %{name: \"john\",\n"
"      languages: [%{name: \"ELIXIR\", type: :functional},\n"
"                  %{name: \"C\", type: :procedural}]}\n"
"\n"
"利用可能なアクセサとしては関数`key/1`, `key!/1`, `elem/1`,  `all/0`を\n"
"参照してください。\n"
"\n"
"## カスタムデータ構造用のAccessビヘイビアの実装\n"
"\n"
"カスタムデータ構造（これは構造体でなければなりません）で`Access`\n"
"プロトコルを使えるようにするには、`Access`ビヘイビアを実装しなければ\n"
"なりません。たとえば、`User`構造体では以下を行わなければなりません:\n"
"\n"
"    defmodule User do\n"
"      defstruct [:name, :email]\n"
"\n"
"      @behaviour Access\n"
"      # Accessコールバックの実装...\n"
"    end\n"
"\n"

#. TRANSLATORS: def Access.pop(container, key)
#: lib/access.ex:313
msgid ""
"Removes the entry with a given key from a container (a map, keyword\n"
"list, or struct that implements the `Access` behaviour).\n"
"\n"
"Returns a tuple containing the value associated with the key and the\n"
"updated container. `nil` is returned for the value if the key isn't\n"
"in the container.\n"
"\n"
"## Examples\n"
"\n"
"With a map:\n"
"\n"
"    iex> Access.pop(%{name: \"Elixir\", creator: \"Valim\"}, :name)\n"
"    {\"Elixir\", %{creator: \"Valim\"}}\n"
"\n"
"A keyword list:\n"
"\n"
"    iex> Access.pop([name: \"Elixir\", creator: \"Valim\"], :name)\n"
"    {\"Elixir\", [creator: \"Valim\"]}\n"
"\n"
"An unknown key:\n"
"\n"
"    iex> Access.pop(%{name: \"Elixir\", creator: \"Valim\"}, :year)\n"
"    {nil, %{creator: \"Valim\", name: \"Elixir\"}}\n"
"\n"
msgstr ""
"コンテナ（マップ、キーワードリスト、または、`Access`ビヘイビアを\n"
"実装している構造体）から指定されたキーを持つエントリを削除します。\n"
"\n"
"キーに関連づけられた値と更新されたコンテナを持つタプルを返します。\n"
"キーがコンテナに存在しない場合は、値として\n"
"`nil`が返ります。\n"
"\n"
"## 例\n"
"\n"
"マップ:\n"
"\n"
"    iex> Access.pop(%{name: \"Elixir\", creator: \"Valim\"}, :name)\n"
"    {\"Elixir\", %{creator: \"Valim\"}}\n"
"\n"
"キーワードリスト:\n"
"\n"
"    iex> Access.pop([name: \"Elixir\", creator: \"Valim\"], :name)\n"
"    {\"Elixir\", [creator: \"Valim\"]}\n"
"\n"
"未知のキー:\n"
"\n"
"    iex> Access.pop(%{name: \"Elixir\", creator: \"Valim\"}, :year)\n"
"    {nil, %{creator: \"Valim\", name: \"Elixir\"}}\n"
"\n"

#. TRANSLATORS: def Access.key(key, default)
#: lib/access.ex:383
msgid ""
"Returns a function that accesses the given key in a map/struct.\n"
"\n"
"The returned function is typically passed as an accessor to `Kernel."
"get_in/2`,\n"
"`Kernel.get_and_update_in/3`, and friends.\n"
"\n"
"The returned function uses the default value if the key does not exist.\n"
"This can be used to specify defaults and safely traverse missing keys:\n"
"\n"
"    iex> get_in(%{}, [Access.key(:user, %{}), Access.key(:name, nil)])\n"
"    nil\n"
"\n"
"Such is also useful when using update functions, allowing us to introduce\n"
"values as we traverse the data-structure for updates:\n"
"\n"
"    iex> put_in(%{}, [Access.key(:user, %{}), Access.key(:name, nil)], \"Mary"
"\")\n"
"    %{user: %{name: \"Mary\"}}\n"
"\n"
"## Examples\n"
"\n"
"    iex> map = %{user: %{name: \"john\"}}\n"
"    iex> get_in(map, [Access.key(:unknown, %{}), Access.key(:name, \"john"
"\")])\n"
"    \"john\"\n"
"    iex> get_and_update_in(map, [Access.key!(:user), Access.key!(:name)], "
"fn\n"
"    ...>   prev -> {prev, String.upcase(prev)}\n"
"    ...> end)\n"
"    {\"john\", %{user: %{name: \"JOHN\"}}}\n"
"    iex> pop_in(map, [Access.key!(:user), Access.key!(:name)])\n"
"    {\"john\", %{user: %{}}}\n"
"\n"
"An error is raised if the accessed structure is not a map or a struct:\n"
"\n"
"    iex> get_in(nil, [Access.key(:foo, nil)])\n"
"    ** (BadMapError) expected a map, got: nil\n"
"\n"
"    iex> get_in([], [Access.key(:foo, nil)])\n"
"    ** (BadMapError) expected a map, got: []\n"
"\n"
msgstr ""
"マップまたは構造体の指定されたキーにアクセスする関数を返します。\n"
"\n"
"返される関数は通常`Kernel.get_in/2`や`Kernel.get_and_update_in/3`などのアクセ"
"サに渡されます。\n"
"\n"
"返される関数はキーが存在しない場合デフォルト値を使用します。\n"
"デフォルト値を指定することでキーが欠落しても安全にトラバースすることができま"
"す。\n"
"\n"
"\n"
"    iex> get_in(%{}, [Access.key(:user, %{}), Access.key(:name, nil)])\n"
"    nil\n"
"\n"
"更新するためにデータ構造をトラバースする際に値を導入することができますの"
"で、\n"
"更新関数を利用する際にも役立ちます。\n"
"\n"
"    iex> put_in(%{}, [Access.key(:user, %{}), Access.key(:name, nil)], \"Mary"
"\")\n"
"    %{user: %{name: \"Mary\"}}\n"
"\n"
"## 例\n"
"\n"
"    iex> map = %{user: %{name: \"john\"}}\n"
"    iex> get_in(map, [Access.key(:unknown, %{}), Access.key(:name, \"john"
"\")])\n"
"    \"john\"\n"
"    iex> get_and_update_in(map, [Access.key!(:user), Access.key!(:name)], "
"fn\n"
"    ...>   prev -> {prev, String.upcase(prev)}\n"
"    ...> end)\n"
"    {\"john\", %{user: %{name: \"JOHN\"}}}\n"
"    iex> pop_in(map, [Access.key!(:user), Access.key!(:name)])\n"
"    {\"john\", %{user: %{}}}\n"
"\n"
"アクセスされるデータ構造がマップまたは構造体でない場合はエラーが発生しま"
"す。\n"
"\n"
"    iex> get_in(nil, [Access.key(:foo, nil)])\n"
"    ** (BadMapError) expected a map, got: nil\n"
"\n"
"    iex> get_in([], [Access.key(:foo, nil)])\n"
"    ** (BadMapError) expected a map, got: []\n"
"\n"

#. TRANSLATORS: def Access.get_and_update(container, key, fun)
#: lib/access.ex:275
msgid ""
"Gets and updates the given key in a container (a map, keyword\n"
"list, or struct that implements the `Access` behaviour).\n"
"\n"
"This `fun` argument receives the value of `key` (or `nil` if `key`\n"
"is not present) and must return a two-element tuple: the \"get\" value\n"
"(the retrieved value, which can be operated on before being returned)\n"
"and the new value to be stored under `key`. The `fun` may also\n"
"return `:pop`, implying the current value shall be removed\n"
"from the container and returned.\n"
"\n"
"The returned value is a two-element tuple with the \"get\" value returned "
"by\n"
"`fun` and a new container with the updated value under `key`.\n"
msgstr ""
"コンテナ（マップ、キーワードリスト、または、`Access`ビヘイビアを\n"
"実装している構造体）中の指定されたキーの値を取り出し、更新します。\n"
"\n"
"引数`fun`は`key`の値（または、`key`が存在しない場合は`nil`）を\n"
"受取り、2要素タプルを返さなければなりません: その第1要素は\n"
"”get”値（検索した値で、返す前に操作されます）で、第2要素は\n"
"`key`に格納する新しい値です。`fun`は`:pop`を返すこともできます。\n"
"これは現在値がコンテナから削除され、返されることを\n"
"意味しています。\n"
"\n"
"返り値は2要素タプルで、第1要素は`fun`から返された”get”値で、第2要素は\n"
"`key`の更新された値を含む新しいコンテナです。\n"
"\n"

#. TRANSLATORS: def Access.elem(index)
#: lib/access.ex:478
msgid ""
"Returns a function that accesses the element at the given index in a tuple.\n"
"\n"
"The returned function is typically passed as an accessor to `Kernel."
"get_in/2`,\n"
"`Kernel.get_and_update_in/3`, and friends.\n"
"\n"
"Raises if the index is out of bounds.\n"
"\n"
"## Examples\n"
"\n"
"    iex> map = %{user: {\"john\", 27}}\n"
"    iex> get_in(map, [:user, Access.elem(0)])\n"
"    \"john\"\n"
"    iex> get_and_update_in(map, [:user, Access.elem(0)], fn\n"
"    ...>   prev -> {prev, String.upcase(prev)}\n"
"    ...> end)\n"
"    {\"john\", %{user: {\"JOHN\", 27}}}\n"
"    iex> pop_in(map, [:user, Access.elem(0)])\n"
"    ** (RuntimeError) cannot pop data from a tuple\n"
"\n"
"An error is raised if the accessed structure is not a tuple:\n"
"\n"
"    iex> get_in(%{}, [Access.elem(0)])\n"
"    ** (RuntimeError) Access.elem/1 expected a tuple, got: %{}\n"
"\n"
msgstr ""
"タプルの指定されたインデックスの要素にアクセスする関数を返します。\n"
"\n"
"返される関数は通常`Kernel.get_in/2`や`Kernel.get_and_update_in/3`などのアクセ"
"サに渡されます。\n"
"\n"
"インデックスが範囲外の場合は例外を発生します。\n"
"\n"
"## 例\n"
"\n"
"    iex> map = %{user: {\"john\", 27}}\n"
"    iex> get_in(map, [:user, Access.elem(0)])\n"
"    \"john\"\n"
"    iex> get_and_update_in(map, [:user, Access.elem(0)], fn\n"
"    ...>   prev -> {prev, String.upcase(prev)}\n"
"    ...> end)\n"
"    {\"john\", %{user: {\"JOHN\", 27}}}\n"
"    iex> pop_in(map, [:user, Access.elem(0)])\n"
"    ** (RuntimeError) cannot pop data from a tuple\n"
"\n"
"アクセスされるデータ構造がタプルでない場合はエラーが発生します。\n"
"\n"
"    iex> get_in(%{}, [Access.elem(0)])\n"
"    ** (RuntimeError) Access.elem/1 expected a tuple, got: %{}\n"
"\n"

#. TRANSLATORS: @callback fetch/2
#: lib/access.ex:143
msgid ""
"Invoked in order to access the value stored under `key` in the given term "
"`term`.\n"
"\n"
"This function should return `{:ok, value}` where `value` is the value under\n"
"`key` if it succeeded, or `:error` if the key does not exist in the "
"structure.\n"
"\n"
"Many of the functions defined in the `Access` module internally call this\n"
"function. This function is also used when the square-brackets access syntax\n"
"(`structure[key]`) is used: the `fetch/2` callback implemented by the "
"module\n"
"that defines the `structure` struct is invoked and if it returns `{:ok,\n"
"value}` then `value` is returned, or if it returns `:error` then `nil` is\n"
"returned.\n"
"\n"
"\n"
"See the `Map.fetch/2` and `Keyword.fetch/2` implementations for examples of\n"
"how to implement this callback.\n"
msgstr ""
"指定された項`term`内の`key`に格納されている値にアクセスするために呼び出されま"
"す。\n"
"\n"
"この関数は成功した場合は、`{:ok, valu}`を返さなければなりません。ここで、"
"`value`は\n"
"`key`の値です。キーがデータ構造に存在しない場合は`:error`を返さなければなりま"
"せん。\n"
"\n"
"`Access`モジュールで定義されている多くの関数は、内部でこの関数を呼び出して\n"
"います。また、この関数は角かっこアクセス構文（`structure[key]`）が使用\n"
"される際にも使われます: `structure`構造体を定義するモジュールで実装\n"
"されているコールバック`fetch/2`が呼び出され、それが`{:ok, value}`を\n"
"返したら`value`を、`:error`を返したら`nil`を\n"
"返します。\n"
"\n"
"\n"
"このコールバックの実装方法の例は`Map.fetch/2`と`Keyword.fetch/2`の\n"
"実装を参照してください。\n"

#. TRANSLATORS: def Access.all()
#: lib/access.ex:521
msgid ""
"Returns a function that accesses all the elements in a list.\n"
"\n"
"The returned function is typically passed as an accessor to `Kernel."
"get_in/2`,\n"
"`Kernel.get_and_update_in/3`, and friends.\n"
"\n"
"## Examples\n"
"\n"
"    iex> list = [%{name: \"john\"}, %{name: \"mary\"}]\n"
"    iex> get_in(list, [Access.all(), :name])\n"
"    [\"john\", \"mary\"]\n"
"    iex> get_and_update_in(list, [Access.all(), :name], fn\n"
"    ...>   prev -> {prev, String.upcase(prev)}\n"
"    ...> end)\n"
"    {[\"john\", \"mary\"], [%{name: \"JOHN\"}, %{name: \"MARY\"}]}\n"
"    iex> pop_in(list, [Access.all(), :name])\n"
"    {[\"john\", \"mary\"], [%{}, %{}]}\n"
"\n"
"Here is an example that traverses the list dropping even\n"
"numbers and multipling odd numbers by 2:\n"
"\n"
"    iex> require Integer\n"
"    iex> get_and_update_in([1, 2, 3, 4, 5], [Access.all], fn\n"
"    ...>   num -> if Integer.is_even(num), do: :pop, else: {num, num * 2}\n"
"    ...> end)\n"
"    {[1, 2, 3, 4, 5], [2, 6, 10]}\n"
"\n"
"An error is raised if the accessed structure is not a list:\n"
"\n"
"    iex> get_in(%{}, [Access.all()])\n"
"    ** (RuntimeError) Access.all/0 expected a list, got: %{}\n"
"\n"
msgstr ""
"リストのすべての要素にアクセスする関数を返します。\n"
"\n"
"返される関数は通常`Kernel.get_in/2`や`Kernel.get_and_update_in/3`などのアクセ"
"サに渡されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> list = [%{name: \"john\"}, %{name: \"mary\"}]\n"
"    iex> get_in(list, [Access.all(), :name])\n"
"    [\"john\", \"mary\"]\n"
"    iex> get_and_update_in(list, [Access.all(), :name], fn\n"
"    ...>   prev -> {prev, String.upcase(prev)}\n"
"    ...> end)\n"
"    {[\"john\", \"mary\"], [%{name: \"JOHN\"}, %{name: \"MARY\"}]}\n"
"    iex> pop_in(list, [Access.all(), :name])\n"
"    {[\"john\", \"mary\"], [%{}, %{}]}\n"
"\n"
"以下はリストをトラバースして偶数を落とし、奇数を2倍する例です。\n"
"\n"
"    iex> require Integer\n"
"    iex> get_and_update_in([1, 2, 3, 4, 5], [Access.all], fn\n"
"    ...>   num -> if Integer.is_even(num), do: :pop, else: {num, num * 2}\n"
"    ...> end)\n"
"    {[1, 2, 3, 4, 5], [2, 6, 10]}\n"
"\n"
"アクセスされるデータ構造がリストでない場合はエラーが発生します。\n"
"\n"
"    iex> get_in(%{}, [Access.all()])\n"
"    ** (RuntimeError) Access.all/0 expected a list, got: %{}\n"
"\n"

#. TRANSLATORS: @callback get/3
#: lib/access.ex:162
msgid ""
"Invoked in order to access the value stored under `key` in the given term "
"`term`,\n"
"defaulting to `default` if not present.\n"
"\n"
"This function should return the value under the key `key` in `term` if "
"there's\n"
"such key, otherwise `default`.\n"
"\n"
"For most data structures, this can be implemented using `fetch/2` "
"internally;\n"
"for example:\n"
"\n"
"    def get(structure, key, default) do\n"
"      case fetch(structure, key) do\n"
"        {:ok, value} -> value\n"
"        :error       -> default\n"
"      end\n"
"    end\n"
"\n"
"See the `Map.get/3` and `Keyword.get/3` implementations for more examples.\n"
msgstr ""
"指定された項`term`内の`key`に格納されている値にアクセスするために呼び出されま"
"す。\n"
"存在しない場合は`default`をデフォルトにします。\n"
"\n"
"この関数は`term`に`key`が存在する場合はその値を、そうでない場合は`default`"
"を\n"
"返さなければなりません。\n"
"\n"
"ほとんどのデータ構造では、これは内部で`fetch/2`を使って実装することができま"
"す。\n"
"たとえば:\n"
"\n"
"    def get(structure, key, default) do\n"
"      case fetch(structure, key) do\n"
"        {:ok, value} -> value\n"
"        :error       -> default\n"
"      end\n"
"    end\n"
"\n"
"他の例は`Map.get/3`と`Keyword.get/3`の実装を参照してください。\n"

#. TRANSLATORS: @callback get_and_update/3
#: lib/access.ex:183
msgid ""
"Invoked in order to access the value under `key` and update it at the same "
"time.\n"
"\n"
"The implementation of this callback should invoke the passed function with "
"the\n"
"value under key `key` in the passed structure, or `nil` if the key is not\n"
"present. This function should return either `{value_to_return, new_value}` "
"or\n"
"`:pop`.\n"
"\n"
"If it returns `{value_to_return, new_value}`, the return value of this\n"
"callback should be `{value_to_return, new_term}` where `new_term` is `term`\n"
"after updating the value of `key` with `new_value`.\n"
"\n"
"If it returns `:pop`, the return value of this callback should be `{value,\n"
"new_term}` where `value` is the value under `key` or `nil` if not present, "
"and\n"
"`new_term` is `term` without the key `key`.\n"
"\n"
"See the implementations of `Map.get_and_update/3` or `Keyword."
"get_and_update/3`\n"
"for more examples.\n"
msgstr ""
"`key`の値にアクセスし、同時にそれを更新するために呼び出されます。\n"
"\n"
"このコールバックの実装は、渡された関数を渡されたデータ構造の`key`の\n"
"値を、キーが存在しない場合は`nil`を引数に呼び出さなければなりません。\n"
"この関数は`{value_to_return, new_value}`か`:pop`のいずれかを返さなければなり"
"ません。\n"
"\n"
"`{value_to_return, new_value}`を帰す場合は、このコールバックの返り値は\n"
"`{value_to_return, new_value}`でなければなりません。ここで、`new_term`は\n"
"`key`の値を`new_value`で更新した後の`term`です。\n"
"\n"
"他の例は`Map.get_and_update/3`か`Keyword.get_and_update/3`の\n"
"実装を参照してください。\n"

#~ msgid "Fetches the container's value for the given key.\n"
#~ msgstr "与えられたキーに対するコンテナの値を取得します。\n"

#~ msgid ""
#~ "Gets and updates the container's value for the given key, in a single "
#~ "pass.\n"
#~ "\n"
#~ "The argument function `fun` must receive the value for the given `key` "
#~ "(or\n"
#~ "`nil` if the key doesn't exist in `container`). It must return a tuple\n"
#~ "containing the `get` value and the new value to be stored in the "
#~ "`container`.\n"
#~ "\n"
#~ "This function returns a two-element tuple.\n"
#~ "The first element is the `get` value, as returned by `fun`.\n"
#~ "The second element is the container, updated with the value returned by "
#~ "`fun`.\n"
#~ msgstr ""
#~ "一度のパスで、与えられたkeyの値を取得し、コンテナを更新します。\n"
#~ "\n"
#~ "引数の関数`fun`は、与えられた`key`の値(`container`にキーが\n"
#~ "存在しない場合は、`nil`)を受け取り、`get`した値と、\n"
#~ "`container`に保存された新しい値を含むタプルを返さなくてはなりません。\n"
#~ "\n"
#~ "この関数は2要素のタプルを返します。\n"
#~ "最初の要素は、`fun`から返された`get`した値です。\n"
#~ "二つめの要素は、`fun`から返された値で更新されたコンテナです。\n"

#~ msgid "Gets the container's value for the given key.\n"
#~ msgstr "与えられたキーに対するコンテナの値を取得します。\n"
