msgid ""
msgstr ""
"Project-Id-Version: l 10n_elixir\n"
"POT-Creation-Date: \n"
"PO-Revision-Date: 2017-02-02 15:40+0900\n"
"Last-Translator: 小田 照敬 <EMAIL@ADDRESS>\n"
"Language-Team: Japanese\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Poedit 1.8.11\n"

#. TRANSLATORS: def IO.binwrite(device \\ :stdio, item)
#: lib/io.ex:163
msgid ""
"Writes `item` as a binary to the given `device`.\n"
"No Unicode conversion happens.\n"
"The operation is Unicode unsafe.\n"
"\n"
"Check `write/2` for more information.\n"
"\n"
"Note: do not use this function on IO devices in Unicode mode\n"
"as it will return the wrong result.\n"
msgstr ""
"指定された`device`にバイナリとして`item`を書き込みます。\n"
"Unicode変換はされません。\n"
"操作はUnicodeアンセーフです。。\n"
"\n"
"詳細な情報は`write/2`をチェックしてください。\n"
"\n"
"注意: UnicodeモードのIOデバイスでは間違った結果を返しますので、\n"
"この関数を使わないでください。\n"

#. TRANSLATORS: def IO.inspect(item, opts \\ [])
#: lib/io.ex:231
msgid ""
"Inspects and writes the given `item` to the device.\n"
"\n"
"It's important to note that it returns the given `item` unchanged.\n"
"This makes it possible to \"spy\" on values by inserting an\n"
"`IO.inspect/2` call almost anywhere in your code, for example,\n"
"in the middle of a pipeline.\n"
"\n"
"It enables pretty printing by default with width of\n"
"80 characters. The width can be changed by explicitly\n"
"passing the `:width` option.\n"
"\n"
"The output can be decorated with a label, by providing the `:label`\n"
"option to easily distinguish it from other `IO.inspect/2` calls.\n"
"The label will be printed before the inspected `item`.\n"
"\n"
"See `Inspect.Opts` for a full list of remaining formatting options.\n"
"\n"
"## Examples\n"
"\n"
"    IO.inspect <<0, 1, 2>>, width: 40\n"
"\n"
"Prints:\n"
"\n"
"    <<0, 1, 2>>\n"
"\n"
"We can use the `:label` option to decorate the output:\n"
"\n"
"    IO.inspect 1..100, label: \"a wonderful range\"\n"
"\n"
"Prints:\n"
"\n"
"    a wonderful range: 1..100\n"
"\n"
"The `:label` option is especially useful with pipelines:\n"
"\n"
"    [1, 2, 3]\n"
"    |> IO.inspect(label: \"before\")\n"
"    |> Enum.map(&(&1 * 2))\n"
"    |> IO.inspect(label: \"after\")\n"
"    |> Enum.sum\n"
"\n"
"Prints:\n"
"\n"
"    before: [1, 2, 3]\n"
"    after: [2, 4, 6]\n"
"\n"
msgstr ""
"指定された`item`を検査してデバイスに書き込みます。\n"
"\n"
"指定された`item`を変更せずに返すことに注意することが\n"
"重要です。 これにより、パイプラインの途中など、コードの\n"
"ほとんどどこにでも`IO.inspect/2`を挿入することで、値を\n"
"「スパイ」することが可能になります。\n"
"\n"
"デフォルトでは幅80文字のプリティプリントが可能です。 \n"
"幅は`:width`オプションを明示的に渡すことで変更できます。\n"
"\n"
"`:label`オプションを指定することで出力をラベルで修飾する\n"
"ことができ、他の`IO.inspect/2`呼び出しと簡単に区別できます。\n"
"ラベルは検査された`item`の前に表示されます。\n"
"\n"
"残りの書式設定オプションの完全なリストは`Inspect.Opts`を参照してください。\n"
"\n"
"## 例\n"
"\n"
"    IO.inspect <<0, 1, 2>>, width: 40\n"
"\n"
"出力:\n"
"\n"
"    <<0, 1, 2>>\n"
"\n"
"`:label`オプションを使用して出力を装飾できます:\n"
"\n"
"    IO.inspect 1..100, label: \"a wonderful range\"\n"
"\n"
"出力:\n"
"\n"
"    a wonderful range: 1..100\n"
"\n"
"`:label` オプションはパイプラインで便利です:\n"
"\n"
"    [1, 2, 3]\n"
"    |> IO.inspect(label: \"before\")\n"
"    |> Enum.map(&(&1 * 2))\n"
"    |> IO.inspect(label: \"after\")\n"
"    |> Enum.sum\n"
"\n"
"出力:\n"
"\n"
"    before: [1, 2, 3]\n"
"    after: [2, 4, 6]\n"
"\n"

#. TRANSLATORS: def IO.getn(prompt, count \\ 1)
#: lib/io.ex:298
msgid ""
"Gets a number of bytes from IO device `:stdio`.\n"
"\n"
"If `:stdio` is a Unicode device, `count` implies\n"
"the number of Unicode codepoints to be retrieved.\n"
"Otherwise, `count` is the number of raw bytes to be retrieved.\n"
"\n"
"See `IO.getn/3` for a description of return values.\n"
"\n"
msgstr ""
"IOデバイス`:stdio`からいくらかのバイトを取得します。\n"
"\n"
"`:stdio`がunicodeデバイスの場合、`count`は取得する\n"
"Unicodeのコードポイントの数を意味します。\n"
"そうでなければ、`count`は取得する生のバイトの数です。\n"
"\n"
"返り値の説明については`IO.getn/3`を参照してください。\n"
"\n"

#. TRANSLATORS: def IO.iodata_length(item)
#: lib/io.ex:485
msgid ""
"Returns the size of an iodata.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> IO.iodata_length([1, 2 | <<3, 4>>])\n"
"    4\n"
"\n"
msgstr ""
"iodataのサイズを返します。\n"
"\n"
"コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> IO.iodata_length([1, 2 | <<3, 4>>])\n"
"    4\n"
"\n"

#. TRANSLATORS: def IO.binread(device \\ :stdio, line_or_chars)
#: lib/io.ex:90
msgid ""
"Reads from the IO `device`. The operation is Unicode unsafe.\n"
"\n"
"The `device` is iterated by the given number of bytes or line by line if\n"
"`:line` is given.\n"
"Alternatively, if `:all` is given, then whole `device` is returned.\n"
"\n"
"It returns:\n"
"\n"
"  * `data` - the output bytes\n"
"\n"
"  * `:eof` - end of file was encountered\n"
"\n"
"  * `{:error, reason}` - other (rare) error condition;\n"
"    for instance, `{:error, :estale}` if reading from an\n"
"    NFS volume\n"
"\n"
"If `:all` is given, `:eof` is never returned, but an\n"
"empty string in case the device has reached EOF.\n"
"\n"
"Note: do not use this function on IO devices in Unicode mode\n"
"as it will return the wrong result.\n"
msgstr ""
"IO `device`から読み込みます。操作はUnicodeアンセーフです。\n"
"\n"
"`device`は、指定された数のバイトごと、または`:line`が指定された場合は行ごと"
"に\n"
"繰り返されます。あるいは、`:all`が指定された場合は、\n"
"`device`全体が返されます。\n"
"\n"
"以下を返します:\n"
"\n"
"  * `data` - 出力バイト\n"
"\n"
"  * `:eof` - ファイルの終端に到達\n"
"\n"
"  * `{:error, reason}` - 他の(まれな)エラー状態;\n"
"    たとえば、NFSボリュームから読み込み場合の\n"
"    `{:error, :estale}`。\n"
"\n"
"`:all`が指定された場合、`:eof`は返されませんが、\n"
"デバイスがEOFに達した場合、空文字列が返されます。\n"
"\n"
"注: UnicodeモードのIOデバイスでは誤った結果を返しますので、\n"
"この関数を使用しないでください。\n"

#. TRANSLATORS: def IO.binstream(device, line_or_bytes)
#: lib/io.ex:400
msgid ""
"Converts the IO `device` into an `IO.Stream`. The operation is Unicode "
"unsafe.\n"
"\n"
"An `IO.Stream` implements both `Enumerable` and\n"
"`Collectable`, allowing it to be used for both read\n"
"and write.\n"
"\n"
"The `device` is iterated by the given number of bytes or line by line if\n"
"`:line` is given.\n"
"This reads from the IO device as a raw binary.\n"
"\n"
"Note that an IO stream has side effects and every time\n"
"you go over the stream you may get different results.\n"
"\n"
"Finally, do not use this function on IO devices in Unicode\n"
"mode as it will return the wrong result.\n"
"\n"
msgstr ""
"IO `device`を`IO.Stream`に変換します。この操作はUnicodeアンセーフです。\n"
"\n"
"`IO.Stream`は、`Enumerable`と`Collectable`の両方を実装\n"
"していますので、読み込みと書き込みの両方で使用できます。\n"
"\n"
"`device`は、指定された数の文字ごと、または、`:line`が指定された場合は\n"
"行ごとに繰り返されます。\n"
"これは生のバイナリとしてIOデバイスから読み込みます。\n"
"\n"
"IOストリームには副作用があり、ストリームを調べるたびに、\n"
"異なる結果を得る場合があることに注意してください。\n"
"\n"
"最後に、UnicodeモードのIOデバイスでは間違った結果を返しますので、\n"
"この関数を使わないでください。\n"

#. TRANSLATORS: def IO.puts(device \\ :stdio, item)
#: lib/io.ex:178
msgid ""
"Writes `item` to the given `device`, similar to `write/2`,\n"
"but adds a newline at the end.\n"
msgstr ""
"指定された`device`に`item`を書き込みます。`write/2`と似ていますが、\n"
"最後に改行を付加します。\n"
"\n"

#. TRANSLATORS: def IO.write(device \\ :stdio, item)
#: lib/io.ex:143
msgid ""
"Writes `item` to the given `device`.\n"
"\n"
"By default the `device` is the standard output.\n"
"It returns `:ok` if it succeeds.\n"
"\n"
"## Examples\n"
"\n"
"    IO.write \"sample\"\n"
"    #=> sample\n"
"\n"
"    IO.write :stderr, \"error\"\n"
"    #=> error\n"
"\n"
msgstr ""
"指定した`device`に`item`を書き込みます。\n"
"\n"
"デフォルトの`device`は標準出力です。\n"
"成功した場合、`:ok`を返します。\n"
"\n"
"## 例\n"
"\n"
"    IO.write \"sample\"\n"
"    #=> \"sample\"\n"
"\n"
"    IO.write :stderr, \"error\"\n"
"    #=> \"error\"\n"
"\n"

#. TRANSLATORS: def IO.read(device \\ :stdio, line_or_chars)
#: lib/io.ex:47
msgid ""
"Reads from the IO `device`.\n"
"\n"
"The `device` is iterated by the given number of characters or line by line "
"if\n"
"`:line` is given.\n"
"Alternatively, if `:all` is given, then whole `device` is returned.\n"
"\n"
"It returns:\n"
"\n"
"  * `data` - the output characters\n"
"\n"
"  * `:eof` - end of file was encountered\n"
"\n"
"  * `{:error, reason}` - other (rare) error condition;\n"
"    for instance, `{:error, :estale}` if reading from an\n"
"    NFS volume\n"
"\n"
"If `:all` is given, `:eof` is never returned, but an\n"
"empty string in case the device has reached EOF.\n"
msgstr ""
"IO `device`から読み込みます。\n"
"\n"
"`device`は指定された数の文字ごとに、または`:line`が指定された\n"
"場合は行ごとに繰り返されます。\n"
"また、`:all`が指定された場合は、`device`全体が返されます。\n"
"\n"
"以下を返します:\n"
"\n"
"  * `data` - 出力文字\n"
"\n"
"  * `:eof` - ファイルの終端に到達\n"
"\n"
"  * `{:error, reason}` - 他の(まれな)エラー状態;\n"
"    たとえば、NFSボリュームから読み込み場合の\n"
"    `{:error, :estale}`。\n"
"\n"
"`:all`が指定された場合、`:eof`は返されませんが、\n"
"デバイスがEOFに達した場合、空文字列が返されます。\n"

#. TRANSLATORS: def IO.iodata_to_binary(item)
#: lib/io.ex:453
msgid ""
"Converts iodata (a list of integers representing bytes, lists\n"
"and binaries) into a binary.\n"
"The operation is Unicode unsafe.\n"
"\n"
"Notice that this function treats lists of integers as raw bytes\n"
"and does not perform any kind of encoding conversion. If you want\n"
"to convert from a charlist to a string (UTF-8 encoded), please\n"
"use `chardata_to_string/1` instead.\n"
"\n"
"If this function receives a binary, the same binary is returned.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> bin1 = <<1, 2, 3>>\n"
"    iex> bin2 = <<4, 5>>\n"
"    iex> bin3 = <<6>>\n"
"    iex> IO.iodata_to_binary([bin1, 1, [2, 3, bin2], 4 | bin3])\n"
"    <<1, 2, 3, 1, 2, 3, 4, 5, 4, 6>>\n"
"\n"
"    iex> bin = <<1, 2, 3>>\n"
"    iex> IO.iodata_to_binary(bin)\n"
"    <<1, 2, 3>>\n"
"\n"
msgstr ""
"iodata（バイトを表す整数、リスト、バイナリのリスト）を\n"
"バイナリに変換します。\n"
"操作はUnicodeアンセーフです。\n"
"\n"
"この関数は整数のリストを生のバイトとして扱い、いかなるエンコーディング\n"
"変換も実行しないことに注意してください。\n"
"文字リストから(UTF-8エンコードされた)文字列へ変換したい場合は、\n"
"代わりに`chardata_to_string/1`を使用してください。\n"
"\n"
"この関数がバイナリを受け取った場合は、同じバイナリが返されます。\n"
"\n"
"コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> bin1 = <<1, 2, 3>>\n"
"    iex> bin2 = <<4, 5>>\n"
"    iex> bin3 = <<6>>\n"
"    iex> IO.iodata_to_binary([bin1, 1, [2, 3, bin2], 4 | bin3])\n"
"    <<1, 2, 3, 1, 2, 3, 4, 5, 4, 6>>\n"
"\n"
"    iex> bin = <<1, 2, 3>>\n"
"    iex> IO.iodata_to_binary(bin)\n"
"    <<1, 2, 3>>\n"
"\n"

#. TRANSLATORS: def IO.stream(device, line_or_codepoints)
#: lib/io.ex:369
msgid ""
"Converts the IO `device` into an `IO.Stream`.\n"
"\n"
"An `IO.Stream` implements both `Enumerable` and\n"
"`Collectable`, allowing it to be used for both read\n"
"and write.\n"
"\n"
"The `device` is iterated by the given number of characters or line by line "
"if\n"
"`:line` is given.\n"
"\n"
"This reads from the IO as UTF-8. Check out\n"
"`IO.binstream/2` to handle the IO as a raw binary.\n"
"\n"
"Note that an IO stream has side effects and every time\n"
"you go over the stream you may get different results.\n"
"\n"
"## Examples\n"
"\n"
"Here is an example on how we mimic an echo server\n"
"from the command line:\n"
"\n"
"    Enum.each IO.stream(:stdio, :line), &IO.write(&1)\n"
"\n"
msgstr ""
"IO `device`を`IO.Stream`に変換します。\n"
"\n"
"`IO.Stream`は、`Enumerable`と`Collectable`の両方を実装\n"
"していますので、読み込みと書き込みの両方で使用できます。\n"
"\n"
"`device`は、指定された数の文字ごと、または、`:line`が指定された場合は\n"
"行ごとに繰り返されます。\n"
"\n"
"これはUTF-8としてIOから読み込みます。生のバイナリとして\n"
"IOを処理するには`IO.binstream/2`をチェックしてください。\n"
"\n"
"IOストリームには副作用があり、ストリームを調べるたびに、\n"
"異なる結果を得る場合があることに注意してください。\n"
"\n"
"## 例\n"
"\n"
"以下はコマンドラインでエコーサーバをまねる\n"
"例です。\n"
"\n"
"    Enum.each IO.stream(:stdio, :line), &IO.write(&1)\n"
"\n"

#. TRANSLATORS: def IO.gets(device \\ :stdio, prompt)
#: lib/io.ex:343
msgid ""
"Reads a line from the IO `device`.\n"
"\n"
"It returns:\n"
"\n"
"  * `data` - the characters in the line terminated\n"
"    by a line-feed (LF) or end of file (EOF)\n"
"\n"
"  * `:eof` - end of file was encountered\n"
"\n"
"  * `{:error, reason}` - other (rare) error condition;\n"
"    for instance, `{:error, :estale}` if reading from an\n"
"    NFS volume\n"
"\n"
"## Examples\n"
"\n"
"To display \"What is your name?\" as a prompt and await user input:\n"
"\n"
"    IO.gets \"What is your name?\\n\"\n"
"\n"
msgstr ""
"IO`device`から行を読み込みます。\n"
"\n"
"以下を返します:\n"
"\n"
"  * `data` - 改行(LF)またはファイルの終端(EOF)で終わる行の文字\n"
"\n"
"  * `:eof` - ファイルの終端に到達\n"
"\n"
"  * `{:error, reason}` - 他の(まれな)エラー状態;\n"
"    たとえば、NFSボリュームから読み込み場合の\n"
"    `{:error, :estale}`。\n"
"\n"
"## 例\n"
"\n"
"プロンプトとして \"What is your name?\" 表示し、ユーザの入力を待ちます:\n"
"\n"
"    IO.gets \"What is your name?\\n\"\n"
"\n"

#. TRANSLATORS: def IO.inspect(device, item, opts)
#: lib/io.ex:284
msgid ""
"Inspects `item` according to the given options using the IO `device`.\n"
"\n"
"See `inspect/2` for a full list of options.\n"
msgstr ""
"指定されたIO `device`を使用して指定されたオプションに従い`item`を検査しま"
"す。\n"
"\n"
"完全なオプションのリストは`inspect/2`を参照してください。\n"

#. TRANSLATORS: def IO.warn(message, stacktrace)
#: lib/io.ex:187
msgid ""
"Writes a `message` to stderr, along with the given `stacktrace`.\n"
"\n"
"This function also notifies the compiler a warning was printed\n"
"(in case --warnings-as-errors was enabled). It returns `:ok`\n"
"if it succeeds.\n"
"\n"
"An empty list can be passed to avoid stacktrace printing.\n"
"\n"
"## Examples\n"
"\n"
"    stacktrace = [{MyApp, :main, 1, [file: 'my_app.ex', line: 4]}]\n"
"    IO.warn \"variable bar is unused\", stacktrace\n"
"    #=> warning: variable bar is unused\n"
"    #=>   my_app.ex:4: MyApp.main/1\n"
"\n"
msgstr ""
"`message`を指定されたスタックトレースとともにstderrに書き込みます。\n"
"\n"
"この関数は（--warnings-as-errorsが有効の場合）警告が\n"
"出力されたことをコンパイラにも通知します。\n"
"成功した場合は`:ok`を返します。\n"
"\n"
"スタックトレースの出力を避けため、空のリストを渡すことができます。\n"
"\n"
"## 例\n"
"\n"
"    stacktrace = [{MyApp, :main, 1, [file: 'my_app.ex', line: 4]}]\n"
"    IO.warn \"variable bar is unused\", stacktrace\n"
"    #=> warning: variable bar is unused\n"
"    #=>   my_app.ex:4: MyApp.main/1\n"
"\n"

#. TRANSLATORS: def IO.warn(message)
#: lib/io.ex:213
msgid ""
"Writes a `message` to stderr, along with the current stacktrace.\n"
"\n"
"It returns `:ok` if it succeeds.\n"
"\n"
"## Examples\n"
"\n"
"    IO.warn \"variable bar is unused\"\n"
"    #=> warning: variable bar is unused\n"
"    #=>   (iex) evaluator.ex:108: IEx.Evaluator.eval/4\n"
"\n"
msgstr ""
"`message`を現在のスタックトレースとともにstderrに書き込みます。\n"
"\n"
"成功した場合は`:ok`を返します。\n"
"\n"
"## 例\n"
"\n"
"    IO.warn \"variable bar is unused\"\n"
"    #=> warning: variable bar is unused\n"
"    #=>   (iex) evaluator.ex:108: IEx.Evaluator.eval/4\n"
"\n"

#. TRANSLATORS: Elixir.IO Summary
#: lib/io.ex:2
msgid ""
"Functions handling input/output (IO).\n"
"\n"
"Many functions in this module expect an IO device as an argument.\n"
"An IO device must be a PID or an atom representing a process.\n"
"For convenience, Elixir provides `:stdio` and `:stderr` as\n"
"shortcuts to Erlang's `:standard_io` and `:standard_error`.\n"
"\n"
"The majority of the functions expect chardata, i.e. strings or\n"
"lists of characters and strings. In case another type is given,\n"
"functions will convert to string via the `String.Chars` protocol\n"
"(as shown in typespecs).\n"
"\n"
"The functions starting with `bin` expect iodata as an argument,\n"
"i.e. binaries or lists of bytes and binaries.\n"
"\n"
"## IO devices\n"
"\n"
"An IO device may be an atom or a PID. In case it is an atom,\n"
"the atom must be the name of a registered process. In addition,\n"
"Elixir provides two shortcuts:\n"
"\n"
"  * `:stdio` - a shortcut for `:standard_io`, which maps to\n"
"    the current `Process.group_leader/0` in Erlang\n"
"\n"
"  * `:stderr` - a shortcut for the named process `:standard_error`\n"
"    provided in Erlang\n"
"\n"
"IO devices maintain their position, that means subsequent calls to any\n"
"reading or writing functions will start from the place when the device\n"
"was last accessed. Position of files can be changed using the\n"
"`:file.position/2` function.\n"
"\n"
msgstr ""
"入力と出力（IO）を扱う関数です。\n"
"\n"
"このモジュールの多くの関数は、IOデバイスを引数として期待します。\n"
"IOデバイスは、PIDかプロセスを表すアトムでなければなりません。\n"
"便宜上、Elixirは、Erlangの`:standard_io`と`:standard_error`の\n"
"ショートカットとして、`:stdio`と`:stderr`を提供します。\n"
"\n"
"関数の大多数は文字データ、すなわち、文字列、または文字と\n"
"文字列のリストを期待します。\n"
"他のタイプが指定された場合、各関数は`String.Chars`プロトコルにより\n"
"（型仕様に示されているように）文字列に変換します。\n"
"\n"
"`bin`で始まる関数は、引数としてiodata、すなわち、バイナリ、\n"
"またはバイトとバイナリのリストを期待します。\n"
"\n"
"## IOデバイス\n"
"\n"
"IOデバイスはアトムかPIDです。アトムの場合、\n"
"アトムは登録されたプロセスの名前でなくてはなりません。\n"
"さらに、Elixirは2つのショートカットを提供しています。\n"
"\n"
"  * `:stdio` - `:standard_io`のショートカットで、Erlangの\n"
"     現在の`Process.group_leader/0`へマップされます。\n"
"\n"
"  * `:stderr` - Erlangで提供されている名前付きプロセス`:standard_error`の\n"
"     ショートカットです。\n"
"\n"
"IOデバイスはその位置を保持します。これは以降に続く読み書きを行う\n"
"任意の関数呼出しは、デバイスが最後にアクセスされた場所から始まる\n"
"ことを意味します。ファイルの位置は`:file.position/2`関数を使用して\n"
"変更することができます。\n"
"\n"

#. TRANSLATORS: def IO.getn(device, prompt, count)
#: lib/io.ex:320
msgid ""
"Gets a number of bytes from the IO `device`.\n"
"\n"
"If the IO `device` is a Unicode device, `count` implies\n"
"the number of Unicode codepoints to be retrieved.\n"
"Otherwise, `count` is the number of raw bytes to be retrieved.\n"
"\n"
"It returns:\n"
"\n"
"  * `data` - the input characters\n"
"\n"
"  * `:eof` - end of file was encountered\n"
"\n"
"  * `{:error, reason}` - other (rare) error condition;\n"
"    for instance, `{:error, :estale}` if reading from an\n"
"    NFS volume\n"
"\n"
msgstr ""
"IOデバイス`:stdio`からいくらかのバイトを取得します。\n"
"\n"
"`:stdio`がunicodeデバイスの場合、`count`は取得する\n"
"Unicodeのコードポイントの数を意味します。\n"
"そうでなければ、`count`は取得する生のバイトの数です。\n"
"\n"
"以下を返します:\n"
"\n"
"  * `data` - 入力文字列\n"
"\n"
"  * `:eof` - ファイルの終端に\n"
"\n"
"  * `{:error, reason}` - 他の(まれな)エラー状態;\n"
"    たとえば、NFSボリュームから読み込み場合の\n"
"    `{:error, :estale}`。\n"
"\n"
"\n"

#. TRANSLATORS: def IO.chardata_to_string(string)
#: lib/io.ex:425
msgid ""
"Converts chardata (a list of integers representing codepoints,\n"
"lists and strings) into a string.\n"
"\n"
"In case the conversion fails, it raises an `UnicodeConversionError`.\n"
"If a string is given, it returns the string itself.\n"
"\n"
"## Examples\n"
"\n"
"    iex> IO.chardata_to_string([0x00E6, 0x00DF])\n"
"    \"æß\"\n"
"\n"
"    iex> IO.chardata_to_string([0x0061, \"bc\"])\n"
"    \"abc\"\n"
"\n"
"    iex> IO.chardata_to_string(\"string\")\n"
"    \"string\"\n"
"\n"
msgstr ""
"chardata（コードポイントを表す整数、リスト、文字列のリスト）を\n"
"文字列に変換します。\n"
"\n"
"変換に失敗した場合は、`UnicodeConversionError`を発生します。\n"
"文字列が指定された場合は、その文字列自身を返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> IO.chardata_to_string([0x00E6, 0x00DF])\n"
"    \"æß\"\n"
"\n"
"    iex> IO.chardata_to_string([0x0061, \"bc\"])\n"
"    \"abc\"\n"
"\n"
"    iex> IO.chardata_to_string(\"string\")\n"
"    \"string\"\n"
"\n"

#~ msgid ""
#~ "Inspects and writes the given argument to the device.\n"
#~ "\n"
#~ "It enables pretty printing by default with width of\n"
#~ "80 characters. The width can be changed by explicitly\n"
#~ "passing the `:width` option.\n"
#~ "\n"
#~ "See `Inspect.Opts` for a full list of options.\n"
#~ "\n"
#~ "## Examples\n"
#~ "\n"
#~ "    IO.inspect Process.list, width: 40\n"
#~ "\n"
#~ msgstr ""
#~ "与えられた引数でデバイスにインスペクトし、書き込みます。\n"
#~ "\n"
#~ "デフォルトで、80文字の幅での、プリティプリンティングを有効にします。\n"
#~ "幅は明示的に`:width`オプションを渡すことで変更できます。\n"
#~ "\n"
#~ "完全なオプションのリストは`Inspect.Opts`を参照してください。\n"
#~ "\n"
#~ "## 例\n"
#~ "\n"
#~ "    IO.inspect Process.list, width: 40\n"
#~ "\n"
