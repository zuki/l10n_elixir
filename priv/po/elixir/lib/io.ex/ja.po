msgid ""
msgstr ""
"Project-Id-Version: l 10n_elixir\n"
"PO-Revision-Date: 2016-02-27 11:19+0900\n"
"Last-Translator: 小田 照敬 <EMAIL@ADDRESS>\n"
"Language-Team: Japanese\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#. TRANSLATORS: def IO.binwrite(device \\ :stdio, item)
#: lib/io.ex:163
#, fuzzy
msgid ""
"Writes `item` as a binary to the given `device`.\n"
"No Unicode conversion happens.\n"
"The operation is Unicode unsafe.\n"
"\n"
"Check `write/2` for more information.\n"
"\n"
"Note: do not use this function on IO devices in Unicode mode\n"
"as it will return the wrong result.\n"
msgstr ""
"与えられた引数を与えられたデバイスにバイナリとして、\n"
"unocode変換を起さずに、書き出します。\n"
"\n"
"それ異常の情報は`write/2`をチェックしてください。\n"
"\n"
"Note: 間違った結果を返すのでunicodeモードのデバイスで\n"
"この関数を使ってはいけません。\n"

#. TRANSLATORS: def IO.getn(prompt, count \\ 1)
#: lib/io.ex:298
#, fuzzy
msgid ""
"Gets a number of bytes from IO device `:stdio`.\n"
"\n"
"If `:stdio` is a Unicode device, `count` implies\n"
"the number of Unicode codepoints to be retrieved.\n"
"Otherwise, `count` is the number of raw bytes to be retrieved.\n"
"\n"
"See `IO.getn/3` for a description of return values.\n"
"\n"
msgstr ""
"IOデバイスから幾らかのバイトを取得します。もし\n"
"もしIOデバイスがunicodeデバイスなら、`count`はunicode\n"
"コードポイントとして取得されることを意味します。\n"
"さもなくば、`count`は取得される生のバイトの数です。\n"

#. TRANSLATORS: def IO.iodata_length(item)
#: lib/io.ex:485
#, fuzzy
msgid ""
"Returns the size of an iodata.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> IO.iodata_length([1, 2 | <<3, 4>>])\n"
"    4\n"
"\n"
msgstr ""
"iodataのサイズを返します。\n"
"\n"
"コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> IO.iodata_length([1, 2|<<3, 4>>])\n"
"    4\n"
"\n"

#. TRANSLATORS: def IO.binread(device \\ :stdio, line_or_chars)
#: lib/io.ex:90
#, fuzzy
msgid ""
"Reads from the IO `device`. The operation is Unicode unsafe.\n"
"\n"
"The `device` is iterated by the given number of bytes or line by line if\n"
"`:line` is given.\n"
"Alternatively, if `:all` is given, then whole `device` is returned.\n"
"\n"
"It returns:\n"
"\n"
"  * `data` - the output bytes\n"
"\n"
"  * `:eof` - end of file was encountered\n"
"\n"
"  * `{:error, reason}` - other (rare) error condition;\n"
"    for instance, `{:error, :estale}` if reading from an\n"
"    NFS volume\n"
"\n"
"If `:all` is given, `:eof` is never returned, but an\n"
"empty string in case the device has reached EOF.\n"
"\n"
"Note: do not use this function on IO devices in Unicode mode\n"
"as it will return the wrong result.\n"
msgstr ""
"`count`文字をIOデバイスから読みます。`:line`なら行全体、\n"
"`:all`なら全てを読みます。\n"
"\n"
"以下を返します:\n"
"\n"
"  * `data` - 入力文字列\n"
"\n"
"  * `:eof` - end of fileに到達したことを示します\n"
"\n"
"  * `{:error, reason}` - 他の(レアな)エラー状態;\n"
"    例えば、`{:error, :estale}`はNFSボリュームから読み込んだ時に\n"
"    起きるかもしれません。\n"
"\n"
"もし`:all`が与えられたら、`:eof`は決して返しません。しかし\n"
"デバイスがEOFになったら空文字列を返します。\n"
"\n"
"注: unicodeモードのIOデバイスにこの関数を使ってはいけません。\n"
"悪い結果を返すでしょう。\n"

#. TRANSLATORS: def IO.inspect(item, opts \\ [])
#: lib/io.ex:231
msgid ""
"Inspects and writes the given `item` to the device.\n"
"\n"
"It's important to note that it returns the given `item` unchanged.\n"
"This makes it possible to \"spy\" on values by inserting an\n"
"`IO.inspect/2` call almost anywhere in your code, for example,\n"
"in the middle of a pipeline.\n"
"\n"
"It enables pretty printing by default with width of\n"
"80 characters. The width can be changed by explicitly\n"
"passing the `:width` option.\n"
"\n"
"The output can be decorated with a label, by providing the `:label`\n"
"option to easily distinguish it from other `IO.inspect/2` calls.\n"
"The label will be printed before the inspected `item`.\n"
"\n"
"See `Inspect.Opts` for a full list of remaining formatting options.\n"
"\n"
"## Examples\n"
"\n"
"    IO.inspect <<0, 1, 2>>, width: 40\n"
"\n"
"Prints:\n"
"\n"
"    <<0, 1, 2>>\n"
"\n"
"We can use the `:label` option to decorate the output:\n"
"\n"
"    IO.inspect 1..100, label: \"a wonderful range\"\n"
"\n"
"Prints:\n"
"\n"
"    a wonderful range: 1..100\n"
"\n"
"The `:label` option is especially useful with pipelines:\n"
"\n"
"    [1, 2, 3]\n"
"    |> IO.inspect(label: \"before\")\n"
"    |> Enum.map(&(&1 * 2))\n"
"    |> IO.inspect(label: \"after\")\n"
"    |> Enum.sum\n"
"\n"
"Prints:\n"
"\n"
"    before: [1, 2, 3]\n"
"    after: [2, 4, 6]\n"
"\n"
msgstr ""

#. TRANSLATORS: def IO.write(device \\ :stdio, item)
#: lib/io.ex:143
#, fuzzy
msgid ""
"Writes `item` to the given `device`.\n"
"\n"
"By default the `device` is the standard output.\n"
"It returns `:ok` if it succeeds.\n"
"\n"
"## Examples\n"
"\n"
"    IO.write \"sample\"\n"
"    #=> sample\n"
"\n"
"    IO.write :stderr, \"error\"\n"
"    #=> error\n"
"\n"
msgstr ""
"与えらえれた引数を与えられたデバイスに書き出します。\n"
"\n"
"デフォルトではデバイスは標準出力です。\n"
"もし成功すれば、`:ok`を返します。\n"
"\n"
"## 例\n"
"\n"
"    IO.write \"sample\"\n"
"    #=> \"sample\"\n"
"\n"
"    IO.write :stderr, \"error\"\n"
"    #=> \"error\"\n"
"\n"

#. TRANSLATORS: def IO.read(device \\ :stdio, line_or_chars)
#: lib/io.ex:47
#, fuzzy
msgid ""
"Reads from the IO `device`.\n"
"\n"
"The `device` is iterated by the given number of characters or line by line "
"if\n"
"`:line` is given.\n"
"Alternatively, if `:all` is given, then whole `device` is returned.\n"
"\n"
"It returns:\n"
"\n"
"  * `data` - the output characters\n"
"\n"
"  * `:eof` - end of file was encountered\n"
"\n"
"  * `{:error, reason}` - other (rare) error condition;\n"
"    for instance, `{:error, :estale}` if reading from an\n"
"    NFS volume\n"
"\n"
"If `:all` is given, `:eof` is never returned, but an\n"
"empty string in case the device has reached EOF.\n"
msgstr ""
"`count`文字をIOデバイスから読みます。`:line`なら行全体、\n"
"`:all`なら全てを読みます。\n"
"\n"
"以下を返します:\n"
"\n"
"  * `data` - 入力文字列\n"
"\n"
"  * `:eof` - end of fileに到達したことを示します\n"
"\n"
"  * `{:error, reason}` - 他の(レアな)エラー状態;\n"
"    例えば、`{:error, :estale}`はNFSボリュームから読み込んだ時に\n"
"    起きるかもしれません。\n"
"\n"
"もし`:all`が与えられたら、`:eof`は決して返しません。しかし\n"
"デバイスがEOFになったら空文字列を返します。\n"

#. TRANSLATORS: def IO.gets(device \\ :stdio, prompt)
#: lib/io.ex:343
#, fuzzy
msgid ""
"Reads a line from the IO `device`.\n"
"\n"
"It returns:\n"
"\n"
"  * `data` - the characters in the line terminated\n"
"    by a line-feed (LF) or end of file (EOF)\n"
"\n"
"  * `:eof` - end of file was encountered\n"
"\n"
"  * `{:error, reason}` - other (rare) error condition;\n"
"    for instance, `{:error, :estale}` if reading from an\n"
"    NFS volume\n"
"\n"
"## Examples\n"
"\n"
"To display \"What is your name?\" as a prompt and await user input:\n"
"\n"
"    IO.gets \"What is your name?\\n\"\n"
"\n"
msgstr ""
"IOデバイスから行を読みます。\n"
"\n"
"以下を返します:\n"
"\n"
"  * `data` - line-feed(LF)あるいはend of file(EOF)で終了された行の文字列\n"
"\n"
"  * `:eof` - end of fileに到達したことを示します\n"
"\n"
"  * `{:error, reason}` - 他の(レアな)エラー状態;\n"
"    例えば、`{:error, :estale}`はNFSボリュームから読み込んだ時に\n"
"    起きるかもしれません。\n"
"\n"
"## Examples\n"
"\n"
"プロンプトとして \"What is your name?\" 表示し、\n"
"ユーザの入力を待ちます:\n"
"\n"
"    IO.gets \"What is your name?\"\n"

#. TRANSLATORS: def IO.iodata_to_binary(item)
#: lib/io.ex:453
#, fuzzy
msgid ""
"Converts iodata (a list of integers representing bytes, lists\n"
"and binaries) into a binary.\n"
"The operation is Unicode unsafe.\n"
"\n"
"Notice that this function treats lists of integers as raw bytes\n"
"and does not perform any kind of encoding conversion. If you want\n"
"to convert from a charlist to a string (UTF-8 encoded), please\n"
"use `chardata_to_string/1` instead.\n"
"\n"
"If this function receives a binary, the same binary is returned.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> bin1 = <<1, 2, 3>>\n"
"    iex> bin2 = <<4, 5>>\n"
"    iex> bin3 = <<6>>\n"
"    iex> IO.iodata_to_binary([bin1, 1, [2, 3, bin2], 4 | bin3])\n"
"    <<1, 2, 3, 1, 2, 3, 4, 5, 4, 6>>\n"
"\n"
"    iex> bin = <<1, 2, 3>>\n"
"    iex> IO.iodata_to_binary(bin)\n"
"    <<1, 2, 3>>\n"
"\n"
msgstr ""
"iodata(バイト表現している整数、リスト、バイナリのリスト)を\n"
"バイナリに変換します。\n"
"\n"
"この関数がrawバイトとして整数のリストを扱い、いかなるエンコーディングの\n"
"変換も実行しないことに注意してください。\n"
"もし文字リストから(UTF-8エンコードされた)文字列へ変換したいなら、\n"
"`chardata_to_string/1`を代りに使ってください。\n"
"\n"
"この関数がバイナリを受け取ったら、同じバイナリを返します。\n"
"\n"
"コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> bin1 = <<1, 2, 3>>\n"
"    iex> bin2 = <<4, 5>>\n"
"    iex> bin3 = <<6>>\n"
"    iex> IO.iodata_to_binary([bin1, 1, [2, 3, bin2], 4|bin3])\n"
"    <<1, 2, 3, 1, 2, 3, 4, 5, 4, 6>>\n"
"\n"
"    iex> bin = <<1, 2, 3>>\n"
"    iex> IO.iodata_to_binary(bin)\n"
"    <<1, 2, 3>>\n"
"\n"

#. TRANSLATORS: def IO.inspect(device, item, opts)
#: lib/io.ex:284
#, fuzzy
msgid ""
"Inspects `item` according to the given options using the IO `device`.\n"
"\n"
"See `inspect/2` for a full list of options.\n"
msgstr ""
"与えられたデバイスを使い、オプションでアイテムをインスペクトします。\n"
"\n"
"完全なオプションのリストは`Inspect.Opts`を参照してください。\n"

#. TRANSLATORS: def IO.warn(message, stacktrace)
#: lib/io.ex:187
msgid ""
"Writes a `message` to stderr, along with the given `stacktrace`.\n"
"\n"
"This function also notifies the compiler a warning was printed\n"
"(in case --warnings-as-errors was enabled). It returns `:ok`\n"
"if it succeeds.\n"
"\n"
"An empty list can be passed to avoid stacktrace printing.\n"
"\n"
"## Examples\n"
"\n"
"    stacktrace = [{MyApp, :main, 1, [file: 'my_app.ex', line: 4]}]\n"
"    IO.warn \"variable bar is unused\", stacktrace\n"
"    #=> warning: variable bar is unused\n"
"    #=>   my_app.ex:4: MyApp.main/1\n"
"\n"
msgstr ""

#. TRANSLATORS: def IO.warn(message)
#: lib/io.ex:213
msgid ""
"Writes a `message` to stderr, along with the current stacktrace.\n"
"\n"
"It returns `:ok` if it succeeds.\n"
"\n"
"## Examples\n"
"\n"
"    IO.warn \"variable bar is unused\"\n"
"    #=> warning: variable bar is unused\n"
"    #=>   (iex) evaluator.ex:108: IEx.Evaluator.eval/4\n"
"\n"
msgstr ""

#. TRANSLATORS: def IO.stream(device, line_or_codepoints)
#: lib/io.ex:369
#, fuzzy
msgid ""
"Converts the IO `device` into an `IO.Stream`.\n"
"\n"
"An `IO.Stream` implements both `Enumerable` and\n"
"`Collectable`, allowing it to be used for both read\n"
"and write.\n"
"\n"
"The `device` is iterated by the given number of characters or line by line "
"if\n"
"`:line` is given.\n"
"\n"
"This reads from the IO as UTF-8. Check out\n"
"`IO.binstream/2` to handle the IO as a raw binary.\n"
"\n"
"Note that an IO stream has side effects and every time\n"
"you go over the stream you may get different results.\n"
"\n"
"## Examples\n"
"\n"
"Here is an example on how we mimic an echo server\n"
"from the command line:\n"
"\n"
"    Enum.each IO.stream(:stdio, :line), &IO.write(&1)\n"
"\n"
msgstr ""
"IOデバイスをを`IO.Stream`に変換します。\n"
"\n"
"`IO.Stream`は、読み書きの両方で使えるように、`Enumerable`と\n"
"`Collectable`の両方を実装します。\n"
"\n"
"deviceは`:line`が与えられたら、行ごとに繰り返され、\n"
"そうでないなら、コードポイントの数毎に繰り返されます。\n"
"\n"
"これはutf-8としてIOを読み込みます。rawバイナリとして\n"
"IOをハンドルするために、`IO.binstream/2`をチェックしてください。\n"
"\n"
"IOストリームは副作用を持つことに注意してください。\n"
"ストリームを調べるたびに、異る結果を得るでしょう。\n"
"\n"
"## 例\n"
"\n"
"どのようにコマンドラインからechoサーバに擬態するかという\n"
"例です:\n"
"\n"
"    Enum.each IO.stream(:stdio, :line), &IO.write(&1)\n"
"\n"

#. TRANSLATORS: def IO.binstream(device, line_or_bytes)
#: lib/io.ex:400
#, fuzzy
msgid ""
"Converts the IO `device` into an `IO.Stream`. The operation is Unicode "
"unsafe.\n"
"\n"
"An `IO.Stream` implements both `Enumerable` and\n"
"`Collectable`, allowing it to be used for both read\n"
"and write.\n"
"\n"
"The `device` is iterated by the given number of bytes or line by line if\n"
"`:line` is given.\n"
"This reads from the IO device as a raw binary.\n"
"\n"
"Note that an IO stream has side effects and every time\n"
"you go over the stream you may get different results.\n"
"\n"
"Finally, do not use this function on IO devices in Unicode\n"
"mode as it will return the wrong result.\n"
"\n"
msgstr ""
"IOデバイスをを`IO.Stream`に変換します。\n"
"\n"
"`IO.Stream`は、読み書きの両方で使えるように、`Enumerable`と\n"
"`Collectable`の両方を実装します。\n"
"\n"
"deviceは`:line`が与えられたら、行ごとか、バイトごとに繰り返さます。\n"
"これはrawバイナリとしてIOデバイスを読み込みます。\n"
"\n"
"IOストリームは副作用を持つことに注意してください。\n"
"ストリームを調べるたびに、異る結果を得るでしょう。\n"
"\n"
"最後に、unicodeモードのIOデバイスでこの関数を使わないでください。\n"
"間違った結果を返すかもしれません。\n"

#. TRANSLATORS: def IO.puts(device \\ :stdio, item)
#: lib/io.ex:178
#, fuzzy
msgid ""
"Writes `item` to the given `device`, similar to `write/2`,\n"
"but adds a newline at the end.\n"
msgstr ""
"`write/2`と似て、引数をデバイスへ書き出しますが、最後に改行を付加します。\n"
"引数はchardataであることを期待しています。\n"

#. TRANSLATORS: Elixir.IO Summary
#: lib/io.ex:2
#, fuzzy
msgid ""
"Functions handling input/output (IO).\n"
"\n"
"Many functions in this module expect an IO device as an argument.\n"
"An IO device must be a PID or an atom representing a process.\n"
"For convenience, Elixir provides `:stdio` and `:stderr` as\n"
"shortcuts to Erlang's `:standard_io` and `:standard_error`.\n"
"\n"
"The majority of the functions expect chardata, i.e. strings or\n"
"lists of characters and strings. In case another type is given,\n"
"functions will convert to string via the `String.Chars` protocol\n"
"(as shown in typespecs).\n"
"\n"
"The functions starting with `bin` expect iodata as an argument,\n"
"i.e. binaries or lists of bytes and binaries.\n"
"\n"
"## IO devices\n"
"\n"
"An IO device may be an atom or a PID. In case it is an atom,\n"
"the atom must be the name of a registered process. In addition,\n"
"Elixir provides two shortcuts:\n"
"\n"
"  * `:stdio` - a shortcut for `:standard_io`, which maps to\n"
"    the current `Process.group_leader/0` in Erlang\n"
"\n"
"  * `:stderr` - a shortcut for the named process `:standard_error`\n"
"    provided in Erlang\n"
"\n"
"IO devices maintain their position, that means subsequent calls to any\n"
"reading or writing functions will start from the place when the device\n"
"was last accessed. Position of files can be changed using the\n"
"`:file.position/2` function.\n"
"\n"
msgstr ""
"IOをハンドリングする関数です。\n"
"\n"
"このモジュールの多くの関数は、IOデバイスを引数として期待します。\n"
"IOデバイスはpidかプロセスを表現するアトムでなければなりません。\n"
"便宜上、Elixirは、Erlangの`:standard_io`と`:standard_error`の\n"
"ショートカットとして、`:stdio`と`:stderr`を提供します。\n"
"\n"
"関数の大多数はchar data、すなわち、文字列か文字また文字列のリスト、\n"
"を期待します。\n"
"他のタイプが与えられた場合、`String.Chars`プロトコルにより文字列に\n"
"変換されます(typespecで示すように)。\n"
"\n"
"`bin*`で始まる関数は、引数としてiodata、すなわち、バイナリかバイトとバ\n"
"イナリのリスト、を期待します。\n"
"\n"
"## IOデバイス\n"
"\n"
"IOデバイスはアトムかpidです。アトムの場合、\n"
"アトムは登録されたプロセスの名前でなくてはなりません。\n"
"しかしながら、この規則に3つの例外があります:\n"
"\n"
"  * `:standard_io` - アトム`:standard_io`が与えらえると、\n"
"    のショートカットとして扱われます。\n"
"\n"
"  * `:stdio` - `:standard_io`のショートカットで、Erlangの\n"
"     現在の`Process.group_leader`へマップされます。\n"
"\n"
"  * `:stderr` - Erlangで提供される`:standard_error`という\n"
"     名前のプロセスへのショートカットです。\n"
"\n"
"IOデバイスはその位置の維持をします。これは以降の任意の読み書きの\n"
"関数呼出しは、デバイスが最後にアクセスされたときの場所から始まる\n"
"ことを意味します。`:file.position/2`関数でファイルの場所を変更すること\n"
"ができます。\n"

#. TRANSLATORS: def IO.getn(device, prompt, count)
#: lib/io.ex:320
#, fuzzy
msgid ""
"Gets a number of bytes from the IO `device`.\n"
"\n"
"If the IO `device` is a Unicode device, `count` implies\n"
"the number of Unicode codepoints to be retrieved.\n"
"Otherwise, `count` is the number of raw bytes to be retrieved.\n"
"\n"
"It returns:\n"
"\n"
"  * `data` - the input characters\n"
"\n"
"  * `:eof` - end of file was encountered\n"
"\n"
"  * `{:error, reason}` - other (rare) error condition;\n"
"    for instance, `{:error, :estale}` if reading from an\n"
"    NFS volume\n"
"\n"
msgstr ""
"IOデバイスから幾らかのバイトを取得します。\n"
"もしIOデバイスがunicodeデバイスなら、`count`はunicode\n"
"コードポイントとして取得されることを意味します。\n"
"さもなくば、`count`は取得される生のバイトの数です。\n"
"以下を返します:\n"
"\n"
"  * `data` - 入力された文字列\n"
"\n"
"  * `:eof` - EOF(ファイルの終わり)に遭遇\n"
"\n"
"  * `{:error, reason}` - 他の(希な)エラー条件;\n"
"    例えば、`{:error, :estale}` はNFSボリュームから\n"
"    読み込んでいるときに起きるかもしれません\n"

#. TRANSLATORS: def IO.chardata_to_string(string)
#: lib/io.ex:425
#, fuzzy
msgid ""
"Converts chardata (a list of integers representing codepoints,\n"
"lists and strings) into a string.\n"
"\n"
"In case the conversion fails, it raises an `UnicodeConversionError`.\n"
"If a string is given, it returns the string itself.\n"
"\n"
"## Examples\n"
"\n"
"    iex> IO.chardata_to_string([0x00E6, 0x00DF])\n"
"    \"æß\"\n"
"\n"
"    iex> IO.chardata_to_string([0x0061, \"bc\"])\n"
"    \"abc\"\n"
"\n"
"    iex> IO.chardata_to_string(\"string\")\n"
"    \"string\"\n"
"\n"
msgstr ""
"chardata(コードポイント表現している整数、リスト、バイナリのリスト)を\n"
"文字列に変換します。\n"
"\n"
"変換に失敗したばあい、`UnicodeConversionError`を上げます。\n"
"もし文字列が与えられたら、その文字列自身を返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> IO.chardata_to_string([0x00E6, 0x00DF])\n"
"    \"æß\"\n"
"\n"
"    iex> IO.chardata_to_string([0x0061, \"bc\"])\n"
"    \"abc\"\n"
"\n"

#~ msgid ""
#~ "Inspects and writes the given argument to the device.\n"
#~ "\n"
#~ "It enables pretty printing by default with width of\n"
#~ "80 characters. The width can be changed by explicitly\n"
#~ "passing the `:width` option.\n"
#~ "\n"
#~ "See `Inspect.Opts` for a full list of options.\n"
#~ "\n"
#~ "## Examples\n"
#~ "\n"
#~ "    IO.inspect Process.list, width: 40\n"
#~ "\n"
#~ msgstr ""
#~ "与えられた引数でデバイスにインスペクトし、書き込みます。\n"
#~ "\n"
#~ "デフォルトで、80文字の幅での、プリティプリンティングを有効にします。\n"
#~ "幅は明示的に`:width`オプションを渡すことで変更できます。\n"
#~ "\n"
#~ "完全なオプションのリストは`Inspect.Opts`を参照してください。\n"
#~ "\n"
#~ "## 例\n"
#~ "\n"
#~ "    IO.inspect Process.list, width: 40\n"
#~ "\n"
