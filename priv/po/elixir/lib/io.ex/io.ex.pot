#. TRANSLATORS: def IO.binwrite(device \\ :stdio, item)
#: lib/io.ex:163 
msgid ""
"Writes `item` as a binary to the given `device`.\n"
"No Unicode conversion happens.\n"
"The operation is Unicode unsafe.\n"
"\n"
"Check `write/2` for more information.\n"
"\n"
"Note: do not use this function on IO devices in Unicode mode\n"
"as it will return the wrong result.\n"
msgstr ""
#. TRANSLATORS: def IO.inspect(item, opts \\ [])
#: lib/io.ex:231 
msgid ""
"Inspects and writes the given `item` to the device.\n"
"\n"
"It's important to note that it returns the given `item` unchanged.\n"
"This makes it possible to \"spy\" on values by inserting an\n"
"`IO.inspect/2` call almost anywhere in your code, for example,\n"
"in the middle of a pipeline.\n"
"\n"
"It enables pretty printing by default with width of\n"
"80 characters. The width can be changed by explicitly\n"
"passing the `:width` option.\n"
"\n"
"The output can be decorated with a label, by providing the `:label`\n"
"option to easily distinguish it from other `IO.inspect/2` calls.\n"
"The label will be printed before the inspected `item`.\n"
"\n"
"See `Inspect.Opts` for a full list of remaining formatting options.\n"
"\n"
"## Examples\n"
"\n"
"    IO.inspect <<0, 1, 2>>, width: 40\n"
"\n"
"Prints:\n"
"\n"
"    <<0, 1, 2>>\n"
"\n"
"We can use the `:label` option to decorate the output:\n"
"\n"
"    IO.inspect 1..100, label: \"a wonderful range\"\n"
"\n"
"Prints:\n"
"\n"
"    a wonderful range: 1..100\n"
"\n"
"The `:label` option is especially useful with pipelines:\n"
"\n"
"    [1, 2, 3]\n"
"    |> IO.inspect(label: \"before\")\n"
"    |> Enum.map(&(&1 * 2))\n"
"    |> IO.inspect(label: \"after\")\n"
"    |> Enum.sum\n"
"\n"
"Prints:\n"
"\n"
"    before: [1, 2, 3]\n"
"    after: [2, 4, 6]\n"
"\n"
msgstr ""
#. TRANSLATORS: def IO.getn(prompt, count \\ 1)
#: lib/io.ex:298 
msgid ""
"Gets a number of bytes from IO device `:stdio`.\n"
"\n"
"If `:stdio` is a Unicode device, `count` implies\n"
"the number of Unicode codepoints to be retrieved.\n"
"Otherwise, `count` is the number of raw bytes to be retrieved.\n"
"\n"
"See `IO.getn/3` for a description of return values.\n"
"\n"
msgstr ""
#. TRANSLATORS: def IO.iodata_length(item)
#: lib/io.ex:485 
msgid ""
"Returns the size of an iodata.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> IO.iodata_length([1, 2 | <<3, 4>>])\n"
"    4\n"
"\n"
msgstr ""
#. TRANSLATORS: def IO.binread(device \\ :stdio, line_or_chars)
#: lib/io.ex:90 
msgid ""
"Reads from the IO `device`. The operation is Unicode unsafe.\n"
"\n"
"The `device` is iterated by the given number of bytes or line by line if\n"
"`:line` is given.\n"
"Alternatively, if `:all` is given, then whole `device` is returned.\n"
"\n"
"It returns:\n"
"\n"
"  * `data` - the output bytes\n"
"\n"
"  * `:eof` - end of file was encountered\n"
"\n"
"  * `{:error, reason}` - other (rare) error condition;\n"
"    for instance, `{:error, :estale}` if reading from an\n"
"    NFS volume\n"
"\n"
"If `:all` is given, `:eof` is never returned, but an\n"
"empty string in case the device has reached EOF.\n"
"\n"
"Note: do not use this function on IO devices in Unicode mode\n"
"as it will return the wrong result.\n"
msgstr ""
#. TRANSLATORS: def IO.binstream(device, line_or_bytes)
#: lib/io.ex:400 
msgid ""
"Converts the IO `device` into an `IO.Stream`. The operation is Unicode unsafe.\n"
"\n"
"An `IO.Stream` implements both `Enumerable` and\n"
"`Collectable`, allowing it to be used for both read\n"
"and write.\n"
"\n"
"The `device` is iterated by the given number of bytes or line by line if\n"
"`:line` is given.\n"
"This reads from the IO device as a raw binary.\n"
"\n"
"Note that an IO stream has side effects and every time\n"
"you go over the stream you may get different results.\n"
"\n"
"Finally, do not use this function on IO devices in Unicode\n"
"mode as it will return the wrong result.\n"
"\n"
msgstr ""
#. TRANSLATORS: def IO.puts(device \\ :stdio, item)
#: lib/io.ex:178 
msgid ""
"Writes `item` to the given `device`, similar to `write/2`,\n"
"but adds a newline at the end.\n"
msgstr ""
#. TRANSLATORS: def IO.write(device \\ :stdio, item)
#: lib/io.ex:143 
msgid ""
"Writes `item` to the given `device`.\n"
"\n"
"By default the `device` is the standard output.\n"
"It returns `:ok` if it succeeds.\n"
"\n"
"## Examples\n"
"\n"
"    IO.write \"sample\"\n"
"    #=> sample\n"
"\n"
"    IO.write :stderr, \"error\"\n"
"    #=> error\n"
"\n"
msgstr ""
#. TRANSLATORS: def IO.read(device \\ :stdio, line_or_chars)
#: lib/io.ex:47 
msgid ""
"Reads from the IO `device`.\n"
"\n"
"The `device` is iterated by the given number of characters or line by line if\n"
"`:line` is given.\n"
"Alternatively, if `:all` is given, then whole `device` is returned.\n"
"\n"
"It returns:\n"
"\n"
"  * `data` - the output characters\n"
"\n"
"  * `:eof` - end of file was encountered\n"
"\n"
"  * `{:error, reason}` - other (rare) error condition;\n"
"    for instance, `{:error, :estale}` if reading from an\n"
"    NFS volume\n"
"\n"
"If `:all` is given, `:eof` is never returned, but an\n"
"empty string in case the device has reached EOF.\n"
msgstr ""
#. TRANSLATORS: def IO.iodata_to_binary(item)
#: lib/io.ex:453 
msgid ""
"Converts iodata (a list of integers representing bytes, lists\n"
"and binaries) into a binary.\n"
"The operation is Unicode unsafe.\n"
"\n"
"Notice that this function treats lists of integers as raw bytes\n"
"and does not perform any kind of encoding conversion. If you want\n"
"to convert from a charlist to a string (UTF-8 encoded), please\n"
"use `chardata_to_string/1` instead.\n"
"\n"
"If this function receives a binary, the same binary is returned.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> bin1 = <<1, 2, 3>>\n"
"    iex> bin2 = <<4, 5>>\n"
"    iex> bin3 = <<6>>\n"
"    iex> IO.iodata_to_binary([bin1, 1, [2, 3, bin2], 4 | bin3])\n"
"    <<1, 2, 3, 1, 2, 3, 4, 5, 4, 6>>\n"
"\n"
"    iex> bin = <<1, 2, 3>>\n"
"    iex> IO.iodata_to_binary(bin)\n"
"    <<1, 2, 3>>\n"
"\n"
msgstr ""
#. TRANSLATORS: def IO.stream(device, line_or_codepoints)
#: lib/io.ex:369 
msgid ""
"Converts the IO `device` into an `IO.Stream`.\n"
"\n"
"An `IO.Stream` implements both `Enumerable` and\n"
"`Collectable`, allowing it to be used for both read\n"
"and write.\n"
"\n"
"The `device` is iterated by the given number of characters or line by line if\n"
"`:line` is given.\n"
"\n"
"This reads from the IO as UTF-8. Check out\n"
"`IO.binstream/2` to handle the IO as a raw binary.\n"
"\n"
"Note that an IO stream has side effects and every time\n"
"you go over the stream you may get different results.\n"
"\n"
"## Examples\n"
"\n"
"Here is an example on how we mimic an echo server\n"
"from the command line:\n"
"\n"
"    Enum.each IO.stream(:stdio, :line), &IO.write(&1)\n"
"\n"
msgstr ""
#. TRANSLATORS: def IO.gets(device \\ :stdio, prompt)
#: lib/io.ex:343 
msgid ""
"Reads a line from the IO `device`.\n"
"\n"
"It returns:\n"
"\n"
"  * `data` - the characters in the line terminated\n"
"    by a line-feed (LF) or end of file (EOF)\n"
"\n"
"  * `:eof` - end of file was encountered\n"
"\n"
"  * `{:error, reason}` - other (rare) error condition;\n"
"    for instance, `{:error, :estale}` if reading from an\n"
"    NFS volume\n"
"\n"
"## Examples\n"
"\n"
"To display \"What is your name?\" as a prompt and await user input:\n"
"\n"
"    IO.gets \"What is your name?\\n\"\n"
"\n"
msgstr ""
#. TRANSLATORS: def IO.inspect(device, item, opts)
#: lib/io.ex:284 
msgid ""
"Inspects `item` according to the given options using the IO `device`.\n"
"\n"
"See `inspect/2` for a full list of options.\n"
msgstr ""
#. TRANSLATORS: def IO.warn(message, stacktrace)
#: lib/io.ex:187 
msgid ""
"Writes a `message` to stderr, along with the given `stacktrace`.\n"
"\n"
"This function also notifies the compiler a warning was printed\n"
"(in case --warnings-as-errors was enabled). It returns `:ok`\n"
"if it succeeds.\n"
"\n"
"An empty list can be passed to avoid stacktrace printing.\n"
"\n"
"## Examples\n"
"\n"
"    stacktrace = [{MyApp, :main, 1, [file: 'my_app.ex', line: 4]}]\n"
"    IO.warn \"variable bar is unused\", stacktrace\n"
"    #=> warning: variable bar is unused\n"
"    #=>   my_app.ex:4: MyApp.main/1\n"
"\n"
msgstr ""
#. TRANSLATORS: def IO.warn(message)
#: lib/io.ex:213 
msgid ""
"Writes a `message` to stderr, along with the current stacktrace.\n"
"\n"
"It returns `:ok` if it succeeds.\n"
"\n"
"## Examples\n"
"\n"
"    IO.warn \"variable bar is unused\"\n"
"    #=> warning: variable bar is unused\n"
"    #=>   (iex) evaluator.ex:108: IEx.Evaluator.eval/4\n"
"\n"
msgstr ""
#. TRANSLATORS: Elixir.IO Summary
#: lib/io.ex:2 
msgid ""
"Functions handling input/output (IO).\n"
"\n"
"Many functions in this module expect an IO device as an argument.\n"
"An IO device must be a PID or an atom representing a process.\n"
"For convenience, Elixir provides `:stdio` and `:stderr` as\n"
"shortcuts to Erlang's `:standard_io` and `:standard_error`.\n"
"\n"
"The majority of the functions expect chardata, i.e. strings or\n"
"lists of characters and strings. In case another type is given,\n"
"functions will convert to string via the `String.Chars` protocol\n"
"(as shown in typespecs).\n"
"\n"
"The functions starting with `bin` expect iodata as an argument,\n"
"i.e. binaries or lists of bytes and binaries.\n"
"\n"
"## IO devices\n"
"\n"
"An IO device may be an atom or a PID. In case it is an atom,\n"
"the atom must be the name of a registered process. In addition,\n"
"Elixir provides two shortcuts:\n"
"\n"
"  * `:stdio` - a shortcut for `:standard_io`, which maps to\n"
"    the current `Process.group_leader/0` in Erlang\n"
"\n"
"  * `:stderr` - a shortcut for the named process `:standard_error`\n"
"    provided in Erlang\n"
"\n"
"IO devices maintain their position, that means subsequent calls to any\n"
"reading or writing functions will start from the place when the device\n"
"was last accessed. Position of files can be changed using the\n"
"`:file.position/2` function.\n"
"\n"
msgstr ""
#. TRANSLATORS: def IO.getn(device, prompt, count)
#: lib/io.ex:320 
msgid ""
"Gets a number of bytes from the IO `device`.\n"
"\n"
"If the IO `device` is a Unicode device, `count` implies\n"
"the number of Unicode codepoints to be retrieved.\n"
"Otherwise, `count` is the number of raw bytes to be retrieved.\n"
"\n"
"It returns:\n"
"\n"
"  * `data` - the input characters\n"
"\n"
"  * `:eof` - end of file was encountered\n"
"\n"
"  * `{:error, reason}` - other (rare) error condition;\n"
"    for instance, `{:error, :estale}` if reading from an\n"
"    NFS volume\n"
"\n"
msgstr ""
#. TRANSLATORS: def IO.chardata_to_string(string)
#: lib/io.ex:425 
msgid ""
"Converts chardata (a list of integers representing codepoints,\n"
"lists and strings) into a string.\n"
"\n"
"In case the conversion fails, it raises an `UnicodeConversionError`.\n"
"If a string is given, it returns the string itself.\n"
"\n"
"## Examples\n"
"\n"
"    iex> IO.chardata_to_string([0x00E6, 0x00DF])\n"
"    \"æß\"\n"
"\n"
"    iex> IO.chardata_to_string([0x0061, \"bc\"])\n"
"    \"abc\"\n"
"\n"
"    iex> IO.chardata_to_string(\"string\")\n"
"    \"string\"\n"
"\n"
msgstr ""
