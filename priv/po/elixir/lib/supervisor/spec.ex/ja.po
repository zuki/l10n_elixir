msgid ""
msgstr ""
"Project-Id-Version: l 10n_elixir\n"
"PO-Revision-Date: 2017-02-23 18:28+0900\n"
"Last-Translator: 小田 照敬 <EMAIL@ADDRESS>\n"
"Language-Team: Japanese\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"POT-Creation-Date: \n"
"X-Generator: Poedit 1.8.12\n"

#. TRANSLATORS: @type spec
#: lib/supervisor/spec.ex:119
msgid "The supervisor specification"
msgstr "スーパバイザの仕様"

#. TRANSLATORS: @type strategy
#: lib/supervisor/spec.ex:101
msgid "Supported strategies"
msgstr "サポートされている`strategy`"

#. TRANSLATORS: def Supervisor.Spec.supervise(children, options)
#: lib/supervisor/spec.ex:127
msgid ""
"Receives a list of children (workers or supervisors) to\n"
"supervise and a set of options.\n"
"\n"
"Returns a tuple containing the supervisor specification. This tuple can "
"be\n"
"used as the return value of the `c:init/1` callback when implementing a\n"
"module-based supervisor.\n"
"\n"
"## Examples\n"
"\n"
"    supervise(children, strategy: :one_for_one)\n"
"\n"
"## Options\n"
"\n"
"  * `:strategy` - the restart strategy option. It can be either\n"
"    `:one_for_one`, `:rest_for_one`, `:one_for_all`, or\n"
"    `:simple_one_for_one`. You can learn more about strategies\n"
"    in the `Supervisor` module docs.\n"
"\n"
"  * `:max_restarts` - the maximum amount of restarts allowed in\n"
"    a time frame. Defaults to `3`.\n"
"\n"
"  * `:max_seconds` - the time frame in which `:max_restarts` applies.\n"
"    Defaults to `5`.\n"
"\n"
"The `:strategy` option is required and by default a maximum of 3 restarts "
"is\n"
"allowed within 5 seconds. Check the `Supervisor` module for a detailed\n"
"description of the available strategies.\n"
msgstr ""
"監視対象の子プロセス(ワーカーまたはスーパーバイザ)のリストと、オプション\n"
"を受け取ります。\n"
"\n"
"スーパバイザ仕様を含んだタプルを返します。このタプルは、モジュールベース"
"の\n"
"スーパーバイザを実装する際に`c:init/1`コールバックの返り値として\n"
"使用できます。\n"
"\n"
"## 例\n"
"\n"
"    supervise(children, strategy: :one_for_one)\n"
"\n"
"## オプション\n"
"\n"
"  * `:strategy` - 再起動戦略オプション。取り得る値は、`:one_for_one`、\n"
"    `:rest_for_one`、 `:one_for_all`、`:simple_one_for_one`のいずれかで"
"す。\n"
"    戦略については、`Supervisor`モジュールのドキュメントでより詳しく学ぶ\n"
"     ことができます。\n"
"\n"
"  * `:max_restarts` - 時間枠内で許される再起動の最大値です。\n"
"     デフォルトは`3`です。\n"
"\n"
"  * `:max_seconds` - `:max_restarts`を適用する時間枠の秒数です。\n"
"     デフォルトは5です。\n"
"\n"
"`:strategy`オプションは必須であり、デフォルトでは5秒\n"
"間に最大3回の再起動が許されます。利用可能な戦略の詳細は、\n"
"`Supervisor`モジュールをチェックしてください。\n"

#. TRANSLATORS: Elixir.Supervisor.Spec Summary
#: lib/supervisor/spec.ex:2
msgid ""
"Convenience functions for defining supervisor specifications.\n"
"\n"
"## Example\n"
"\n"
"By using the functions in this module one can specify the children\n"
"to be used under a supervisor, started with `Supervisor.start_link/2`:\n"
"\n"
"    import Supervisor.Spec\n"
"\n"
"    children = [\n"
"      worker(MyWorker, [arg1, arg2, arg3]),\n"
"      supervisor(MySupervisor, [arg1])\n"
"    ]\n"
"\n"
"    Supervisor.start_link(children, strategy: :one_for_one)\n"
"\n"
"Sometimes, it may be handy to define supervisors backed\n"
"by a module:\n"
"\n"
"    defmodule MySupervisor do\n"
"      use Supervisor\n"
"\n"
"      def start_link(arg) do\n"
"        Supervisor.start_link(__MODULE__, arg)\n"
"      end\n"
"\n"
"      def init(arg) do\n"
"        children = [\n"
"          worker(MyWorker, [arg], restart: :temporary)\n"
"        ]\n"
"\n"
"        supervise(children, strategy: :simple_one_for_one)\n"
"      end\n"
"    end\n"
"\n"
"Notice in this case we don't have to explicitly import\n"
"`Supervisor.Spec` as `use Supervisor` automatically does so.\n"
"Defining a module-based supervisor can be useful, for example,\n"
"to perform initialization tasks in the `c:init/1` callback.\n"
"\n"
"## Supervisor and worker options\n"
"\n"
"In the example above, we defined specs for workers and supervisors.\n"
"These specs (both for workers as well as supervisors) accept the\n"
"following options:\n"
"\n"
"  * `:id` - a name used to identify the child specification\n"
"    internally by the supervisor; defaults to the given module\n"
"    name for the child worker/supervisor\n"
"\n"
"  * `:function` - the function to invoke on the child to start it\n"
"\n"
"  * `:restart` - an atom that defines when a terminated child process "
"should\n"
"    be restarted (see the \"Restart values\" section below)\n"
"\n"
"  * `:shutdown` - an atom that defines how a child process should be\n"
"    terminated (see the \"Shutdown values\" section below)\n"
"\n"
"  * `:modules` - it should be a list with one element `[module]`,\n"
"    where module is the name of the callback module only if the\n"
"    child process is a `Supervisor` or `GenServer`; if the child\n"
"    process is a `GenEvent`, `:modules` should be `:dynamic`\n"
"\n"
"### Restart values (:restart)\n"
"\n"
"The following restart values are supported in the `:restart` option:\n"
"\n"
"  * `:permanent` - the child process is always restarted\n"
"\n"
"  * `:temporary` - the child process is never restarted (not even\n"
"    when the supervisor's strategy is `:rest_for_one` or `:one_for_all`)\n"
"\n"
"  * `:transient` - the child process is restarted only if it\n"
"    terminates abnormally, i.e., with an exit reason other than\n"
"    `:normal`, `:shutdown` or `{:shutdown, term}`\n"
"\n"
"### Shutdown values (:shutdown)\n"
"\n"
"The following shutdown values are supported in the `:shutdown` option:\n"
"\n"
"  * `:brutal_kill` - the child process is unconditionally terminated\n"
"    using `Process.exit(child, :kill)`\n"
"\n"
"  * `:infinity` - if the child process is a supervisor, this is a "
"mechanism\n"
"    to give the subtree enough time to shutdown; it can also be used "
"with\n"
"    workers with care\n"
"\n"
"  * any integer - the value of `:shutdown` can also be any integer "
"meaning\n"
"    that the supervisor tells the child process to terminate by calling\n"
"    `Process.exit(child, :shutdown)` and then waits for an exit signal "
"back.\n"
"    If no exit signal is received within the specified time (the value of "
"this\n"
"    option, in milliseconds), the child process is unconditionally "
"terminated\n"
"    using `Process.exit(child, :kill)`\n"
"\n"
msgstr ""
"スーパーバイザの仕様を定義するための便利な関数群です。\n"
"\n"
"## 例\n"
"\n"
"このモジュールの関数を使用して、スーババイザの下で使用する子プロセスを\n"
"指定し、`Supervisor.start_link/2`で起動することができます:\n"
"\n"
"    import Supervisor.Spec\n"
"\n"
"    children = [\n"
"      worker(MyWorker, [arg1, arg2, arg3]),\n"
"      supervisor(MySupervisor, [arg1])\n"
"    ]\n"
"\n"
"    Supervisor.start_link(children, strategy: :one_for_one)\n"
"\n"
"場合によっては、モジュールベースのスーパバイザを定義すると便利な場合も\n"
"あります:\n"
"\n"
"    defmodule MySupervisor do\n"
"      use Supervisor\n"
"\n"
"      def start_link(arg) do\n"
"        Supervisor.start_link(__MODULE__, arg)\n"
"      end\n"
"\n"
"      def init(arg) do\n"
"        children = [\n"
"          worker(MyWorker, [arg], restart: :temporary)\n"
"        ]\n"
"\n"
"        supervise(children, strategy: :simple_one_for_one)\n"
"      end\n"
"    end\n"
"\n"
"この場合は明示的に`Supervicor.Spec`をインポートする必要はないことに\n"
"注意してください。`use Supervisor`が自動的に行ってくれるからです。\n"
"モジュールベースのスーパーバイザの定義は、たとえば、`c:init/1`コールバック"
"で\n"
"初期化タスクを実行する場合などで便利でしょう。\n"
"\n"
"## スーバーバイザとワーカーのオプション\n"
"\n"
"上の例では、ワーカーとスーパーバイザの仕様を定義しました。これらの仕様\n"
"（ワーカー、スーバーバイザの両者とも）では以下のオプションを受け付けま"
"す。\n"
"\n"
"  * `:id` - スーバーバイザが子プロセス仕様を定義するために内部的に使用す"
"る\n"
"    名前。デフォルトは子プロセスのワーカーまたはスーパーバイザに指定され"
"た\n"
"    モジュール名です。\n"
"\n"
"  * `:function` - 子プロセスを起動するために呼び出す関数\n"
"\n"
"  * `:restart` - 子プロセスが終了した時に再起動するべきかを定義するアト"
"ム\n"
"    （「再起動値」セクションを参照）。\n"
"\n"
"  * `:shutdown` - 子プロセスはどのように停止されるべきかを定義する\n"
"    アトム（「停止値」セクションを参照）。\n"
"\n"
"  * `:modules` - １つの要素`[module]`を持つリストでなければなりません。\n"
"    ここで`module`は、子プロセスが`Supervisor`または`GenServer`の場合"
"は、\n"
"    コールバックモジュールの名前で、子プロセスが`GenEvent`の場合は、\n"
"    `:dynamic`でなければなりません。\n"
"\n"
"### 再起動値（:restart）\n"
"\n"
"`:restart`オプションの値としては以下がサポートされています:\n"
"\n"
"  * `:permanent` - 子プロセスは常に再起動されます\n"
"\n"
"  * `:temporary` - 子プロセスは決して再起動されません\n"
"    （たとえ、スーパバイザの戦略が`rest_for_one`や`:one_for_all`であって"
"も)\n"
"\n"
"  * `:transient` - 子プロセスが異常終了した（すなわち、終了理由が、`:"
"normal`, \n"
"    `:shutdown`, `{:shutdown, term}`以外の）場合のみ再起動されます。\n"
"\n"
"### 停止値（:shutdown）\n"
"\n"
"`: shutdown `オプションの値としては以下がサポートされています:\n"
"\n"
"  * `:brutal_kill` - `Process.exit(child, :kill)`の使用して、子プロセス"
"は\n"
"    無条件に停止させられます。\n"
"\n"
"  * `:infinity` - 子プロセスがスーパーバイザの場合、停止するための十分な時"
"間を\n"
"    サブツリーに与えるためのメカニズムです。注意すればワーカーにも\n"
"    使用できます。\n"
"\n"
"  * 任意の整数 - `:shutodown`の値には任意の整数を与えることもできます。\n"
"    これは、スーパバイザは`Process.exit(child, :shutdown)`を呼び出すこと"
"で\n"
"    子プロセスに停止を知らせ、終了シグナルが来るのを待つことを意味しま"
"す。\n"
"    指定した時間（このオプションの値で、ミリ秒単位）内に終了シグナルが\n"
"    受信できなかった場合は、`Process.exit(child, :kill)`の使用して、子プロ"
"セスは\n"
"    無条件に停止させられます。\n"
"\n"

#. TRANSLATORS: def Supervisor.Spec.supervisor(module, args, options \\ [])
#: lib/supervisor/spec.ex:211
msgid ""
"Defines the given `module` as a supervisor which will be started\n"
"with the given arguments.\n"
"\n"
"    supervisor(ExUnit.Runner, [], restart: :permanent)\n"
"\n"
"By default, the function `start_link` is invoked on the given\n"
"module. Overall, the default values for the options are:\n"
"\n"
"    [id: module,\n"
"     function: :start_link,\n"
"     restart: :permanent,\n"
"     shutdown: :infinity,\n"
"     modules: [module]]\n"
"\n"
"Check the documentation for the `Supervisor.Spec` module for more\n"
"information on the options.\n"
msgstr ""
"指定した`module`を指定した引数で開始されるスーパバイザとして\n"
"定義します。\n"
"\n"
"    supervisor(ExUnit.Runner, [], restart: :permanent)\n"
"\n"
"デフォルトでは、`start_link`関数は指定したモジュールで\n"
"起動されます。オプションのすべてのデフォルト値は次の通りです:\n"
"\n"
"    [id: module,\n"
"     function: :start_link,\n"
"     restart: :permanent,\n"
"     shutdown: :infinity,\n"
"     modules: [module]]\n"
"\n"
"オプションの詳細は `Supervisor.Spec` モジュールのドキュメントを\n"
"チェックしてください。\n"

#. TRANSLATORS: def Supervisor.Spec.worker(module, args, options \\ [])
#: lib/supervisor/spec.ex:187
msgid ""
"Defines the given `module` as a worker which will be started\n"
"with the given arguments.\n"
"\n"
"    worker(ExUnit.Runner, [], restart: :permanent)\n"
"\n"
"By default, the function `start_link` is invoked on the given\n"
"module. Overall, the default values for the options are:\n"
"\n"
"    [id: module,\n"
"     function: :start_link,\n"
"     restart: :permanent,\n"
"     shutdown: 5000,\n"
"     modules: [module]]\n"
"\n"
"Check the documentation for the `Supervisor.Spec` module for more\n"
"information on the options.\n"
msgstr ""
"指定した`module`を指定した引数で開始されるワーカーとして\n"
"定義します。\n"
"\n"
"    worker(ExUnit.Runner, [], restart: :permanent)\n"
"\n"
"デフォルトでは、`start_link`関数は指定したモジュールで\n"
"起動されます。オプションのすべてのデフォルト値は次の通りです:\n"
"\n"
"    [id: module,\n"
"     function: :start_link,\n"
"     restart: :permanent,\n"
"     shutdown: 5000,\n"
"     modules: [module]]\n"
"\n"
"オプションの詳細は `Supervisor.Spec` モジュールのドキュメントを\n"
"チェックしてください。\n"

#. TRANSLATORS: @type restart
#: lib/supervisor/spec.ex:104
msgid "Supported restart values"
msgstr "サポートされている`restart`値"

#. TRANSLATORS: @type modules
#: lib/supervisor/spec.ex:113
msgid "Supported module values"
msgstr "サポートされている`module`値"

#. TRANSLATORS: @type shutdown
#: lib/supervisor/spec.ex:107
msgid "Supported shutdown values"
msgstr "サポートされている`shutdown`値"

#. TRANSLATORS: @type child_id
#: lib/supervisor/spec.ex:116
msgid "Supported id values"
msgstr "サポートされている`id`値"

#. TRANSLATORS: @type worker
#: lib/supervisor/spec.ex:110
msgid "Supported worker values"
msgstr "サポートされている`worker`値"
