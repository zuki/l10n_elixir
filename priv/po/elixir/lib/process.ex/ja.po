msgid ""
msgstr ""
"Project-Id-Version: l 10n_elixir\n"
"PO-Revision-Date: 2017-03-01 16:17+0900\n"
"Last-Translator: 小田 照敬 <EMAIL@ADDRESS>\n"
"Language-Team: Japanese\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"POT-Creation-Date: \n"
"X-Generator: Poedit 1.8.12\n"

#. TRANSLATORS: def Process.exit(pid, reason)
#: lib/process.ex:93
msgid ""
"Sends an exit signal with the given `reason` to the `pid`.\n"
"\n"
"The following behaviour applies if `reason` is any term except `:normal`\n"
"or `:kill`:\n"
"\n"
"  1. If `pid` is not trapping exits, `pid` will exit with the given\n"
"     `reason`.\n"
"\n"
"  2. If `pid` is trapping exits, the exit signal is transformed into a\n"
"     message `{:EXIT, from, reason}` and delivered to the message queue\n"
"     of `pid`.\n"
"\n"
"If `reason` is the atom `:normal`, `pid` will not exit (unless `pid` is\n"
"the calling process, in which case it will exit with the reason `:normal`).\n"
"If it is trapping exits, the exit signal is transformed into a message\n"
"`{:EXIT, from, :normal}` and delivered to its message queue.\n"
"\n"
"If `reason` is the atom `:kill`, that is if `exit(pid, :kill)` is called,\n"
"an untrappable exit signal is sent to `pid` which will unconditionally exit\n"
"with reason `:killed`.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    Process.exit(pid, :kill)\n"
"\n"
msgstr ""
"指定した`reason`の終了シグナルを`pid`に送信します。\n"
"\n"
"`reason`が、`:normal`または`:kill`以外の項の場合、以下の振舞いが\n"
"適用されます:\n"
"\n"
"  1. `pid`が終了を捕捉していない場合、`pid`は指定した`reason`で終了します。\n"
"\n"
"  2. `pid`が終了を捕捉している場合、終了シグナルは`{:EXIT, from, reason}`と\n"
"     いうメッセージに変換され、`pid`のメッセージキューに配送されます。\n"
"\n"
"`reason`がアトム`:normal`の場合、`pid`は終了しません（`pid`が\n"
"呼出し側プロセスでない場合。呼び出し側プロセスの場合は理由`:normal`で\n"
"終了します）。終了を捕捉している場合は、終了シグナルは`{:EXIT, from, reason}`"
"と\n"
"いうメッセージに変換され、メッセージキューに配送されます。\n"
"\n"
"`reason`がアトム`:kill`の場合、すなわち、`exit(pid, :kill)`が呼ばれた場合、\n"
"補足できない終了シグナルが`pid`に送信され、理由`:killed`で無条件に終了しま"
"す。\n"
"\n"
"コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    Process.exit(pid, :kill)\n"
"\n"

#. TRANSLATORS: def Process.info(pid, spec)
#: lib/process.ex:529
msgid ""
"Returns information about the process identified by `pid`,\n"
"or returns `nil` if the process is not alive.\n"
"\n"
"See [`:erlang.process_info/2`](http://www.erlang.org/doc/man/erlang."
"html#process_info-2) for more info.\n"
msgstr ""
"`pid`により識別されるプロセスニ関する情報を返します。\n"
"プロセスが生きていない場合は`nil`を返します。\n"
"\n"
"詳細は、\n"
"[`:erlang.process_info/2`](http://www.erlang.org/doc/man/erlang."
"html#process_info-2)\n"
"を参照してください。\n"

#. TRANSLATORS: def Process.hibernate(mod, fun, args)
#: lib/process.ex:550
msgid ""
"Puts the calling process into a wait state\n"
"where its memory allocation has been reduced as much as possible,\n"
"which is useful if the process does not expect to receive any messages\n"
"in the near future.\n"
"\n"
"See [`:erlang.hibernate/3`](http://www.erlang.org/doc/man/erlang."
"html#hibernate-3) for more info.\n"
"\n"
"Inlined by the compiler.\n"
msgstr ""
"呼出しプロセスをwait状態にします。これによりプロセスへのメモリ\n"
"アロケーションが可能な限り縮小されます。これは、プロセスが近い将来\n"
"メッセージを受信しないことが予想される場合に便利です。\n"
"\n"
"詳細は、\n"
"[`:erlang.hibernate/3`](http://www.erlang.org/doc/man/erlang."
"html#hibernate-3)\n"
"を参照してください。\n"
"\n"
"コンパイラによりインライン化されます。\n"

#. TRANSLATORS: def Process.unlink(pid)
#: lib/process.ex:399
msgid ""
"Removes the link, if there is one, between the calling process and\n"
"the process or port referred to by `pid`. Returns `true` and does not\n"
"fail, even if there is no link or `id` does not exist\n"
"\n"
"See [`:erlang.unlink/1`](http://www.erlang.org/doc/man/erlang.html#unlink-1) "
"for more info.\n"
"\n"
"Inlined by the compiler.\n"
msgstr ""
"呼び出し側プロセスと`pid`により参照されるプロセスまたはポートの間の\n"
"リンクを、もしそれがあれば、削除します。たとえリンクがなくても、`id`が\n"
"存在しなくても、失敗はせず`true`を返します。\n"
"\n"
"詳細は、\n"
"[`:erlang.unlink/1`](http://www.erlang.org/doc/man/erlang.html#unlink-1)\n"
"を参照してください。\n"
"\n"
"コンパイラによりインライン化されます。\n"

#. TRANSLATORS: def Process.flag(pid, flag, value)
#: lib/process.ex:505
msgid ""
"Sets certain flags for the process `pid`, in the same manner as `flag/2`.\n"
"Returns the old value of the `flag`. The allowed values for `flag` are\n"
"only a subset of those allowed in `flag/2`, namely `:save_calls`.\n"
"\n"
"See [`:erlang.process_flag/3`](http://www.erlang.org/doc/man/erlang."
"html#process_flag-3) for more info.\n"
msgstr ""
"`flag/2`と同じ方法で、`pid`プロセスに特定のフラグをセットします。\n"
"`flag`の古い値を返します。`flag`に指定可能な値は`flag/2`で許されている\n"
"値のサブセットである`:save_calls`だけです。\n"
"\n"
"詳細は\n"
"[`:erlang.process_flag/3`](http://www.erlang.org/doc/man/erlang."
"html#process_flag-3)\n"
"を参照してください。\n"

#. TRANSLATORS: def Process.get()
#: lib/process.ex:30
msgid ""
"Returns all key-value pairs in the process dictionary.\n"
"\n"
"Inlined by the compiler.\n"
msgstr ""
"プロセス辞書のすべてのkey-valueペアを返します。\n"
"\n"
"コンパイラによりインライン化されます。\n"

#. TRANSLATORS: def Process.send(dest, msg, options)
#: lib/process.ex:201
msgid ""
"Sends a message to the given process.\n"
"\n"
"If the option `:noconnect` is used and sending the message would require an\n"
"auto-connection to another node the message is not sent and `:noconnect` is\n"
"returned.\n"
"\n"
"If the option `:nosuspend` is used and sending the message would cause the\n"
"sender to be suspended the message is not sent and `:nosuspend` is "
"returned.\n"
"\n"
"Otherwise the message is sent and `:ok` is returned.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Process.send({:name, :node_does_not_exist}, :hi, [:noconnect])\n"
"    :noconnect\n"
"\n"
msgstr ""
"指定したプロセスにメッセージを送信します。\n"
"\n"
"`:noconnect`オプションが使用され、送信するメッセージが別ノードへの\n"
"自動接続が必要な場合、メッセージは送信されず、`:noconnect`が返されます。\n"
"\n"
"`:nosuspend`オプションが使用され、送信するメッセージが送信者をサスペンド\n"
"させることになる場合、メッセージは送信されず、`:nosuspend`が返されます。\n"
"\n"
"これら以外はメッセージは送信され、`:ok`が返されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> Process.send({:name, :node_does_not_exist}, :hi, [:noconnect])\n"
"    :noconnect\n"
"\n"

#. TRANSLATORS: def Process.get_keys(value)
#: lib/process.ex:64
msgid ""
"Returns all keys that have the given `value`.\n"
"\n"
"Inlined by the compiler.\n"
msgstr ""
"指定した`value`をもつすべてのキーを返します。\n"
"\n"
"コンパイラによりインライン化されます。\n"

#. TRANSLATORS: def Process.register(pid_or_port, name)
#: lib/process.ex:413
msgid ""
"Registers the given `pid_or_port` under the given `name`.\n"
"\n"
"`name` must be an atom and can then be used instead of the\n"
"PID/port identifier when sending messages with `Kernel.send/2`.\n"
"\n"
"`register/2` will fail with `ArgumentError` if the PID/Port is\n"
"not existing locally and alive, if the name is already registered\n"
"or if the `pid_or_port` is already registered to a different `name`.\n"
"\n"
"The following names are reserved and cannot be assigned to\n"
"processes nor ports: `nil`, `false`, `true` or `:undefined`.\n"
msgstr ""
"指定した`name`で`pid_or_port`を登録します。\n"
"\n"
"`name`はアトムでなければならず、`Kernel.send/2`でメッセージを\n"
"送信する際に、PIDやポート識別子の代わりに使用することができます。\n"
"\n"
"PIDまたはポートがローカルに存在しない、または生きていない場合、\n"
"名前がすでに登録されている場合、または、`pid_or_port`がすでに別の\n"
"名前で登録されている場合、`register/2`は`ArgumentError`で失敗します。\n"
"\n"
"次の名前は予約されており、プロセスやポートに付与することはできません: \n"
"`nil`、`false`、`true`、`:undefined`。\n"

#. TRANSLATORS: def Process.monitor(item)
#: lib/process.ex:341
msgid ""
"The calling process starts monitoring the given `item`.\n"
"It returns the monitor reference.\n"
"\n"
"See [the need for monitoring](http://elixir-lang.org/getting-started/mix-otp/"
"genserver.html#the-need-for-monitoring)\n"
"for an example.\n"
"See [`:erlang.monitor/2`](http://www.erlang.org/doc/man/erlang."
"html#monitor-2) for more info.\n"
"\n"
"Inlined by the compiler.\n"
msgstr ""
"呼び出し側プロセスは指定した`item`のモニタを開始します。\n"
"モニタリファレンスを返します。\n"
"\n"
"例は [モニタリングの必要性](http://elixir-lang.org/getting-started/mix-otp/"
"genserver.html#the-need-for-monitoring)\n"
"を参照してください。\n"
"\n"
"詳細は \n"
"[`:erlang.monitor/2`](http://www.erlang.org/doc/man/erlang.html#monitor-2)\n"
"を参照してください。\n"
"\n"
"コンパイラによりインライン化されます。\n"

#. TRANSLATORS: def Process.get_keys()
#: lib/process.ex:54
msgid ""
"Returns all keys in the process dictionary.\n"
"\n"
"Inlined by the compiler.\n"
msgstr ""
"プロセス辞書のすべてのキーを返します。\n"
"\n"
"コンパイラによりインライン化されます。\n"

#. TRANSLATORS: def Process.cancel_timer(timer_ref)
#: lib/process.ex:258
msgid ""
"Cancels a timer created by `send_after/3`.\n"
"\n"
"When the result is an integer, it represents the time in milliseconds\n"
"left until the timer would have expired.\n"
"\n"
"When the result is `false`, a timer corresponding to `timer_ref` could\n"
"not be found. This can be either because the timer expired, already has\n"
"been canceled, or because `timer_ref` never corresponded to a timer.\n"
"\n"
"If the timer has expired, the timeout message has been sent, but it does\n"
"not tell you whether or not it has arrived at its destination yet.\n"
"\n"
"Inlined by the compiler.\n"
msgstr ""
"`send_after/3`で作成されたタイマーをキャンセルします。\n"
"\n"
"結果が整数の場合、タイマーが期限切れになるまでの時間をミリ秒単位で\n"
"表します。\n"
"\n"
"結果が`false`の場合、`timer_ref`に対応するタイマがみつからなかった\n"
"ことを示します。これは、タイマーが期限切れになっているか、既にキャンセル\n"
"されているか、`timer_ref`がタイマーに対応していないか、のいずれかが\n"
"原因です。\n"
"\n"
"タイマが期限が切れている場合はタイムアウトメッセージが送信されますが、\n"
"それが宛先に到着したか否かはわかりません。\n"
"\n"
"コンパイラによりインライン化されます。\n"

#. TRANSLATORS: def Process.put(key, value)
#: lib/process.ex:74
msgid ""
"Stores the given `key`-`value` pair in the process dictionary.\n"
"\n"
"The return value is the value that was previously stored under the key "
"`key`\n"
"(or `nil` in case no value was stored under `key`).\n"
msgstr ""
"指定した`key`-`value`ペアをプロセス辞書に保存します。\n"
"\n"
"返り値はキー`key`で保存されていた前の値（`key`で保存されていた値が\n"
"無い場合は`nil`）を返します。\n"

#. TRANSLATORS: def Process.flag(flag, value)
#: lib/process.ex:494
msgid ""
"Sets certain flags for the process which calls this function.\n"
"Returns the old value of the `flag`.\n"
"\n"
"See [`:erlang.process_flag/2`](http://www.erlang.org/doc/man/erlang."
"html#process_flag-2) for more info.\n"
msgstr ""
"この関数を呼び出したプロセスに特定のフラグをセットします。\n"
"`flag`の古い値を返します。\n"
"\n"
"詳細は\n"
"[`:erlang.process_flag/2`](http://www.erlang.org/doc/man/erlang."
"html#process_flag-2)\n"
"を参照してください。\n"

#. TRANSLATORS: def Process.sleep(timeout)
#: lib/process.ex:127
msgid ""
"Sleeps the current process by `timeout`.\n"
"\n"
"`timeout` is either the number of milliseconds to sleep as an\n"
"integer or the atom `:infinity`. When `:infinity` is given,\n"
"the current process will suspend forever.\n"
"\n"
"**Use this function with extreme care**. For almost all situations\n"
"where you would use `sleep/1` in Elixir, there is likely a\n"
"more correct, faster and precise way of achieving it with\n"
"message passing.\n"
"\n"
"For example, if you are waiting a process to perform some\n"
"action, it is better to communicate.\n"
"\n"
"In other words, **do not**:\n"
"\n"
"    Task.start_link fn ->\n"
"      do_something()\n"
"      ...\n"
"    end\n"
"\n"
"    # Wait until work is done\n"
"    Process.sleep(2000)\n"
"\n"
"But **do**:\n"
"\n"
"    parent = self()\n"
"    Task.start_link fn ->\n"
"      do_something()\n"
"      send parent, :work_is_done\n"
"      ...\n"
"    end\n"
"\n"
"    receive do\n"
"      :work_is_done -> :ok\n"
"    after\n"
"      30_000 -> :timeout # Optional timeout\n"
"    end\n"
"\n"
"Or even use `Task.async/1` and `Task.await/2` in the example\n"
"above.\n"
"\n"
"Similarly, if you are waiting for a process to terminate,\n"
"use monitor instead of sleep. **Do not**:\n"
"\n"
"    Task.start_link fn ->\n"
"      ...\n"
"    end\n"
"\n"
"    # Wait until task terminates\n"
"    Process.sleep(2000)\n"
"\n"
"Instead **do**:\n"
"\n"
"    {:ok, pid} =\n"
"      Task.start_link fn ->\n"
"        ...\n"
"      end\n"
"\n"
"    ref = Process.monitor(pid)\n"
"    receive do\n"
"      {:DOWN, ^ref, _, _, _} -> :task_is_down\n"
"    after\n"
"      30_000 -> :timeout # Optional timeout\n"
"    end\n"
"\n"
msgstr ""
"現在のプロセスを`timeout`だけスリープさせます。\n"
"\n"
"`timeout`はスリープさせるミリ秒を表す整数値か、アトム`:infinity`です。\n"
"`:infinity`が指定された場合、現在のプロセスは永久にサスペンドします。\n"
"\n"
"**この関数は細心の注意を払って使用してください**。\n"
"Elixirで`sleep/1`を使用するほぼすべての状況において、\n"
"メッセージの受け渡しで行う、より正しく速く正確な方法があります。\n"
"\n"
"たとえば、何らかのアクションを実行するためにプロセスを\n"
"待たせるなら、通信した方が良いです。\n"
"\n"
"言い替えると、 **次のようにはしないでください**:\n"
"\n"
"    Task.start_link fn ->\n"
"      do_something()\n"
"      ...\n"
"    end\n"
"\n"
"    # 作業が終わるまで待つ\n"
"    Process.sleep(2000)\n"
"\n"
"このように **してください**:\n"
"\n"
"    parent = self()\n"
"    Task.start_link fn ->\n"
"      do_something()\n"
"      send parent, :work_is_done\n"
"      ...\n"
"    end\n"
"\n"
"    receive do\n"
"      :work_is_done -> :ok\n"
"    after\n"
"      30_000 -> :timeout # オプションのタイムアウト\n"
"    end\n"
"\n"
"むしろ、上の例では`Task.async/1`と`Task.await/2`を\n"
"使ってください。\n"
"\n"
"同様に、プロセスの終了を待つなら、sleepのかわりに\n"
"monitorを使ってください。**次のようにはしないでください**:\n"
"\n"
"    Task.start_link fn ->\n"
"      ...\n"
"    end\n"
"\n"
"    # タスクの終了を待つ\n"
"    Process.sleep(2000)\n"
"\n"
"代わりに **こうしてください**:\n"
"\n"
"    {:ok, pid} =\n"
"      Task.start_link fn ->\n"
"        ...\n"
"      end\n"
"\n"
"    ref = Process.monitor(pid)\n"
"    receive do\n"
"      {:DOWN, ^ref, _, _, _} -> :task_is_down\n"
"    after\n"
"      30_000 -> :timeout # オプションのタイムアウト\n"
"    end\n"
"\n"

#. TRANSLATORS: def Process.demonitor(monitor_ref, options \\ [])
#: lib/process.ex:356
msgid ""
"If `monitor_ref` is a reference which the calling process\n"
"obtained by calling `monitor/1`, this monitoring is turned off.\n"
"If the monitoring is already turned off, nothing happens.\n"
"\n"
"See [`:erlang.demonitor/2`](http://www.erlang.org/doc/man/erlang."
"html#demonitor-2) for more info.\n"
"\n"
"Inlined by the compiler.\n"
msgstr ""
"`monitor_ref`が、呼び出し側プロセスが`monitor/1`を呼ぶことで得た\n"
"参照である場合、このモニタリングが無効になります。モニタリングが\n"
"既に無効の場合は何も起きません。\n"
"\n"
"詳細は\n"
"[`:erlang.demonitor/2`](http://www.erlang.org/doc/man/erlang."
"html#demonitor-2)\n"
"を参照してください。\n"
"\n"
"コンパイラによりインライン化されます。\n"

#. TRANSLATORS: def Process.list()
#: lib/process.ex:371
msgid ""
"Returns a list of process identifiers corresponding to all the\n"
"processes currently existing on the local node.\n"
"\n"
"Note that a process that is exiting, exists but is not alive, i.e.,\n"
"`alive?/1` will return `false` for a process that is exiting,\n"
"but its process identifier will be part of the result returned.\n"
"\n"
"See [`:erlang.processes/0`](http://www.erlang.org/doc/man/erlang."
"html#processes-0) for more info.\n"
msgstr ""
"ローカルノードに現在存在するすべてのプロセスに対応する\n"
"プロセス識別子のリストを返します。\n"
"\n"
"終了したプロセスや存在するが生きていないプロセス、`alive?/1`が\n"
"`false`を返すような、終了しようとしているプロセスのプロセス識別子も\n"
"返されたリストに含まれることに注意してください。\n"
"\n"
"詳細は \n"
"[`:erlang.processes/0`](http://www.erlang.org/doc/man/erlang."
"html#processes-0)\n"
"を参照してください。\n"

#. TRANSLATORS: def Process.whereis(name)
#: lib/process.ex:455
msgid ""
"Returns the PID or port identifier with the registered `name`.\n"
"Returns `nil` if the name is not registered.\n"
"\n"
"See [`:erlang.whereis/1`](http://www.erlang.org/doc/man/erlang."
"html#whereis-1) for more info.\n"
msgstr ""
"登録済みの`name`を持つPIDまたはポート識別子を返します。\n"
"登録されていない場合は`nil`を返します。\n"
"\n"
"詳細は \n"
"[`:erlang.whereis/1`](http://www.erlang.org/doc/man/erlang.html#whereis-1)\n"
"を参照してください。\n"

#. TRANSLATORS: def Process.alive?(pid)
#: lib/process.ex:17
msgid ""
"Returns `true` if the process exists and is alive (i.e. it is not exiting\n"
"and has not exited yet). Otherwise, returns `false`.\n"
"\n"
"`pid` must refer to a process at the local node.\n"
"\n"
"Inlined by the compiler.\n"
msgstr ""
"プロセスが存在し、生きている（すなわち、終了していない、\n"
"まだ終了途中でない）場合は`true`を返します。\n"
"そうでない場合は`false`を返します。\n"
"\n"
"`pid`はローカルノードのプロセスの参照でなければなりません。\n"
"\n"
"コンパイラによりインライン化されます。\n"

#. TRANSLATORS: def Process.info(pid)
#: lib/process.ex:517
msgid ""
"Returns information about the process identified by `pid`, or returns `nil` "
"if the process\n"
"is not alive.\n"
"Use this only for debugging information.\n"
"\n"
"See [`:erlang.process_info/1`](http://www.erlang.org/doc/man/erlang."
"html#process_info-1) for more info.\n"
msgstr ""
"`pid`により識別されるプロセスに関する情報を返します。\n"
"プロセスが生きていない場合は`nil`を返します。\n"
"これはデバッギング情報が必要な場合にのみ使用してください。\n"
"\n"
"詳細は、\n"
"[`:erlang.process_info/1`](http://www.erlang.org/doc/man/erlang."
"html#process_info-1)\n"
"を参照してください。\n"

#. TRANSLATORS: def Process.read_timer(timer_ref)
#: lib/process.ex:278
msgid ""
"Reads a timer created by `send_after/3`.\n"
"\n"
"When the result is an integer, it represents the time in milliseconds\n"
"left until the timer will expire.\n"
"\n"
"When the result is `false`, a timer corresponding to `timer_ref` could\n"
"not be found. This can be either because the timer expired, already has\n"
"been canceled, or because `timer_ref` never corresponded to a timer.\n"
"\n"
"If the timer has expired, the timeout message has been sent, but it does\n"
"not tell you whether or not it has arrived at its destination yet.\n"
"\n"
"Inlined by the compiler.\n"
msgstr ""
"`send_after/3`で作成されたタイマを読みます。\n"
"\n"
"結果が整数の場合は、タイマが期限切れになるまでの残りの時間を\n"
"ミリ秒単位で表します。\n"
"\n"
"結果が`false`の場合は、`timer_ref`に対応するタイマがみつからなかった\n"
"ことを示します。これは、タイマーが期限切れになっているか、既にキャンセル\n"
"されているか、`timer_ref`がタイマーに対応していないか、のいずれかが\n"
"原因です。\n"
"\n"
"タイマが期限が切れている場合はタイムアウトメッセージが送信されますが、\n"
"それが宛先に到着したか否かはわかりません。\n"
"\n"
"コンパイラによりインライン化されます。\n"

#. TRANSLATORS: Elixir.Process Summary
#: lib/process.ex:2
msgid ""
"Conveniences for working with processes and the process dictionary.\n"
"\n"
"Besides the functions available in this module, the `Kernel` module\n"
"exposes and auto-imports some basic functionality related to processes\n"
"available through the functions:\n"
"\n"
"  * `Kernel.spawn/1` and `Kernel.spawn/3`\n"
"  * `Kernel.spawn_link/1` and `Kernel.spawn_link/3`\n"
"  * `Kernel.spawn_monitor/1` and `Kernel.spawn_monitor/3`\n"
"  * `Kernel.self/0`\n"
"  * `Kernel.send/2`\n"
"\n"
msgstr ""
"プロセスとプロセス辞書を扱うための便利な関数群です。\n"
"\n"
"このモジュールで利用できる関数の他にも、`Kernel`モジュールが以下の関数\n"
"を通じて利用可能なプロセス関連の基本的機能を公開し、自動インポートし\n"
"ています。\n"
"\n"
"  * `Kernel.spawn/1` 、 `Kernel.spawn/3`\n"
"  * `Kernel.spawn_link/1` 、 `Kernel.spawn_link/3`\n"
"  * `Kernel.spawn_monitor/1` 、 `Kernel.spawn_monitor/3`\n"
"  * `Kernel.self/0`\n"
"  * `Kernel.send/2`\n"
"\n"

#. TRANSLATORS: def Process.registered()
#: lib/process.ex:483
msgid ""
"Returns a list of names which have been registered using `register/2`.\n"
msgstr "`register/2`を使って登録された名前のリストを返します。\n"

#. TRANSLATORS: def Process.unregister(name)
#: lib/process.ex:443
msgid ""
"Removes the registered `name`, associated with a PID\n"
"or a port identifier.\n"
"\n"
"Fails with `ArgumentError` if the name is not registered\n"
"to any PID or port.\n"
msgstr ""
"PIDまたはポート識別子に関連付けれらた登録済の`name`を削除します。\n"
"\n"
"名前がPIDまたはポートに登録されていない場合は`ArgumentError`で\n"
"失敗します。\n"

#. TRANSLATORS: def Process.group_leader()
#: lib/process.ex:466
msgid ""
"Returns the PID of the group leader for the process which evaluates the "
"function.\n"
msgstr "関数を評価するプロセスのグループリーダのPIDを返します。\n"

#. TRANSLATORS: def Process.group_leader(pid, leader)
#: lib/process.ex:474
msgid ""
"Sets the group leader of `pid` to `leader`. Typically, this is used when a "
"processes\n"
"started from a certain shell should have a group leader other than `:init`.\n"
msgstr ""
"`pid`のグループリーダーを`leader`にセットします。通常、特定のシェルから\n"
"起動されたプロセスが`:init`以外のグループリーダーを持つ必要がある場合に\n"
"使用されます。\n"

#. TRANSLATORS: def Process.get(key, default \\ nil)
#: lib/process.ex:40
msgid ""
"Returns the value for the given `key` or `default` if `key` is not set.\n"
msgstr ""
"指定した`key`の値を返します。`key`が設定されていない場合は\n"
"`default`を返します。\n"

#. TRANSLATORS: def Process.delete(key)
#: lib/process.ex:85
msgid "Deletes the given `key` from the process dictionary.\n"
msgstr "指定した`key`をプロセス辞書から削除します。\n"

#. TRANSLATORS: def Process.spawn(mod, fun, args, opts)
#: lib/process.ex:322
msgid ""
"Spawns the given function from module `mod`, passing the given `args`\n"
"according to the given options.\n"
"\n"
"The result depends on the given options. In particular,\n"
"if `:monitor` is given as an option, it will return a tuple\n"
"containing the PID and the monitoring reference, otherwise\n"
"just the spawned process PID.\n"
"\n"
"It also accepts extra options, for the list of available options\n"
"check [`:erlang.spawn_opt/4`](http://www.erlang.org/doc/man/erlang."
"html#spawn_opt-4).\n"
"\n"
"Inlined by the compiler.\n"
msgstr ""
"指定した`args`を引数にモジュール`mod`の指定した関数を\n"
"指定のオプションに従って生成します。\n"
"\n"
"返り値は、指定したオプションによります。特に、`:monitor`が\n"
"オプションとして指定された場合は、PIDとモニタリファレンスを\n"
"含むタプルを返します。それ以外は、生成されたプロセスのPIDを返します。\n"
"\n"
"その他のオプションも受け付けます。利用可能なオプションの\n"
"リストについては\n"
"[`:erlang.spawn_opt/4`](http://www.erlang.org/doc/man/erlang."
"html#spawn_opt-4)\n"
"をチェックしてください。\n"
"\n"
"コンパイラによりインライン化されます。\n"

#. TRANSLATORS: def Process.link(pid)
#: lib/process.ex:386
msgid ""
"Creates a link between the calling process and another process\n"
"(or port) `pid`, if there is not such a link already.\n"
"\n"
"See [`:erlang.link/1`](http://www.erlang.org/doc/man/erlang.html#link-1) for "
"more info.\n"
"\n"
"Inlined by the compiler.\n"
msgstr ""
"呼び出し側プロセスと他のプロセス(またはport)`pid`の間に、まだ\n"
"そのようなリンクがない場合に、リンクを作成します。\n"
"\n"
"詳細は、\n"
"[`:erlang.link/1`](http://www.erlang.org/doc/man/erlang.html#link-1)\n"
"を参照してください。\n"
"\n"
"コンパイラによりインライン化されます。\n"

#. TRANSLATORS: def Process.send_after(dest, msg, time, opts \\ [])
#: lib/process.ex:227
msgid ""
"Sends `msg` to `dest` after `time` milliseconds.\n"
"\n"
"If `dest` is a PID, it must be the PID of a local process, dead or alive.\n"
"If `dest` is an atom, it must be the name of a registered process\n"
"which is looked up at the time of delivery. No error is given if the name "
"does\n"
"not refer to a process.\n"
"\n"
"This function returns a timer reference, which can be read or canceled with\n"
"`read_timer/1` and `cancel_timer/1`.\n"
"\n"
"Finally, the timer will be automatically canceled if the given `dest` is a "
"PID\n"
"which is not alive or when the given PID exits. Note that timers will not "
"be\n"
"automatically canceled when `dest` is an atom (as the atom resolution is "
"done\n"
"on delivery).\n"
"\n"
"## Options\n"
"\n"
"  * `:abs` - (boolean) when `false`, `time` is treated as relative to the\n"
"  current monotonic time. When `true`, `time` is the absolute value of the\n"
"  Erlang monotonic time at which `msg` should be delivered to `dest`.\n"
"  To read more about Erlang monotonic time and other time-related concepts,\n"
"  look at the documentation for the `System` module. Defaults to `false`.\n"
"\n"
msgstr ""
"`msg`を`dest`に`time`ミリ秒後に送信します。\n"
"\n"
"`dest`がPIDの場合、死んでいるか生きているかにかかわらず、\n"
"ローカルプロセスのPIDでなければなりません。`dest`がアトムの場合、\n"
"配送時に調べた時に登録済みのプロセスの名前でなければなりません。\n"
"名前がプロセスを参照できなくても、エラーにはなりません。\n"
"\n"
"この関数はタイマーリファレンスを返します。`read_timer/1`と\n"
"`cancel_timer/1`でタイマーの読み込みとキャンセルができます。\n"
"\n"
"最後に、指定した`pid`が、生きていない、または存在しない場合、\n"
"タイマは自動的にキャンセルされます。ただし、`dest`がアトムの\n"
"場合、タイマーは自動的にはキャセンセルされないことに注意して\n"
"ください。（アトムの解決は配送時に行われるからです）。\n"
"\n"
"## オプション\n"
"\n"
"  * `:abs` - （ブール値）`false`の場合、`time`は現在の単調時間に対する相対時"
"間と\n"
"  して扱われます。`true`の場合、`time`は`msg`が`dest`に配送されるべきErlang"
"の\n"
"  単調時間の絶対値です。Eralngの単調時間やその他の時間関連の概念に関する詳細"
"は\n"
"  `System`モジュールのドキュメントを見てください。デフォルトは`false`です。\n"
"\n"

#. TRANSLATORS: def Process.spawn(fun, opts)
#: lib/process.ex:304
msgid ""
"Spawns the given function according to the given options.\n"
"\n"
"The result depends on the given options. In particular,\n"
"if `:monitor` is given as an option, it will return a tuple\n"
"containing the PID and the monitoring reference, otherwise\n"
"just the spawned process PID.\n"
"\n"
"It also accepts extra options, for the list of available options\n"
"check [`:erlang.spawn_opt/4`](http://www.erlang.org/doc/man/erlang."
"html#spawn_opt-4).\n"
"\n"
"Inlined by the compiler.\n"
msgstr ""
"指定した関数を指定のオプションに従って生成します。\n"
"\n"
"返り値は、指定したオプションによります。特に、`:monitor`が\n"
"オプションとして指定された場合は、PIDとモニタリファレンスを\n"
"含むタプルを返します。それ以外は、生成されたプロセスのPIDを返します。\n"
"\n"
"その他のオプションも受け付けます。利用可能なオプションの\n"
"リストについては\n"
"[`:erlang.spawn_opt/4`](http://www.erlang.org/doc/man/erlang."
"html#spawn_opt-4)\n"
"をチェックしてください。\n"
"\n"
"コンパイラによりインライン化されます。\n"

#, fuzzy
#~ msgid ""
#~ "\n"
#~ "Removes the link between the calling process and the given item (process "
#~ "or\n"
#~ "port).\n"
#~ "\n"
#~ "If there is no such link, this function does nothing. If `pid_or_port` "
#~ "does\n"
#~ "not exist, this function does not produce any errors and simply does "
#~ "nothing.\n"
#~ "\n"
#~ "The return value of this function is always `true`.\n"
#~ "\n"
#~ "See [`:erlang.unlink/1`](http://www.erlang.org/doc/man/erlang."
#~ "html#unlink-1) for more info.\n"
#~ "\n"
#~ "Inlined by the compiler.\n"
#~ msgstr ""
#~ "もし、呼び出したプロセスと、`pid`で参照されたプロセスあるいはポートとの\n"
#~ "間にリンクがあれば、それを削除します。\n"
#~ "もしリンクが無い、あるいは`pid`が存在しないとしても、\n"
#~ "失敗せず、`true`を返します。\n"
#~ "\n"
#~ "詳細は \n"
#~ "[`:erlang.unlink/1`](http://www.erlang.org/doc/man/erlang.html#unlink-1)\n"
#~ "を参照してください。\n"
#~ "\n"
#~ "コンパイラによりインライン化されます。\n"

#, fuzzy
#~ msgid ""
#~ "Spawns the given function according to the given options.\n"
#~ "\n"
#~ "The result depends on the given options. In particular,\n"
#~ "if `:monitor` is given as an option, it will return a tuple\n"
#~ "containing the PID and the monitoring reference, otherwise\n"
#~ "just the spawned process PID.\n"
#~ "\n"
#~ "More options are available; for the comprehensive list of available "
#~ "options\n"
#~ "check [`:erlang.spawn_opt/4`](http://www.erlang.org/doc/man/erlang."
#~ "html#spawn_opt-4).\n"
#~ "\n"
#~ "Inlined by the compiler.\n"
#~ msgstr ""
#~ "与えられたオプションによって、与えられたモジュールと関数に与えられた引\n"
#~ "数を送ってプロセスを生成します。\n"
#~ "\n"
#~ "戻値は、与えられたオプションによります。特に、`:monitor`オプションが与\n"
#~ "えられると、pidとモニタリファレンスを含むタプルを返し、さもなければ、生\n"
#~ "成されたプロセスのpidを返します。\n"
#~ "\n"
#~ "他のオプションも受け入れます。利用できるオプションのリストについては\n"
#~ "[`:erlang.spawn_opt/4`](http://www.erlang.org/doc/man/erlang."
#~ "html#spawn_opt-4)\n"
#~ "をチェックしてください。\n"
#~ "\n"
#~ "コンパイラによりインライン化されます。\n"

#~ msgid ""
#~ "Returns all key-values in the dictionary.\n"
#~ "\n"
#~ "Inlined by the compiler.\n"
#~ msgstr ""
#~ "プロセス辞書の全てのキー/値の組を全て返します。\n"
#~ "\n"
#~ "コンパイラによりインライン化されます。\n"

#~ msgid "Stores the given key-value in the process dictionary.\n"
#~ msgstr "プロセス辞書に与えられたキーバリューを保存します。\n"
