msgid ""
msgstr ""
"Project-Id-Version: l 10n_elixir\n"
"PO-Revision-Date: 2017-03-01 11:09+0900\n"
"Last-Translator: 小田 照敬 <EMAIL@ADDRESS>\n"
"Language-Team: Japanese\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"POT-Creation-Date: \n"
"X-Generator: Poedit 1.8.12\n"

#. TRANSLATORS: def GenEvent.add_handler(manager, handler, args)
#: lib/gen_event.ex:430
msgid ""
"Adds a new event handler to the event `manager`.\n"
"\n"
"The event manager will call the `c:init/1` callback with `args` to\n"
"initiate the event handler and its internal state.\n"
"\n"
"If `c:init/1` returns a correct value indicating successful completion,\n"
"the event manager adds the event handler and this function returns\n"
"`:ok`. If the callback fails with `reason` or returns `{:error, reason}`,\n"
"the event handler is ignored and this function returns `{:error, reason}`.\n"
"\n"
"If the given handler was previously installed at the manager, this\n"
"function returns `{:error, :already_present}`.\n"
"\n"
"For installing multiple instances of the same handler, `{Module, id}` "
"instead\n"
"of `Module` must be used. The handler could be then referenced with\n"
"`{Module, id}` instead of just `Module`.\n"
msgstr ""
"イベント`manager`に新しいイベントハンドラを追加します。\n"
"\n"
"イベントマネージャは、イベントハンドラとその内部状態を初期化\n"
"するために、`args`を引数に`init/1`コールバックを呼び出します。\n"
"\n"
"`init/1`が正常終了を示す正しい値を返した場合、イベントマネージャは\n"
"そのイベントハンドラを追加し、この関数は`:ok`を返します。\n"
"コールバックが`reason`で失敗したり、`{:error, reason}`を返した場合は、\n"
"そのイベントハンドラは無視され、この関数は`{:error, reason}`を返します。\n"
"\n"
"指定したハンドラが、すでにマネージャにインストールされていた場合、\n"
"この関数は`{:error, :already_present}`を返します。\n"
"\n"
"同じハンドラのインスタンスを複数インストールをするには、\n"
"`Module`の代りに`{Module, id}`を使わなければなりません。\n"
"その後、そのハンドラは`Module`ではなく`{Module, id}`で参照される\n"
"ことになります。\n"

#. TRANSLATORS: def GenEvent.notify(manager, event)
#: lib/gen_event.ex:498
msgid ""
"Sends an event notification to the event `manager`.\n"
"\n"
"The event manager will call `c:handle_event/2` for each\n"
"installed event handler.\n"
"\n"
"`notify` is asynchronous and will return immediately after the\n"
"notification is sent. `notify` will not fail even if the specified\n"
"event manager does not exist, unless it is specified as an atom.\n"
msgstr ""
"イベント`manager`にイベント通知を送ります。\n"
"\n"
"イベントマネージャはインストールされた各イベントハンドラの\n"
"`c:handle_event/2`を呼び出します。\n"
"\n"
"`notify`は非同期で、通知を送信後、直ちに返ります。`notify`は\n"
"アトムで指定されている場合を除き、たとえ、指定されたイベントマネージャが\n"
"存在しなくても失敗しません。\n"

#. TRANSLATORS: @callback init/1
#: lib/gen_event.ex:138
msgid ""
"Invoked when the handler is added to the `GenEvent` process. "
"`add_handler/3`\n"
"(and `add_mon_handler/3`) will block until it returns.\n"
"\n"
"`args` is the argument term (third argument) passed to `add_handler/3`.\n"
"\n"
"Returning `{:ok, state}` will cause `add_handler/3` to return `:ok` and "
"the\n"
"handler to become part of the `GenEvent` loop with state `state`.\n"
"\n"
"Returning `{:ok, state, :hibernate}` is similar to\n"
"`{:ok, state}` except the `GenEvent` process is hibernated before "
"continuing\n"
"its loop. See `c:handle_event/2` for more information on hibernation.\n"
"\n"
"Returning `{:error, reason}` will cause `add_handler/3` to return\n"
"`{:error, reason}` and the handler is not added to `GenEvent` loop.\n"
msgstr ""
"ハンドラが`GenEvent` プロセスに追加された時に呼び出されます。\n"
"`add_handler/3` (と `add_mon_handler/3` )はこれが戻るまで\n"
"ブロックされます。\n"
"\n"
"`args` は `add_handler/3`へ渡される(3番目の)引数です。\n"
"\n"
"`{:ok, state}`を返すと、`add_handler/3`は`:ok` を返し、\n"
"ハンドラは`state`状態を持つ、`GenEvent`ループの一員になります。\n"
"\n"
"`{:ok, state, :hibernate}`は`GenEvent`プロセスがループを\n"
"継続する前に ハイバネートされることを除いて、`{:ok, state}`と\n"
"同じです。ハイバネーションについては`c:handle_event/2`を\n"
"参照してください。\n"
"\n"
"`{:error, reason}`を返すと、`add_handler/3`は`{:error, reason}`を\n"
"返し、ハンドラは`GenEvent`ループに追加されません。\n"

#. TRANSLATORS: def GenEvent.sync_notify(manager, event)
#: lib/gen_event.ex:538
msgid ""
"Sends a sync event notification to the event `manager`.\n"
"\n"
"In other words, this function only returns `:ok` after the event manager\n"
"invokes the `c:handle_event/2` callback on each installed event handler.\n"
"\n"
"See `notify/2` for more info.\n"
msgstr ""
"イベント`manager`にsyncイベント通知を送信します。\n"
"\n"
"言い替えると、この関数は、イベントマネージャがインストールされた\n"
"各イベントハンドラの`c:handle_event/2`を呼び出した後に、はじめて\n"
"`:ok`を返します。\n"
"\n"
"更なる情報は、`notify/2`を参照してください。\n"

#. TRANSLATORS: def GenEvent.start_link(options \\ [])
#: lib/gen_event.ex:350
msgid ""
"Starts an event manager linked to the current process.\n"
"\n"
"This is often used to start the `GenEvent` as part of a supervision tree.\n"
"\n"
"It accepts the `:name` option which is described under the `Name "
"Registration`\n"
"section in the `GenServer` module docs.\n"
"\n"
"If the event manager is successfully created and initialized, the function\n"
"returns `{:ok, pid}`, where `pid` is the PID of the server. If a process "
"with\n"
"the specified server name already exists, the function returns\n"
"`{:error, {:already_started, pid}}` with the PID of that process.\n"
"\n"
"Note that a `GenEvent` started with `start_link/1` is linked to the\n"
"parent process and will exit not only on crashes but also if the parent\n"
"process exits with `:normal` reason.\n"
msgstr ""
"イベントマネージャを現在のプロセスにリンクさせて起動します。\n"
"\n"
"通常、監視ツリーの一部として`GenEvent`を起動する場合に使用されます。\n"
"\n"
"`GenServer`モジュールドキュメントの「名前の登録」セクションに記述\n"
"されている`:name`オプションを受け付けます。\n"
"\n"
"イベントマネージャが正常に作成・初期化された場合、この関数は\n"
"`{:ok, pid}`を返します。ここで、`pid`はサーバーのPIDです。\n"
"指定したサーバ名を持つプロセスが既に存在した場合、この関数は\n"
"`{:error, {:already_started, pid}}`を返します。`pid`はそのプロセスの\n"
"PIDです。\n"
"\n"
"`start_link/1`で起動した`GenEvent`は親プロセスにリンクされ、\n"
"親プロセスがクラッシュした場合だけでなく、`:normal` 理由で\n"
"終了した場合にも、終了することに注意してください。\n"

#. TRANSLATORS: @callback code_change/3
#: lib/gen_event.ex:265
msgid ""
"Invoked to change the state of the handler when a different version of the\n"
"handler's module is loaded (hot code swapping) and the state's term\n"
"structure should be changed.\n"
"\n"
"`old_vsn` is the previous version of the module (defined by the `@vsn`\n"
"attribute) when upgrading. When downgrading the previous version is wrapped "
"in\n"
"a 2-tuple with first element `:down`. `state` is the current state of the\n"
"handler and `extra` is any extra data required to change the state.\n"
"\n"
"Returning `{:ok, new_state}` changes the state to `new_state` and the code\n"
"change is successful.\n"
"\n"
"If `c:code_change/3` raises, the code change fails and the handler will "
"continue\n"
"with its previous state. Therefore this callback does not usually contain "
"side\n"
"effects.\n"
msgstr ""
"異ったバージョンのハンドラモジュールがロードされた時、\n"
"ハンドラの状態を変更するために呼び出されます(ホットコード\n"
"スワッピング)。状態の項構造体は変更されます。\n"
"n\n"
"\n"
"`old_vsn`は、アップグレードの場合はモジュールの（`@vsn`属性で\n"
"定義される）前バージョンです。ダウングレードの場合は、前バージョンは\n"
"2要素タプルで包まれ、その第1要素は`:down`です。`state`はハンドラの\n"
"現在の状態で、`extra`は状態の変更に必要な任意の追加データです。\n"
"\n"
"`{:ok, new_state}`を返すと、状態は`new_state`に変更され、コード変更は\n"
"成功です。\n"
"\n"
"`c:code_change/3`が例外を発生させた場合は、コード変更は失敗であり、\n"
"ハンドラは以前の状態のまま継続します。したがって、通常、このコールバックは\n"
"副作用を持ちません。\n"

#. TRANSLATORS: @callback handle_call/2
#: lib/gen_event.ex:187
msgid ""
"Invoked to handle synchronous `call/4` messages to a specific handler.\n"
"\n"
"`request` is the request message sent by a `call/4` and `state` is the "
"current\n"
"state of the handler.\n"
"\n"
"Returning `{:ok, reply, new_state}` sends `reply` as a response to the "
"call\n"
"and sets the handler's state to `new_state`.\n"
"\n"
"Returning `{:ok, reply, new_state, :hibernate}` is similar to\n"
"`{:ok, reply, new_state}` except the process is hibernated. See\n"
"`c:handle_event/2` for more information on hibernation.\n"
"\n"
"Returning `{:remove_handler, reply}` sends `reply` as a response to the "
"call,\n"
"removes the handler from the `GenEvent` loop and calls `c:terminate/2` "
"with\n"
"reason `:remove_handler` and state `state`.\n"
msgstr ""
"特定のハンドラへの同期的な`call/4`メッセージを処理するために呼び出されま"
"す。\n"
"\n"
"`request`は`call/4`により送信されたリクエストメッセージであり、\n"
"`state`はハンドラの現在の状態です。\n"
"\n"
"`{:ok, reply, new_state}`を返すと、呼出しの応答として`reply`を\n"
"送信し、ハンドラの状態を`new_state`にセットします。\n"
"\n"
"`{:ok, reply, new_state, :hibernate}`は`{:ok, reply, new_state}`と\n"
"プロセスがハイバネートされることを除いて同じです。\n"
"ハイバネーションについては`c:handle_event/2`を参照してください。\n"
"\n"
"`{:remove_handler, reply}`を返すと、呼出しの応答として`reply`を\n"
"送信し、`GenEvent`のループからハンドラを削除し、\n"
"`:remove_handler`をreason引数に、`state`をstate引数に\n"
"`terminate/2`を呼出します。\n"

#. TRANSLATORS: def GenEvent.ack_notify(manager, event)
#: lib/gen_event.ex:551
msgid ""
"Sends an ack event notification to the event `manager`.\n"
"\n"
"In other words, this function only returns `:ok` as soon as the\n"
"event manager starts processing this event, but it does not wait\n"
"for event handlers to process the sent event.\n"
"\n"
"See `notify/2` for more info. Note this function is specific\n"
"to Elixir's GenEvent and does not work with Erlang ones.\n"
msgstr ""
"ackイベント通知をイベント`manager`へ送信します。\n"
"\n"
"言い替えると、この関数は、イベントマネージャがこのイベントの処理を\n"
"開始するとすぐに`:ok`を返すだけで、イベントハンドラが送られた\n"
"イベントを処理するのは待ちません。\n"
"\n"
"詳しくは`notify/2`を参照してください。この関数はElixirの\n"
"GenEventに特有なものであり、Erlangの関数と一緒には動作しません。\n"

#. TRANSLATORS: def GenEvent.swap_mon_handler(manager, handler1, args1, handler2, args2)
#: lib/gen_event.ex:622
msgid ""
"Replaces an old event handler with a new monitored one in the event "
"`manager`.\n"
"\n"
"Read the docs for `add_mon_handler/3` and `swap_handler/5` for more "
"information.\n"
msgstr ""
"イベント`manager`内の古いイベントハンドラをモニタされている\n"
"新しいイベントハンドラで置き換えます。\n"
"\n"
"詳細は、`add_mon_handler/3`と`swap_handler/5`のドキュメントを\n"
"参照してください。\n"

#. TRANSLATORS: def GenEvent.swap_handler(manager, handler1, args1, handler2, args2)
#: lib/gen_event.ex:601
msgid ""
"Replaces an old event handler with a new one in the event `manager`.\n"
"\n"
"First, the old event handler is deleted by calling `c:terminate/2` with\n"
"the given `args1` and collects the return value. Then the new event "
"handler\n"
"is added and initiated by calling `init({args2, term})`, where `term` is "
"the\n"
"return value of calling `c:terminate/2` in the old handler. This makes it\n"
"possible to transfer information from one handler to another.\n"
"\n"
"The new handler will be added even if the specified old event handler\n"
"is not installed or if the handler fails to terminate with a given reason\n"
"in which case `state = {:error, term}`.\n"
"\n"
"If `c:init/1` in the second handler returns a correct value, this\n"
"function returns `:ok`.\n"
msgstr ""
"イベント`manager`内の古いイベントハンドラを新しいハンドラに置き換えます。\n"
"\n"
"まず、指定した`args1`を引数に`c:terminate/2`を呼び出して\n"
"古いイベントハンドラを削除し、返り値を集めます。次に、\n"
"`init({args2, term})`を呼び出して新しいイベントハンドラを追加・\n"
"初期化します。ここで`term`は古いハンドラの`c:terminate/2`を\n"
"呼び出した際の返り値です。これにより、古いハンドラから新しいハンドラに\n"
"情報を伝達できます。\n"
"\n"
"たとえ、指定した古いイベントハンドラがインストールされていなくても、\n"
"または、ハンドラが指定の理由による終了に失敗しても（この場合、\n"
"`state = {:error, term}`となります）、新しいハンドラは追加されます。\n"
"\n"
"2番目のハンドラの`init/1`が正しい値を返した場合、この関数は`:ok`を\n"
"返します。\n"

#. TRANSLATORS: def GenEvent.call(manager, handler, request, timeout \\ 5000)
#: lib/gen_event.ex:566
msgid ""
"Makes a synchronous call to the event `handler` installed in `manager`.\n"
"\n"
"The given `request` is sent and the caller waits until a reply arrives or\n"
"a timeout occurs. The event manager will call `c:handle_call/2` to handle\n"
"the request.\n"
"\n"
"The return value `reply` is defined in the return value of `c:"
"handle_call/2`.\n"
"If the specified event handler is not installed, the function returns\n"
"`{:error, :not_found}`.\n"
msgstr ""
"`manager`にインストールされているイベント`handler`を同期的に呼び出します。\n"
"\n"
"指定した`request`が送信され、応答が到着するか、タイムアウトが発生する\n"
"まで、呼び出し側は待たされます。イベントマネージャは、リクエストを処理する\n"
"ために、`handle_call/2`を呼び出します。\n"
"\n"
"返り値`reply`は`handle_call/2`の返り値で定義されています。指定した\n"
"イベントハンドラがインストールされていない場合、関数は\n"
"`{:error, :not_found}`を返します。\n"

#. TRANSLATORS: def GenEvent.stop(manager, reason \\ :normal, timeout \\ :infinity)
#: lib/gen_event.ex:640
msgid ""
"Stops the manager with the given `reason`.\n"
"\n"
"Before terminating, the event manager will call\n"
"`terminate(:stop, ...)` for each installed event handler.\n"
"It returns `:ok` if the manager terminates with the given\n"
"reason, if it terminates with another reason, the call will\n"
"exit.\n"
"\n"
"This function keeps OTP semantics regarding error reporting.\n"
"If the reason is any other than `:normal`, `:shutdown` or\n"
"`{:shutdown, _}`, an error report will be logged.\n"
msgstr ""
"指定した`reason`でマネージャを停止します。\n"
"\n"
"終了するまえに、イベントマネージャはインストールされた\n"
"各イベントハンドラの`terminate(:stop, ...)`を呼出します。\n"
"マネージャが指定した理由で終了した場合は`:ok`を返します。\n"
"別の理由で終了した場合は、この呼出は終了します。\n"
"\n"
"この関数はエラーレポートに関するOTPセマンティクスに従います。\n"
"理由が`:normal`、`:shutdown`、`{:shutdown, _}`以外の場合は\n"
"エラーレポートがログされます。\n"

#. TRANSLATORS: Elixir.GenEvent Summary
#: lib/gen_event.ex:4
msgid ""
"A behaviour module for implementing event handling functionality.\n"
"\n"
"The event handling model consists of a generic event manager\n"
"process with an arbitrary number of event handlers which are\n"
"added and deleted dynamically.\n"
"\n"
"An event manager implemented using this module will have a standard\n"
"set of interface functions and include functionality for tracing and\n"
"error reporting. It will also fit into a supervision tree.\n"
"\n"
"## Example\n"
"\n"
"There are many use cases for event handlers. For example, a logging\n"
"system can be built using event handlers where each log message is\n"
"an event and different event handlers can be attached to handle the\n"
"log messages. One handler may print error messages on the terminal,\n"
"another can write it to a file, while a third one can keep the\n"
"messages in memory (like a buffer) until they are read.\n"
"\n"
"As an example, let's have a GenEvent that accumulates messages until\n"
"they are collected by an explicit call.\n"
"\n"
"    # Define an Event Handler\n"
"    defmodule LoggerHandler do\n"
"      use GenEvent\n"
"\n"
"      # Callbacks\n"
"\n"
"      def handle_event({:log, x}, messages) do\n"
"        {:ok, [x | messages]}\n"
"      end\n"
"\n"
"      def handle_call(:messages, messages) do\n"
"        {:ok, Enum.reverse(messages), []}\n"
"      end\n"
"    end\n"
"\n"
"    # Start a new event manager.\n"
"    {:ok, pid} = GenEvent.start_link([])\n"
"\n"
"    # Attach an event handler to the event manager.\n"
"    GenEvent.add_handler(pid, LoggerHandler, [])\n"
"    #=> :ok\n"
"\n"
"    # Send some events to the event manager.\n"
"    GenEvent.notify(pid, {:log, 1})\n"
"    #=> :ok\n"
"\n"
"    GenEvent.notify(pid, {:log, 2})\n"
"    #=> :ok\n"
"\n"
"    # Call functions on specific handlers in the manager.\n"
"    GenEvent.call(pid, LoggerHandler, :messages)\n"
"    #=> [1, 2]\n"
"\n"
"    GenEvent.call(pid, LoggerHandler, :messages)\n"
"    #=> []\n"
"\n"
"We start a new event manager by calling `GenEvent.start_link/1`.\n"
"Notifications can be sent to the event manager which will then\n"
"invoke `c:handle_event/2` for each registered handler.\n"
"\n"
"We can add new handlers with `add_handler/3` and `add_mon_handler/3`.\n"
"Calls can also be made to specific handlers by using `call/3`.\n"
"\n"
"## Callbacks\n"
"\n"
"There are 6 callbacks required to be implemented in a `GenEvent`. By\n"
"adding `use GenEvent` to your module, Elixir will automatically define\n"
"all 6 callbacks for you, leaving it up to you to implement the ones\n"
"you want to customize.\n"
"\n"
"## Name Registration\n"
"\n"
"A GenEvent is bound to the same name registration rules as a `GenServer`.\n"
"Read more about it in the `GenServer` docs.\n"
"\n"
"## Modes\n"
"\n"
"GenEvent supports three different notifications.\n"
"\n"
"On `GenEvent.ack_notify/2`, the manager acknowledges each event,\n"
"providing backpressure, but processing of the message happens\n"
"asynchronously.\n"
"\n"
"On `GenEvent.sync_notify/2`, the manager acknowledges an event\n"
"just after it is processed by all event handlers.\n"
"\n"
"On `GenEvent.notify/2`, all events are processed asynchronously and\n"
"there is no ack (which means there is no backpressure).\n"
"\n"
"## Streaming\n"
"\n"
"`GenEvent` messages can be streamed with the help of `stream/2`.\n"
"You will need to start another process to consume the stream:\n"
"\n"
"    Task.start_link fn ->\n"
"      stream = GenEvent.stream(pid)\n"
"\n"
"      # Discard the next 3 events\n"
"      _ = Enum.take(stream, 3)\n"
"\n"
"      # Print all remaining events\n"
"      for event <- stream do\n"
"        IO.inspect event\n"
"      end\n"
"    end\n"
"\n"
"Now call `GenEvent.notify/2` multiple times. You will see the\n"
"first three events will be skipped while the rest will be\n"
"continuously printed.\n"
"\n"
"## Learn more and compatibility\n"
"\n"
"If you wish to find out more about GenEvent, the documentation and links\n"
"in Erlang can provide extra insight.\n"
"\n"
"  * [`:gen_event` module documentation](http://www.erlang.org/doc/man/"
"gen_event.html)\n"
"  * [Event Handlers – Learn You Some Erlang for Great Good!](http://"
"learnyousomeerlang.com/event-handlers)\n"
"\n"
"Keep in mind though Elixir and Erlang gen events are not 100% compatible.\n"
"The `:gen_event.add_sup_handler/3` is not supported by Elixir's GenEvent,\n"
"which in turn supports `GenEvent.add_mon_handler/3`.\n"
"\n"
"The benefits of the monitoring approach are described in the \"Don't drink\n"
"too much kool aid\" section of the \"Learn you some Erlang\" link above. "
"Due\n"
"to those changes, Elixir's GenEvent does not trap exits by default.\n"
"\n"
"Furthermore, Elixir also normalizes the `{:error, _}` tuples returned\n"
"by many functions, in order to be more consistent with themselves and\n"
"the `GenServer` module.\n"
msgstr ""
"イベントハンドリング機能を実装するためのビヘイビアモジュールです。\n"
"\n"
"イベントハンドリングモデルは汎用イベントマネージャプロセスと任意の数の\n"
"イベントハンドラで構成されます。イベントハンドラは動的に追加・削除されま"
"す。\n"
"\n"
"このモジュールを使用して実装されたイベントマネージャは、標準的な一連の\n"
"インタフェース関数を持ち、トレースとエラーレポートのための機能を持ちます。\n"
"これは監視ツリーにも適したものです。\n"
"\n"
"## 例\n"
"\n"
"イベントハンドラには多くのユースケースがあります。たとえば、ロギング\n"
"システムはイベントハンドラを使って構築できます。そこでは、各ログ\n"
"メッセージがイベントであり、ログメッセージを処理する様々なイベントハンドラ"
"を\n"
"アタッチすることができます。そして、あるハンドラはエラーメッセージを端末に\n"
"表示し、別のハンドラはそれをファイルに書き、第3のハンドラはそれらの\n"
"準備が整うまでメッセージを（バッファのように）メモリ上に保持します。\n"
"\n"
"例として、明示的に呼び出すまで、メッセージを蓄積するGenEventを作って\n"
"みましょう。\n"
"\n"
"    # イベントハンドラを定義する\n"
"    defmodule LoggerHandler do\n"
"      use GenEvent\n"
"\n"
"      # コールバック\n"
"\n"
"      def handle_event({:log, x}, messages) do\n"
"        {:ok, [x|messages]}\n"
"      end\n"
"\n"
"      def handle_call(:messages, messages) do\n"
"        {:ok, Enum.reverse(messages), []}\n"
"      end\n"
"    end\n"
"\n"
"    # 新しいイベントマネージャを起動する\n"
"    {:ok, pid} = GenEvent.start_link()\n"
"\n"
"    # イベントマネージャにイベントハンドラをアタッチする\n"
"    GenEvent.add_handler(pid, LoggerHandler, [])\n"
"    #=> :ok\n"
"\n"
"    # イベントマネージャにイベントをいくつか送信する\n"
"    GenEvent.notify(pid, {:log, 1})\n"
"    #=> :ok\n"
"\n"
"    GenEvent.notify(pid, {:log, 2})\n"
"    #=> :ok\n"
"\n"
"    # マネージャ内の特定のハンドラの関数を呼び出す\n"
"    GenEvent.call(pid, LoggerHandler, :messages)\n"
"    #=> [1, 2]\n"
"\n"
"    GenEvent.call(pid, LoggerHandler, :messages)\n"
"    #=> []\n"
"\n"
"`GenEvent.start_link/1`を実行することで、新しいイベントマネージャを\n"
"起動します。通知はこのイベントマネージャに送信します。するとマネージャは\n"
"登録された各ハンドラの`c:handle_event/2`を実行します。\n"
"\n"
"`add_handler/3`と`add_mon_handler/3`を使って新しいハンドラを\n"
"追加できます。`call/3`を使って特定のハンドラを呼び出すこともできます。\n"
"\n"
"## コールバック\n"
"\n"
"`GenEvent`では実装が必要なコールバックが6つあります。あなたのモジュールに\n"
"`use GenEvent`を追加することにより、Elixirは自動的に6つのコールバック\n"
"すべてを定義しますので、独自にカスタマイズしたいコールバックだけ実装すれば\n"
"良いのです。\n"
"\n"
"## 名前の登録\n"
"\n"
"GenEventは`GenServer`と同じ名前登録規則に従います。\n"
"詳細は、`GenServer`のドキュメントを参照してください。\n"
"\n"
"## モード\n"
"\n"
"GenEventは3つの通知モードをサポートします。\n"
"\n"
"`GenEvent.ack_notiry/2`では、マネージャは各イベントの受信確認を送ります。\n"
"バックプレッシャーは提供しますが、メッセージの処理は非同期で行います。\n"
"\n"
"`GenEvent.sync_notiry/2`では、マネージャは、すべてのイベントハンドラにより\n"
"処理された直後にイベントの受信確認を送ります。\n"
"\n"
"`GenEvent.notify/2`では、すべてのイベントは非同期で処理され、\n"
"受信確認の送信はありません（これはバックプレッシャーがないことを意味しま"
"す）。\n"
"\n"
"## ストリーミング\n"
"\n"
"`GenEvent`メッセージは`stream/2`の助けを借りて、ストリーム化する\n"
"ことができます。\n"
"\n"
"    Task.start_link fn ->\n"
"      stream = GenEvent.stream(pid)\n"
"\n"
"      # 次の3つのイベントを破棄する\n"
"      _ = Enum.drop(stream, 3)\n"
"\n"
"      # 残りのイベントをすべて表示する\n"
"      for event <- stream do\n"
"        IO.inspect event\n"
"      end\n"
"    end\n"
"\n"
"この状態で`GenEvent.notify/2`は複数回呼出すと、最初の3つのイベントが\n"
"スキップされ、残りのイベントが継続的に表示されるのがわかります。\n"
"\n"
"## さらなる情報と互換性\n"
"\n"
"gen eventについてもっと知りたい場合は、Elixir getting started guide\n"
"がチュートリアルライクの導入を提供します。Erlangのドキュメントと次の\n"
"リンクでさらなる知見を得ることができます。\n"
"\n"
"  * [`:gen_event` モジュールのドキュメント](http://www.erlang.org/doc/man/"
"gen_event.html)\n"
"  * [イベントハンドラ – Learn You Some Erlang for Great Good!](http://"
"learnyousomeerlang.com/event-handlers)\n"
"\n"
"ただし、ElixirとErlangのgen eventは100%互換性があるわけではない\n"
"こと留意してください。`:gen_event.add_sup_handler/3`はElixirの\n"
"GenEventではサポートされていません。代わりに\n"
"`GenEvent.add_mon_handler/3`をサポートしています。\n"
"\n"
"モニタアプローチの利点は上のリンク \"Learn you some Erlang\" の \"Don't\n"
"drink too much kool aid\" セクションに記述されています。それらの変更によ\n"
"り、ElixirのGenEventはデフォルトではexitを捕捉しません。\n"
"\n"
"さらに、Elixirは多くの関数により返される`{:error, _}`タプルを正規化\n"
"しています。それは、それら関数と`GenServer`モジュールの整合性を高める\n"
"ためです。\n"

#. TRANSLATORS: @callback handle_info/2
#: lib/gen_event.ex:210
msgid ""
"Invoked to handle all other messages. All handlers are run in the "
"`GenEvent`\n"
"process so messages intended for other handlers should be ignored with a "
"catch\n"
"all clause.\n"
"\n"
"`msg` is the message and `state` is the current state of the handler.\n"
"\n"
"Return values are the same as `c:handle_event/2`.\n"
msgstr ""
"他のすべてのメッセージを処理するために呼び出されます。すべての\n"
"ハンドラは`GenEvent`プロセス内で実行されます。したがって、\n"
"他のハンドラを対象とするメッセージは、catch all節で無視しなければ\n"
"なりません。\n"
"\n"
"`msg`は メッセージであり、`state`は ハンドラの現在の状態です。\n"
"\n"
"返り値は`c:handle_event/2`と同じです。\n"

#. TRANSLATORS: def GenEvent.which_handlers(manager)
#: lib/gen_event.ex:632
msgid "Returns a list of all event handlers installed in the `manager`.\n"
msgstr ""
"`manager`にインストールされているすべてのイベントハンドラの\n"
"リストを返します。\n"

#. TRANSLATORS: @callback handle_event/2
#: lib/gen_event.ex:159
msgid ""
"Invoked to handle `notify/2`, `ack_notify/2` or `sync_notify/2` messages.\n"
"\n"
"`event` is the event message and `state` is the current state of the "
"handler.\n"
"\n"
"Returning `{:ok, new_state}` sets the handler's state to `new_state` and "
"the\n"
"`GenEvent` loop continues.\n"
"\n"
"Returning `{:ok, new_state, :hibernate}` is similar to\n"
"`{:ok, new_state}` except the process is hibernated once all handlers have\n"
"handled the events. The `GenEvent` process will continue the loop once a\n"
"message is its message queue. If a message is already in the message queue\n"
"this will be immediately. Hibernating a `GenEvent` causes garbage "
"collection\n"
"and leaves a continuous heap that minimises the memory used by the "
"process.\n"
"\n"
"Hibernating should not be used aggressively as too much time could be "
"spent\n"
"garbage collecting. Normally it should only be used when a message is not\n"
"expected soon and minimising the memory of the process is shown to be\n"
"beneficial.\n"
"\n"
"Returning `:remove_handler` removes the handler from the `GenEvent` loop "
"and\n"
"calls `c:terminate/2` with reason `:remove_handler` and state `state`.\n"
msgstr ""
"`notify/2`、`ack_notiry/2`または`sync_notiry/2`メッセージを\n"
"処理するために呼び出されます。\n"
"\n"
"`event`はイベントメッセージで、`state`はハンドラの現在の状態です。\n"
"\n"
"`{:ok, new_state}`を返すと、ハンドラの状態を`new_state`に\n"
"セットし、`GenEvent`ループを継続します。\n"
"\n"
"`{:ok, new_state, :hibernate}`を返すことは、すべてのハンドラが\n"
"イベントを処理した後、プロセスがハイバネートされることを除いて\n"
"`{:ok, new_state}` と同じです。メッセージがメッセージキューに入ると\n"
"`GenEvent`プロセスはループを継続します。既にメッセージがメッセージ\n"
"キューにある場合は、これがすぐに行われます。`GenEvent`のハイバネートは\n"
"ガベージコレクションを引き起し、プロセスにより使用されるメモリを最小化し、\n"
"連続したヒープ領域を作成します。\n"
"\n"
"ハイバネートは使いすぎてはいけません。余り頻繁におこなうと\n"
"ガベージコレクションに時間を取られるからです。通常は、メッセージが\n"
"すぐには来ないことが予想され、プロセスメモリの最小化が有益であることが\n"
"示された場合にのみ使用するべきです。\n"
"\n"
"`:remove_handler`を返すと、`GenEvent`ループからハンドラを削除し、\n"
"`:remove_handler`を引数reasonに、`state`を引数stateに\n"
"`c:terminate/2`を呼出します。\n"

#. TRANSLATORS: @type manager
#: lib/gen_event.ex:294
msgid "The event manager reference"
msgstr "イベントマネージャのリファレンス"

#. TRANSLATORS: def GenEvent.add_mon_handler(manager, handler, args)
#: lib/gen_event.ex:453
msgid ""
"Adds a monitored event handler to the event `manager`.\n"
"\n"
"Expects the same input and returns the same values as `add_handler/3`.\n"
"\n"
"## Monitored handlers\n"
"\n"
"A monitored handler implies the calling process will now be monitored\n"
"by the GenEvent manager.\n"
"\n"
"If the calling process later terminates with `reason`, the event manager\n"
"will delete the event handler by calling the `c:terminate/2` callback with\n"
"`{:stop, reason}` as argument. If the event handler later is deleted,\n"
"the event manager sends a message `{:gen_event_EXIT, handler, reason}`\n"
"to the calling process. Reason is one of the following:\n"
"\n"
"  * `:normal` - if the event handler has been removed due to a call to\n"
"    `remove_handler/3`, or `:remove_handler` has been returned by a "
"callback\n"
"    function\n"
"\n"
"  * `:shutdown` - if the event handler has been removed because the event\n"
"    manager is terminating\n"
"\n"
"  * `{:swapped, new_handler, pid}` - if the process PID has replaced the\n"
"    event handler by another\n"
"\n"
"  * `term` - if the event handler is removed due to an error. Which term\n"
"    depends on the error\n"
"\n"
"Keep in mind that the `{:gen_event_EXIT, handler, reason}` message is not\n"
"guaranteed to be delivered in case the manager crashes. If you want to\n"
"guarantee the message is delivered, you have two options:\n"
"\n"
"  * monitor the event manager\n"
"  * link to the event manager and then set `Process.flag(:trap_exit, "
"true)`\n"
"    in your handler callback\n"
"\n"
"Finally, this functionality only works with GenEvent started via this\n"
"module (it is not backwards compatible with Erlang's `:gen_event`).\n"
msgstr ""
"モニタされているイベントハンドラをイベント`manager`に追加します。\n"
"\n"
"`add_handler/3`と同じ引数と返り値を期待します。\n"
"\n"
"## モニターされているハンドラ\n"
"\n"
"モニターされているハンドラとは、呼出し側プロセスがGenEvent\n"
"マネージャにより現在モニタされていることを意味します。\n"
"\n"
"その後、呼出し側プロセスが`reason`で終了した場合、イベントマネージャは\n"
"`{:stop, reason}`を引数に`terminate/2`コールバックを呼び出すことにより、\n"
"イベントハンドラを削除します。\n"
"その後、イベントハンドラが削除された場合、イベントマネージャは、\n"
"`{:gen_event_EXIT,handler, reason}`メッセージを、呼出し側プロセスに\n"
"送信します。`reason`は以下のいずれかです:\n"
"\n"
"  * `:normal` - イベントハンドラが`remove_handler/3`の呼び出しにより\n"
"     削除された場合。または、コールバック関数により`:remove_handler`が\n"
"     返された場合。\n"
"\n"
"  * `:shutdown` - イベントマネージャの終了によりイベントハンドラが\n"
"     削除された場合\n"
"\n"
"  * `{:swapped, new_handler, pid}` - プロセスPIDがイベントハンドラを別のもの"
"に\n"
"     置き換えた場合\n"
"\n"
"  * `term` - イベントハンドラがエラーにより削除された場合。`term`は\n"
"    エラーによります。\n"
"\n"
"マネージャがクラッシュした場合は`{:gen_event_EXIT, handler, reason}`\n"
"メッセージが配信される保証はないことに留意してください。\n"
"メッセージの配信を保証したい場合は、二つの選択肢があります:\n"
"\n"
"  * イベントマネージャをモニタする\n"
"  * イベントマネージャにリンクして、ハンドラコールバックで、\n"
"    `Process.flag(:trap_exit, true)`をセットする\n"
"\n"
"最後に、この機能は、このモジュールを介して起動されたGenEventでのみ\n"
"動作します（Erlangの`:gen_event`との後方互換性はありません）。\n"

#. TRANSLATORS: @type handler
#: lib/gen_event.ex:297
msgid "Supported values for new handlers"
msgstr "新しいハンドラでサポートされる値"

#. TRANSLATORS: def GenEvent.start(options \\ [])
#: lib/gen_event.ex:372
msgid ""
"Starts an event manager process without links (outside of a supervision "
"tree).\n"
"\n"
"See `start_link/1` for more information.\n"
msgstr ""
"イベントマネージャプロセスをリンクせずに(監視ツリーの外側で)起動します。\n"
"\n"
"詳細は `start_link/1` を参照してください。\n"

#. TRANSLATORS: @callback terminate/2
#: lib/gen_event.ex:224
msgid ""
"Invoked when the server is about to exit. It should do any cleanup "
"required.\n"
"\n"
"`reason` is removal reason and `state` is the current state of the "
"handler.\n"
"The return value is returned to `GenEvent.remove_handler/3` or ignored if\n"
"removing for another reason.\n"
"\n"
"`reason` is one of:\n"
"\n"
"-  `:stop` - manager is terminating\n"
"-  `{:stop, term}` - monitored process terminated (for monitored handlers)\n"
"-  `:remove_handler` - handler is being removed\n"
"-  `{:error, term}` - handler crashed or returned a bad value and an error "
"is\n"
"logged\n"
"-  `term` - any term passed to functions like `GenEvent.remove_handler/3`\n"
"\n"
"If part of a supervision tree, a `GenEvent`'s `Supervisor` will send an "
"exit\n"
"signal when shutting it down. The exit signal is based on the shutdown\n"
"strategy in the child's specification. If it is `:brutal_kill` the "
"`GenEvent`\n"
"is killed and so `c:terminate/2` is not called for its handlers. However if "
"it is\n"
"a timeout the `Supervisor` will send the exit signal `:shutdown` and the\n"
"`GenEvent` will have the duration of the timeout to call `c:terminate/2` on "
"all\n"
"of its handlers - if the process is still alive after the timeout it is\n"
"killed.\n"
"\n"
"If the `GenEvent` receives an exit signal (that is not `:normal`) from any\n"
"process when it is not trapping exits it will exit abruptly with the same\n"
"reason and so not call the handlers' `c:terminate/2`. Note that a process "
"does\n"
"*NOT* trap exits by default and an exit signal is sent when a linked "
"process\n"
"exits or its node is disconnected. Therefore it is not guaranteed that\n"
"`c:terminate/2` is called when a `GenEvent` exits.\n"
"\n"
"Care should be taken to cleanup because the `GenEvent` can continue to "
"loop\n"
"after removing the handler. This is different to most other OTP "
"behaviours.\n"
"For example if the handler controls a `port` (e.g. `:gen_tcp.socket`) or\n"
"`t:File.io_device/0`, it will be need to be closed in `c:terminate/2` as "
"the\n"
"process is not exiting so will not be automatically cleaned up.\n"
msgstr ""
"サーバが終了しようとする時に呼び出されます。必要なクリーンアップ\n"
"を行う必要があります。\n"
"\n"
"`reason`は削除理由であり、`state`はハンドラの現在の状態です。\n"
"返り値は`GenEvent.remove_handler/3`に返されるか、\n"
"別の理由で削除された場合は無視されます。\n"
"\n"
"`reason` 以下のいずれかです:\n"
"\n"
"-  `:stop` - マネージャが終了した\n"
"-  `{:stop, term}` - モニタされていたプロセスが終了した(モニタハンドラの場"
"合)\n"
"-  `:remove_handler` - ハンドラが削除された\n"
"-  `{:error, term}` - ハンドラがクラッシュしたか、不正な値を返した。エラーは"
"ログされます\n"
"-  `term` - `GenEvent.remove_handler/3`などの関数に渡される任意の項\n"
"\n"
"監視ツリー配下の場合、`GenEvent`の`Supervisor`が`GenEvent`を\n"
"シャットダウンする際に終了シグナルを送信します。終了シグナル\n"
"は子プロセス仕様のシャットダウン戦略に基いています。`:brutal_kill`の場合、\n"
"`GenEvent`は強制終了させられ、ハンドラの`terminate/2`は呼び出されません。\n"
"しかし、理由がタイムアウトの場合は、`Supervisor`が終了シグナルとして\n"
"`:shutdown`を送信し、`GenEvent`はすべてのハンドラの`c:terminate/2`を\n"
"呼び出すだけのタイムアウトまでの時間を持ちます。タイムアウト後にも\n"
"まだプロセスが生きている場合は、強制終了させられます。\n"
"\n"
"`GenEvent`が終了を捕捉していない時に、任意のプロセスから(`:normal`以外の）\n"
"終了シグナルを受信した場合は、同じ理由で突然終了し、ハンドラの`c:"
"terminate/2`は\n"
"呼び出しません。プロセスはデフォルトでは終了を捕捉*しない*こと、\n"
"リンクされたプロセスが終了した場合やノードが切断された場合に終了シグナルが\n"
"送信されることに注意してください。したがって、`GenEvent` が終了した際に\n"
"`c:terminate/2`が呼び出されることは保証されません。\n"
"\n"
"`GenEvent`はハンドラを削除した後もループを継続できるため、\n"
"クリーンアップには注意が必要です。これは他のほとんどのOTPの\n"
"動作とは異なります。たとえば、ハンドラが`port`（たとえば、`:gen_tcp."
"socket`）\n"
"や`File.io_device`を制御している場合、プロセスは終了していないので\n"
"これらは自動的にはクリーンアップされないため、`c:terminate/2`の中で\n"
"クローズする必要があります。\n"

#. TRANSLATORS: def GenEvent.stream(manager, options \\ [])
#: lib/gen_event.ex:408
msgid ""
"Returns a stream that consumes events from the `manager`.\n"
"\n"
"The stream is a `GenEvent` struct that implements the `Enumerable`\n"
"protocol. Consumption of events only begins when enumeration starts.\n"
"\n"
"Note streaming is specific to Elixir's GenEvent and does not work\n"
"with Erlang ones.\n"
"\n"
"## Options\n"
"\n"
"  * `:timeout` - raises if no event arrives in X milliseconds\n"
"    (defaults to `:infinity`)\n"
"\n"
msgstr ""
"`manager`からのイベントを消費するストリームを返します。\n"
"\n"
"ストリームは、`Enumerable`プロトコルを実装した`GenEvent`構造体です。\n"
"イベントの消費はenumerationが開始された時、はじめて始まります。\n"
"\n"
"ストリーミングは、ElixirのGenEventに特有なものであり、Erlangでは\n"
"動作しないことに注意してください。\n"
"\n"
"## オプション\n"
"\n"
"  * `:timeout` - Xミリ秒の間にイベントが到着しない場合、\n"
"     例外を発生させます(デフォルトは `:infinity`)\n"
"\n"

#. TRANSLATORS: def GenEvent.remove_handler(manager, handler, args)
#: lib/gen_event.ex:589
msgid ""
"Removes an event handler from the event `manager`.\n"
"\n"
"The event manager will call `c:terminate/2` to terminate the event handler\n"
"and return the callback value. If the specified event handler is not\n"
"installed, the function returns `{:error, :not_found}`.\n"
msgstr ""
"イベント`manager`からイベントハンドラを削除します。\n"
"\n"
"イベントマネージャは、イベントハンドラを終了するために\n"
"`c:terminate/2`を呼び出し、コールバック値を返します。\n"
"指定したイベントハンドラがインストールされていない場合、\n"
"この関数は`{:error, :not_found}`を返します。\n"

#. TRANSLATORS: @type name
#: lib/gen_event.ex:288
msgid "The GenEvent manager name"
msgstr "GenEventマネージャの名前"
