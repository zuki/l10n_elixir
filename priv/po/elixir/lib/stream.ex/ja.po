msgid ""
msgstr ""
"Project-Id-Version: l 10n_elixir\n"
"PO-Revision-Date: 2017-02-28 14:19+0900\n"
"Last-Translator: 小田 照敬 <EMAIL@ADDRESS>\n"
"Language-Team: Japanese\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"POT-Creation-Date: \n"
"X-Generator: Poedit 1.8.12\n"

#. TRANSLATORS: def Stream.map(enum, fun)
#: lib/stream.ex:482
msgid ""
"Creates a stream that will apply the given function on\n"
"enumeration.\n"
"\n"
"## Examples\n"
"\n"
"    iex> stream = Stream.map([1, 2, 3], fn(x) -> x * 2 end)\n"
"    iex> Enum.to_list(stream)\n"
"    [2, 4, 6]\n"
"\n"
msgstr ""
"Enumerationに対して指定した関数を適用するストリームを\n"
"作成します。\n"
"\n"
"## 例\n"
"\n"
"    iex> stream = Stream.map([1, 2, 3], fn(x) -> x * 2 end)\n"
"    iex> Enum.to_list(stream)\n"
"    [2, 4, 6]\n"
"\n"

#. TRANSLATORS: def Stream.interval(n)
#: lib/stream.ex:418
msgid ""
"Creates a stream that emits a value after the given period `n`\n"
"in milliseconds.\n"
"\n"
"The values emitted are an increasing counter starting at `0`.\n"
"This operation will block the caller by the given interval\n"
"every time a new item is streamed.\n"
"\n"
"Do not use this function to generate a sequence of numbers.\n"
"If blocking the caller process is not necessary, use\n"
"`Stream.iterate(0, & &1 + 1)` instead.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Stream.interval(10) |> Enum.take(10)\n"
"    [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n"
"\n"
msgstr ""
"指定した`n`ミリ秒周期で値を発生するストリームを作成します。\n"
"\n"
"流される値は`0`から始まる増加するカウンタです。この操作は、\n"
"新しい項目が流される度に指定の時間だけ呼び出し元をブロックします。\n"
"\n"
"この関数を一連の数の生成に使用しないでください。呼び出し元のプロセスを\n"
"ブロックする必要がない場合は、`Stream.iterate(0, & &1 + 1)` を使ってくださ"
"い。\n"
"\n"
"## 例\n"
"\n"
"    iex> Stream.interval(10) |> Enum.take(10)\n"
"    [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n"
"\n"

#. TRANSLATORS: def Stream.cycle(enumerable)
#: lib/stream.ex:1103
msgid ""
"Creates a stream that cycles through the given enumerable,\n"
"infinitely.\n"
"\n"
"## Examples\n"
"\n"
"    iex> stream = Stream.cycle([1, 2, 3])\n"
"    iex> Enum.take(stream, 5)\n"
"    [1, 2, 3, 1, 2]\n"
"\n"
msgstr ""
"指定されたenumerableを通して、無現に循環するストリームを作成します。\n"
"\n"
"## 例\n"
"\n"
"    iex> stream = Stream.cycle([1, 2, 3])\n"
"    iex> Enum.take(stream, 5)\n"
"    [1, 2, 3, 1, 2]\n"
"\n"

#. TRANSLATORS: def Stream.flat_map(enum, mapper)
#: lib/stream.ex:364
msgid ""
"Creates a stream that will apply the given function on enumeration and\n"
"flatten the result, but only one level deep.\n"
"\n"
"## Examples\n"
"\n"
"    iex> stream = Stream.flat_map([1, 2, 3], fn(x) -> [x, x * 2] end)\n"
"    iex> Enum.to_list(stream)\n"
"    [1, 2, 2, 4, 3, 6]\n"
"\n"
"    iex> stream = Stream.flat_map([1, 2, 3], fn(x) -> [[x]] end)\n"
"    iex> Enum.to_list(stream)\n"
"    [[1], [2], [3]]\n"
"\n"
msgstr ""
"Enumerationに対して指定した関数を適用し、結果を１レベルだけ\n"
"フラット化したストリームを作成します。\n"
"\n"
"## 例\n"
"\n"
"    iex> stream = Stream.flat_map([1, 2, 3], fn(x) -> [x, x * 2] end)\n"
"    iex> Enum.to_list(stream)\n"
"    [1, 2, 2, 4, 3, 6]\n"
"\n"
"    iex> stream = Stream.flat_map([1, 2, 3], fn(x) -> [[x]] end)\n"
"    iex> Enum.to_list(stream)\n"
"    [[1], [2], [3]]\n"
"\n"

#. TRANSLATORS: def Stream.timer(n)
#: lib/stream.ex:692
msgid ""
"Creates a stream that emits a single value after `n` milliseconds.\n"
"\n"
"The value emitted is `0`. This operation will block the caller by\n"
"the given time until the item is streamed.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Stream.timer(10) |> Enum.to_list\n"
"    [0]\n"
"\n"
msgstr ""
"`n`ミリ秒後に一つの値を流すストリームを作成します。\n"
"\n"
"流される値は`0`です。この操作は項目が流されるまで指定の時間\n"
"呼び出し元をブロックします。\n"
"\n"
"## 例\n"
"\n"
"    iex> Stream.timer(10) |> Enum.to_list\n"
"    [0]\n"
"\n"

#. TRANSLATORS: def Stream.uniq_by(enum, fun)
#: lib/stream.ex:908
msgid ""
"Creates a stream that only emits elements if they are unique, by removing "
"the\n"
"elements for which function `fun` returned duplicate items.\n"
"\n"
"The function `fun` maps every element to a term which is used to\n"
"determine if two elements are duplicates.\n"
"\n"
"Keep in mind that, in order to know if an element is unique\n"
"or not, this function needs to store all unique values emitted\n"
"by the stream. Therefore, if the stream is infinite, the number\n"
"of items stored will grow infinitely, never being garbage collected.\n"
"\n"
"## Example\n"
"\n"
"    iex> Stream.uniq_by([{1, :x}, {2, :y}, {1, :z}], fn {x, _} -> x end) |> "
"Enum.to_list\n"
"    [{1, :x}, {2, :y}]\n"
"\n"
"    iex> Stream.uniq_by([a: {:tea, 2}, b: {:tea, 2}, c: {:coffee, 1}], fn "
"{_, y} -> y end) |> Enum.to_list\n"
"    [a: {:tea, 2}, c: {:coffee, 1}]\n"
"\n"
msgstr ""
"関数`fun`が返す重複した項目を削除することによりユニークな要素のみを\n"
"流すストリームを作成します。\n"
"\n"
"関数`fun`はすべての要素をマップして、２つの要素が重複しているか否かを\n"
"決定する際に使われる項を返します。\n"
"\n"
"要素がユニークか否かを知るために、この関数はストリームから流れる\n"
"すべてのユニークな値を保存する必要があることに留意してください。\n"
"したがって、ストリームが無限の場合、保存される値の数も無現に\n"
"増大して、ガベージコレクションされることはありません。\n"
"\n"
"## 例\n"
"\n"
"    iex> Stream.uniq_by([{1, :x}, {2, :y}, {1, :z}], fn {x, _} -> x end) |> "
"Enum.to_list\n"
"    [{1, :x}, {2, :y}]\n"
"\n"
"    iex> Stream.uniq_by([a: {:tea, 2}, b: {:tea, 2}, c: {:coffee, 1}], fn "
"{_, y} -> y end) |> Enum.to_list\n"
"    [a: {:tea, 2}, c: {:coffee, 1}]\n"
"\n"

#. TRANSLATORS: def Stream.resource(start_fun, next_fun, after_fun)
#: lib/stream.ex:1210
msgid ""
"Emits a sequence of values for the given resource.\n"
"\n"
"Similar to `transform/3` but the initial accumulated value is\n"
"computed lazily via `start_fun` and executes an `after_fun` at\n"
"the end of enumeration (both in cases of success and failure).\n"
"\n"
"Successive values are generated by calling `next_fun` with the\n"
"previous accumulator (the initial value being the result returned\n"
"by `start_fun`) and it must return a tuple containing a list\n"
"of items to be emitted and the next accumulator. The enumeration\n"
"finishes if it returns `{:halt, acc}`.\n"
"\n"
"As the name says, this function is useful to stream values from\n"
"resources.\n"
"\n"
"## Examples\n"
"\n"
"    Stream.resource(fn -> File.open!(\"sample\") end,\n"
"                    fn file ->\n"
"                      case IO.read(file, :line) do\n"
"                        data when is_binary(data) -> {[data], file}\n"
"                        _ -> {:halt, file}\n"
"                      end\n"
"                    end,\n"
"                    fn file -> File.close(file) end)\n"
"\n"
msgstr ""
"指定したリソースから値のシーケンスを流します。\n"
"\n"
"`transform/3`と似ていますが、初期アキュムレータは`start_fun`により\n"
"遅延計算され、(成功しても、失敗しても)列挙の終わりに`after_run`を\n"
"実行します。\n"
"\n"
"次の値は、前回のアキュムレータ(初期値は`start_fun`が返す値)を`next_fun`に\n"
"渡して実行結果により生成されます。この関数は、ストリームにより流される項目"
"の\n"
"リストと次のアキュムレータからなるタプルを返さなければなりません。\n"
"関数が`{:halt, acc}`を返すとenumerationは終了します。\n"
"\n"
"名前が示すように、この関数はリソースから値をストリームするのに\n"
"便利です。\n"
"\n"
"## 例\n"
"\n"
"    Stream.resource(fn -> File.open!(\"sample\") end,\n"
"                    fn file ->\n"
"                      case IO.read(file, :line) do\n"
"                        data when is_binary(data) -> {[data], file}\n"
"                        _ -> {:halt, file}\n"
"                      end\n"
"                    end,\n"
"                    fn file -> File.close(file) end)\n"
"\n"

#. TRANSLATORS: def Stream.drop_every(enum, nth)
#: lib/stream.ex:290
msgid ""
"Creates a stream that drops every `nth` item from the enumerable.\n"
"\n"
"The first item is always dropped, unless `nth` is 0.\n"
"\n"
"`nth` must be a non-negative integer.\n"
"\n"
"## Examples\n"
"\n"
"    iex> stream = Stream.drop_every(1..10, 2)\n"
"    iex> Enum.to_list(stream)\n"
"    [2, 4, 6, 8, 10]\n"
"\n"
"    iex> stream = Stream.drop_every(1..1000, 1)\n"
"    iex> Enum.to_list(stream)\n"
"    []\n"
"\n"
"    iex> stream = Stream.drop_every([1, 2, 3, 4, 5], 0)\n"
"    iex> Enum.to_list(stream)\n"
"    [1, 2, 3, 4, 5]\n"
"\n"
msgstr ""
"enumerableから毎回`nth`番目の項目を落とすストリームを作成します。\n"
"\n"
"`nth`が0でなければ、最初の項目は常に落とされます。\n"
"\n"
"`nth`は非負の整数でなければなりません。\n"
"\n"
"## 例\n"
"\n"
"    iex> stream = Stream.drop_every(1..10, 2)\n"
"    iex> Enum.to_list(stream)\n"
"    [2, 4, 6, 8, 10]\n"
"\n"
"    iex> stream = Stream.drop_every(1..1000, 1)\n"
"    iex> Enum.to_list(stream)\n"
"    []\n"
"\n"
"    iex> stream = Stream.drop_every([1, 2, 3, 4, 5], 0)\n"
"    iex> Enum.to_list(stream)\n"
"    [1, 2, 3, 4, 5]\n"
"\n"

#. TRANSLATORS: def Stream.chunk_by(enum, fun)
#: lib/stream.ex:181
msgid ""
"Chunks the `enum` by buffering elements for which `fun` returns\n"
"the same value and only emit them when `fun` returns a new value\n"
"or the `enum` finishes.\n"
"\n"
"## Examples\n"
"\n"
"    iex> stream = Stream.chunk_by([1, 2, 2, 3, 4, 4, 6, 7, 7], &(rem(&1, 2) "
"== 1))\n"
"    iex> Enum.to_list(stream)\n"
"    [[1], [2, 2], [3], [4, 4, 6], [7, 7]]\n"
"\n"
msgstr ""
"`fun`が同じ値を返す間、要素をバッファリングして`enum`をチャンク\n"
"化します。そして、`fun`が新しい値を返すか、`enum`が終了した時のみ\n"
"チャンクを流します。\n"
"\n"
"## 例\n"
"\n"
"    iex> stream = Stream.chunk_by([1, 2, 2, 3, 4, 4, 6, 7, 7], &(rem(&1, 2) "
"== 1))\n"
"    iex> Enum.to_list(stream)\n"
"    [[1], [2, 2], [3], [4, 4, 6], [7, 7]]\n"
"\n"

#. TRANSLATORS: def Stream.filter_map(enum, filter, mapper)
#: lib/stream.ex:400
msgid ""
"Creates a stream that filters and then maps elements according\n"
"to given functions.\n"
"\n"
"Exists for symmetry with `Enum.filter_map/3`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> stream = Stream.filter_map(1..6, fn(x) -> rem(x, 2) == 0 end, &(&1 "
"* 2))\n"
"    iex> Enum.to_list(stream)\n"
"    [4, 8, 12]\n"
"\n"
msgstr ""
"指定された関数に従って、要素をフィルタしてマップする\n"
"ストリームを作成します。\n"
"\n"
"`Enum.filter_map/3`との対称性の為に存在します。\n"
"\n"
"## 例\n"
"\n"
"    iex> stream = Stream.filter_map(1..6, fn(x) -> rem(x, 2) == 0 end, &(&1 "
"* 2))\n"
"    iex> Enum.to_list(stream)\n"
"    [4, 8, 12]\n"
"\n"

#. TRANSLATORS: def Stream.repeatedly(generator_fun)
#: lib/stream.ex:1182
msgid ""
"Returns a stream generated by calling `generator_fun` repeatedly.\n"
"\n"
"## Examples\n"
"\n"
"    # Although not necessary, let's seed the random algorithm\n"
"    iex> :rand.seed(:exsplus, {1, 2, 3})\n"
"    iex> Stream.repeatedly(&:rand.uniform/0) |> Enum.take(3)\n"
"    [0.40502929729990744, 0.45336720247823126, 0.04094511692041057]\n"
"\n"
msgstr ""
"`generator_fun`を繰り返し呼ぶことで生成されるストリームを返します。\n"
"\n"
"## 例\n"
"\n"
"    # 必ずしも必要ではないが、ランダムアルゴリズムの種を与える\n"
"    iex> :rand.seed(:exsplus, {1, 2, 3})\n"
"    iex> Stream.repeatedly(&:rand.uniform/0) |> Enum.take(3)\n"
"    [0.40502929729990744, 0.45336720247823126, 0.04094511692041057]\n"
"\n"

#. TRANSLATORS: def Stream.transform(enum, acc, reducer)
#: lib/stream.ex:709
msgid ""
"Transforms an existing stream.\n"
"\n"
"It expects an accumulator and a function that receives each stream item\n"
"and an accumulator, and must return a tuple containing a new stream\n"
"(often a list) with the new accumulator or a tuple with `:halt` as first\n"
"element and the accumulator as second.\n"
"\n"
"Note: this function is similar to `Enum.flat_map_reduce/3` except the\n"
"latter returns both the flat list and accumulator, while this one returns\n"
"only the stream.\n"
"\n"
"## Examples\n"
"\n"
"`Stream.transform/3` is useful as it can be used as the basis to implement\n"
"many of the functions defined in this module. For example, we can implement\n"
"`Stream.take(enum, n)` as follows:\n"
"\n"
"    iex> enum = 1..100\n"
"    iex> n = 3\n"
"    iex> stream = Stream.transform(enum, 0, fn i, acc ->\n"
"    ...>   if acc < n, do: {[i], acc + 1}, else: {:halt, acc}\n"
"    ...> end)\n"
"    iex> Enum.to_list(stream)\n"
"    [1, 2, 3]\n"
"\n"
msgstr ""
"既存のストリームを変換します。\n"
"\n"
"アキュムレータと関数を引数にとります。この関数は、ストリームの各項目と\n"
"アキュムレータを受けとり、新しいストリーム(通常はリスト)と新しい\n"
"アキュムレータを含むタプルか、第１要素が`:halt`で第２要素がアキュムレータで\n"
"あるタプルを返さなければなりません。\n"
"\n"
"注: この関数は、`Enum.flat_map_reduce/3`と似ていますが、後者は\n"
"フラットリストとアキュムレータを返すことに対して、この関数はストリーム\n"
"のみを返します。\n"
"\n"
"## 例\n"
"\n"
"`Stream.transform/3`は便利です。このモジュールで定義されている\n"
"多くの関数を実装するための基礎として使うことができるからです。たとえば、\n"
"`Stream.take(enum, n)`は次のように実装できます:\n"
"\n"
"    iex> enum = 1..100\n"
"    iex> n = 3\n"
"    iex> stream = Stream.transform(enum, 0, fn i, acc ->\n"
"    ...>   if acc < n, do: {[i], acc + 1}, else: {:halt, acc}\n"
"    ...> end)\n"
"    iex> Enum.to_list(stream)\n"
"    [1, 2, 3]\n"
"\n"

#. TRANSLATORS: def Stream.take_while(enum, fun)
#: lib/stream.ex:676
msgid ""
"Lazily takes elements of the enumerable while the given\n"
"function returns `true`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> stream = Stream.take_while(1..100, &(&1 <= 5))\n"
"    iex> Enum.to_list(stream)\n"
"    [1, 2, 3, 4, 5]\n"
"\n"
msgstr ""
"指定した関数が`true`の間、enumerableの要素を遅延評価して取り出します。\n"
"\n"
"## 例\n"
"\n"
"    iex> stream = Stream.take_while(1..100, &(&1 <= 5))\n"
"    iex> Enum.to_list(stream)\n"
"    [1, 2, 3, 4, 5]\n"
"\n"

#. TRANSLATORS: def Stream.with_index(enum, offset \\ 0)
#: lib/stream.ex:934
msgid ""
"Creates a stream where each item in the enumerable will\n"
"be wrapped in a tuple alongside its index.\n"
"\n"
"If an `offset` is given, we will index from the given offset instead of from "
"zero.\n"
"\n"
"## Examples\n"
"\n"
"    iex> stream = Stream.with_index([1, 2, 3])\n"
"    iex> Enum.to_list(stream)\n"
"    [{1, 0}, {2, 1}, {3, 2}]\n"
"\n"
"    iex> stream = Stream.with_index([1, 2, 3], 3)\n"
"    iex> Enum.to_list(stream)\n"
"    [{1, 3}, {2, 4}, {3, 5}]\n"
"\n"
msgstr ""
"enumerableの各項目がインデックスと共にタプルにラップされた\n"
"ストリームを作成します。\n"
"\n"
"`offset`が指定された場合は、0の代わりに指定したオフセットから\n"
"索引をふります。\n"
"\n"
"## 例\n"
"\n"
"    iex> stream = Stream.with_index([1, 2, 3])\n"
"    iex> Enum.to_list(stream)\n"
"    [{1, 0}, {2, 1}, {3, 2}]\n"
"\n"
"    iex> stream = Stream.with_index([1, 2, 3], 3)\n"
"    iex> Enum.to_list(stream)\n"
"    [{1, 3}, {2, 4}, {3, 5}]\n"
"\n"

#. TRANSLATORS: def Stream.concat(first, second)
#: lib/stream.ex:974
msgid ""
"Creates a stream that enumerates the first argument, followed by the "
"second.\n"
"\n"
"## Examples\n"
"\n"
"    iex> stream = Stream.concat(1..3, 4..6)\n"
"    iex> Enum.to_list(stream)\n"
"    [1, 2, 3, 4, 5, 6]\n"
"\n"
"    iex> stream1 = Stream.cycle([1, 2, 3])\n"
"    iex> stream2 = Stream.cycle([4, 5, 6])\n"
"    iex> stream = Stream.concat(stream1, stream2)\n"
"    iex> Enum.take(stream, 6)\n"
"    [1, 2, 3, 1, 2, 3]\n"
"\n"
msgstr ""
"最初の引数を列挙し、続いて2番目の引数を列挙するストリームを作成します。\n"
"\n"
"## 例\n"
"\n"
"    iex> stream = Stream.concat(1..3, 4..6)\n"
"    iex> Enum.to_list(stream)\n"
"    [1, 2, 3, 4, 5, 6]\n"
"\n"
"    iex> stream1 = Stream.cycle([1, 2, 3])\n"
"    iex> stream2 = Stream.cycle([4, 5, 6])\n"
"    iex> stream = Stream.concat(stream1, stream2)\n"
"    iex> Enum.take(stream, 6)\n"
"    [1, 2, 3, 1, 2, 3]\n"
"\n"

#. TRANSLATORS: def Stream.drop(enum, n)
#: lib/stream.ex:242
msgid ""
"Lazily drops the next `n` items from the enumerable.\n"
"\n"
"If a negative `n` is given, it will drop the last `n` items from\n"
"the collection. Note that the mechanism by which this is implemented\n"
"will delay the emission of any item until `n` additional items have\n"
"been emitted by the enum.\n"
"\n"
"## Examples\n"
"\n"
"    iex> stream = Stream.drop(1..10, 5)\n"
"    iex> Enum.to_list(stream)\n"
"    [6, 7, 8, 9, 10]\n"
"\n"
"    iex> stream = Stream.drop(1..10, -5)\n"
"    iex> Enum.to_list(stream)\n"
"    [1, 2, 3, 4, 5]\n"
"\n"
msgstr ""
"enumerableから次の`n`項目を遅延評価して削除します。\n"
"\n"
"負の`n`が指定された場合は、コレクションの最後の`n`項目が削除されます。\n"
"この関数が実装された機構では、Enumにより`n`個の項目が流されるまで\n"
"項目の流出が遅延されることに注意してください。\n"
"\n"
"## 例\n"
"\n"
"    iex> stream = Stream.drop(1..10, 5)\n"
"    iex> Enum.to_list(stream)\n"
"    [6, 7, 8, 9, 10]\n"
"\n"
"    iex> stream = Stream.drop(1..10, -5)\n"
"    iex> Enum.to_list(stream)\n"
"    [1, 2, 3, 4, 5]\n"
"\n"

#. TRANSLATORS: def Stream.reject(enum, fun)
#: lib/stream.ex:533
msgid ""
"Creates a stream that will reject elements according to\n"
"the given function on enumeration.\n"
"\n"
"## Examples\n"
"\n"
"    iex> stream = Stream.reject([1, 2, 3], fn(x) -> rem(x, 2) == 0 end)\n"
"    iex> Enum.to_list(stream)\n"
"    [1, 3]\n"
"\n"
msgstr ""
"Enumerationに対して指定した関数の結果に従って要素を拒否する\n"
"ストリームを作成します。\n"
"\n"
"## 例\n"
"\n"
"    iex> stream = Stream.reject([1, 2, 3], fn(x) -> rem(x, 2) == 0 end)\n"
"    iex> Enum.to_list(stream)\n"
"    [1, 3]\n"
"\n"

#. TRANSLATORS: def Stream.dedup_by(enum, fun)
#: lib/stream.ex:227
msgid ""
"Creates a stream that only emits elements if the result of calling `fun` on "
"the element is\n"
"different from the (stored) result of calling `fun` on the last emitted "
"element.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Stream.dedup_by([{1, :x}, {2, :y}, {2, :z}, {1, :x}], fn {x, _} -> "
"x end) |> Enum.to_list\n"
"    [{1, :x}, {2, :y}, {1, :x}]\n"
"\n"
msgstr ""
"要素に対して`fun`を適用した結果が、最後に流れた要素に対して`fun`を\n"
"適用した（保存済の）結果と異なる要素のみを流すストリームを作成します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Stream.dedup_by([{1, :x}, {2, :y}, {2, :z}, {1, :x}], fn {x, _} -> "
"x end) |> Enum.to_list\n"
"    [{1, :x}, {2, :y}, {1, :x}]\n"
"\n"

#. TRANSLATORS: def Stream.take_every(enum, nth)
#: lib/stream.ex:645
msgid ""
"Creates a stream that takes every `nth` item from the enumerable.\n"
"\n"
"The first item is always included, unless `nth` is 0.\n"
"\n"
"`nth` must be a non-negative integer.\n"
"\n"
"## Examples\n"
"\n"
"    iex> stream = Stream.take_every(1..10, 2)\n"
"    iex> Enum.to_list(stream)\n"
"    [1, 3, 5, 7, 9]\n"
"\n"
"    iex> stream = Stream.take_every([1, 2, 3, 4, 5], 1)\n"
"    iex> Enum.to_list(stream)\n"
"    [1, 2, 3, 4, 5]\n"
"\n"
"    iex> stream = Stream.take_every(1..1000, 0)\n"
"    iex> Enum.to_list(stream)\n"
"    []\n"
"\n"
msgstr ""
"enumerableから`nth`項目毎に取り出すストリームを作成します。\n"
"\n"
"`nth`が0でなければ、最初の項目は常に含まれます。\n"
"\n"
"`nth`は非負の整数でなければなりません。\n"
"\n"
"## 例\n"
"\n"
"    iex> stream = Stream.take_every(1..10, 2)\n"
"    iex> Enum.to_list(stream)\n"
"    [1, 3, 5, 7, 9]\n"
"\n"
"    iex> stream = Stream.take_every([1, 2, 3, 4, 5], 1)\n"
"    iex> Enum.to_list(stream)\n"
"    [1, 2, 3, 4, 5]\n"
"\n"
"    iex> stream = Stream.take_every(1..1000, 0)\n"
"    iex> Enum.to_list(stream)\n"
"    []\n"
"\n"

#. TRANSLATORS: Elixir.Stream Summary
#: lib/stream.ex:2
msgid ""
"Module for creating and composing streams.\n"
"\n"
"Streams are composable, lazy enumerables. Any enumerable that generates\n"
"items one by one during enumeration is called a stream. For example,\n"
"Elixir's `Range` is a stream:\n"
"\n"
"    iex> range = 1..5\n"
"    1..5\n"
"    iex> Enum.map range, &(&1 * 2)\n"
"    [2, 4, 6, 8, 10]\n"
"\n"
"In the example above, as we mapped over the range, the elements being\n"
"enumerated were created one by one, during enumeration. The `Stream`\n"
"module allows us to map the range, without triggering its enumeration:\n"
"\n"
"    iex> range = 1..3\n"
"    iex> stream = Stream.map(range, &(&1 * 2))\n"
"    iex> Enum.map(stream, &(&1 + 1))\n"
"    [3, 5, 7]\n"
"\n"
"Notice we started with a range and then we created a stream that is\n"
"meant to multiply each item in the range by 2. At this point, no\n"
"computation was done. Only when `Enum.map/2` is called we actually\n"
"enumerate over each item in the range, multiplying it by 2 and adding 1.\n"
"We say the functions in `Stream` are *lazy* and the functions in `Enum`\n"
"are *eager*.\n"
"\n"
"Due to their laziness, streams are useful when working with large\n"
"(or even infinite) collections. When chaining many operations with `Enum`,\n"
"intermediate lists are created, while `Stream` creates a recipe of\n"
"computations that are executed at a later moment. Let's see another\n"
"example:\n"
"\n"
"    1..3\n"
"    |> Enum.map(&IO.inspect(&1))\n"
"    |> Enum.map(&(&1 * 2))\n"
"    |> Enum.map(&IO.inspect(&1))\n"
"    1\n"
"    2\n"
"    3\n"
"    2\n"
"    4\n"
"    6\n"
"    #=> [2, 4, 6]\n"
"\n"
"Notice that we first printed each item in the list, then multiplied each\n"
"element by 2 and finally printed each new value. In this example, the list\n"
"was enumerated three times. Let's see an example with streams:\n"
"\n"
"    stream = 1..3\n"
"    |> Stream.map(&IO.inspect(&1))\n"
"    |> Stream.map(&(&1 * 2))\n"
"    |> Stream.map(&IO.inspect(&1))\n"
"    Enum.to_list(stream)\n"
"    1\n"
"    2\n"
"    2\n"
"    4\n"
"    3\n"
"    6\n"
"    #=> [2, 4, 6]\n"
"\n"
"Although the end result is the same, the order in which the items were\n"
"printed changed! With streams, we print the first item and then print\n"
"its double. In this example, the list was enumerated just once!\n"
"\n"
"That's what we meant when we said earlier that streams are composable,\n"
"lazy enumerables. Notice we could call `Stream.map/2` multiple times,\n"
"effectively composing the streams and keeping them lazy. The computations\n"
"are only performed when you call a function from the `Enum` module.\n"
"\n"
"## Creating Streams\n"
"\n"
"There are many functions in Elixir's standard library that return\n"
"streams, some examples are:\n"
"\n"
"  * `IO.stream/2`         - streams input lines, one by one\n"
"  * `URI.query_decoder/1` - decodes a query string, pair by pair\n"
"\n"
"This module also provides many convenience functions for creating streams,\n"
"like `Stream.cycle/1`, `Stream.unfold/2`, `Stream.resource/3` and more.\n"
"\n"
"Note the functions in this module are guaranteed to return enumerables.\n"
"Since enumerables can have different shapes (structs, anonymous functions,\n"
"and so on), the functions in this module may return any of those shapes\n"
"and that this may change at any time. For example, a function that today\n"
"returns an anonymous function may return a struct in future releases.\n"
msgstr ""
"ストリームの作成と構成のためのモジュールです。\n"
"\n"
"ストリームは構成可能な、遅延Enumerableです。\n"
"Enumerableのうち、列挙している間に項目を一つずつ生成するものは\n"
"ストリームと呼ばれます。例えば、Elixirの`Range`はストリームです:\n"
"\n"
"    iex> range = 1..5\n"
"    1..5\n"
"    iex> Enum.map range, &(&1 * 2)\n"
"    [2, 4, 6, 8, 10]\n"
"\n"
"上の例では、rangeについてマップしたので、列挙の間に列挙されたアイテムは一つ\n"
"ずつ作成されました。`Stream`モジュールは、列挙操作を起動させることなく\n"
"rangeのマップ操作を可能にします:\n"
"\n"
"    iex> range = 1..3\n"
"    iex> stream = Stream.map(range, &(&1 * 2))\n"
"    iex> Enum.map(stream, &(&1 + 1))\n"
"    [3, 5, 7]\n"
"\n"
"rangeから開始して、rangeのそれぞれの項目を2倍にするストリームを作っ\n"
"たことに注意してください。この時点ではまだ計算はされていません。\n"
"`Enum.map/2`が呼ばれた時にはじめて、rangeのそれぞれの項目が実際に列挙され、\n"
"2倍されて、1が加えられます。\n"
"我々は`Stream`の関数は*遅延（lazy）*する、`Enum`の関数は*先行（eager）*する"
"と\n"
"言います。\n"
"\n"
"遅延処理をするため、ストリームは、巨大な(さらには無限の)コレクションを\n"
"扱う時に役に立ちます。多くの操作を`Enum`で繋ぐ時は中間のリストが\n"
"作成されますが、`Stream`では後で実行される計算のレシピを作成します。\n"
"もう一つ例を見てみましょう:\n"
"\n"
"    1..3\n"
"    |> Enum.map(&IO.inspect(&1))\n"
"    |> Enum.map(&(&1 * 2))\n"
"    |> Enum.map(&IO.inspect(&1))\n"
"    1\n"
"    2\n"
"    3\n"
"    2\n"
"    4\n"
"    6\n"
"    #=> [2, 4, 6]\n"
"\n"
"最初にリストの各項目をプリントし、次に各項目を2倍し、最後に新しい値を\n"
"プリントしています。この例で、リストは3回列挙されています。\n"
"ストリームを使った場合の例を見てみましょう:\n"
"\n"
"    stream = 1..3\n"
"    |> Stream.map(&IO.inspect(&1))\n"
"    |> Stream.map(&(&1 * 2))\n"
"    |> Stream.map(&IO.inspect(&1))\n"
"    Enum.to_list(stream)\n"
"    1\n"
"    2\n"
"    2\n"
"    4\n"
"    3\n"
"    6\n"
"    #=> [2, 4, 6]\n"
"\n"
"最終的な結果は同じですが、項目のプリントされる順番が変わっています!\n"
"ストリームでは、最初の項目をプリントし、次にそれを2倍したものを\n"
"プリントしています。この例ではリストは一度しか列挙されていません!\n"
"\n"
"これが、はじめにストリームは構成可能で遅延Enumerableであると言った\n"
"際に意味したものです。ストリームを効果的に構成し、かつ、その遅延性を\n"
"保持するために、`Stream.map/2`を複数回呼び出せることに注意してください。\n"
"計算の実行は、`Enum`モジュールの関数を呼び出した時にだけ行われます。\n"
"\n"
"## ストリームの作成\n"
"\n"
"Elixirの標準ライブラリにはストリームを返す関数が沢山あります。\n"
"以下はその例です:\n"
"\n"
"  * `IO.stream/2`         - 入力行を１行ずつストリームします。\n"
"  * `URI.query_decoder/1` - クエリ文字列を１組毎にデコードします。\n"
"\n"
"このモジュールもストリームを作成するための便利な関数を数多く提供していま"
"す。\n"
"`Stream.cycle/1`、`Stream.unfold/2`、`Stream.resource/3`などです。\n"
"\n"
"このモジュールの関数はenumerableを返すことが保証されていることに\n"
"注意してください。enumerableは(構造体や無名関数など)さまざまな形態を\n"
"持つことができるので、このモジュールの関数もこれらの形態のいずれかを\n"
"返す可能性があり、それがいつ変るかもしれません。たとえば、今日無名関数を\n"
"返す関数が、将来のリリースでは構造体を返すかもしれません。\n"

#. TRANSLATORS: def Stream.zip(enumerables)
#: lib/stream.ex:1011
msgid ""
"Zips corresponding elements from a collection of enumerables\n"
"into one stream of tuples.\n"
"\n"
"The zipping finishes as soon as any enumerable completes.\n"
"\n"
"## Examples\n"
"\n"
"    iex> concat = Stream.concat(1..3, 4..6)\n"
"    iex> cycle = Stream.cycle([\"foo\", \"bar\", \"baz\"])\n"
"    iex> Stream.zip([concat, [:a, :b, :c], cycle]) |> Enum.to_list\n"
"    [{1, :a, \"foo\"}, {2, :b, \"bar\"}, {3, :c, \"baz\"}]\n"
"\n"
msgstr ""
"Enumerableのコレクションから対応する要素をzipして\n"
"1つのタプルの流れにします。\n"
"\n"
"いずれかのEnumerableが完了するとすぐにzippingも終了します。\n"
"\n"
"## 例\n"
"\n"
"    iex> concat = Stream.concat(1..3, 4..6)\n"
"    iex> cycle = Stream.cycle([\"foo\", \"bar\", \"baz\"])\n"
"    iex> Stream.zip([concat, [:a, :b, :c], cycle]) |> Enum.to_list\n"
"    [{1, :a, \"foo\"}, {2, :b, \"bar\"}, {3, :c, \"baz\"}]\n"
"\n"

#. TRANSLATORS: def Stream.iterate(start_value, next_fun)
#: lib/stream.ex:1161
msgid ""
"Emits a sequence of values, starting with `start_value`. Successive\n"
"values are generated by calling `next_fun` on the previous value.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Stream.iterate(0, &(&1+1)) |> Enum.take(5)\n"
"    [0, 1, 2, 3, 4]\n"
"\n"
msgstr ""
"`start_value`で初まる値のシーケンスを流します。\n"
"次の値は、`next_fun`に前の値を渡して呼び出すことにより生成されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> Stream.iterate(0, &(&1+1)) |> Enum.take(5)\n"
"    [0, 1, 2, 3, 4]\n"
"\n"

#. TRANSLATORS: def Stream.take(enum, count)
#: lib/stream.ex:608
msgid ""
"Lazily takes the next `count` items from the enumerable and stops\n"
"enumeration.\n"
"\n"
"If a negative `count` is given, the last `count` values will be taken.\n"
"For such, the collection is fully enumerated keeping up to `2 * count`\n"
"elements in memory. Once the end of the collection is reached,\n"
"the last `count` elements will be executed. Therefore, using\n"
"a negative `count` on an infinite collection will never return.\n"
"\n"
"## Examples\n"
"\n"
"    iex> stream = Stream.take(1..100, 5)\n"
"    iex> Enum.to_list(stream)\n"
"    [1, 2, 3, 4, 5]\n"
"\n"
"    iex> stream = Stream.take(1..100, -5)\n"
"    iex> Enum.to_list(stream)\n"
"    [96, 97, 98, 99, 100]\n"
"\n"
"    iex> stream = Stream.cycle([1, 2, 3]) |> Stream.take(5)\n"
"    iex> Enum.to_list(stream)\n"
"    [1, 2, 3, 1, 2]\n"
"\n"
msgstr ""
"次の`n`項目をenumerableから遅延評価して取り出し、列挙を\n"
"停止します。\n"
"\n"
"負値の`n`が指定された場合は、最後の`n`個が取り出されます。そのため、\n"
"コレクションはすべて列挙され、メモリ上に`2 * n`個の要素が保持されます。\n"
"コレクションの終わりに到達したら、最後の`count`個の要素が実行されます。\n"
"従って、無限のコレクションに対して負の`n`を使うと、結果が戻らなくなります。\n"
"\n"
"## 例\n"
"\n"
"    iex> stream = Stream.take(1..100, 5)\n"
"    iex> Enum.to_list(stream)\n"
"    [1, 2, 3, 4, 5]\n"
"\n"
"    iex> stream = Stream.take(1..100, -5)\n"
"    iex> Enum.to_list(stream)\n"
"    [96, 97, 98, 99, 100]\n"
"\n"
"    iex> stream = Stream.cycle([1, 2, 3]) |> Stream.take(5)\n"
"    iex> Enum.to_list(stream)\n"
"    [1, 2, 3, 1, 2]\n"
"\n"

#. TRANSLATORS: def Stream.each(enum, fun)
#: lib/stream.ex:337
msgid ""
"Executes the given function for each item.\n"
"\n"
"Useful for adding side effects (like printing) to a stream.\n"
"\n"
"## Examples\n"
"\n"
"    iex> stream = Stream.each([1, 2, 3], fn(x) -> send self(), x end)\n"
"    iex> Enum.to_list(stream)\n"
"    iex> receive do: (x when is_integer(x) -> x)\n"
"    1\n"
"    iex> receive do: (x when is_integer(x) -> x)\n"
"    2\n"
"    iex> receive do: (x when is_integer(x) -> x)\n"
"    3\n"
"\n"
msgstr ""
"各項目に対し指定した関数を実行します。\n"
"\n"
"ストリームに(プリントのような)副作用を加えるのに役立ちます。\n"
"\n"
"## 例\n"
"\n"
"    iex> stream = Stream.each([1, 2, 3], fn(x) -> send self, x end)\n"
"    iex> Enum.to_list(stream)\n"
"    iex> receive do: (x when is_integer(x) -> x)\n"
"    1\n"
"    iex> receive do: (x when is_integer(x) -> x)\n"
"    2\n"
"    iex> receive do: (x when is_integer(x) -> x)\n"
"    3\n"
"\n"

#. TRANSLATORS: def Stream.concat(enumerables)
#: lib/stream.ex:959
msgid ""
"Creates a stream that enumerates each enumerable in an enumerable.\n"
"\n"
"## Examples\n"
"\n"
"    iex> stream = Stream.concat([1..3, 4..6, 7..9])\n"
"    iex> Enum.to_list(stream)\n"
"    [1, 2, 3, 4, 5, 6, 7, 8, 9]\n"
"\n"
msgstr ""
"enumerable中の各enumerableを列挙するストリームを作成します。\n"
"\n"
"## 例\n"
"\n"
"    iex> stream = Stream.concat([1..3, 4..6, 7..9])\n"
"    iex> Enum.to_list(stream)\n"
"    [1, 2, 3, 4, 5, 6, 7, 8, 9]\n"
"\n"

#. TRANSLATORS: def Stream.filter(enum, fun)
#: lib/stream.ex:384
msgid ""
"Creates a stream that filters elements according to\n"
"the given function on enumeration.\n"
"\n"
"## Examples\n"
"\n"
"    iex> stream = Stream.filter([1, 2, 3], fn(x) -> rem(x, 2) == 0 end)\n"
"    iex> Enum.to_list(stream)\n"
"    [2]\n"
"\n"
msgstr ""
"Enumerationに対して指定された関数に従って要素をフィルタする\n"
"ストリームを作成します。\n"
"\n"
"## 例\n"
"\n"
"    iex> stream = Stream.filter([1, 2, 3], fn(x) -> rem(x, 2) == 0 end)\n"
"    iex> Enum.to_list(stream)\n"
"    [2]\n"
"\n"

#. TRANSLATORS: def Stream.map_every(enum, nth, fun)
#: lib/stream.ex:498
msgid ""
"Creates a stream that will apply the given function on\n"
"every `nth` item from the enumerable.\n"
"\n"
"The first item is always passed to the given function.\n"
"\n"
"`nth` must be a non-negative integer.\n"
"\n"
"## Examples\n"
"\n"
"    iex> stream = Stream.map_every(1..10, 2, fn(x) -> x * 2 end)\n"
"    iex> Enum.to_list(stream)\n"
"    [2, 2, 6, 4, 10, 6, 14, 8, 18, 10]\n"
"\n"
"    iex> stream = Stream.map_every([1, 2, 3, 4, 5], 1, fn(x) -> x * 2 end)\n"
"    iex> Enum.to_list(stream)\n"
"    [2, 4, 6, 8, 10]\n"
"\n"
"    iex> stream = Stream.map_every(1..5, 0, fn(x) -> x * 2 end)\n"
"    iex> Enum.to_list(stream)\n"
"    [1, 2, 3, 4, 5]\n"
"\n"
msgstr ""
"Enumerableから`nth`番目の項目に対して指定した関数を適用するストリームを\n"
"作成します。\n"
"\n"
"最初の項目は常に指定した関数に渡されます。\n"
"\n"
"`nth`は非負の整数でなければなりません。\n"
"\n"
"## 例\n"
"\n"
"    iex> stream = Stream.map_every(1..10, 2, fn(x) -> x * 2 end)\n"
"    iex> Enum.to_list(stream)\n"
"    [2, 2, 6, 4, 10, 6, 14, 8, 18, 10]\n"
"\n"
"    iex> stream = Stream.map_every([1, 2, 3, 4, 5], 1, fn(x) -> x * 2 end)\n"
"    iex> Enum.to_list(stream)\n"
"    [2, 4, 6, 8, 10]\n"
"\n"
"    iex> stream = Stream.map_every(1..5, 0, fn(x) -> x * 2 end)\n"
"    iex> Enum.to_list(stream)\n"
"    [1, 2, 3, 4, 5]\n"
"\n"

#. TRANSLATORS: def Stream.dedup(enum)
#: lib/stream.ex:209
msgid ""
"Creates a stream that only emits elements if they are different from the "
"last emitted element.\n"
"\n"
"This function only ever needs to store the last emitted element.\n"
"\n"
"Elements are compared using `===`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Stream.dedup([1, 2, 3, 3, 2, 1]) |> Enum.to_list\n"
"    [1, 2, 3, 2, 1]\n"
"\n"
msgstr ""
"最後に流した要素とは異なる要素だけを流すストリームを作成します。\n"
"\n"
"この関数は最後に流した要素を保存する必要があります。\n"
"\n"
"要素は `===` で比較されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> Stream.dedup([1, 2, 3, 3, 2, 1]) |> Enum.to_list\n"
"    [1, 2, 3, 2, 1]\n"
"\n"

#. TRANSLATORS: def Stream.uniq(enum)
#: lib/stream.ex:884
msgid ""
"Creates a stream that only emits elements if they are unique.\n"
"\n"
"Keep in mind that, in order to know if an element is unique\n"
"or not, this function needs to store all unique values emitted\n"
"by the stream. Therefore, if the stream is infinite, the number\n"
"of items stored will grow infinitely, never being garbage collected.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Stream.uniq([1, 2, 3, 3, 2, 1]) |> Enum.to_list\n"
"    [1, 2, 3]\n"
"\n"
msgstr ""
"ユニークな要素のみを流すストリームを作成します。\n"
"\n"
"要素がユニークか否かを知るために、この関数はストリームから流れる\n"
"すべてのユニークな値を保存する必要があることに留意してください。\n"
"したがって、ストリームが無限の場合、保存される値の数も無現に\n"
"増大して、ガベージコレクションされることはありません。\n"
"\n"
"## 例\n"
"\n"
"    iex> Stream.uniq([1, 2, 3, 3, 2, 1]) |> Enum.to_list\n"
"    [1, 2, 3]\n"
"\n"

#. TRANSLATORS: def Stream.chunk(enum, n)
#: lib/stream.ex:124
msgid "Shortcut to `chunk(enum, n, n)`.\n"
msgstr "`chunk(enum, n, n)`へのショートカットです。\n"

#. TRANSLATORS: def Stream.chunk(enum, n, step, leftover \\ nil)
#: lib/stream.ex:130
msgid ""
"Streams the enumerable in chunks, containing `n` items each, where\n"
"each new chunk starts `step` elements into the enumerable.\n"
"\n"
"`step` is optional and, if not passed, defaults to `n`, i.e.\n"
"chunks do not overlap. If the final chunk does not have `n`\n"
"elements to fill the chunk, elements are taken as necessary\n"
"from `leftover` if it was passed. If `leftover` is passed and\n"
"does not have enough elements to fill the chunk, then the chunk is\n"
"returned anyway with less than `n` elements. If `leftover` is not\n"
"passed at all or is `nil`, then the partial chunk is discarded\n"
"from the result.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Stream.chunk([1, 2, 3, 4, 5, 6], 2) |> Enum.to_list\n"
"    [[1, 2], [3, 4], [5, 6]]\n"
"\n"
"    iex> Stream.chunk([1, 2, 3, 4, 5, 6], 3, 2) |> Enum.to_list\n"
"    [[1, 2, 3], [3, 4, 5]]\n"
"\n"
"    iex> Stream.chunk([1, 2, 3, 4, 5, 6], 3, 2, [7]) |> Enum.to_list\n"
"    [[1, 2, 3], [3, 4, 5], [5, 6, 7]]\n"
"\n"
"    iex> Stream.chunk([1, 2, 3, 4, 5, 6], 3, 3, []) |> Enum.to_list\n"
"    [[1, 2, 3], [4, 5, 6]]\n"
"\n"
msgstr ""
"各々`n`個の項目を含むチャンクを流します。新たなチャンクは\n"
"enumerableの`step`要素毎に始まります。\n"
"\n"
"`step`はオプションで、指定されない場合のデフォルトは`n`です。\n"
"すなわち、チャンクは重なりません。最後のチャンクがチャンクを満す\n"
"`n`個の要素を持っていない場合、`leftover`が指定されている場合は\n"
"そこから必要に応じて取られます。`leftover`は指定されているが、\n"
"チャンクを満たすだけの要素がない場合は、`n`個未満のチャンクが\n"
"返されます。`leftover`が指定されていない、またはnilの場合は、不完全な\n"
"チャンクは結果から外されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> Stream.chunk([1, 2, 3, 4, 5, 6], 2) |> Enum.to_list\n"
"    [[1, 2], [3, 4], [5, 6]]\n"
"\n"
"    iex> Stream.chunk([1, 2, 3, 4, 5, 6], 3, 2) |> Enum.to_list\n"
"    [[1, 2, 3], [3, 4, 5]]\n"
"\n"
"    iex> Stream.chunk([1, 2, 3, 4, 5, 6], 3, 2, [7]) |> Enum.to_list\n"
"    [[1, 2, 3], [3, 4, 5], [5, 6, 7]]\n"
"\n"
"    iex> Stream.chunk([1, 2, 3, 4, 5, 6], 3, 3, []) |> Enum.to_list\n"
"    [[1, 2, 3], [4, 5, 6]]\n"
"\n"

#. TRANSLATORS: def Stream.scan(enum, acc, fun)
#: lib/stream.ex:591
msgid ""
"Creates a stream that applies the given function to each\n"
"element, emits the result and uses the same result as the accumulator\n"
"for the next computation. Uses the given `acc` as the starting value.\n"
"\n"
"## Examples\n"
"\n"
"    iex> stream = Stream.scan(1..5, 0, &(&1 + &2))\n"
"    iex> Enum.to_list(stream)\n"
"    [1, 3, 6, 10, 15]\n"
"\n"
msgstr ""
"指定した関数を各要素に適用し、その結果を流し、同じ結果を\n"
"次の計算のためのアキュムレータとして使用するストリームを作成します。\n"
"指定した`acc`を初期値として使用します。\n"
"\n"
"## 例\n"
"\n"
"    iex> stream = Stream.scan(1..5, 0, &(&1 + &2))\n"
"    iex> Enum.to_list(stream)\n"
"    [1, 3, 6, 10, 15]\n"
"\n"

#. TRANSLATORS: def Stream.into(enum, collectable, transform \\ fn x -> x end)
#: lib/stream.ex:444
msgid ""
"Injects the stream values into the given collectable as a side-effect.\n"
"\n"
"This function is often used with `run/1` since any evaluation\n"
"is delayed until the stream is executed. See `run/1` for an example.\n"
msgstr ""
"指定したcollectableにストリームの値を副作用として注入します。\n"
"\n"
"通常、この関数は`run/1`と共に使われます。ストリームが実行される\n"
"まで、すべての評価が遅延されるからです。例は、`run/1`を参照してください。\n"

#. TRANSLATORS: def Stream.run(stream)
#: lib/stream.ex:549
msgid ""
"Runs the given stream.\n"
"\n"
"This is useful when a stream needs to be run, for side effects,\n"
"and there is no interest in its return result.\n"
"\n"
"## Examples\n"
"\n"
"Open up a file, replace all `#` by `%` and stream to another file\n"
"without loading the whole file in memory:\n"
"\n"
"    stream = File.stream!(\"code\")\n"
"    |> Stream.map(&String.replace(&1, \"#\", \"%\"))\n"
"    |> Stream.into(File.stream!(\"new\"))\n"
"    |> Stream.run\n"
"\n"
"No computation will be done until we call one of the Enum functions\n"
"or `Stream.run/1`.\n"
msgstr ""
"指定したストリームを実行します。\n"
"\n"
"これは、ストリームを副作用のために実行する必要があり、それが\n"
"返す結果には関心がない場合に便利です。\n"
"\n"
"## 例\n"
"\n"
"ファイルをオープンして、すべての`#`を`%`に置き換え、メモリにファイルの\n"
"全体をロードすることなく別のファイルへ流します:\n"
"\n"
"    stream = File.stream!(\"code\")\n"
"    |> Stream.map(&String.replace(&1, \"#\", \"%\"))\n"
"    |> Stream.into(File.stream!(\"new\"))\n"
"    |> Stream.run\n"
"\n"
"Enumモジュールの関数か`Stream.run/1`のいずれかを呼び出すまで\n"
"計算は行われません。\n"

#. TRANSLATORS: def Stream.drop_while(enum, fun)
#: lib/stream.ex:321
msgid ""
"Lazily drops elements of the enumerable while the given\n"
"function returns `true`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> stream = Stream.drop_while(1..10, &(&1 <= 5))\n"
"    iex> Enum.to_list(stream)\n"
"    [6, 7, 8, 9, 10]\n"
"\n"
msgstr ""
"指定した関数が`true`を返す間、enumerableの要素を遅延評価して落とします。\n"
"\n"
"## 例\n"
"\n"
"    iex> stream = Stream.drop_while(1..10, &(&1 <= 5))\n"
"    iex> Enum.to_list(stream)\n"
"    [6, 7, 8, 9, 10]\n"
"\n"

#. TRANSLATORS: def Stream.unfold(next_acc, next_fun)
#: lib/stream.ex:1325
msgid ""
"Emits a sequence of values for the given accumulator.\n"
"\n"
"Successive values are generated by calling `next_fun` with the previous\n"
"accumulator and it must return a tuple with the current value and next\n"
"accumulator. The enumeration finishes if it returns `nil`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Stream.unfold(5, fn 0 -> nil; n -> {n, n-1} end) |> Enum.to_list()\n"
"    [5, 4, 3, 2, 1]\n"
"\n"
msgstr ""
"指定したアキュムレータから値のシーケンスを流します。\n"
"\n"
"次の値は、前回のアキュムレータを`next_fun`に渡して実行することにより\n"
"生成されます。`next_fun`は、現在値と次のアキュムレータを持つタプルを\n"
"返さなくてはなりません。この関数が`nil`を返すと列挙は終わります。\n"
"\n"
"## 例\n"
"\n"
"    iex> Stream.unfold(5, fn 0 -> nil; n -> {n, n-1} end) |> Enum.to_list()\n"
"    [5, 4, 3, 2, 1]\n"
"\n"

#. TRANSLATORS: def Stream.transform(enum, start_fun, reducer, after_fun)
#: lib/stream.ex:743
msgid ""
"Transforms an existing stream with function-based start and finish.\n"
"\n"
"The accumulator is only calculated when transformation starts. It also\n"
"allows an after function to be given which is invoked when the stream\n"
"halts or completes.\n"
"\n"
"This function can be seen as a combination of `Stream.resource/3` with\n"
"`Stream.transform/3`.\n"
msgstr ""
"既存のstreamを関数ベースのstartとfinishで変換します。\n"
"\n"
"アキュムレータは変換が開始した時点ではじめて計算されます。\n"
"after関数を指定することもできます。この関数は、streamが停止\n"
"または完了したときに呼び出されます。\n"
"\n"
"この関数は、`Stream.resource/3` と `Stream.transform/3` \n"
"の組み合わせとみなすことができます。\n"
"\n"

#. TRANSLATORS: def Stream.scan(enum, fun)
#: lib/stream.ex:574
msgid ""
"Creates a stream that applies the given function to each\n"
"element, emits the result and uses the same result as the accumulator\n"
"for the next computation.\n"
"\n"
"## Examples\n"
"\n"
"    iex> stream = Stream.scan(1..5, &(&1 + &2))\n"
"    iex> Enum.to_list(stream)\n"
"    [1, 3, 6, 10, 15]\n"
"\n"
msgstr ""
"指定した関数を各要素に適用し、その結果を流し、同じ結果を\n"
"次の計算のためのアキュムレータとして使用するストリームを作成します。\n"
"\n"
"## 例\n"
"\n"
"    iex> stream = Stream.scan(1..5, &(&1 + &2))\n"
"    iex> Enum.to_list(stream)\n"
"    [1, 3, 6, 10, 15]\n"
"\n"

#. TRANSLATORS: def Stream.zip(left, right)
#: lib/stream.ex:995
msgid ""
"Zips two collections together, lazily.\n"
"\n"
"The zipping finishes as soon as any enumerable completes.\n"
"\n"
"## Examples\n"
"\n"
"    iex> concat = Stream.concat(1..3, 4..6)\n"
"    iex> cycle  = Stream.cycle([:a, :b, :c])\n"
"    iex> Stream.zip(concat, cycle) |> Enum.to_list\n"
"    [{1, :a}, {2, :b}, {3, :c}, {4, :a}, {5, :b}, {6, :c}]\n"
"\n"
msgstr ""
"二つのコレクションを遅延評価しながらzipします。\n"
"\n"
"いずれかのEnumerableが完了するとすぐにzippingも終了します。\n"
"\n"
"## 例\n"
"\n"
"    iex> concat = Stream.concat(1..3, 4..6)\n"
"    iex> cycle  = Stream.cycle([:a, :b, :c])\n"
"    iex> Stream.zip(concat, cycle) |> Enum.to_list\n"
"    [{1, :a}, {2, :b}, {3, :c}, {4, :a}, {5, :b}, {6, :c}]\n"
"\n"
