msgid ""
msgstr ""
"Project-Id-Version: l 10n_elixir\n"
"PO-Revision-Date: 2017-02-04 11:56+0900\n"
"Last-Translator: 小田 照敬 <EMAIL@ADDRESS>\n"
"Language-Team: Japanese\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"POT-Creation-Date: \n"
"X-Generator: Poedit 1.8.11\n"

#. TRANSLATORS: def List.keydelete(list, key, position)
#: lib/list.ex:339
msgid ""
"Receives a `list` of tuples and deletes the first tuple\n"
"where the item at `position` matches the\n"
"given `key`. Returns the new list.\n"
"\n"
"## Examples\n"
"\n"
"    iex> List.keydelete([a: 1, b: 2], :a, 0)\n"
"    [b: 2]\n"
"\n"
"    iex> List.keydelete([a: 1, b: 2], 2, 1)\n"
"    [a: 1]\n"
"\n"
"    iex> List.keydelete([a: 1, b: 2], :c, 0)\n"
"    [a: 1, b: 2]\n"
"\n"
msgstr ""
"タプルのリストを受け取り、`position`の項目が指定された\n"
"`key`にマッチする最初のタプルを削除します。\n"
"新しいリストを返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> List.keydelete([a: 1, b: 2], :a, 0)\n"
"    [b: 2]\n"
"\n"
"    iex> List.keydelete([a: 1, b: 2], 2, 1)\n"
"    [a: 1]\n"
"\n"
"    iex> List.keydelete([a: 1, b: 2], :c, 0)\n"
"    [a: 1, b: 2]\n"
"\n"

#. TRANSLATORS: def List.foldr(list, acc, function)
#: lib/list.ex:188
msgid ""
"Folds (reduces) the given list from the right with\n"
"a function. Requires an accumulator.\n"
"\n"
"## Examples\n"
"\n"
"    iex> List.foldr([1, 2, 3, 4], 0, fn(x, acc) -> x - acc end)\n"
"    -2\n"
"\n"
msgstr ""
"指定されたリストを指定の関数で右から畳み込み（reduce)します。\n"
"アキュムレータは必須です。\n"
"\n"
"## 例\n"
"\n"
"    iex> List.foldr([1, 2, 3, 4], 0, fn(x, acc) -> x - acc end)\n"
"    -2\n"
"\n"

#. TRANSLATORS: def List.keytake(list, key, position)
#: lib/list.ex:361
msgid ""
"Receives a `list` of tuples and returns the first tuple\n"
"where the element at `position` in the tuple matches the\n"
"given `key`, as well as the `list` without found tuple.\n"
"\n"
"If such a tuple is not found, `nil` will be returned.\n"
"\n"
"## Examples\n"
"\n"
"    iex> List.keytake([a: 1, b: 2], :a, 0)\n"
"    {{:a, 1}, [b: 2]}\n"
"\n"
"    iex> List.keytake([a: 1, b: 2], 2, 1)\n"
"    {{:b, 2}, [a: 1]}\n"
"\n"
"    iex> List.keytake([a: 1, b: 2], :c, 0)\n"
"    nil\n"
"\n"
msgstr ""
"タプルのリストを受け取り、タプルの`position`の\n"
"項目が指定された`key`にマッチする最初のタプルと、\n"
"それを取り除いた`list`を返します。\n"
"\n"
"そのようなタプルが見つからない場合は`nil`を返します。\n"
"\n"
"## Examples\n"
"\n"
"    iex> List.keytake([a: 1, b: 2], :a, 0)\n"
"    {{:a, 1}, [b: 2]}\n"
"\n"
"    iex> List.keytake([a: 1, b: 2], 2, 1)\n"
"    {{:b, 2}, [a: 1]}\n"
"\n"
"    iex> List.keytake([a: 1, b: 2], :c, 0)\n"
"    nil\n"
"\n"

#. TRANSLATORS: def List.to_string(list)
#: lib/list.ex:686
msgid ""
"Converts a list of integers representing codepoints, lists or\n"
"strings into a string.\n"
"\n"
"Notice that this function expects a list of integers representing\n"
"UTF-8 codepoints. If you have a list of bytes, you must instead use\n"
"the [`:binary` module](http://www.erlang.org/doc/man/binary.html).\n"
"\n"
"## Examples\n"
"\n"
"    iex> List.to_string([0x00E6, 0x00DF])\n"
"    \"æß\"\n"
"\n"
"    iex> List.to_string([0x0061, \"bc\"])\n"
"    \"abc\"\n"
"\n"
msgstr ""
"コードポイントで表現された整数、リスト、文字列のリストを、\n"
"文字列に変換します。\n"
"\n"
"この関数は、UTF-8コードポイントを表現する整数のリストを期待している\n"
"ことに注意してください。バイトのリストを持っている場合は、代わりに\n"
"[`:binary`モジュール](http://erlang.org/doc/man/binary.html)を使わなければ"
"なりません。\n"
"\n"
"## 例\n"
"\n"
"    iex> List.to_string([0x00E6, 0x00DF])\n"
"    \"æß\"\n"
"\n"
"    iex> List.to_string([0x0061, \"bc\"])\n"
"    \"abc\"\n"
"\n"

#. TRANSLATORS: def List.myers_difference(list1, list2)
#: lib/list.ex:734
msgid ""
"Returns a keyword list that represents an *edit script*.\n"
"\n"
"The algorithm is outlined in the\n"
"\"An O(ND) Difference Algorithm and Its Variations\" paper by E. Myers.\n"
"\n"
"An *edit script* is a keyword list. Each key describes the \"editing action"
"\" to\n"
"take in order to bring `list1` closer to being equal to `list2`; a key can "
"be\n"
"`:eq`, `:ins`, or `:del`. Each value is a sublist of either `list1` or "
"`list2`\n"
"that should be inserted (if the corresponding key `:ins`), deleted (if "
"the\n"
"corresponding key is `:del`), or left alone (if the corresponding key is\n"
"`:eq`) in `list1` in order to be closer to `list2`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> List.myers_difference([1, 4, 2, 3], [1, 2, 3, 4])\n"
"    [eq: [1], del: [4], eq: [2, 3], ins: [4]]\n"
"\n"
msgstr ""
"*編集スクリプト*を表すキーワードリストを返します。\n"
"\n"
"アルゴリズムはE. Myersの論文「An O(ND) Difference Algorithm\n"
" and Its Variations」に概説されています。\n"
"\n"
"*編集スクリプト*はキーワードリストです。各キーは`list1`が`list2`に\n"
"等しくなるようにするために取るべき*編集アクション*を記述します。\n"
"キーは、`:eq`、`:ins`、`:del`のいずれかです。各値は`list2`に近づける\n"
"ために`list2`に挿入（対応するキーが`:ins`の場合）、削除（対応する\n"
"キーが`:del`の場合）、放置（対応するキーが`:eq`の場合）するべき\n"
"`list1`または`list2`の部分リストです。\n"
"\n"
"## 例\n"
"\n"
"    iex> List.myers_difference([1, 4, 2, 3], [1, 2, 3, 4])\n"
"    [eq: [1], del: [4], eq: [2, 3], ins: [4]]\n"
"\n"

#. TRANSLATORS: def List.flatten(list)
#: lib/list.ex:140
msgid ""
"Flattens the given `list` of nested lists.\n"
"\n"
"## Examples\n"
"\n"
"    iex> List.flatten([1, [[2], 3]])\n"
"    [1, 2, 3]\n"
"\n"
msgstr ""
"指定された入れ子のリスト`list`を平坦化します。\n"
"\n"
"## 例\n"
"\n"
"    iex> List.flatten([1, [[2], 3]])\n"
"    [1, 2, 3]\n"
"\n"

#. TRANSLATORS: def List.duplicate(elem, n)
#: lib/list.ex:123
msgid ""
"Duplicates the given element `n` times in a list.\n"
"\n"
"## Examples\n"
"\n"
"    iex> List.duplicate(\"hello\", 3)\n"
"    [\"hello\", \"hello\", \"hello\"]\n"
"\n"
"    iex> List.duplicate([1, 2], 2)\n"
"    [[1, 2], [1, 2]]\n"
"\n"
msgstr ""
"指定された要素を`n`回複製したリストを作成します。\n"
"\n"
"## 例\n"
"\n"
"    iex> List.duplicate(\"hello\", 3)\n"
"    [\"hello\", \"hello\", \"hello\"]\n"
"\n"
"    iex> List.duplicate([1, 2], 2)\n"
"    [[1, 2], [1, 2]]\n"
"\n"

#. TRANSLATORS: def List.to_integer(charlist)
#: lib/list.ex:638
msgid ""
"Returns an integer whose text representation is `charlist`.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> List.to_integer('123')\n"
"    123\n"
"\n"
msgstr ""
"テキスト表現が`charlist`である整数を返します。\n"
"\n"
"コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> List.to_integer('123')\n"
"    123\n"
"\n"

#. TRANSLATORS: def List.delete_at(list, index)
#: lib/list.ex:529
msgid ""
"Produces a new list by removing the value at the specified `index`.\n"
"\n"
"Negative indices indicate an offset from the end of the `list`.\n"
"If `index` is out of bounds, the original `list` is returned.\n"
"\n"
"## Examples\n"
"\n"
"    iex> List.delete_at([1, 2, 3], 0)\n"
"    [2, 3]\n"
"\n"
"    iex> List.delete_at([1, 2, 3], 10)\n"
"    [1, 2, 3]\n"
"\n"
"    iex> List.delete_at([1, 2, 3], -1)\n"
"    [1, 2]\n"
"\n"
msgstr ""
"指定された`index`の値を削除した、新しいリストを作成します。\n"
"\n"
"負のインデックスは`list`の末尾からのオフセットを示します。\n"
"`index`が範囲外の場合は、オリジナルの`list`が返されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> List.delete_at([1, 2, 3], 0)\n"
"    [2, 3]\n"
"\n"
"    iex> List.delete_at([1, 2, 3], 10)\n"
"    [1, 2, 3]\n"
"\n"
"    iex> List.delete_at([1, 2, 3], -1)\n"
"    [1, 2]\n"
"\n"

#. TRANSLATORS: def List.insert_at(list, index, value)
#: lib/list.ex:439
msgid ""
"Returns a list with `value` inserted at the specified `index`.\n"
"\n"
"Note that `index` is capped at the list length. Negative indices\n"
"indicate an offset from the end of the `list`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> List.insert_at([1, 2, 3, 4], 2, 0)\n"
"    [1, 2, 0, 3, 4]\n"
"\n"
"    iex> List.insert_at([1, 2, 3], 10, 0)\n"
"    [1, 2, 3, 0]\n"
"\n"
"    iex> List.insert_at([1, 2, 3], -1, 0)\n"
"    [1, 2, 3, 0]\n"
"\n"
"    iex> List.insert_at([1, 2, 3], -10, 0)\n"
"    [0, 1, 2, 3]\n"
"\n"
msgstr ""
"指定された位置`index`に`value`を挿入したリストを返します。\n"
"\n"
"リストの長さが`index`の上限になることに注意してください。\n"
"負のインデックスは`list`の末尾からのオフセットを指示します。\n"
"\n"
"## 例\n"
"\n"
"    iex> List.insert_at([1, 2, 3, 4], 2, 0)\n"
"    [1, 2, 0, 3, 4]\n"
"\n"
"    iex> List.insert_at([1, 2, 3], 10, 0)\n"
"    [1, 2, 3, 0]\n"
"\n"
"    iex> List.insert_at([1, 2, 3], -1, 0)\n"
"    [1, 2, 3, 0]\n"
"\n"
"    iex> List.insert_at([1, 2, 3], -10, 0)\n"
"    [0, 1, 2, 3]\n"
"\n"

#. TRANSLATORS: def List.to_tuple(list)
#: lib/list.ex:670
msgid ""
"Converts a list to a tuple.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> List.to_tuple([:share, [:elixir, 163]])\n"
"    {:share, [:elixir, 163]}\n"
"\n"
msgstr ""
"リストをタプルに変換します。\n"
"\n"
"コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> List.to_tuple([:share, [:elixir, 163]])\n"
"    {:share, [:elixir, 163]}\n"
"\n"

#. TRANSLATORS: def List.keysort(list, position)
#: lib/list.ex:301
msgid ""
"Receives a list of tuples and sorts the items\n"
"at `position` of the tuples. The sort is stable.\n"
"\n"
"## Examples\n"
"\n"
"    iex> List.keysort([a: 5, b: 1, c: 3], 1)\n"
"    [b: 1, c: 3, a: 5]\n"
"\n"
"    iex> List.keysort([a: 5, c: 1, b: 3], 0)\n"
"    [a: 5, b: 3, c: 1]\n"
"\n"
msgstr ""
"タプルのリストを受け取り、タプルの`position`の項目で\n"
"ソートします。ソートは安定です。\n"
"\n"
"## 例\n"
"\n"
"    iex> List.keysort([a: 5, b: 1, c: 3], 1)\n"
"    [b: 1, c: 3, a: 5]\n"
"\n"
"    iex> List.keysort([a: 5, c: 1, b: 3], 0)\n"
"    [a: 5, b: 3, c: 1]\n"
"\n"

#. TRANSLATORS: Elixir.List Summary
#: lib/list.ex:2
msgid ""
"Functions that work on (linked) lists.\n"
"\n"
"Lists in Elixir are specified between square brackets:\n"
"\n"
"    iex> [1, \"two\", 3, :four]\n"
"    [1, \"two\", 3, :four]\n"
"\n"
"Two lists can be concatenated and subtracted using the\n"
"`Kernel.++/2` and `Kernel.--/2` operators:\n"
"\n"
"    iex> [1, 2, 3] ++ [4, 5, 6]\n"
"    [1, 2, 3, 4, 5, 6]\n"
"    iex> [1, true, 2, false, 3, true] -- [true, false]\n"
"    [1, 2, 3, true]\n"
"\n"
"Lists in Elixir are effectively linked lists, which means\n"
"they are internally represented in pairs containing the\n"
"head and the tail of a list:\n"
"\n"
"    iex> [head | tail] = [1, 2, 3]\n"
"    iex> head\n"
"    1\n"
"    iex> tail\n"
"    [2, 3]\n"
"\n"
"Similarly, we could write the list `[1, 2, 3]` using only\n"
"such pairs (called cons cells):\n"
"\n"
"    iex> [1 | [2 | [3 | []]]]\n"
"    [1, 2, 3]\n"
"\n"
"Some lists, called improper lists, do not have an empty list as\n"
"the second element in the last cons cell:\n"
"\n"
"    iex> [1 | [2 | [3 | 4]]]\n"
"    [1, 2, 3 | 4]\n"
"\n"
"Although improper lists are generally avoided, they are used in some\n"
"special circumstances like iodata and chardata entities (see the `IO` "
"module).\n"
"\n"
"Due to their cons cell based representation, prepending an element\n"
"to a list is always fast (constant time), while appending becomes\n"
"slower as the list grows in size (linear time):\n"
"\n"
"    iex> list = [1, 2, 3]\n"
"    iex> [0 | list]   # fast\n"
"    [0, 1, 2, 3]\n"
"    iex> list ++ [4]  # slow\n"
"    [1, 2, 3, 4]\n"
"\n"
"The `Kernel` module contains many functions to manipulate lists\n"
"and that are allowed in guards. For example, `Kernel.hd/1` to\n"
"retrieve the head, `Kernel.tl/1` to fetch the tail and\n"
"`Kernel.length/1` for calculating the length. Keep in mind that,\n"
"similar to appending to a list, calculating the length needs to\n"
"traverse the whole list.\n"
"\n"
"## Charlists\n"
"\n"
"If a list is made of non-negative integers, it can also be called\n"
"a charlist. Elixir uses single quotes to define charlists:\n"
"\n"
"    iex> 'héllo'\n"
"    [104, 233, 108, 108, 111]\n"
"\n"
"In particular, charlists may be printed back in single\n"
"quotes if they contain only ASCII-printable codepoints:\n"
"\n"
"    iex> 'abc'\n"
"    'abc'\n"
"\n"
"The rationale behind this behaviour is to better support\n"
"Erlang libraries which may return text as charlists\n"
"instead of Elixir strings. One example of such functions\n"
"is `Application.loaded_applications/0`:\n"
"\n"
"    Application.loaded_applications\n"
"    #=>  [{:stdlib, 'ERTS  CXC 138 10', '2.6'},\n"
"          {:compiler, 'ERTS  CXC 138 10', '6.0.1'},\n"
"          {:elixir, 'elixir', '1.0.0'},\n"
"          {:kernel, 'ERTS  CXC 138 10', '4.1'},\n"
"          {:logger, 'logger', '1.0.0'}]\n"
"\n"
"## List and Enum modules\n"
"\n"
"This module aims to provide operations that are specific\n"
"to lists, like conversion between data types, updates,\n"
"deletions and key lookups (for lists of tuples). For traversing\n"
"lists in general, developers should use the functions in the\n"
"`Enum` module that work across a variety of data types.\n"
"\n"
"In both `Enum` and `List` modules, any kind of index access\n"
"on a list is linear. Negative indexes are also supported but\n"
"they imply the list will be iterated twice, one to calculate\n"
"the proper index and another to perform the operation.\n"
msgstr ""
"（連結）リストを扱う関数です。\n"
"\n"
"Elixirのリストは角括弧で囲んで指定します:\n"
"\n"
"    iex> [1, \"two\", 3, :four]\n"
"    [1, \"two\", 3, :four]\n"
"\n"
"2つのリストは`Kernel.++/2`および`Kernel.--/2`演算子を\n"
"使用して、連結および減算することができます。\n"
"\n"
"    iex> [1, 2, 3] ++ [4, 5, 6]\n"
"    [1, 2, 3, 4, 5, 6]\n"
"    iex> [1, true, 2, false, 3, true] -- [true, false]\n"
"    [1, 2, 3, true]\n"
"\n"
"Elixirのリストは効果的な連結リストです。つまり、\n"
"内部的にはリストのヘッドとテイルを含むペアで表現\n"
"されています。\n"
"\n"
"    iex> [head | tail] = [1, 2, 3]\n"
"    iex> head\n"
"    1\n"
"    iex> tail\n"
"    [2, 3]\n"
"\n"
"同様に、そのようなペア（コンスセルと呼ばれます）のみを\n"
"使用してリスト`[1, 2, 3]`を書くこともできます。\n"
"\n"
"    iex> [1 | [2 | [3 | []]]]\n"
"    [1, 2, 3]\n"
"\n"
"リストの中には、（不適切なリストと呼ばれる）\n"
"最後のコンスセルの第2要素に空のリストを持たないものがあります。\n"
"\n"
"    iex> [1 | [2 | [3 | 4]]]\n"
"    [1, 2, 3 | 4]\n"
"\n"
"不適切なリストは一般に避けられますが、iodataやchardataのような\n"
"特殊な状況で使用されます（`IO`モジュールを参照）。\n"
"\n"
"コンスセルを基本とした表現のため、リストの先頭への要素の追加は常に\n"
"高速（定数時間）ですが、末尾への追加はリストのサイズが大きくなるに\n"
"つれ遅くなります（線形時間）。\n"
"\n"
"    iex> list = [1, 2, 3]\n"
"    iex> [0 | list]   # 早い\n"
"    [0, 1, 2, 3]\n"
"    iex> list ++ [4]  # 遅い\n"
"    [1, 2, 3, 4]\n"
"\n"
"`Kernel` モジュールはリストを操作するための、そしてガードで\n"
"使用できる関数を多く含んでいます。たとえば、ヘッドを取り出す\n"
"`Kernel.hd/1`、テイルを取得する`Kernel.tl/1`、長さを計算する\n"
"`Kernel.length/1`などです。\n"
"リストの末尾への追加と同様に、長さの計算も全リストを走査する\n"
"必要があることに注意してください。\n"
"\n"
"## 文字のリスト（Charlist）\n"
"\n"
"リストが非負整数でできている場合、文字のリストと呼ぶことができます。\n"
"Elixirは文字のリストを定義するのに一重引用符を使用します。\n"
"\n"
"    iex> 'héllo'\n"
"    [104, 233, 108, 108, 111]\n"
"\n"
"特に、文字のリストはASCIIの印字可能なコードポイントのみを含む場合、\n"
"一重引用部で印字されます。\n"
"\n"
"    iex> 'abc'\n"
"    'abc'\n"
"\n"
"この動作の背後にある理由は、テキストをElixirの文字列ではなく文字の\n"
"リストで返すErlangライブリをより良くサポートすることです。その\n"
"ような関数の1つの例が\n"
"`Application.loaded_applications/0`です。\n"
"\n"
"    Application.loaded_applications\n"
"    #=>  [{:stdlib, 'ERTS  CXC 138 10', '2.6'},\n"
"          {:compiler, 'ERTS  CXC 138 10', '6.0.1'},\n"
"          {:elixir, 'elixir', '1.0.0'},\n"
"          {:kernel, 'ERTS  CXC 138 10', '4.1'},\n"
"          {:logger, 'logger', '1.0.0'}]\n"
"\n"
"## リストとEnumモジュール\n"
"\n"
"このモジュールは、データ型の変換、更新、削除、\n"
"（タプルのリストの）キーの検索など、リストに固有の操作を\n"
"提供することを目的としています。\n"
"一般にリストを走査する場合は、さまざまなデータ型で機能する\n"
"`Enum`モジュールの関数を使用するべきです。\n"
"\n"
"`Enum`モジュールと`List`モジュールの両方において、リストに対する\n"
"あらゆる種類のインデックスアクセスは線形です。負のインデックスも\n"
"サポートされていますが、これはリストが2回反復されることを意味します。\n"
"1回は適切なインデックスの計算のため、もう1回は操作の実行のためです。\n"
"\n"

#. TRANSLATORS: def List.keyfind(list, key, position, default \\ nil)
#: lib/list.ex:242
msgid ""
"Receives a list of tuples and returns the first tuple\n"
"where the item at `position` in the tuple matches the\n"
"given `key`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> List.keyfind([a: 1, b: 2], :a, 0)\n"
"    {:a, 1}\n"
"\n"
"    iex> List.keyfind([a: 1, b: 2], 2, 1)\n"
"    {:b, 2}\n"
"\n"
"    iex> List.keyfind([a: 1, b: 2], :c, 0)\n"
"    nil\n"
"\n"
msgstr ""
"タプルのリストを受け取り、タプルの`position`の\n"
"項目が指定された`key`にマッチする最初のタプルを\n"
"返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> List.keyfind([a: 1, b: 2], :a, 0)\n"
"    {:a, 1}\n"
"\n"
"    iex> List.keyfind([a: 1, b: 2], 2, 1)\n"
"    {:b, 2}\n"
"\n"
"    iex> List.keyfind([a: 1, b: 2], :c, 0)\n"
"    nil\n"
"\n"

#. TRANSLATORS: def List.wrap(list)
#: lib/list.ex:388
msgid ""
"Wraps the argument in a list.\n"
"\n"
"If the argument is already a list, returns the list.\n"
"If the argument is `nil`, returns an empty list.\n"
"\n"
"## Examples\n"
"\n"
"    iex> List.wrap(\"hello\")\n"
"    [\"hello\"]\n"
"\n"
"    iex> List.wrap([1, 2, 3])\n"
"    [1, 2, 3]\n"
"\n"
"    iex> List.wrap(nil)\n"
"    []\n"
"\n"
msgstr ""
"引数をリストで包みます。\n"
"\n"
"引数が既にリストの場合は、そのリストを返します。\n"
"引数が`nil`の場合は、空のリストを返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> List.wrap(\"hello\")\n"
"    [\"hello\"]\n"
"\n"
"    iex> List.wrap([1, 2, 3])\n"
"    [1, 2, 3]\n"
"\n"
"    iex> List.wrap(nil)\n"
"    []\n"
"\n"

#. TRANSLATORS: def List.update_at(list, index, fun)
#: lib/list.ex:499
msgid ""
"Returns a list with an updated value at the specified `index`.\n"
"\n"
"Negative indices indicate an offset from the end of the `list`.\n"
"If `index` is out of bounds, the original `list` is returned.\n"
"\n"
"## Examples\n"
"\n"
"    iex> List.update_at([1, 2, 3], 0, &(&1 + 10))\n"
"    [11, 2, 3]\n"
"\n"
"    iex> List.update_at([1, 2, 3], 10, &(&1 + 10))\n"
"    [1, 2, 3]\n"
"\n"
"    iex> List.update_at([1, 2, 3], -1, &(&1 + 10))\n"
"    [1, 2, 13]\n"
"\n"
"    iex> List.update_at([1, 2, 3], -10, &(&1 + 10))\n"
"    [1, 2, 3]\n"
"\n"
msgstr ""
"指定された`index`の値を更新したリストを返します。\n"
"\n"
"負のインデックスは`list`の末尾からのオフセットを示します。\n"
"`index`が範囲外の場合は、オリジナルの`list`が返されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> List.update_at([1, 2, 3], 0, &(&1 + 10))\n"
"    [11, 2, 3]\n"
"\n"
"    iex> List.update_at([1, 2, 3], 10, &(&1 + 10))\n"
"    [1, 2, 3]\n"
"\n"
"    iex> List.update_at([1, 2, 3], -1, &(&1 + 10))\n"
"    [1, 2, 13]\n"
"\n"
"    iex> List.update_at([1, 2, 3], -10, &(&1 + 10))\n"
"    [1, 2, 3]\n"
"\n"

#. TRANSLATORS: def List.last(list)
#: lib/list.ex:222
msgid ""
"Returns the last element in `list` or `nil` if `list` is empty.\n"
"\n"
"## Examples\n"
"\n"
"    iex> List.last([])\n"
"    nil\n"
"\n"
"    iex> List.last([1])\n"
"    1\n"
"\n"
"    iex> List.last([1, 2, 3])\n"
"    3\n"
"\n"
msgstr ""
"`list`の最後の要素、または`list`が空なら`nil`を返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> List.last([])\n"
"    nil\n"
"\n"
"    iex> List.last([1])\n"
"    1\n"
"\n"
"    iex> List.last([1, 2, 3])\n"
"    3\n"
"\n"

#. TRANSLATORS: def List.keystore(list, key, position, new_tuple)
#: lib/list.ex:319
msgid ""
"Receives a `list` of tuples and replaces the item\n"
"identified by `key` at `position`.\n"
"\n"
"If the item does not exist, it is added to the end of the `list`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> List.keystore([a: 1, b: 2], :a, 0, {:a, 3})\n"
"    [a: 3, b: 2]\n"
"\n"
"    iex> List.keystore([a: 1, b: 2], :c, 0, {:c, 3})\n"
"    [a: 1, b: 2, c: 3]\n"
"\n"
msgstr ""
"タプルのリストを受け取り、`position`の`key`により指定された\n"
"項目を置き換えます。\n"
"\n"
"アイテムが存在しない場合は、リストの末尾に追加されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> List.keystore([a: 1, b: 2], :a, 0, {:a, 3})\n"
"    [a: 3, b: 2]\n"
"\n"
"    iex> List.keystore([a: 1, b: 2], :c, 0, {:c, 3})\n"
"    [a: 1, b: 2, c: 3]\n"
"\n"

#. TRANSLATORS: def List.replace_at(list, index, value)
#: lib/list.ex:469
msgid ""
"Returns a list with a replaced value at the specified `index`.\n"
"\n"
"Negative indices indicate an offset from the end of the `list`.\n"
"If `index` is out of bounds, the original `list` is returned.\n"
"\n"
"## Examples\n"
"\n"
"    iex> List.replace_at([1, 2, 3], 0, 0)\n"
"    [0, 2, 3]\n"
"\n"
"    iex> List.replace_at([1, 2, 3], 10, 0)\n"
"    [1, 2, 3]\n"
"\n"
"    iex> List.replace_at([1, 2, 3], -1, 0)\n"
"    [1, 2, 0]\n"
"\n"
"    iex> List.replace_at([1, 2, 3], -10, 0)\n"
"    [1, 2, 3]\n"
"\n"
msgstr ""
"指定された`index`の値を置き換えたリストを返します。\n"
"\n"
"負のインデックスは`list`の末尾からのオフセットを示します。\n"
"`index`が範囲外の場合は、オリジナルの`list`が返されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> List.replace_at([1, 2, 3], 0, 0)\n"
"    [0, 2, 3]\n"
"\n"
"    iex> List.replace_at([1, 2, 3], 10, 0)\n"
"    [1, 2, 3]\n"
"\n"
"    iex> List.replace_at([1, 2, 3], -1, 0)\n"
"    [1, 2, 0]\n"
"\n"
"    iex> List.replace_at([1, 2, 3], -10, 0)\n"
"    [1, 2, 3]\n"
"\n"

#. TRANSLATORS: def List.to_float(charlist)
#: lib/list.ex:622
msgid ""
"Returns the float whose text representation is `charlist`.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> List.to_float('2.2017764e+0')\n"
"    2.2017764\n"
"\n"
msgstr ""
"テキスト表現が`charlist`である浮動小数点数を返します。\n"
"\n"
"コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> List.to_float('2.2017764e+0')\n"
"    2.2017764\n"
"\n"

#. TRANSLATORS: def List.pop_at(list, index, default \\ nil)
#: lib/list.ex:552
msgid ""
"Returns and removes the value at the specified `index` in the `list`.\n"
"\n"
"Negative indices indicate an offset from the end of the `list`.\n"
"If `index` is out of bounds, the original `list` is returned.\n"
"\n"
"## Examples\n"
"\n"
"    iex> List.pop_at([1, 2, 3], 0)\n"
"    {1, [2, 3]}\n"
"    iex> List.pop_at([1, 2, 3], 5)\n"
"    {nil, [1, 2, 3]}\n"
"    iex> List.pop_at([1, 2, 3], 5, 10)\n"
"    {10, [1, 2, 3]}\n"
"    iex> List.pop_at([1, 2, 3], -1)\n"
"    {3, [1, 2]}\n"
"\n"
msgstr ""
"`index`の指定された`index`の値とそれを削除したリストを返します。\n"
"\n"
"負のインデックスは`list`の末尾からのオフセットを示します。\n"
"`index`が範囲外の場合は、オリジナルの`list`が返されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> List.pop_at([1, 2, 3], 0)\n"
"    {1, [2, 3]}\n"
"    iex> List.pop_at([1, 2, 3], 5)\n"
"    {nil, [1, 2, 3]}\n"
"    iex> List.pop_at([1, 2, 3], 5, 10)\n"
"    {10, [1, 2, 3]}\n"
"    iex> List.pop_at([1, 2, 3], -1)\n"
"    {3, [1, 2]}\n"
"\n"

#. TRANSLATORS: def List.keymember?(list, key, position)
#: lib/list.ex:264
msgid ""
"Receives a list of tuples and returns `true` if there is\n"
"a tuple where the item at `position` in the tuple matches\n"
"the given `key`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> List.keymember?([a: 1, b: 2], :a, 0)\n"
"    true\n"
"\n"
"    iex> List.keymember?([a: 1, b: 2], 2, 1)\n"
"    true\n"
"\n"
"    iex> List.keymember?([a: 1, b: 2], :c, 0)\n"
"    false\n"
"\n"
msgstr ""
"タプルのリストを受け取り、タプルの`position`の\n"
"項目が指定された`key`にマッチするタプルがあれば、\n"
"`true`を返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> List.keymember?([a: 1, b: 2], :a, 0)\n"
"    true\n"
"\n"
"    iex> List.keymember?([a: 1, b: 2], 2, 1)\n"
"    true\n"
"\n"
"    iex> List.keymember?([a: 1, b: 2], :c, 0)\n"
"    false\n"
"\n"

#. TRANSLATORS: def List.foldl(list, acc, function)
#: lib/list.ex:170
msgid ""
"Folds (reduces) the given list from the left with\n"
"a function. Requires an accumulator.\n"
"\n"
"## Examples\n"
"\n"
"    iex> List.foldl([5, 5], 10, fn(x, acc) -> x + acc end)\n"
"    20\n"
"\n"
"    iex> List.foldl([1, 2, 3, 4], 0, fn(x, acc) -> x - acc end)\n"
"    2\n"
"\n"
msgstr ""
"指定されたリストを指定の関数で左から畳み込み(reduce)ます。\n"
"アキュムレータは必須です。\n"
"\n"
"## 例\n"
"\n"
"    iex> List.foldl([5, 5], 10, fn(x, acc) -> x + acc end)\n"
"    20\n"
"\n"
"    iex> List.foldl([1, 2, 3, 4], 0, fn(x, acc) -> x - acc end)\n"
"    2\n"
"\n"

#. TRANSLATORS: def List.keyreplace(list, key, position, new_tuple)
#: lib/list.ex:286
msgid ""
"Receives a list of tuples and replaces the item\n"
"identified by `key` at `position` if it exists.\n"
"\n"
"## Examples\n"
"\n"
"    iex> List.keyreplace([a: 1, b: 2], :a, 0, {:a, 3})\n"
"    [a: 3, b: 2]\n"
"\n"
msgstr ""
"タプルのリストを受け取り、`position`に`key`により\n"
"識別される項目があれば置き換えます\n"
"\n"
"## 例\n"
"\n"
"    iex> List.keyreplace([a: 1, b: 2], :a, 0, {:a, 3})\n"
"    [a: 3, b: 2]\n"
"\n"

#. TRANSLATORS: def List.zip(list_of_lists)
#: lib/list.ex:419
msgid ""
"Zips corresponding elements from each list in `list_of_lists`.\n"
"\n"
"The zipping finishes as soon as any list terminates.\n"
"\n"
"## Examples\n"
"\n"
"    iex> List.zip([[1, 2], [3, 4], [5, 6]])\n"
"    [{1, 3, 5}, {2, 4, 6}]\n"
"\n"
"    iex> List.zip([[1, 2], [3], [5, 6]])\n"
"    [{1, 3, 5}]\n"
"\n"
msgstr ""
"`list_of_list`の各リストから対応する要素をzipします。\n"
"\n"
"いずれかのリストが終了した場合は直ちに処理を終了します。\n"
"\n"
"## 例\n"
"\n"
"    iex> List.zip([[1, 2], [3, 4], [5, 6]])\n"
"    [{1, 3, 5}, {2, 4, 6}]\n"
"\n"
"    iex> List.zip([[1, 2], [3], [5, 6]])\n"
"    [{1, 3, 5}]\n"
"\n"

#. TRANSLATORS: def List.to_atom(charlist)
#: lib/list.ex:579
msgid ""
"Converts a charlist to an atom.\n"
"\n"
"Currently Elixir does not support conversions from charlists\n"
"which contains Unicode codepoints greater than 0xFF.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> List.to_atom('elixir')\n"
"    :elixir\n"
"\n"
msgstr ""
"文字のリストをアトムに変換します。\n"
"\n"
"現在のElixirは、0xFFを越えるUnicodeコードポイントを含む\n"
"文字のリストからの変換はサポートしていません。\n"
"\n"
"コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> List.to_atom('elixir')\n"
"    :elixir\n"
"\n"

#. TRANSLATORS: def List.to_existing_atom(charlist)
#: lib/list.ex:598
msgid ""
"Converts a charlist to an existing atom. Raises an `ArgumentError`\n"
"if the atom does not exist.\n"
"\n"
"Currently Elixir does not support conversions from charlists\n"
"which contains Unicode codepoints greater than 0xFF.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> _ = :my_atom\n"
"    iex> List.to_existing_atom('my_atom')\n"
"    :my_atom\n"
"\n"
"    iex> List.to_existing_atom('this_atom_will_never_exist')\n"
"    ** (ArgumentError) argument error\n"
"\n"
msgstr ""
"文字のリストを既存のアトムに変換します。アトムが存在しない場合\n"
"`ArgumentError`が発生します。\n"
"\n"
"現在のElixirは、0xFFを越えるUnicodeコードポイントを含む\n"
"文字のリストからの変換はサポートしていません。\n"
"\n"
"コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> _ = :my_atom\n"
"    iex> List.to_existing_atom('my_atom')\n"
"    :my_atom\n"
"\n"
"    iex> List.to_existing_atom('this_atom_will_never_exist')\n"
"    ** (ArgumentError) argument error\n"
"\n"

#. TRANSLATORS: def List.flatten(list, tail)
#: lib/list.ex:154
msgid ""
"Flattens the given `list` of nested lists.\n"
"The list `tail` will be added at the end of\n"
"the flattened list.\n"
"\n"
"## Examples\n"
"\n"
"    iex> List.flatten([1, [[2], 3]], [4, 5])\n"
"    [1, 2, 3, 4, 5]\n"
"\n"
msgstr ""
"指定された入れ子のリスト`list`を平坦化します。\n"
"リスト`tail`を平坦化されたlistの末尾に追加します。\n"
"\n"
"## 例\n"
"\n"
"    iex> List.flatten([1, [[2], 3]], [4, 5])\n"
"    [1, 2, 3, 4, 5]\n"
"\n"

#. TRANSLATORS: def List.first(list)
#: lib/list.ex:203
msgid ""
"Returns the first element in `list` or `nil` if `list` is empty.\n"
"\n"
"## Examples\n"
"\n"
"    iex> List.first([])\n"
"    nil\n"
"\n"
"    iex> List.first([1])\n"
"    1\n"
"\n"
"    iex> List.first([1, 2, 3])\n"
"    1\n"
"\n"
msgstr ""
"`list`の最初の要素、または`list`が空の場合は`nil`を返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> List.first([])\n"
"    nil\n"
"\n"
"    iex> List.first([1])\n"
"    1\n"
"\n"
"    iex> List.first([1, 2, 3])\n"
"    1\n"
"\n"

#. TRANSLATORS: def List.to_integer(charlist, base)
#: lib/list.ex:654
msgid ""
"Returns an integer whose text representation is `charlist` in base "
"`base`.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> List.to_integer('3FF', 16)\n"
"    1023\n"
"\n"
msgstr ""
"テキスト表現が基数`base`の`charlist`である整数を返します。\n"
"\n"
"コンパイラによりインライン化されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> List.to_integer('3FF', 16)\n"
"    1023\n"
"\n"

#. TRANSLATORS: def List.delete(list, item)
#: lib/list.ex:102
msgid ""
"Deletes the given `item` from the `list`. Returns a new list without\n"
"the item.\n"
"\n"
"If the `item` occurs more than once in the `list`, just\n"
"the first occurrence is removed.\n"
"\n"
"## Examples\n"
"\n"
"    iex> List.delete([:a, :b, :c], :a)\n"
"    [:b, :c]\n"
"\n"
"    iex> List.delete([:a, :b, :b, :c], :b)\n"
"    [:a, :b, :c]\n"
"\n"
msgstr ""
"`list`から指定された`item`を削除します。その項目を\n"
"持たない新しいリストを返します。\n"
"\n"
"`list`中に`item`が2つ以上ある場合は、最初に現れた\n"
"1つだけが削除されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> List.delete([:a, :b, :c], :a)\n"
"    [:b, :c]\n"
"\n"
"    iex> List.delete([:a, :b, :b, :c], :b)\n"
"    [:a, :b, :c]\n"
"\n"

#~ msgid ""
#~ "Specialized functions that only work on lists.\n"
#~ "\n"
#~ "In general, favor using the `Enum` API instead of `List`.\n"
#~ "\n"
#~ "Index access for list is linear. Negative indexes are also\n"
#~ "supported but they imply the list will be iterated twice,\n"
#~ "one to calculate the proper index and another to perform the\n"
#~ "operation.\n"
#~ "\n"
#~ "A decision was taken to delegate most functions to\n"
#~ "Erlang's standard library but follow Elixir's convention\n"
#~ "of receiving the subject (in this case, a list) as the\n"
#~ "first argument.\n"
#~ "\n"
#~ "## Char lists\n"
#~ "\n"
#~ "If a list is made of non-negative integers, it can also\n"
#~ "be called as a char list. Elixir uses single quotes to\n"
#~ "define char lists:\n"
#~ "\n"
#~ "    iex> 'héllo'\n"
#~ "    [104, 233, 108, 108, 111]\n"
#~ "\n"
#~ "In particular, char lists may be printed back in single\n"
#~ "quotes if they contain only ASCII-printable codepoints:\n"
#~ "\n"
#~ "    iex> 'abc'\n"
#~ "    'abc'\n"
#~ "\n"
#~ "The rationale behind this behaviour is to better support\n"
#~ "Erlang libraries which may return text as char lists\n"
#~ "instead of Elixir strings. One example of such functions\n"
#~ "is `Application.loaded_applications`:\n"
#~ "\n"
#~ "    Application.loaded_applications\n"
#~ "    #=>  [{:stdlib, 'ERTS  CXC 138 10', '2.6'},\n"
#~ "          {:compiler, 'ERTS  CXC 138 10', '6.0.1'},\n"
#~ "          {:elixir, 'elixir', '1.0.0'},\n"
#~ "          {:kernel, 'ERTS  CXC 138 10', '4.1'},\n"
#~ "          {:logger, 'logger', '1.0.0'}]\n"
#~ msgstr ""
#~ "リストでのみ働く特別な関数です。\n"
#~ "\n"
#~ "一般に、`List`の代りに`Enum` API を使うことを好みます。\n"
#~ "\n"
#~ "リストのインデックスアクセスは線形の時間が掛ります。\n"
#~ "負のインデックスもサポートされていますが、リストは\n"
#~ "暗黙的に2囘走査されます。一つは適切なインデックスを\n"
#~ "計算するために、そしてもう一つは操作を実行するためです。\n"
#~ "\n"
#~ "\n"
#~ "Erlangの標準ライブラリに殆どの関数は委譲することを決定\n"
#~ "しましたが、最初の引数として処理対象(この場合、\n"
#~ "リストです)を渡すというElixirの習慣に従っています。\n"
#~ "\n"
#~ "## Char lists\n"
#~ "\n"
#~ "もしリストが非負整数で作られたなら、それはchar listとも\n"
#~ "呼ばれることもあります。Elixirはchar listを定義する\n"
#~ "為にシングルクォーテーションを使います:\n"
#~ "\n"
#~ "    iex> 'héllo'\n"
#~ "    [104, 233, 108, 108, 111]\n"
#~ "\n"
#~ "具体的には、char listはASCII-printableコードポイントのみを\n"
#~ "含むなら、シングルクォーテーションでプリントバックされる\n"
#~ "でしょう:\n"
#~ "\n"
#~ "    iex> 'abc'\n"
#~ "    'abc'\n"
#~ "\n"
#~ "この振る舞いの背後の理論的根拠はElixir文字列の代りに\n"
#~ "char listとしてテキストを返すErlangライブラリのよりよい\n"
#~ "サポートのためです。そのような関数の一つの例が\n"
#~ "`Application.loaded_applications`です:\n"
#~ "\n"
#~ "    Application.loaded_applications\n"
#~ "    #=>  [{:stdlib, 'ERTS  CXC 138 10', '2.6'},\n"
#~ "          {:compiler, 'ERTS  CXC 138 10', '6.0.1'},\n"
#~ "          {:elixir, 'elixir', '1.0.0'},\n"
#~ "          {:kernel, 'ERTS  CXC 138 10', '4.1'},\n"
#~ "          {:logger, 'logger', '1.0.0'}]\n"
