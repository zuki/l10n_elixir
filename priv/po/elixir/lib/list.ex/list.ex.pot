#. TRANSLATORS: def List.keydelete(list, key, position)
#: lib/list.ex:339 
msgid ""
"Receives a `list` of tuples and deletes the first tuple\n"
"where the item at `position` matches the\n"
"given `key`. Returns the new list.\n"
"\n"
"## Examples\n"
"\n"
"    iex> List.keydelete([a: 1, b: 2], :a, 0)\n"
"    [b: 2]\n"
"\n"
"    iex> List.keydelete([a: 1, b: 2], 2, 1)\n"
"    [a: 1]\n"
"\n"
"    iex> List.keydelete([a: 1, b: 2], :c, 0)\n"
"    [a: 1, b: 2]\n"
"\n"
msgstr ""
#. TRANSLATORS: def List.foldr(list, acc, function)
#: lib/list.ex:188 
msgid ""
"Folds (reduces) the given list from the right with\n"
"a function. Requires an accumulator.\n"
"\n"
"## Examples\n"
"\n"
"    iex> List.foldr([1, 2, 3, 4], 0, fn(x, acc) -> x - acc end)\n"
"    -2\n"
"\n"
msgstr ""
#. TRANSLATORS: def List.keytake(list, key, position)
#: lib/list.ex:361 
msgid ""
"Receives a `list` of tuples and returns the first tuple\n"
"where the element at `position` in the tuple matches the\n"
"given `key`, as well as the `list` without found tuple.\n"
"\n"
"If such a tuple is not found, `nil` will be returned.\n"
"\n"
"## Examples\n"
"\n"
"    iex> List.keytake([a: 1, b: 2], :a, 0)\n"
"    {{:a, 1}, [b: 2]}\n"
"\n"
"    iex> List.keytake([a: 1, b: 2], 2, 1)\n"
"    {{:b, 2}, [a: 1]}\n"
"\n"
"    iex> List.keytake([a: 1, b: 2], :c, 0)\n"
"    nil\n"
"\n"
msgstr ""
#. TRANSLATORS: def List.to_string(list)
#: lib/list.ex:686 
msgid ""
"Converts a list of integers representing codepoints, lists or\n"
"strings into a string.\n"
"\n"
"Notice that this function expects a list of integers representing\n"
"UTF-8 codepoints. If you have a list of bytes, you must instead use\n"
"the [`:binary` module](http://www.erlang.org/doc/man/binary.html).\n"
"\n"
"## Examples\n"
"\n"
"    iex> List.to_string([0x00E6, 0x00DF])\n"
"    \"æß\"\n"
"\n"
"    iex> List.to_string([0x0061, \"bc\"])\n"
"    \"abc\"\n"
"\n"
msgstr ""
#. TRANSLATORS: def List.flatten(list)
#: lib/list.ex:140 
msgid ""
"Flattens the given `list` of nested lists.\n"
"\n"
"## Examples\n"
"\n"
"    iex> List.flatten([1, [[2], 3]])\n"
"    [1, 2, 3]\n"
"\n"
msgstr ""
#. TRANSLATORS: def List.duplicate(elem, n)
#: lib/list.ex:123 
msgid ""
"Duplicates the given element `n` times in a list.\n"
"\n"
"## Examples\n"
"\n"
"    iex> List.duplicate(\"hello\", 3)\n"
"    [\"hello\", \"hello\", \"hello\"]\n"
"\n"
"    iex> List.duplicate([1, 2], 2)\n"
"    [[1, 2], [1, 2]]\n"
"\n"
msgstr ""
#. TRANSLATORS: def List.replace_at(list, index, value)
#: lib/list.ex:469 
msgid ""
"Returns a list with a replaced value at the specified `index`.\n"
"\n"
"Negative indices indicate an offset from the end of the `list`.\n"
"If `index` is out of bounds, the original `list` is returned.\n"
"\n"
"## Examples\n"
"\n"
"    iex> List.replace_at([1, 2, 3], 0, 0)\n"
"    [0, 2, 3]\n"
"\n"
"    iex> List.replace_at([1, 2, 3], 10, 0)\n"
"    [1, 2, 3]\n"
"\n"
"    iex> List.replace_at([1, 2, 3], -1, 0)\n"
"    [1, 2, 0]\n"
"\n"
"    iex> List.replace_at([1, 2, 3], -10, 0)\n"
"    [1, 2, 3]\n"
"\n"
msgstr ""
#. TRANSLATORS: def List.to_tuple(list)
#: lib/list.ex:670 
msgid ""
"Converts a list to a tuple.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> List.to_tuple([:share, [:elixir, 163]])\n"
"    {:share, [:elixir, 163]}\n"
"\n"
msgstr ""
#. TRANSLATORS: def List.delete_at(list, index)
#: lib/list.ex:529 
msgid ""
"Produces a new list by removing the value at the specified `index`.\n"
"\n"
"Negative indices indicate an offset from the end of the `list`.\n"
"If `index` is out of bounds, the original `list` is returned.\n"
"\n"
"## Examples\n"
"\n"
"    iex> List.delete_at([1, 2, 3], 0)\n"
"    [2, 3]\n"
"\n"
"    iex> List.delete_at([1, 2, 3], 10)\n"
"    [1, 2, 3]\n"
"\n"
"    iex> List.delete_at([1, 2, 3], -1)\n"
"    [1, 2]\n"
"\n"
msgstr ""
#. TRANSLATORS: def List.insert_at(list, index, value)
#: lib/list.ex:439 
msgid ""
"Returns a list with `value` inserted at the specified `index`.\n"
"\n"
"Note that `index` is capped at the list length. Negative indices\n"
"indicate an offset from the end of the `list`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> List.insert_at([1, 2, 3, 4], 2, 0)\n"
"    [1, 2, 0, 3, 4]\n"
"\n"
"    iex> List.insert_at([1, 2, 3], 10, 0)\n"
"    [1, 2, 3, 0]\n"
"\n"
"    iex> List.insert_at([1, 2, 3], -1, 0)\n"
"    [1, 2, 3, 0]\n"
"\n"
"    iex> List.insert_at([1, 2, 3], -10, 0)\n"
"    [0, 1, 2, 3]\n"
"\n"
msgstr ""
#. TRANSLATORS: def List.to_integer(charlist)
#: lib/list.ex:638 
msgid ""
"Returns an integer whose text representation is `charlist`.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> List.to_integer('123')\n"
"    123\n"
"\n"
msgstr ""
#. TRANSLATORS: def List.to_float(charlist)
#: lib/list.ex:622 
msgid ""
"Returns the float whose text representation is `charlist`.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> List.to_float('2.2017764e+0')\n"
"    2.2017764\n"
"\n"
msgstr ""
#. TRANSLATORS: def List.keysort(list, position)
#: lib/list.ex:301 
msgid ""
"Receives a list of tuples and sorts the items\n"
"at `position` of the tuples. The sort is stable.\n"
"\n"
"## Examples\n"
"\n"
"    iex> List.keysort([a: 5, b: 1, c: 3], 1)\n"
"    [b: 1, c: 3, a: 5]\n"
"\n"
"    iex> List.keysort([a: 5, c: 1, b: 3], 0)\n"
"    [a: 5, b: 3, c: 1]\n"
"\n"
msgstr ""
#. TRANSLATORS: def List.flatten(list, tail)
#: lib/list.ex:154 
msgid ""
"Flattens the given `list` of nested lists.\n"
"The list `tail` will be added at the end of\n"
"the flattened list.\n"
"\n"
"## Examples\n"
"\n"
"    iex> List.flatten([1, [[2], 3]], [4, 5])\n"
"    [1, 2, 3, 4, 5]\n"
"\n"
msgstr ""
#. TRANSLATORS: def List.first(list)
#: lib/list.ex:203 
msgid ""
"Returns the first element in `list` or `nil` if `list` is empty.\n"
"\n"
"## Examples\n"
"\n"
"    iex> List.first([])\n"
"    nil\n"
"\n"
"    iex> List.first([1])\n"
"    1\n"
"\n"
"    iex> List.first([1, 2, 3])\n"
"    1\n"
"\n"
msgstr ""
#. TRANSLATORS: def List.last(list)
#: lib/list.ex:222 
msgid ""
"Returns the last element in `list` or `nil` if `list` is empty.\n"
"\n"
"## Examples\n"
"\n"
"    iex> List.last([])\n"
"    nil\n"
"\n"
"    iex> List.last([1])\n"
"    1\n"
"\n"
"    iex> List.last([1, 2, 3])\n"
"    3\n"
"\n"
msgstr ""
#. TRANSLATORS: def List.wrap(list)
#: lib/list.ex:388 
msgid ""
"Wraps the argument in a list.\n"
"\n"
"If the argument is already a list, returns the list.\n"
"If the argument is `nil`, returns an empty list.\n"
"\n"
"## Examples\n"
"\n"
"    iex> List.wrap(\"hello\")\n"
"    [\"hello\"]\n"
"\n"
"    iex> List.wrap([1, 2, 3])\n"
"    [1, 2, 3]\n"
"\n"
"    iex> List.wrap(nil)\n"
"    []\n"
"\n"
msgstr ""
#. TRANSLATORS: def List.update_at(list, index, fun)
#: lib/list.ex:499 
msgid ""
"Returns a list with an updated value at the specified `index`.\n"
"\n"
"Negative indices indicate an offset from the end of the `list`.\n"
"If `index` is out of bounds, the original `list` is returned.\n"
"\n"
"## Examples\n"
"\n"
"    iex> List.update_at([1, 2, 3], 0, &(&1 + 10))\n"
"    [11, 2, 3]\n"
"\n"
"    iex> List.update_at([1, 2, 3], 10, &(&1 + 10))\n"
"    [1, 2, 3]\n"
"\n"
"    iex> List.update_at([1, 2, 3], -1, &(&1 + 10))\n"
"    [1, 2, 13]\n"
"\n"
"    iex> List.update_at([1, 2, 3], -10, &(&1 + 10))\n"
"    [1, 2, 3]\n"
"\n"
msgstr ""
#. TRANSLATORS: def List.keyfind(list, key, position, default \\ nil)
#: lib/list.ex:242 
msgid ""
"Receives a list of tuples and returns the first tuple\n"
"where the item at `position` in the tuple matches the\n"
"given `key`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> List.keyfind([a: 1, b: 2], :a, 0)\n"
"    {:a, 1}\n"
"\n"
"    iex> List.keyfind([a: 1, b: 2], 2, 1)\n"
"    {:b, 2}\n"
"\n"
"    iex> List.keyfind([a: 1, b: 2], :c, 0)\n"
"    nil\n"
"\n"
msgstr ""
#. TRANSLATORS: def List.keystore(list, key, position, new_tuple)
#: lib/list.ex:319 
msgid ""
"Receives a `list` of tuples and replaces the item\n"
"identified by `key` at `position`.\n"
"\n"
"If the item does not exist, it is added to the end of the `list`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> List.keystore([a: 1, b: 2], :a, 0, {:a, 3})\n"
"    [a: 3, b: 2]\n"
"\n"
"    iex> List.keystore([a: 1, b: 2], :c, 0, {:c, 3})\n"
"    [a: 1, b: 2, c: 3]\n"
"\n"
msgstr ""
#. TRANSLATORS: Elixir.List Summary
#: lib/list.ex:2 
msgid ""
"Functions that work on (linked) lists.\n"
"\n"
"Lists in Elixir are specified between square brackets:\n"
"\n"
"    iex> [1, \"two\", 3, :four]\n"
"    [1, \"two\", 3, :four]\n"
"\n"
"Two lists can be concatenated and subtracted using the\n"
"`Kernel.++/2` and `Kernel.--/2` operators:\n"
"\n"
"    iex> [1, 2, 3] ++ [4, 5, 6]\n"
"    [1, 2, 3, 4, 5, 6]\n"
"    iex> [1, true, 2, false, 3, true] -- [true, false]\n"
"    [1, 2, 3, true]\n"
"\n"
"Lists in Elixir are effectively linked lists, which means\n"
"they are internally represented in pairs containing the\n"
"head and the tail of a list:\n"
"\n"
"    iex> [head | tail] = [1, 2, 3]\n"
"    iex> head\n"
"    1\n"
"    iex> tail\n"
"    [2, 3]\n"
"\n"
"Similarly, we could write the list `[1, 2, 3]` using only\n"
"such pairs (called cons cells):\n"
"\n"
"    iex> [1 | [2 | [3 | []]]]\n"
"    [1, 2, 3]\n"
"\n"
"Some lists, called improper lists, do not have an empty list as\n"
"the second element in the last cons cell:\n"
"\n"
"    iex> [1 | [2 | [3 | 4]]]\n"
"    [1, 2, 3 | 4]\n"
"\n"
"Although improper lists are generally avoided, they are used in some\n"
"special circumstances like iodata and chardata entities (see the `IO` module).\n"
"\n"
"Due to their cons cell based representation, prepending an element\n"
"to a list is always fast (constant time), while appending becomes\n"
"slower as the list grows in size (linear time):\n"
"\n"
"    iex> list = [1, 2, 3]\n"
"    iex> [0 | list]   # fast\n"
"    [0, 1, 2, 3]\n"
"    iex> list ++ [4]  # slow\n"
"    [1, 2, 3, 4]\n"
"\n"
"The `Kernel` module contains many functions to manipulate lists\n"
"and that are allowed in guards. For example, `Kernel.hd/1` to\n"
"retrieve the head, `Kernel.tl/1` to fetch the tail and\n"
"`Kernel.length/1` for calculating the length. Keep in mind that,\n"
"similar to appending to a list, calculating the length needs to\n"
"traverse the whole list.\n"
"\n"
"## Charlists\n"
"\n"
"If a list is made of non-negative integers, it can also be called\n"
"a charlist. Elixir uses single quotes to define charlists:\n"
"\n"
"    iex> 'héllo'\n"
"    [104, 233, 108, 108, 111]\n"
"\n"
"In particular, charlists may be printed back in single\n"
"quotes if they contain only ASCII-printable codepoints:\n"
"\n"
"    iex> 'abc'\n"
"    'abc'\n"
"\n"
"The rationale behind this behaviour is to better support\n"
"Erlang libraries which may return text as charlists\n"
"instead of Elixir strings. One example of such functions\n"
"is `Application.loaded_applications/0`:\n"
"\n"
"    Application.loaded_applications\n"
"    #=>  [{:stdlib, 'ERTS  CXC 138 10', '2.6'},\n"
"          {:compiler, 'ERTS  CXC 138 10', '6.0.1'},\n"
"          {:elixir, 'elixir', '1.0.0'},\n"
"          {:kernel, 'ERTS  CXC 138 10', '4.1'},\n"
"          {:logger, 'logger', '1.0.0'}]\n"
"\n"
"## List and Enum modules\n"
"\n"
"This module aims to provide operations that are specific\n"
"to lists, like conversion between data types, updates,\n"
"deletions and key lookups (for lists of tuples). For traversing\n"
"lists in general, developers should use the functions in the\n"
"`Enum` module that work across a variety of data types.\n"
"\n"
"In both `Enum` and `List` modules, any kind of index access\n"
"on a list is linear. Negative indexes are also supported but\n"
"they imply the list will be iterated twice, one to calculate\n"
"the proper index and another to perform the operation.\n"
msgstr ""
#. TRANSLATORS: def List.pop_at(list, index, default \\ nil)
#: lib/list.ex:552 
msgid ""
"Returns and removes the value at the specified `index` in the `list`.\n"
"\n"
"Negative indices indicate an offset from the end of the `list`.\n"
"If `index` is out of bounds, the original `list` is returned.\n"
"\n"
"## Examples\n"
"\n"
"    iex> List.pop_at([1, 2, 3], 0)\n"
"    {1, [2, 3]}\n"
"    iex> List.pop_at([1, 2, 3], 5)\n"
"    {nil, [1, 2, 3]}\n"
"    iex> List.pop_at([1, 2, 3], 5, 10)\n"
"    {10, [1, 2, 3]}\n"
"    iex> List.pop_at([1, 2, 3], -1)\n"
"    {3, [1, 2]}\n"
"\n"
msgstr ""
#. TRANSLATORS: def List.keymember?(list, key, position)
#: lib/list.ex:264 
msgid ""
"Receives a list of tuples and returns `true` if there is\n"
"a tuple where the item at `position` in the tuple matches\n"
"the given `key`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> List.keymember?([a: 1, b: 2], :a, 0)\n"
"    true\n"
"\n"
"    iex> List.keymember?([a: 1, b: 2], 2, 1)\n"
"    true\n"
"\n"
"    iex> List.keymember?([a: 1, b: 2], :c, 0)\n"
"    false\n"
"\n"
msgstr ""
#. TRANSLATORS: def List.foldl(list, acc, function)
#: lib/list.ex:170 
msgid ""
"Folds (reduces) the given list from the left with\n"
"a function. Requires an accumulator.\n"
"\n"
"## Examples\n"
"\n"
"    iex> List.foldl([5, 5], 10, fn(x, acc) -> x + acc end)\n"
"    20\n"
"\n"
"    iex> List.foldl([1, 2, 3, 4], 0, fn(x, acc) -> x - acc end)\n"
"    2\n"
"\n"
msgstr ""
#. TRANSLATORS: def List.delete(list, item)
#: lib/list.ex:102 
msgid ""
"Deletes the given `item` from the `list`. Returns a new list without\n"
"the item.\n"
"\n"
"If the `item` occurs more than once in the `list`, just\n"
"the first occurrence is removed.\n"
"\n"
"## Examples\n"
"\n"
"    iex> List.delete([:a, :b, :c], :a)\n"
"    [:b, :c]\n"
"\n"
"    iex> List.delete([:a, :b, :b, :c], :b)\n"
"    [:a, :b, :c]\n"
"\n"
msgstr ""
#. TRANSLATORS: def List.myers_difference(list1, list2)
#: lib/list.ex:734 
msgid ""
"Returns a keyword list that represents an *edit script*.\n"
"\n"
"The algorithm is outlined in the\n"
"\"An O(ND) Difference Algorithm and Its Variations\" paper by E. Myers.\n"
"\n"
"An *edit script* is a keyword list. Each key describes the \"editing action\" to\n"
"take in order to bring `list1` closer to being equal to `list2`; a key can be\n"
"`:eq`, `:ins`, or `:del`. Each value is a sublist of either `list1` or `list2`\n"
"that should be inserted (if the corresponding key `:ins`), deleted (if the\n"
"corresponding key is `:del`), or left alone (if the corresponding key is\n"
"`:eq`) in `list1` in order to be closer to `list2`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> List.myers_difference([1, 4, 2, 3], [1, 2, 3, 4])\n"
"    [eq: [1], del: [4], eq: [2, 3], ins: [4]]\n"
"\n"
msgstr ""
#. TRANSLATORS: def List.zip(list_of_lists)
#: lib/list.ex:419 
msgid ""
"Zips corresponding elements from each list in `list_of_lists`.\n"
"\n"
"The zipping finishes as soon as any list terminates.\n"
"\n"
"## Examples\n"
"\n"
"    iex> List.zip([[1, 2], [3, 4], [5, 6]])\n"
"    [{1, 3, 5}, {2, 4, 6}]\n"
"\n"
"    iex> List.zip([[1, 2], [3], [5, 6]])\n"
"    [{1, 3, 5}]\n"
"\n"
msgstr ""
#. TRANSLATORS: def List.to_existing_atom(charlist)
#: lib/list.ex:598 
msgid ""
"Converts a charlist to an existing atom. Raises an `ArgumentError`\n"
"if the atom does not exist.\n"
"\n"
"Currently Elixir does not support conversions from charlists\n"
"which contains Unicode codepoints greater than 0xFF.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> _ = :my_atom\n"
"    iex> List.to_existing_atom('my_atom')\n"
"    :my_atom\n"
"\n"
"    iex> List.to_existing_atom('this_atom_will_never_exist')\n"
"    ** (ArgumentError) argument error\n"
"\n"
msgstr ""
#. TRANSLATORS: def List.to_atom(charlist)
#: lib/list.ex:579 
msgid ""
"Converts a charlist to an atom.\n"
"\n"
"Currently Elixir does not support conversions from charlists\n"
"which contains Unicode codepoints greater than 0xFF.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> List.to_atom('elixir')\n"
"    :elixir\n"
"\n"
msgstr ""
#. TRANSLATORS: def List.to_integer(charlist, base)
#: lib/list.ex:654 
msgid ""
"Returns an integer whose text representation is `charlist` in base `base`.\n"
"\n"
"Inlined by the compiler.\n"
"\n"
"## Examples\n"
"\n"
"    iex> List.to_integer('3FF', 16)\n"
"    1023\n"
"\n"
msgstr ""
#. TRANSLATORS: def List.keyreplace(list, key, position, new_tuple)
#: lib/list.ex:286 
msgid ""
"Receives a list of tuples and replaces the item\n"
"identified by `key` at `position` if it exists.\n"
"\n"
"## Examples\n"
"\n"
"    iex> List.keyreplace([a: 1, b: 2], :a, 0, {:a, 3})\n"
"    [a: 3, b: 2]\n"
"\n"
msgstr ""
