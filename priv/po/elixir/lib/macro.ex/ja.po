msgid ""
msgstr ""
"Project-Id-Version: l 10n_elixir\n"
"POT-Creation-Date: \n"
"PO-Revision-Date: 2017-01-29 12:15+0900\n"
"Last-Translator: 小田 照敬 <EMAIL@ADDRESS>\n"
"Language-Team: Japanese\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Poedit 1.8.11\n"

#. TRANSLATORS: def Macro.expand(tree, env)
#: lib/macro.ex:1147
msgid ""
"Receives an AST node and expands it until it can no longer\n"
"be expanded.\n"
"\n"
"This function uses `expand_once/2` under the hood. Check\n"
"it out for more information and examples.\n"
msgstr ""
"ASTノードを受け取り、展開できなくなるまで展開します。\n"
"\n"
"この関数は内部で`expand_once/2`を使います。\n"
"詳細と例については`expand_once/2`をチェックしてください。\n"

#. TRANSLATORS: def Macro.postwalk(ast, acc, fun)
#: lib/macro.ex:326
msgid ""
"Performs a depth-first, post-order traversal of quoted expressions\n"
"using an accumulator.\n"
msgstr ""
"アキュムレータを使用してquoteされた式の深さ優先\n"
"帰りがけ順走査を実行します。\n"

#. TRANSLATORS: def Macro.prewalk(ast, acc, fun)
#: lib/macro.ex:309
msgid ""
"Performs a depth-first, pre-order traversal of quoted expressions\n"
"using an accumulator.\n"
msgstr ""
"アキュムレータを使用してquoteされた式の深さ優先\n"
"行きがけ順走査を実行します。\n"

#. TRANSLATORS: def Macro.validate(expr)
#: lib/macro.ex:400
msgid ""
"Validates the given expressions are valid quoted expressions.\n"
"\n"
"Checks the `t:Macro.t/0` for the specification of a valid\n"
"quoted expression.\n"
"\n"
"It returns `:ok` if the expression is valid. Otherwise it returns a tuple in "
"the form of\n"
"`{:error, remainder}` where `remainder` is the invalid part of the quoted "
"expression.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Macro.validate({:two_element, :tuple})\n"
"    :ok\n"
"    iex> Macro.validate({:three, :element, :tuple})\n"
"    {:error, {:three, :element, :tuple}}\n"
"\n"
"    iex> Macro.validate([1, 2, 3])\n"
"    :ok\n"
"    iex> Macro.validate([1, 2, 3, {4}])\n"
"    {:error, {4}}\n"
"\n"
msgstr ""
"指定された式が妥当なquoted式であることを検証します。\n"
"\n"
"妥当なquoted式の仕様については、`type:Macro.t`をチェック\n"
"してください。\n"
"\n"
"式が妥当な場合は`:ok`を返します。そうでなければ、`{:error, remainder}`形式"
"の\n"
"タプルを返します。ここで、`remainder`はquoted式の不正な部分です。\n"
"\n"
"## 例\n"
"\n"
"    iex> Macro.validate({:two_element, :tuple})\n"
"    :ok\n"
"    iex> Macro.validate({:three, :element, :tuple})\n"
"    {:error, {:three, :element, :tuple}}\n"
"\n"
"    iex> Macro.validate([1, 2, 3])\n"
"    :ok\n"
"    iex> Macro.validate([1, 2, 3, {4}])\n"
"    {:error, {4}}\n"
"\n"

#. TRANSLATORS: def Macro.unescape_string(chars, map)
#: lib/macro.ex:479
msgid ""
"Unescapes the given chars according to the map given.\n"
"\n"
"Check `unescape_string/1` if you want to use the same map\n"
"as Elixir single- and double-quoted strings.\n"
"\n"
"## Map\n"
"\n"
"The map must be a function. The function receives an integer\n"
"representing the codepoint of the character it wants to unescape.\n"
"Here is the default mapping function implemented by Elixir:\n"
"\n"
"    def unescape_map(?0), do: ?0\n"
"    def unescape_map(?a), do: ?\\a\n"
"    def unescape_map(?b), do: ?\\b\n"
"    def unescape_map(?d), do: ?\\d\n"
"    def unescape_map(?e), do: ?\\e\n"
"    def unescape_map(?f), do: ?\\f\n"
"    def unescape_map(?n), do: ?\\n\n"
"    def unescape_map(?r), do: ?\\r\n"
"    def unescape_map(?s), do: ?\\s\n"
"    def unescape_map(?t), do: ?\\t\n"
"    def unescape_map(?v), do: ?\\v\n"
"    def unescape_map(?x), do: true\n"
"    def unescape_map(?u), do: true\n"
"    def unescape_map(e),  do: e\n"
"\n"
"If the `unescape_map/1` function returns `false`. The char is\n"
"not escaped and the backslash is kept in the string.\n"
"\n"
"Hexadecimals and Unicode codepoints will be escaped if the map\n"
"function returns `true` for `?x`. Unicode codepoints if the map\n"
"function returns `true` for `?u`.\n"
"\n"
"## Examples\n"
"\n"
"Using the `unescape_map/1` function defined above is easy:\n"
"\n"
"    Macro.unescape_string \"example\\\\n\", &unescape_map(&1)\n"
"\n"
msgstr ""
"指定された文字を指定されたマップに従ってアンエスケープします。\n"
"\n"
"Elixirが単一引用符と二重引用符の文字列で使用しているものと同じマップを\n"
"使いたい場合、`unescape_string/1`をチェックしてください。\n"
"\n"
"## マップ\n"
"\n"
"マップは関数でなければなりません。関数はアンエスケープしたい\n"
"文字のコードポイントを表す整数を受け取ります。\n"
"以下は、Elixirで実装されているデフォルトのマッピング関数です:\n"
"\n"
"    def unescape_map(?0), do: ?0\n"
"    def unescape_map(?a), do: ?\a\n"
"    def unescape_map(?b), do: ?\\b\n"
"    def unescape_map(?d), do: ?\\d\n"
"    def unescape_map(?e), do: ?\\e\n"
"    def unescape_map(?f), do: ?\\f\n"
"    def unescape_map(?n), do: ?\\n\n"
"    def unescape_map(?r), do: ?\\r\n"
"    def unescape_map(?s), do: ?\\s\n"
"    def unescape_map(?t), do: ?\\t\n"
"    def unescape_map(?v), do: ?\\v\n"
"    def unescape_map(?x), do: true\n"
"    def unescape_map(?u), do: true\n"
"    def unescape_map(e),  do: e\n"
"\n"
"`unescape_map`関数が`false`を帰す場合は、その文字はエスケープされず、\n"
"バックスラッシュは文字列中に保持されます。\n"
"\n"
"16進数は、マップ関数が`?x`に対して`true`を返した場合、エスケープされます。\n"
"Unicodeコードポイントは、マップ関数が`?u`に対して`true`を返した場合、\n"
"エスケープされます。\n"
"\n"
"## 例\n"
"\n"
"上で定義された`unescape_map`関数を使用することは簡単です:\n"
"\n"
"    Macro.unescape_string \"example\\\\n\", &unescape_map(&1)\n"
"\n"

#. TRANSLATORS: def Macro.var(var, context)
#: lib/macro.ex:226
msgid ""
"Generates an AST node representing the variable given\n"
"by the atoms `var` and `context`.\n"
"\n"
"## Examples\n"
"\n"
"In order to build a variable, a context is expected.\n"
"Most of the times, in order to preserve hygiene, the\n"
"context must be `__MODULE__/0`:\n"
"\n"
"    iex> Macro.var(:foo, __MODULE__)\n"
"    {:foo, [], __MODULE__}\n"
"\n"
"However, if there is a need to access the user variable,\n"
"nil can be given:\n"
"\n"
"    iex> Macro.var(:foo, nil)\n"
"    {:foo, [], nil}\n"
"\n"
msgstr ""
"アトム`var`と`context`によって与えれた変数を表すASTノードを\n"
"生成します。\n"
"\n"
"## 例\n"
"\n"
"変数を作成するためには、コンテキストが必要です。\n"
"ほとんどの場合、健全性を維持するために、\n"
"コンテキストは`__MODULE__/0`でなくてはなりません:\n"
"\n"
"    iex> Macro.var(:foo, __MODULE__)\n"
"    {:foo, [], __MODULE__}\n"
"\n"
"しかし、ユーザ変数にアクセスする必要がある場合は、\n"
"nilを与えることができます:\n"
"\n"
"    iex> Macro.var(:foo, nil)\n"
"    {:foo, [], nil}\n"
"\n"

#. TRANSLATORS: def Macro.prewalk(ast, fun)
#: lib/macro.ex:301
msgid "Performs a depth-first, pre-order traversal of quoted expressions.\n"
msgstr "quoteされた式の深さ優先行きがけ順走査を実行します。\n"

#. TRANSLATORS: def Macro.postwalk(ast, fun)
#: lib/macro.ex:318
msgid "Performs a depth-first, post-order traversal of quoted expressions.\n"
msgstr "quoteされた式の深さ優先帰りがけ順走査を実行します。\n"

#. TRANSLATORS: @type t
#: lib/macro.ex:58
msgid "Abstract Syntax Tree (AST)"
msgstr "抽象構文木(AST)"

#. TRANSLATORS: def Macro.unescape_tokens(tokens)
#: lib/macro.ex:525
msgid ""
"Unescapes the given tokens according to the default map.\n"
"\n"
"Check `unescape_string/1` and `unescape_string/2` for more\n"
"information about unescaping.\n"
"\n"
"Only tokens that are binaries are unescaped, all others are\n"
"ignored. This function is useful when implementing your own\n"
"sigils. Check the implementation of `Kernel.sigil_s/2`\n"
"for examples.\n"
msgstr ""
"指定されたトークンをデフォルトマップに従ってアンエスケープします。\n"
"\n"
"アンエスケープについての詳しい情報は、`unescape_tokens/1`と\n"
"`unescape_string/2`をチェックしてください。\n"
"\n"
"バイナリのトークンだけがアンエスケープされます、他の全ては\n"
"無視されます。この関数は独自のシジルを実装するときに便利です。\n"
"例については`Kernel.sigil_s/2`の実装をチェック\n"
"してください。\n"

#. TRANSLATORS: def Macro.to_string(tree, fun \\ fn _ast, string -> string end)
#: lib/macro.ex:551
msgid ""
"Converts the given expression to a binary.\n"
"\n"
"The given `fun` is called for every node in the AST with two arguments: the\n"
"AST of the node being printed and the string representation of that same\n"
"node. The return value of this function is used as the final string\n"
"representation for that AST node.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Macro.to_string(quote(do: foo.bar(1, 2, 3)))\n"
"    \"foo.bar(1, 2, 3)\"\n"
"\n"
"    iex> Macro.to_string(quote(do: 1 + 2), fn\n"
"    ...>   1, _string -> \"one\"\n"
"    ...>   2, _string -> \"two\"\n"
"    ...>   _ast, string -> string\n"
"    ...> end)\n"
"    \"one + two\"\n"
"\n"
msgstr ""
"指定された式をバイナリに変換します。\n"
"\n"
"指定された`fun`は、ASTのノードごとに2つの引数を付けて\n"
"呼び出されます。ここで、第1引数は表示されるべきノードのASTで、\n"
"第2引数は同じノードの文字列表現です。\n"
"この関数の返り値はASTノードの最終的な文字列表現です。\n"
"\n"
"## 例\n"
"\n"
"    iex> Macro.to_string(quote(do: foo.bar(1, 2, 3)))\n"
"    \"foo.bar(1, 2, 3)\"\n"
"\n"
"    iex> Macro.to_string(quote(do: 1 + 2), fn\n"
"    ...>   1, _string -> \"one\"\n"
"    ...>   2, _string -> \"two\"\n"
"    ...>   _ast, string -> string\n"
"    ...> end)\n"
"    \"one + two\"\n"
"\n"

#. TRANSLATORS: def Macro.underscore(atom)
#: lib/macro.ex:1166
msgid ""
"Converts the given atom or binary to underscore format.\n"
"\n"
"If an atom is given, it is assumed to be an Elixir module,\n"
"so it is converted to a binary and then processed.\n"
"\n"
"This function was designed to underscore language identifiers/tokens,\n"
"that's why it belongs to the `Macro` module. Do not use it as a general\n"
"mechanism for underscoring strings as it does not support Unicode or\n"
"characters that are not valid in Elixir identifiers.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Macro.underscore \"FooBar\"\n"
"    \"foo_bar\"\n"
"\n"
"    iex> Macro.underscore \"Foo.Bar\"\n"
"    \"foo/bar\"\n"
"\n"
"    iex> Macro.underscore Foo.Bar\n"
"    \"foo/bar\"\n"
"\n"
"In general, `underscore` can be thought of as the reverse of\n"
"`camelize`, however, in some cases formatting may be lost:\n"
"\n"
"    iex> Macro.underscore \"SAPExample\"\n"
"    \"sap_example\"\n"
"\n"
"    iex> Macro.camelize \"sap_example\"\n"
"    \"SapExample\"\n"
"\n"
"    iex> Macro.camelize \"hello_10\"\n"
"    \"Hello10\"\n"
"\n"
msgstr ""
"指定されたアトムまたはバイナリをアンダースコア形式に変換します。\n"
"\n"
"アトムが指定された場合、Elixirのモジュールとみなされ、\n"
"バイナリに変換された後、処理されます。\n"
"\n"
"この関数は言語の識別子とトークンをアンダースコア化するために設計されていま"
"す。\n"
"`Macro`モジュールに属するのはそのためです。文字列をアンダースコア化するため"
"の\n"
"一般的な機構として使用しないでください。ユニコードやElixir識別子として\n"
"有効ではない文字をサポートしていなからです。\n"
"\n"
"## 例\n"
"\n"
"    iex> Macro.underscore \"FooBar\"\n"
"    \"foo_bar\"\n"
"\n"
"    iex> Macro.underscore \"Foo.Bar\"\n"
"    \"foo/bar\"\n"
"\n"
"    iex> Macro.underscore Foo.Bar\n"
"    \"foo/bar\"\n"
"\n"
"一般に、`undersocre`は`camelize`の逆だと考えることができますが、\n"
"フォーマットが失われることもあります:\n"
"\n"
"    iex> Macro.underscore \"SAPExample\"\n"
"    \"sap_example\"\n"
"\n"
"    iex> Macro.camelize \"sap_example\"\n"
"    \"SapExample\"\n"
"\n"
"    iex> Macro.camelize \"hello_10\"\n"
"    \"Hello10\"\n"
"\n"

#. TRANSLATORS: def Macro.unescape_tokens(tokens, map)
#: lib/macro.ex:541
msgid ""
"Unescapes the given tokens according to the given map.\n"
"\n"
"Check `unescape_tokens/1` and `unescape_string/2` for more information.\n"
msgstr ""
"指定されたトークンを指定されたマップに従ってアンエスケープします。\n"
"\n"
"更なる情報は、`unescape_tokens/1`と`unescape_string/2`をチェックしてくださ"
"い。\n"

#. TRANSLATORS: def Macro.camelize(string)
#: lib/macro.ex:1234
msgid ""
"Converts the given string to CamelCase format.\n"
"\n"
"This function was designed to camelize language identifiers/tokens,\n"
"that's why it belongs to the `Macro` module. Do not use it as a general\n"
"mechanism for camelizing strings as it does not support Unicode or\n"
"characters that are not valid in Elixir identifiers.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Macro.camelize \"foo_bar\"\n"
"    \"FooBar\"\n"
"\n"
msgstr ""
"指定された文字列をCamelCase形式に変換します。\n"
"\n"
"この関数は言語の識別子とトークンをキャメル化するために設計されました。\n"
"`Macro`モジュールに属するのはそのためです。文字列をキャメル化するための\n"
"一般的な機構として使用しないでください。ユニコードやElixir識別子として\n"
"有効ではない文字をサポートしていなからです。\n"
"\n"
"## 例\n"
"\n"
"    iex> Macro.camelize \"foo_bar\"\n"
"    \"FooBar\"\n"
"\n"

#. TRANSLATORS: def Macro.expand_once(ast, env)
#: lib/macro.ex:968
msgid ""
"Receives an AST node and expands it once.\n"
"\n"
"The following contents are expanded:\n"
"\n"
"  * Macros (local or remote)\n"
"  * Aliases are expanded (if possible) and return atoms\n"
"  * Compilation environment macros (`__ENV__/0`, `__MODULE__/0` and "
"`__DIR__/0`)\n"
"  * Module attributes reader (`@foo`)\n"
"\n"
"If the expression cannot be expanded, it returns the expression\n"
"itself. Notice that `expand_once/2` performs the expansion just\n"
"once and it is not recursive. Check `expand/2` for expansion\n"
"until the node can no longer be expanded.\n"
"\n"
"## Examples\n"
"\n"
"In the example below, we have a macro that generates a module\n"
"with a function named `name_length` that returns the length\n"
"of the module name. The value of this function will be calculated\n"
"at compilation time and not at runtime.\n"
"\n"
"Consider the implementation below:\n"
"\n"
"    defmacro defmodule_with_length(name, do: block) do\n"
"      length = length(Atom.to_charlist(name))\n"
"\n"
"      quote do\n"
"        defmodule unquote(name) do\n"
"          def name_length, do: unquote(length)\n"
"          unquote(block)\n"
"        end\n"
"      end\n"
"    end\n"
"\n"
"When invoked like this:\n"
"\n"
"    defmodule_with_length My.Module do\n"
"      def other_function, do: ...\n"
"    end\n"
"\n"
"The compilation will fail because `My.Module` when quoted\n"
"is not an atom, but a syntax tree as follow:\n"
"\n"
"    {:__aliases__, [], [:My, :Module]}\n"
"\n"
"That said, we need to expand the aliases node above to an\n"
"atom, so we can retrieve its length. Expanding the node is\n"
"not straight-forward because we also need to expand the\n"
"caller aliases. For example:\n"
"\n"
"    alias MyHelpers, as: My\n"
"\n"
"    defmodule_with_length My.Module do\n"
"      def other_function, do: ...\n"
"    end\n"
"\n"
"The final module name will be `MyHelpers.Module` and not\n"
"`My.Module`. With `Macro.expand/2`, such aliases are taken\n"
"into consideration. Local and remote macros are also\n"
"expanded. We could rewrite our macro above to use this\n"
"function as:\n"
"\n"
"    defmacro defmodule_with_length(name, do: block) do\n"
"      expanded = Macro.expand(name, __CALLER__)\n"
"      length   = length(Atom.to_charlist(expanded))\n"
"\n"
"      quote do\n"
"        defmodule unquote(name) do\n"
"          def name_length, do: unquote(length)\n"
"          unquote(block)\n"
"        end\n"
"      end\n"
"    end\n"
"\n"
msgstr ""
"ASTノードを受け取り、一度だけ展開します。\n"
"\n"
"以下のコンテンツが展開されます:\n"
"\n"
"  * マクロ (ローカルまたはリモート)\n"
"  * エリアスは（可能であれば）展開され、アトムを返します。\n"
"  * コンパイル環境マクロ（`__ENV__/0`, `__MODULE__/0`, `__DIR__/0`）\n"
"  * モジュール属性リーダー(`@foo`)\n"
"\n"
"式が展開できない場合は、式自身を返します。`expand_once/2`は\n"
"展開を一度だけ実行し、再帰的には実行しないことに注意してください。ノードを\n"
"展開できなくなるまで展開するためには`expand/2`をチェックしてください。\n"
"\n"
"## 例\n"
"\n"
"下の例は、モジュール名の長さを返す`name_length`という名前の関数を持つ\n"
"モジュールを生成するマクロです。この関数の値はコンパイル時に計算されます。\n"
"実行時ではありません。\n"
"\n"
"以下の実装を考えてみます:\n"
"\n"
"    defmacro defmodule_with_length(name, do: block) do\n"
"      length = length(Atom.to_charlist(name))\n"
"\n"
"      quote do\n"
"        defmodule unquote(name) do\n"
"          def name_length, do: unquote(length)\n"
"          unquote(block)\n"
"        end\n"
"      end\n"
"    end\n"
"\n"
"次のように実行すると:\n"
"\n"
"    defmodule_with_length My.Module do\n"
"      def other_function, do: ...\n"
"    end\n"
"\n"
"コンパイルは失敗します。`My.Module`はquoteされる際にはアトムではない\n"
"からです。構文ツリーは以下のようになります:\n"
"\n"
"    {:__aliases__, [], [:My, :Module]}\n"
"\n"
"つまり、エイリアスノードをアトムに展開する必要があり、そうすれば\n"
"その長さを取り出すことができます。ノードの拡張は簡単ではありません。\n"
"呼び出し元のエイリアスを展開する必要があるからです。\n"
"たとえば:\n"
"\n"
"    alias MyHelpers, as: My\n"
"\n"
"    defmodule_with_length My.Module do\n"
"      def other_function, do: ...\n"
"    end\n"
"\n"
"最終的なモジュール名は`My.Module`ではなく`MyHelpers.Module`に\n"
"なります。`Macro.expand/2`によりエイリアスが考慮されます。\n"
"ローカルとリモートのマクロも展開されます。この関数を使用して\n"
"上のマクロを書き直すことができるでしょう:\n"
"\n"
"    defmacro defmodule_with_length(name, do: block) do\n"
"      expanded = Macro.expand(name, __CALLER__)\n"
"      length   = length(Atom.to_charlist(expanded))\n"
"\n"
"      quote do\n"
"        defmodule unquote(name) do\n"
"          def name_length, do: unquote(length)\n"
"          unquote(block)\n"
"        end\n"
"      end\n"
"    end\n"
"\n"

#. TRANSLATORS: Elixir.Macro Summary
#: lib/macro.ex:4
msgid ""
"Conveniences for working with macros.\n"
"\n"
"## Custom Sigils\n"
"\n"
"To create a custom sigil, define a function with the name\n"
"`sigil_{identifier}` that takes two arguments. The first argument will be\n"
"the string, the second will be a charlist containing any modifiers. If the\n"
"sigil is lower case (such as `sigil_x`) then the string argument will allow\n"
"interpolation. If the sigil is upper case (such as `sigil_X`) then the "
"string\n"
"will not be interpolated.\n"
"\n"
"Valid modifiers include only lower and upper case letters. Other characters\n"
"will cause a syntax error.\n"
"\n"
"The module containing the custom sigil must be imported before the sigil\n"
"syntax can be used.\n"
"\n"
"### Examples\n"
"\n"
"    defmodule MySigils do\n"
"      defmacro sigil_x(term, [?r]) do\n"
"        quote do\n"
"          unquote(term) |> String.reverse()\n"
"        end\n"
"      end\n"
"      defmacro sigil_x(term, _modifiers) do\n"
"        term\n"
"      end\n"
"      defmacro sigil_X(term, [?r]) do\n"
"        quote do\n"
"          unquote(term) |> String.reverse()\n"
"        end\n"
"      end\n"
"      defmacro sigil_X(term, _modifiers) do\n"
"        term\n"
"      end\n"
"    end\n"
"\n"
"    import MySigils\n"
"\n"
"    ~x(with #{\"inter\" <> \"polation\"})\n"
"    #=>\"with interpolation\"\n"
"\n"
"    ~x(with #{\"inter\" <> \"polation\"})r\n"
"    #=>\"noitalopretni htiw\"\n"
"\n"
"    ~X(without #{\"interpolation\"})\n"
"    #=>\"without \\#{\"interpolation\"}\"\n"
"\n"
"    ~X(without #{\"interpolation\"})r\n"
"    #=>\"}\\\"noitalopretni\\\"{# tuohtiw\"\n"
msgstr ""
"マクロ関連の便利関数です。\n"
"\n"
"## カスタムシジル\n"
"\n"
"カスタムシジルを作るには、`sigil_{identifier}`という名前の\n"
"2引数の関数を定義してください。第1引数は文字列で、第2引数は\n"
"任意の修飾子を含む文字リストです。\n"
"シジルが(`sigil_x`のような)小文字の場合、文字列引数は埋め込み式が\n"
"展開されます。\n"
"シジルが(`sigil_X`のような)大文字の場合、文字列は展開されません。\n"
"\n"
"有効な修飾子は小文字と大文字だけです。他の文字は構文エラー\n"
"となります。\n"
"\n"
"カスタムシジルを含むモジュールは、シジル構文を使う前に\n"
"インポートされなければなりません。\n"
"\n"
"### 例\n"
"\n"
"    defmodule MySigils do\n"
"      defmacro sigil_x(term, [?r]) do\n"
"        quote do\n"
"          unquote(term) |> String.reverse()\n"
"        end\n"
"      end\n"
"      defmacro sigil_x(term, _modifiers) do\n"
"        term\n"
"      end\n"
"      defmacro sigil_X(term, [?r]) do\n"
"        quote do\n"
"          unquote(term) |> String.reverse()\n"
"        end\n"
"      end\n"
"      defmacro sigil_X(term, _modifiers) do\n"
"        term\n"
"      end\n"
"    end\n"
"\n"
"    import MySigils\n"
"\n"
"    ~x(with #{\"inter\" <> \"polation\"})\n"
"    #=>\"with interpolation\"\n"
"\n"
"    ~x(with #{\"inter\" <> \"polation\"})r\n"
"    #=>\"noitalopretni htiw\"\n"
"\n"
"    ~X(without #{\"interpolation\"})\n"
"    #=>\"without \\#{\"interpolation\"}\"\n"
"\n"
"    ~X(without #{\"interpolation\"})r\n"
"    #=>\"}\\\"noitalopretni\\\"{# tuohtiw\"\n"

#. TRANSLATORS: def Macro.unpipe(expr)
#: lib/macro.ex:101
msgid ""
"Breaks a pipeline expression into a list.\n"
"\n"
"The AST for a pipeline (a sequence of applications of `|>`) is similar to "
"the\n"
"AST of a sequence of binary operators or function applications: the top-"
"level\n"
"expression is the right-most `:|>` (which is the last one to be executed), "
"and\n"
"its left-hand and right-hand sides are its arguments:\n"
"\n"
"    quote do: 100 |> div(5) |> div(2)\n"
"    #=> {:|>, _, [arg1, arg2]}\n"
"\n"
"In the example above, the `|>` pipe is the right-most pipe; `arg1` is the "
"AST\n"
"for `100 |> div(5)`, and `arg2` is the AST for `div(2)`.\n"
"\n"
"It's often useful to have the AST for such a pipeline as a list of function\n"
"applications. This function does exactly that:\n"
"\n"
"    Macro.unpipe(quote do: 100 |> div(5) |> div(2))\n"
"    #=> [{100, 0}, {{:div, [], [5]}, 0}, {{:div, [], [2]}, 0}]\n"
"\n"
"We get a list that follows the pipeline directly: first the `100`, then the\n"
"`div(5)` (more precisely, its AST), then `div(2)`. The `0` as the second\n"
"element of the tuples is the position of the previous element in the "
"pipeline\n"
"inside the current function application: `{{:div, [], [5]}, 0}` means that "
"the\n"
"previous element (`100`) will be inserted as the 0th (first) argument to "
"the\n"
"`div/2` function, so that the AST for that function will become `{:div, [],\n"
"[100, 5]}` (`div(100, 5)`).\n"
msgstr ""
"パイプライン式をリストに分解します。\n"
"\n"
"パイプライン（`|>`適用のシーケンス）のASTは、2項演算子または\n"
"関数適用のシーケンスやASTに似ています:トップレベルの式は最も\n"
"右の`:>`(最後に実行されるパイプ演算子)で、その左辺と右辺が引数です:\n"
"\n"
"    quote do: 100 |> div(5) |> div(2)\n"
"    #=> {:|>, _, [arg1, arg2]}\n"
"\n"
"上の例では、`|>`パイプは最も右のパイプです; `arg1`は`100 |>div(5)`\n"
"のASTで、`arg2`は`div(2)`のASTです。\n"
"\n"
"そのようなパイプラインのASTを関数適用のリストとして持つ\n"
"ことはしばしば役に立ちます。この関数は正にそれをします:\n"
"\n"
"    Macro.unpipe(quote do: 100 |> div(5) |> div(2))\n"
"    #=> [{100, 0}, {{:div, [], [5]}, 0}, {{:div, [], [2]}, 0}]\n"
"\n"
"直接パイプラインをたどるリストを得ました: 最初が`100`、次に\n"
"`div(5)`(より正確には、そのAST)、次に`div(2)`。各タプル\n"
"の二番目の要素である`0`は、現在の関数適用のパイプライン中での\n"
"前の要素の位置です: `{{:div, [], [5]}, 0}`は、その前の要素\n"
"(`100`)が、`div/2`関数の第0(最初の)引数として挿入されることを\n"
"意味し、そのため、その関数のASTは`{:div, [], [100,5]}`\n"
"(`div(100, 5)`)になります。\n"

#. TRANSLATORS: def Macro.unescape_string(chars)
#: lib/macro.ex:450
msgid ""
"Unescapes the given chars.\n"
"\n"
"This is the unescaping behaviour used by default in Elixir\n"
"single- and double-quoted strings. Check `unescape_string/2`\n"
"for information on how to customize the escaping map.\n"
"\n"
"In this setup, Elixir will escape the following: `\\0`, `\\a`, `\\b`,\n"
"`\\d`, `\\e`, `\\f`, `\\n`, `\\r`, `\\s`, `\\t` and `\\v`. Bytes can be\n"
"given as hexadecimals via `\\xNN` and Unicode Codepoints as\n"
"`\\uNNNN` escapes.\n"
"\n"
"This function is commonly used on sigil implementations\n"
"(like `~r`, `~s` and others) which receive a raw, unescaped\n"
"string.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Macro.unescape_string(\"example\\\\n\")\n"
"    \"example\\n\"\n"
"\n"
"In the example above, we pass a string with `\\n` escaped\n"
"and return a version with it unescaped.\n"
msgstr ""
"指定された文字をアンエスケープします。\n"
"\n"
"このアンエスケープは、Elixirの単一引用符と二重引用符の文字列で使われている\n"
"デフォルトの振舞いです。エスケープマップをカスタマイズする方法についての\n"
"情報は`unescape_string/2`をチェックしてください。\n"
"\n"
"ここでの設定では、Elixirは次をエスケープします: `\\0`,\n"
"`\a`, `\\b`, `\\d`, `\\e`, `\\f`, `\\n`, `\\r`, `\\s`, `\\t`, `\\v`。\n"
"バイトは16進数は`\\xNN`で、Unicodeコードポイントは`\\uNNNN`で\n"
"指定することもできます。\n"
"\n"
"この関数は通常、エスケープされていないraw文字列を受け取る\n"
"（`~r`や`~s`などの）シジルの実装で使用されます。\n"
"\n"
"## 例\n"
"\n"
"    iex> Macro.unescape_string(\"example\\\\n\")\n"
"    \"example\\n\"\n"
"\n"
"上の例では、エスケープされた`\\n`を持つ文字列を渡し、\n"
"アンエスケープされたバージョンを返しています。\n"

#. TRANSLATORS: def Macro.update_meta(quoted, fun)
#: lib/macro.ex:200
msgid ""
"Applies the given function to the node metadata if it contains one.\n"
"\n"
"This is often useful when used with `Macro.prewalk/2` to remove\n"
"information like lines and hygienic counters from the expression\n"
"for either storage or comparison.\n"
"\n"
"## Examples\n"
"\n"
"    iex> quoted = quote line: 10, do: sample()\n"
"    {:sample, [line: 10], []}\n"
"    iex> Macro.update_meta(quoted, &Keyword.delete(&1, :line))\n"
"    {:sample, [], []}\n"
"\n"
msgstr ""
"ノードがメタデータを含んでいる場合、指定された関数をノードのメタデータに\n"
"適用します。\n"
"\n"
"これは`Macro.prewalk/2`と共に使用して、保管または比較の目的で、\n"
"式から行番号や健全性カウンタなどの情報を削除するのに\n"
"便利です。\n"
"\n"
"## 例\n"
"\n"
"    iex> quoted = quote line: 10, do: sample()\n"
"    {:sample, [line: 10], []}\n"
"    iex> Macro.update_meta(quoted, &Keyword.delete(&1, :line))\n"
"    {:sample, [], []}\n"
"\n"

#. TRANSLATORS: def Macro.escape(expr, opts \\ [])
#: lib/macro.ex:374
msgid ""
"Recursively escapes a value so it can be inserted\n"
"into a syntax tree.\n"
"\n"
"One may pass `unquote: true` to `escape/2`\n"
"which leaves `unquote/1` statements unescaped, effectively\n"
"unquoting the contents on escape.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Macro.escape(:foo)\n"
"    :foo\n"
"\n"
"    iex> Macro.escape({:a, :b, :c})\n"
"    {:{}, [], [:a, :b, :c]}\n"
"\n"
"    iex> Macro.escape({:unquote, [], [1]}, unquote: true)\n"
"    1\n"
"\n"
msgstr ""
"構文ツリーに挿入できるように値を再帰的に\n"
"エスケープします。\n"
"\n"
"`unquote: true`を`escape/2`に渡すと、`unquote/1`文を\n"
"エスケープしません。これによりエスケースにおいてコンテンツを\n"
"効率的にアンコートできます。\n"
"\n"
"## 例\n"
"\n"
"    iex> Macro.escape(:foo)\n"
"    :foo\n"
"\n"
"    iex> Macro.escape({:a, :b, :c})\n"
"    {:{}, [], [:a, :b, :c]}\n"
"\n"
"    iex> Macro.escape({:unquote, [], [1]}, unquote: true)\n"
"    1\n"
"\n"

#. TRANSLATORS: def Macro.pipe(expr, call_args, position)
#: lib/macro.ex:142
msgid "Pipes `expr` into the `call_args` at the given `position`.\n"
msgstr "`expr`を`call_args`の指定された`position`に継ぎます。\n"

#. TRANSLATORS: def Macro.decompose_call(ast)
#: lib/macro.ex:335
msgid ""
"Decomposes a local or remote call into its remote part (when provided),\n"
"function name and argument list.\n"
"\n"
"Returns `:error` when an invalid call syntax is provided.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Macro.decompose_call(quote(do: foo))\n"
"    {:foo, []}\n"
"\n"
"    iex> Macro.decompose_call(quote(do: foo()))\n"
"    {:foo, []}\n"
"\n"
"    iex> Macro.decompose_call(quote(do: foo(1, 2, 3)))\n"
"    {:foo, [1, 2, 3]}\n"
"\n"
"    iex> Macro.decompose_call(quote(do: Elixir.M.foo(1, 2, 3)))\n"
"    {{:__aliases__, [], [:Elixir, :M]}, :foo, [1, 2, 3]}\n"
"\n"
"    iex> Macro.decompose_call(quote(do: 42))\n"
"    :error\n"
"\n"
msgstr ""
"ローカル呼び出しまたはリモート呼び出しを、リモートパート(もしあれば)と\n"
"関数名、引数リストに分解します。\n"
"\n"
"無効な呼び出し構文の場合、`:error`を返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Macro.decompose_call(quote(do: foo))\n"
"    {:foo, []}\n"
"\n"
"    iex> Macro.decompose_call(quote(do: foo()))\n"
"    {:foo, []}\n"
"\n"
"    iex> Macro.decompose_call(quote(do: foo(1, 2, 3)))\n"
"    {:foo, [1, 2, 3]}\n"
"\n"
"    iex> Macro.decompose_call(quote(do: Elixir.M.foo(1, 2, 3)))\n"
"    {{:__aliases__, [], [:Elixir, :M]}, :foo, [1, 2, 3]}\n"
"\n"
"    iex> Macro.decompose_call(quote(do: 42))\n"
"    :error\n"
"\n"

#. TRANSLATORS: def Macro.traverse(ast, acc, pre, post)
#: lib/macro.ex:251
msgid ""
"Performs a depth-first traversal of quoted expressions\n"
"using an accumulator.\n"
msgstr ""
"アキュムレータを使用してquoteされた式の深さ優先\n"
"走査を実行します。\n"

#~ msgid ""
#~ "Converts the given expression to a binary.\n"
#~ "\n"
#~ "## Examples\n"
#~ "\n"
#~ "    iex> Macro.to_string(quote(do: foo.bar(1, 2, 3)))\n"
#~ "    \"foo.bar(1, 2, 3)\"\n"
#~ "\n"
#~ msgstr ""
#~ "与えられた式をバイナリに変換します。\n"
#~ "\n"
#~ "## Examples\n"
#~ "\n"
#~ "    iex> Macro.to_string(quote(do: foo.bar(1, 2, 3)))\n"
#~ "    \"foo.bar(1, 2, 3)\"\n"
#~ "\n"

#~ msgid ""
#~ "Converts the given string to CamelCase format.\n"
#~ "\n"
#~ "## Examples\n"
#~ "\n"
#~ "    iex> Macro.camelize \"foo_bar\"\n"
#~ "    \"FooBar\"\n"
#~ "\n"
#~ msgstr ""
#~ "与えられた文字列をCamelCaseフォーマットに変換します。\n"
#~ "\n"
#~ "## Examples\n"
#~ "\n"
#~ "    iex> Macro.camelize \"foo_bar\"\n"
#~ "    \"FooBar\"\n"
#~ "\n"

#~ msgid ""
#~ "Breaks a pipeline expression into a list.\n"
#~ "\n"
#~ "Raises if the pipeline is ill-formed.\n"
#~ msgstr ""
#~ "パイプライン式をリストにします。\n"
#~ "\n"
#~ "パイプラインが不適格なら、エラーを上げます。\n"

#~ msgid ""
#~ "Validates the given expressions are valid quoted expressions.\n"
#~ "\n"
#~ "Check the `type:Macro.t` for the specification of a valid\n"
#~ "quoted expression.\n"
#~ msgstr ""
#~ "与えられた式がquoteされた式として正しいか検証します。\n"
#~ "\n"
#~ "正しいquoteされた式の仕様については`type:Macro.t`をチェック\n"
#~ "してください。\n"

#~ msgid ""
#~ "Conveniences for working with macros.\n"
#~ "\n"
#~ "## Custom Sigils\n"
#~ "\n"
#~ "To create a custom sigil, define a function with the name\n"
#~ "`sigil_{identifier}` that takes two arguments. The first argument will "
#~ "be\n"
#~ "the interpolated string, the second will be a char list containing any\n"
#~ "modifiers.\n"
#~ "\n"
#~ "Valid modifiers include only lower and upper case letters. Other "
#~ "characters\n"
#~ "will cause a syntax error.\n"
#~ "\n"
#~ "The module containing the custom sigil must be imported before the sigil\n"
#~ "syntax can be used.\n"
#~ msgstr ""
#~ "マクロで働くための便利なものです。\n"
#~ "\n"
#~ "## Custom Sigils\n"
#~ "\n"
#~ "カスタムsigilを作るために、`sigil_{identifier}`という\n"
#~ "名前の2引数の関数を定義してください。\n"
#~ "最初の引数は展開される文字列で、二つめは文字の\n"
#~ "リストで構成される任意のmodifier(修飾子)です。\n"
#~ "\n"
#~ "有効なmodifierは小文字と大文字だけです。他の文字は\n"
#~ "シンタックスエラーとなります。\n"
#~ "\n"
#~ "カスタムsigilを含むモジュールは、そのsigilシンタックスが\n"
#~ "使われる前にimportされなければなりません。\n"

#~ msgid "Expr node (remaining ones are literals)"
#~ msgstr "Exprノード(残りの物はリテラルです)"

#~ msgid "Conveniences for working with macros.\n"
#~ msgstr "マクロで働くための便利なものです。\n"
