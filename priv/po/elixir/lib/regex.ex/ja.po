msgid ""
msgstr ""
"Project-Id-Version: l 10n_elixir\n"
"PO-Revision-Date: 2017-03-25 11:46+0900\n"
"Last-Translator: 小田 照敬 <EMAIL@ADDRESS>\n"
"Language-Team: Japanese\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"POT-Creation-Date: \n"
"X-Generator: Poedit 1.8.12\n"

#. TRANSLATORS: def Regex.scan(regex, string, options \\ [])
#: lib/regex.ex:293
msgid ""
"Same as `run/3`, but scans the target several times collecting all\n"
"matches of the regular expression.\n"
"\n"
"A list of lists is returned, where each entry in the primary list represents "
"a\n"
"match and each entry in the secondary list represents the captured "
"contents.\n"
"\n"
"## Options\n"
"\n"
"  * `:return`  - sets to `:index` to return indexes. Defaults to `:binary`.\n"
"  * `:capture` - what to capture in the result. Check the moduledoc for "
"`Regex`\n"
"    to see the possible capture values.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Regex.scan(~r/c(d|e)/, \"abcd abce\")\n"
"    [[\"cd\", \"d\"], [\"ce\", \"e\"]]\n"
"\n"
"    iex> Regex.scan(~r/c(?:d|e)/, \"abcd abce\")\n"
"    [[\"cd\"], [\"ce\"]]\n"
"\n"
"    iex> Regex.scan(~r/e/, \"abcd\")\n"
"    []\n"
"\n"
"    iex> Regex.scan(~r/\\p{Sc}/u, \"$, £, and €\")\n"
"    [[\"$\"], [\"£\"], [\"€\"]]\n"
"\n"
msgstr ""
"`run/3`と同じですが、正規表現にマッチするものをすべて集めるために\n"
"対象を何度かスキャンします。\n"
"\n"
"リストのリストを返します。ここで、第1リストの各項目はマッチを表し、\n"
"2次リストの各項目はキャプチャされた内容を表します。\n"
"\n"
"## オプション\n"
"\n"
"  * `:return`  - `:index`をセットするとindexを返します。デフォルトは\n"
"      `:binary`です。\n"
"  * `:capture` - 結果にどのキャプチャを含めるかを指定します。指定可能な\n"
"      キャプチャの値はこのモジュールのドキュメントをチェックしてください。\n"
"\n"
"## 例\n"
"\n"
"    iex> Regex.scan(~r/c(d|e)/, \"abcd abce\")\n"
"    [[\"cd\", \"d\"], [\"ce\", \"e\"]]\n"
"\n"
"    iex> Regex.scan(~r/c(?:d|e)/, \"abcd abce\")\n"
"    [[\"cd\"], [\"ce\"]]\n"
"\n"
"    iex> Regex.scan(~r/e/, \"abcd\")\n"
"    []\n"
"\n"
"    iex> Regex.scan(~r/\\p{Sc}/u, \"$, £, and €\")\n"
"    [[\"$\"], [\"£\"], [\"€\"]]\n"
"\n"

#. TRANSLATORS: def Regex.escape(string)
#: lib/regex.ex:635
msgid ""
"Escapes a string to be literally matched in a regex.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Regex.escape(\".\")\n"
"    \"\\\\.\"\n"
"\n"
"    iex> Regex.escape(\"\\\\what if\")\n"
"    \"\\\\\\\\what\\\\ if\"\n"
"\n"
msgstr ""
"正規表現に文字通りにマッチするよう文字列をエスケープします。\n"
"\n"
"## 例\n"
"\n"
"    iex> Regex.escape(\".\")\n"
"    \"\\\\.\"\n"
"\n"
"    iex> Regex.escape(\"\\\\what if\")\n"
"    \"\\\\\\\\what\\\\ if\"\n"
"\n"

#. TRANSLATORS: def Regex.named_captures(regex, string, options \\ [])
#: lib/regex.ex:217
msgid ""
"Returns the given captures as a map or `nil` if no captures are\n"
"found. The option `:return` can be set to `:index` to get indexes\n"
"back.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Regex.named_captures(~r/c(?<foo>d)/, \"abcd\")\n"
"    %{\"foo\" => \"d\"}\n"
"\n"
"    iex> Regex.named_captures(~r/a(?<foo>b)c(?<bar>d)/, \"abcd\")\n"
"    %{\"bar\" => \"d\", \"foo\" => \"b\"}\n"
"\n"
"    iex> Regex.named_captures(~r/a(?<foo>b)c(?<bar>d)/, \"efgh\")\n"
"    nil\n"
"\n"
msgstr ""
"指定したキャプチャをマップとして返します。キャプチャが見つからなかった\n"
"場合は`nil`を返します。`:return`オプションに`:index`をセットすると\n"
"インデックスを返すようにすることができます。\n"
"\n"
"## 例\n"
"\n"
"    iex> Regex.named_captures(~r/c(?<foo>d)/, \"abcd\")\n"
"    %{\"foo\" => \"d\"}\n"
"\n"
"    iex> Regex.named_captures(~r/a(?<foo>b)c(?<bar>d)/, \"abcd\")\n"
"    %{\"bar\" => \"d\", \"foo\" => \"b\"}\n"
"\n"
"    iex> Regex.named_captures(~r/a(?<foo>b)c(?<bar>d)/, \"efgh\")\n"
"    nil\n"
"\n"

#. TRANSLATORS: def Regex.replace(regex, string, replacement, options \\ [])
#: lib/regex.ex:456
msgid ""
"Receives a regex, a binary and a replacement, returns a new\n"
"binary where all matches are replaced by the replacement.\n"
"\n"
"The replacement can be either a string or a function. The string\n"
"is used as a replacement for every match and it allows specific\n"
"captures to be accessed via `\\N` or `\\g{N}`, where `N` is the\n"
"capture. In case `\\0` is used, the whole match is inserted. Note\n"
"that in regexes the backslash needs to be escaped, hence in practice\n"
"you'll need to use `\\\\N` and `\\\\g{N}`.\n"
"\n"
"When the replacement is a function, the function may have arity\n"
"N where each argument maps to a capture, with the first argument\n"
"being the whole match. If the function expects more arguments\n"
"than captures found, the remaining arguments will receive `\"\"`.\n"
"\n"
"## Options\n"
"\n"
"  * `:global` - when `false`, replaces only the first occurrence\n"
"    (defaults to `true`)\n"
"\n"
"## Examples\n"
"\n"
"    iex> Regex.replace(~r/d/, \"abc\", \"d\")\n"
"    \"abc\"\n"
"\n"
"    iex> Regex.replace(~r/b/, \"abc\", \"d\")\n"
"    \"adc\"\n"
"\n"
"    iex> Regex.replace(~r/b/, \"abc\", \"[\\\\0]\")\n"
"    \"a[b]c\"\n"
"\n"
"    iex> Regex.replace(~r/a(b|d)c/, \"abcadc\", \"[\\\\1]\")\n"
"    \"[b][d]\"\n"
"\n"
"    iex> Regex.replace(~r/\\.(\\d)$/, \"500.5\", \".\\\\g{1}0\")\n"
"    \"500.50\"\n"
"\n"
"    iex> Regex.replace(~r/a(b|d)c/, \"abcadc\", fn _, x -> \"[#{x}]\" end)\n"
"    \"[b][d]\"\n"
"\n"
"    iex> Regex.replace(~r/a/, \"abcadc\", \"A\", global: false)\n"
"    \"Abcadc\"\n"
"\n"
msgstr ""
"正規表現とバイナリ、`replacement`を受け取り、すべてのマッチが`replacement`"
"で\n"
"置き換えられた新しいバイナリを返します。\n"
"\n"
"`replacement`には文字列か関数を指定できます。文字列はすべての\n"
"マッチの置換文字列として使われます。また、`\\N`または`\\g{N}`により、\n"
"特定のキャプチャにアクセスできます。ここで、`N`はキャプチャです。\n"
"`\\0`が使われた場合は、マッチした全体が挿入されます。正規表現の\n"
"中ではバックスラッシュはエスケープされる必要があることに注意してください。\n"
"したがって、実際には`\\\\N`と`\\\\g{N}`を使う必要があります。\n"
"\n"
"`replacement`が関数の場合、関数はアリティNを持つことができます。\n"
"ここで各引数はキャプチャに対応づけられ、最初の引数はマッチ全体に\n"
"なります。見つかったキャプチャより多くの引数を指定した場合は、\n"
"残りの引数は`\"\"`を受け取ります。\n"
"\n"
"## オプション\n"
"\n"
"  * `:global` - `false`の場合、最初のマッチのみ置き換えます\n"
"    （デフォルトは`true`です）\n"
"\n"
"## 例\n"
"\n"
"    iex> Regex.replace(~r/d/, \"abc\", \"d\")\n"
"    \"abc\"\n"
"\n"
"    iex> Regex.replace(~r/b/, \"abc\", \"d\")\n"
"    \"adc\"\n"
"\n"
"    iex> Regex.replace(~r/b/, \"abc\", \"[\\\\0]\")\n"
"    \"a[b]c\"\n"
"\n"
"    iex> Regex.replace(~r/a(b|d)c/, \"abcadc\", \"[\\\\1]\")\n"
"    \"[b][d]\"\n"
"\n"
"    iex> Regex.replace(~r/\\.(\\d)$/, \"500.5\", \".\\\\g{1}0\")\n"
"    \"500.50\"\n"
"\n"
"    iex> Regex.replace(~r/a(b|d)c/, \"abcadc\", fn _, x -> \"[#{x}]\" end)\n"
"    \"[b][d]\"\n"
"\n"
"    iex> Regex.replace(~r/a/, \"abcadc\", \"A\", global: false)\n"
"    \"Abcadc\"\n"
"\n"

#. TRANSLATORS: def Regex.compile(source, options \\ "")
#: lib/regex.ex:89
msgid ""
"Compiles the regular expression.\n"
"\n"
"The given options can either be a binary with the characters\n"
"representing the same regex options given to the `~r` sigil,\n"
"or a list of options, as expected by the Erlang's [`:re` module](http://www."
"erlang.org/doc/man/re.html).\n"
"\n"
"It returns `{:ok, regex}` in case of success,\n"
"`{:error, reason}` otherwise.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Regex.compile(\"foo\")\n"
"    {:ok, ~r\"foo\"}\n"
"\n"
"    iex> Regex.compile(\"*foo\")\n"
"    {:error, {'nothing to repeat', 0}}\n"
"\n"
msgstr ""
"正規表現をコンパイルします。\n"
"\n"
"指定するオプションは、`~r`シギルに与える正規表現オプションと同じ\n"
"文字列表現を持つバイナリか、Erlangの\n"
"[`:re` モジュール](http://www.erlang.org/doc/man/re.html)\n"
"で想定されるオプションのリストのいずれかです。\n"
"\n"
"成功した場合は`{:ok, regex}`を返し、そうでなければ`{:error, reason}`を\n"
"返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Regex.compile(\"foo\")\n"
"    {:ok, ~r\"foo\"}\n"
"\n"
"    iex> Regex.compile(\"*foo\")\n"
"    {:error, {'nothing to repeat', 0}}\n"
"\n"

#. TRANSLATORS: def Regex.opts(regex)
#: lib/regex.ex:264
msgid ""
"Returns the regex options as a string.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Regex.opts(~r(foo)m)\n"
"    \"m\"\n"
"\n"
msgstr ""
"正規表現オプションを文字列で返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Regex.opts(~r(foo)m)\n"
"    \"m\"\n"
"\n"

#. TRANSLATORS: def Regex.regex?(term)
#: lib/regex.ex:163
msgid ""
"Returns `true` if the given `term` is a regex.\n"
"Otherwise returns `false`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Regex.regex?(~r/foo/)\n"
"    true\n"
"\n"
"    iex> Regex.regex?(0)\n"
"    false\n"
"\n"
msgstr ""
"指定した`term`が正規表現の場合`true`を返します。\n"
"そうでなければ`false`を返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Regex.regex?(~r/foo/)\n"
"    true\n"
"\n"
"    iex> Regex.regex?(0)\n"
"    false\n"
"\n"

#. TRANSLATORS: def Regex.run(regex, string, options \\ [])
#: lib/regex.ex:181
msgid ""
"Runs the regular expression against the given string until the first match.\n"
"It returns a list with all captures or `nil` if no match occurred.\n"
"\n"
"## Options\n"
"\n"
"  * `:return`  - sets to `:index` to return indexes. Defaults to `:binary`.\n"
"  * `:capture` - what to capture in the result. Check the moduledoc for "
"`Regex`\n"
"    to see the possible capture values.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Regex.run(~r/c(d)/, \"abcd\")\n"
"    [\"cd\", \"d\"]\n"
"\n"
"    iex> Regex.run(~r/e/, \"abcd\")\n"
"    nil\n"
"\n"
"    iex> Regex.run(~r/c(d)/, \"abcd\", return: :index)\n"
"    [{2, 2}, {3, 1}]\n"
"\n"
msgstr ""
"指定した文字列に対して正規表現を最初にマッチするまで実行します。\n"
"すべてのキャプチャのリスト、または、マッチがなかった場合は`nil`を返します。\n"
"\n"
"## オプション\n"
"\n"
"  * `:return`  - `:index`をセットするとindexを返します。デフォルトは\n"
"      `:binary`です。\n"
"  * `:capture` - 結果にどのキャプチャを含めるかを指定します。指定可能な\n"
"      キャプチャの値はこのモジュールのドキュメントをチェックしてください。\n"
"\n"
"## 例\n"
"\n"
"    iex> Regex.run(~r/c(d)/, \"abcd\")\n"
"    [\"cd\", \"d\"]\n"
"\n"
"    iex> Regex.run(~r/e/, \"abcd\")\n"
"    nil\n"
"\n"
"    iex> Regex.run(~r/c(d)/, \"abcd\", return: :index)\n"
"    [{2, 2}, {3, 1}]\n"
"\n"

#. TRANSLATORS: def Regex.names(regex)
#: lib/regex.ex:278
msgid ""
"Returns a list of names in the regex.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Regex.names(~r/(?<foo>bar)/)\n"
"    [\"foo\"]\n"
"\n"
msgstr ""
"正規表現中の名前のリストを返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Regex.names(~r/(?<foo>bar)/)\n"
"    [\"foo\"]\n"
"\n"

#. TRANSLATORS: def Regex.match?(regex, string)
#: lib/regex.ex:146
msgid ""
"Returns a boolean indicating whether there was a match or not.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Regex.match?(~r/foo/, \"foo\")\n"
"    true\n"
"\n"
"    iex> Regex.match?(~r/foo/, \"bar\")\n"
"    false\n"
"\n"
msgstr ""
"マッチするか否かを論理値で返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Regex.match?(~r/foo/, \"foo\")\n"
"    true\n"
"\n"
"    iex> Regex.match?(~r/foo/, \"bar\")\n"
"    false\n"
"\n"

#. TRANSLATORS: def Regex.compile!(source, options \\ "")
#: lib/regex.ex:134
msgid ""
"Compiles the regular expression according to the given options.\n"
"Fails with `Regex.CompileError` if the regex cannot be compiled.\n"
msgstr ""
"指定したオプションにしたがって正規表現をコンパイルします。\n"
"正規表現がコンパイルできなかった場合は`Regex.CompileError`で失敗します。\n"

#. TRANSLATORS: def Regex.source(regex)
#: lib/regex.ex:250
msgid ""
"Returns the regex source as a binary.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Regex.source(~r(foo))\n"
"    \"foo\"\n"
"\n"
msgstr ""
"正規表現のソースをバイナリで返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> Regex.source(~r(foo))\n"
"    \"foo\"\n"
"\n"

#. TRANSLATORS: def Regex.re_pattern(regex)
#: lib/regex.ex:242
msgid "Returns the underlying `re_pattern` in the regular expression.\n"
msgstr "正規表現の根底にある`re_pattern`を返します。\n"

#. TRANSLATORS: def Regex.split(regex, string, options \\ [])
#: lib/regex.ex:336
msgid ""
"Splits the given target based on the given pattern and in the given number "
"of\n"
"parts.\n"
"\n"
"## Options\n"
"\n"
"  * `:parts` - when specified, splits the string into the given number of\n"
"    parts. If not specified, `:parts` defaults to `:infinity`, which will\n"
"    split the string into the maximum number of parts possible based on the\n"
"    given pattern.\n"
"\n"
"  * `:trim` - when `true`, removes empty strings (`\"\"`) from the result.\n"
"\n"
"  * `:on` - specifies which captures to split the string on, and in what\n"
"    order. Defaults to `:first` which means captures inside the regex do "
"not\n"
"    affect the splitting process.\n"
"\n"
"  * `:include_captures` - when `true`, includes in the result the matches "
"of\n"
"    the regular expression. Defaults to `false`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> Regex.split(~r{-}, \"a-b-c\")\n"
"    [\"a\", \"b\", \"c\"]\n"
"\n"
"    iex> Regex.split(~r{-}, \"a-b-c\", [parts: 2])\n"
"    [\"a\", \"b-c\"]\n"
"\n"
"    iex> Regex.split(~r{-}, \"abc\")\n"
"    [\"abc\"]\n"
"\n"
"    iex> Regex.split(~r{}, \"abc\")\n"
"    [\"a\", \"b\", \"c\", \"\"]\n"
"\n"
"    iex> Regex.split(~r{a(?<second>b)c}, \"abc\")\n"
"    [\"\", \"\"]\n"
"\n"
"    iex> Regex.split(~r{a(?<second>b)c}, \"abc\", on: [:second])\n"
"    [\"a\", \"c\"]\n"
"\n"
"    iex> Regex.split(~r{(x)}, \"Elixir\", include_captures: true)\n"
"    [\"Eli\", \"x\", \"ir\"]\n"
"\n"
"    iex> Regex.split(~r{a(?<second>b)c}, \"abc\", on: [:second], "
"include_captures: true)\n"
"    [\"a\", \"b\", \"c\"]\n"
"\n"
msgstr ""
"指定した対象を指定したパターンに基づき、指定した数の部分に分割します。\n"
"\n"
"## オプション\n"
"\n"
"  * `:parts` - 指定された場合、文字列を指定した数の部分に分割します。\n"
"    指定されない場合、`:parts`のデフォルトは`:infinity`であり、\n"
"    指定したパターンに基いて可能な限り最大数の部分に分割します。\n"
"\n"
"  * `:trim` - `true`の場合、結果から空文字列(\"\")を取り除きます。\n"
"\n"
"  * `:on` - どのキャプチャで、どの順番で文字列を分割するかを指定します。\n"
"    デフォルトは`:first`で、これは正規表現中のキャプチャは分割処理に影響を\n"
"    与えないことを意味します。\n"
"\n"
"  * `:include_captures` - `true`の場合、そ正規表現にマッチした部分も\n"
"    結果に含めます。デフォルトは`false`です。\n"
"\n"
"## 例\n"
"\n"
"    iex> Regex.split(~r{-}, \"a-b-c\")\n"
"    [\"a\", \"b\", \"c\"]\n"
"\n"
"    iex> Regex.split(~r{-}, \"a-b-c\", [parts: 2])\n"
"    [\"a\", \"b-c\"]\n"
"\n"
"    iex> Regex.split(~r{-}, \"abc\")\n"
"    [\"abc\"]\n"
"\n"
"    iex> Regex.split(~r{}, \"abc\")\n"
"    [\"a\", \"b\", \"c\", \"\"]\n"
"\n"
"    iex> Regex.split(~r{a(?<second>b)c}, \"abc\")\n"
"    [\"\", \"\"]\n"
"\n"
"    iex> Regex.split(~r{a(?<second>b)c}, \"abc\", on: [:second])\n"
"    [\"a\", \"c\"]\n"
"\n"
"    iex> Regex.split(~r{(x)}, \"Elixir\", include_captures: true)\n"
"    [\"Eli\", \"x\", \"ir\"]\n"
"\n"
"    iex> Regex.split(~r{a(?<second>b)c}, \"abc\", on: [:second], "
"include_captures: true)\n"
"    [\"a\", \"b\", \"c\"]\n"
"\n"

#. TRANSLATORS: Elixir.Regex Summary
#: lib/regex.ex:2
msgid ""
"Provides regular expressions for Elixir. Built on top of Erlang's `:re`\n"
"module.\n"
"\n"
"As the `:re` module, Regex is based on PCRE\n"
"(Perl Compatible Regular Expressions). More information can be\n"
"found in the [`:re` module documentation](http://www.erlang.org/doc/man/re."
"html).\n"
"\n"
"Regular expressions in Elixir can be created using `Regex.compile!/2`\n"
"or using the special form with [`~r`](Kernel.html#sigil_r/2) or [`~R`]"
"(Kernel.html#sigil_R/2):\n"
"\n"
"    # A simple regular expressions that matches foo anywhere in the string\n"
"    ~r/foo/\n"
"\n"
"    # A regular expression with case insensitive and Unicode options\n"
"    ~r/foo/iu\n"
"\n"
"A Regex is represented internally as the `Regex` struct. Therefore,\n"
"`%Regex{}` can be used whenever there is a need to match on them.\n"
"\n"
"## Modifiers\n"
"\n"
"The modifiers available when creating a Regex are:\n"
"\n"
"  * `unicode` (u) - enables Unicode specific patterns like `\\p` and change\n"
"    modifiers like `\\w`, `\\W`, `\\s` and friends to also match on "
"Unicode.\n"
"    It expects valid Unicode strings to be given on match\n"
"\n"
"  * `caseless` (i) - adds case insensitivity\n"
"\n"
"  * `dotall` (s) - causes dot to match newlines and also set newline to\n"
"    anycrlf; the new line setting can be overridden by setting `(*CR)` or\n"
"    `(*LF)` or `(*CRLF)` or `(*ANY)` according to re documentation\n"
"\n"
"  * `multiline` (m) - causes `^` and `$` to mark the beginning and end of\n"
"    each line; use `\\A` and `\\z` to match the end or beginning of the "
"string\n"
"\n"
"  * `extended` (x) - whitespace characters are ignored except when escaped\n"
"    and allow `#` to delimit comments\n"
"\n"
"  * `firstline` (f) - forces the unanchored pattern to match before or at "
"the\n"
"    first newline, though the matched text may continue over the newline\n"
"\n"
"  * `ungreedy` (U) - inverts the \"greediness\" of the regexp\n"
"    (the previous `r` option is deprecated in favor of `U`)\n"
"\n"
"The options not available are:\n"
"\n"
"  * `anchored` - not available, use `^` or `\\A` instead\n"
"  * `dollar_endonly` - not available, use `\\z` instead\n"
"  * `no_auto_capture` - not available, use `?:` instead\n"
"  * `newline` - not available, use `(*CR)` or `(*LF)` or `(*CRLF)` or\n"
"    `(*ANYCRLF)` or `(*ANY)` at the beginning of the regexp according to "
"the\n"
"    re documentation\n"
"\n"
"## Captures\n"
"\n"
"Many functions in this module handle what to capture in a regex\n"
"match via the `:capture` option. The supported values are:\n"
"\n"
"  * `:all` - all captured subpatterns including the complete matching "
"string\n"
"    (this is the default)\n"
"\n"
"  * `:first` - only the first captured subpattern, which is always the\n"
"    complete matching part of the string; all explicitly captured "
"subpatterns\n"
"    are discarded\n"
"\n"
"  * `:all_but_first`- all but the first matching subpattern, i.e. all\n"
"    explicitly captured subpatterns, but not the complete matching part of\n"
"    the string\n"
"\n"
"  * `:none` - does not return matching subpatterns at all\n"
"\n"
"  * `:all_names` - captures all names in the Regex\n"
"\n"
"  * `list(binary)` - a list of named captures to capture\n"
"\n"
msgstr ""
"Erlangに正規表現を提供します。Erlangの`:re`モジュールの上に構築されていま"
"す。\n"
"\n"
"`re`モジュールと同じく、RegexはPCRE（Perl互換正規表現: Perl Compatible "
"Regular Expressions)に基いています。詳細は、\n"
"[`:re`モジュールのドキュメント documentation](http://www.erlang.org/doc/man/"
"re.html)を参照してください。\n"
"\n"
"Elixirの正規表現は、`Regex.compile!/2`、または、スペシャルフォームの\n"
"[`~r`](Kernel.html#sigil_r/2) と[`~R`](Kernel.html#sigil_R/2) を使って\n"
"作成することができます:\n"
"\n"
"    # 文字列中のどこにあるfooにもマッチするシンプルな正規表現\n"
"    ~r/foo/\n"
"\n"
"    # 大文字小文字を無視とUnicodeの2つのオプションを持つ正規表現\n"
"    ~r/foo/iu\n"
"\n"
"Regexは、内部では`Regex`構造体で表現されています。従って、\n"
"マッチする必要があるときはいつでも`%Regex{}`を使うことができます。\n"
"\n"
"## 修飾子\n"
"\n"
"Regexを作成する際に使用可能な修飾子は以下の通りです。\n"
"\n"
"  * `unicode` (u) - `\\p`のようなUnicode特有のパターンを有効にし、\n"
"    `\\w`、`\\W`、`\\s`などの修飾子をUnicodeにも\n"
"     マッチするよう変更します。マッチには正しいUnicode文字列が指定される\n"
"     ことを期待します\n"
"\n"
"  * `caseless` (i) - 大文字小文字を無視します\n"
"\n"
"  * `dotall` (s) - ドット(.)を改行にマッチさせ、改行を`(*ANYCRLF)`に\n"
"    セットします; 改行設定は、`re`モジュールのドキュメントに従って、\n"
"    `(*CR)`、`(*LF)`、`(*CRLF)`、`(*ANY)`を設定することで上書きできます。\n"
"\n"
"  * `multiline` (m) - `^`と`$`を行の先頭と末尾にマークします。\n"
"    文字列の先頭と末尾にマッチさせるには`\\A`と`\\Z`を使ってください\n"
"\n"
"  * `extended` (x) - エスケープされたものを除き、空白文字を無視します。\n"
"    また、`#`でコメントを区切ることができます。\n"
"\n"
"  * `firstline` (f) - 先頭固定ではないパターンも、最初の改行またはそれ以前"
"で\n"
"    マッチすることを強制します。ただし、マッチしたテキストは改行を越えて続い"
"ても\n"
"    良い。\n"
"\n"
"  * `ungreedy` (U) - 正規表現の\"貪欲さ\"を反転します。\n"
"    (以前の`r`オプションは非推奨で、`U`を使ってください)\n"
"\n"
"使用できないオプションは以下の通りです。\n"
"\n"
"  * `anchored` - 使用できません。代わりに、’^’か`\\A`を使ってください\n"
"  * `dollar_endonly` - 使用できません。代わりに、`\\z`を使ってください\n"
"  * `no_auto_capture` - 使用できません。代わりに、`?:`を使ってください\n"
"  * `newline` - 使用できません。正規表現の先頭に、`(*CR)`、 `(*LF)` 、\n"
"    `(*CRLF)` 、`(*ANYCRLF)` 、`(*ANY)` のいずれかを指定してください。\n"
"    詳しくは`re`モジュールのドキュメントを参照してください\n"
"\n"
"## キャプチャ\n"
"\n"
"このモジュールの多くの関数は、正規表現マッチで何をキャプチャするかを\n"
"`:capture`オプションで指定できます。サポートされている値は以下の通りです。\n"
"\n"
"  * `:all` - 完全にマッチする文字列を含むすべてのサブパターンをキャプチャ\n"
"    (これはデフォルトです)\n"
"\n"
"  * `:first` - 最初のサブパターンのみをキャプチャ。これは常に文字列の内、\n"
"    完全にマッチする部分です。明示的にキャプチャしたすべてのサブパターンは\n"
"    放棄されます\n"
"\n"
"  * `:all_but_first`- 最初にマッチしたサブパターン以外のすべてのサブパターン"
"を\n"
"     キャプチャ。すなわち、明示的にキャプチャしたすべてのサブパターンを\n"
"    キャプチャしますが、文字列の内、完全にマッチする部分はキャプチャしませ"
"ん\n"
"\n"
"  * `:none` - マッチしたサブパーンをまったく返しません\n"
"\n"
"  * `:all_names` - Regexの中のすべての名前を捕捉します\n"
"\n"
"  * `list(binary)` - キャプチャするための名前付けキャプチャのリストを返しま"
"す\n"
"\n"
