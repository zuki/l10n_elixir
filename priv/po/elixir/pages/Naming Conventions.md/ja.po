msgid ""
msgstr ""
"Project-Id-Version: l 10n_elixir\n"
"PO-Revision-Date: 2017-01-26 18:06+0900\n"
"Last-Translator: 小田 照敬 <EMAIL@ADDRESS>\n"
"Language-Team: Japanese\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"POT-Creation-Date: \n"
"X-Generator: Poedit 1.8.11\n"

#: deps/elixir/lib/elixir/pages/Naming Conventions.md:1
msgid "# Naming Conventions"
msgstr "# 命名規約"

#: deps/elixir/lib/elixir/pages/Naming Conventions.md:3
msgid ""
"This document covers some naming conventions in Elixir code, from casing to "
"punctuation characters."
msgstr ""
"このドキュメントは、Elixirコードにおけるケーシングから句読点文字に至る命名規"
"約についてカバーします。"

#: deps/elixir/lib/elixir/pages/Naming Conventions.md:5
msgid "## Casing"
msgstr "## ケーシング"

#: deps/elixir/lib/elixir/pages/Naming Conventions.md:7
msgid ""
"Elixir developers must use `snake_case` when defining variables, function "
"names, module attributes, etc:"
msgstr ""
"Elixir開発者は変数、関数名、モジュール属性などを定義する際には`snake_case`を"
"使わなければなりません:"

#: deps/elixir/lib/elixir/pages/Naming Conventions.md:12
msgid ""
"Aliases, commonly used as module names, are an exception as they must be "
"capitalized and written in `CamelCase`, like `OptionParser`. For aliases, "
"capital letters are kept in acronyms, like `ExUnit.CaptureIO` or `Mix.SCM`."
msgstr ""
"一般にモジュール名として使われるエリアスは例外で、`OptionParser`のように、大"
"文字から始めて`CamelCase`で書かなければなりません。エリアスでは、`ExUnit."
"CaptureIO`や`Mix.SCM`のように、アクロニムの大文字はそのまま使います。"

#: deps/elixir/lib/elixir/pages/Naming Conventions.md:14
msgid ""
"Atoms can be written either in `:snake_case` or `:CamelCase`, although the "
"convention is to use the snake case version throughout Elixir."
msgstr ""
"アトムは、`:snake_case`と`:CamelCase`のいずれかで書くことができます。ただし、"
"Elixir全体を通じてsnake case版を使うことが規約になっています。"

#: deps/elixir/lib/elixir/pages/Naming Conventions.md:16
msgid ""
"Generally speaking, filenames follow the `snake_case` convention of the "
"module they define. For example, `MyApp` should be defined inside the "
"`my_app.ex` file. However, this is only a convention. At the end of the day, "
"any filename can be used as they do not affect the compiled code in any way."
msgstr ""
"一般的に言って、ファイル名はそこで定義するモジュールの`snake_case`規約に従い"
"ます。たとえば、`MyApp`は`my_app.ex`ファイルの中で定義されるべきです。しかし"
"ながら、これは規約にすぎません。結局は、任意のファイル名を使うことができま"
"す。ファイル名はコンパイルされるコードにいかなる影響も与えないからです。"

#: deps/elixir/lib/elixir/pages/Naming Conventions.md:18
msgid "## Underscore (_foo)"
msgstr "## アンダースコア (_foo)"

#: deps/elixir/lib/elixir/pages/Naming Conventions.md:20
msgid "Elixir relies on underscores in different situations."
msgstr "Elixirはさまざまな状況でアンダースコアを頼りにします。"

#: deps/elixir/lib/elixir/pages/Naming Conventions.md:22
msgid ""
"For example, a value that is not meant to be used must be assigned to `_` or "
"to a variable starting with underscore:"
msgstr ""
"たとえば、使われることを意味しない値は、`_`、または、アンダースコアで始まる変"
"数に代入されなければなりません:"

#: deps/elixir/lib/elixir/pages/Naming Conventions.md:26
msgid ""
"Function names may also start with an underscore. Such functions are never "
"imported by default:"
msgstr ""
"関数名もアンダースコアで始まる場合があります。そのような関数はデフォルトでは"
"importされることはありません:"

#: deps/elixir/lib/elixir/pages/Naming Conventions.md:38
msgid ""
"Due to this property, Elixir relies on functions starting with underscore to "
"attach compile-time metadata to modules. Such functions are most often in "
"the `__foo__` format. For example, every module in Elixir has an "
"`__info__/1` function:"
msgstr ""
"この特性のために、Elixirはコンパイル時メタデータをモジュールに添付するために"
"アンダースコアで始まる関数に依存しています。そのような関数でもっとも多いのは"
"`__foo__`の形式です。たとえば、Elixirのすべてのモジュールは関数`__info__/1`を"
"持っています:"

#: deps/elixir/lib/elixir/pages/Naming Conventions.md:43
msgid ""
"Elixir also includes 4 special variables that follow the double underscore "
"format. These forms retrieve compile-time information about the current "
"environment: `__MODULE__/0`, `__DIR__/0`, `__ENV__/0` and `__CALLER__/0`."
msgstr ""
"Elixirはダブルアンダースコア形式にしたがう4つの特別な変数も持っています。これ"
"らの変数は現在の環境に関するコンパイル時の情報を取り出します: "
"`__MODULE__/0`, `__DIR__`/0, `__ENV__/0` そして `__CALLER__/0`。"

#: deps/elixir/lib/elixir/pages/Naming Conventions.md:45
msgid "## Trailing bang (foo!)"
msgstr "## 末尾のbang (foo!)"

#: deps/elixir/lib/elixir/pages/Naming Conventions.md:47
msgid ""
"A trailing bang (exclamation mark) signifies a function or macro where "
"failure cases raise an exception."
msgstr ""
"末尾のbang(感嘆符)は失敗すると例外を発生する関数またはマクロであることを示し"
"ます。"

#: deps/elixir/lib/elixir/pages/Naming Conventions.md:49
msgid ""
"Many functions come in pairs, such as `File.read/1` and `File.read!/1`. "
"`File.read/1` will return a success or failure tuple, whereas `File.read!/1` "
"will return a plain value or else raise an exception:"
msgstr ""
"`File.read/1`と`File.read!/1`のように、多くの関数はペアをなしています。`File."
"read/1`は成功か失敗のタプルを返します。一方、`File.read!/1`は単純な値か、さも"
"なければ例外を発生させます:"

#: deps/elixir/lib/elixir/pages/Naming Conventions.md:61
msgid ""
"The version without `!` is preferred when you want to handle different "
"outcomes using pattern matching:"
msgstr ""
"`!`なしのバージョンは、パターンマッチを使って異なる結果を取り扱いたいときに好"
"まれます:"

#: deps/elixir/lib/elixir/pages/Naming Conventions.md:68
msgid ""
"However, if you expect the outcome to always to be successful (e.g. if you "
"expect the file always to exist), the bang variation can be more convenient "
"and will raise a more helpful error message (than a failed pattern match) on "
"failure."
msgstr ""
"しかしながら、常に成功の結果を期待する場合（たとえば、ファイルは常に存在する"
"期待する場合）は、bang版の方が便利であり、失敗時に(パターンマッチの失敗)より"
"役に立つエラーメッセージを上げることができます。"

#: deps/elixir/lib/elixir/pages/Naming Conventions.md:70
msgid ""
"More examples of paired functions: `Base.decode16/2` and `Base.decode16!/2`, "
"`File.cwd/0` and `File.cwd!/0`"
msgstr ""
"ペア関数のさらなる例には、`Base.decode16/2` と `Base.decode16!/2`、`File."
"cwd/0` と `File.cwd!/0`があります。"

#: deps/elixir/lib/elixir/pages/Naming Conventions.md:72
msgid ""
"There are also some non-paired functions, with no non-bang variant. The bang "
"still signifies that it will raise an exception on failure. Examples: `Mix."
"Config.validate!/1`, `Protocol.assert_protocol!/1`"
msgstr ""
"bangなし版をもたない、ペアになっていない関数も存在します。ここでもbangは失敗"
"時に例外を発生することを示します。たとえば、 `Mix.Config.validate!/1`や"
"`Protocol.assert_protocol!/1`です。"

#: deps/elixir/lib/elixir/pages/Naming Conventions.md:74
msgid ""
"In macro code, the bang on `Kernel.alias!/1` and `Kernel.var!/2` signifies "
"that [macro hygiene](http://elixir-lang.org/getting-started/meta/macros."
"html#macros-hygiene) is set aside."
msgstr ""
"マクロコードにおいては、`Kernel.alias!/1`と`Kernel.var!/2`のbangは[マクロの健"
"全さ (macro hygiene)](http://elixir-lang.org/getting-started/meta/macros."
"html#macros-hygiene)\n"
"が破棄されることを示します。"

#: deps/elixir/lib/elixir/pages/Naming Conventions.md:76
msgid "## Trailing question mark (foo?)"
msgstr "## 末尾の疑問符 (foo?)"

#: deps/elixir/lib/elixir/pages/Naming Conventions.md:78
msgid ""
"Functions that return a boolean are named with a trailing question mark."
msgstr "booleanを返す関数は末尾に疑問符を持つ名前にします。"

#: deps/elixir/lib/elixir/pages/Naming Conventions.md:80
msgid "Examples: `Keyword.keyword?/1`, `Mix.debug?/0`, `String.contains?/2`"
msgstr "例: `Keyword.keyword?/1`, `Mix.debug?/0`, `String.contains?/2`"

#: deps/elixir/lib/elixir/pages/Naming Conventions.md:82
msgid ""
"However, functions that return booleans and are valid in guards follow "
"another convention, described next."
msgstr ""
"しかしながら、booleanを返すがガード節で妥当な関数は、次に説明する、もう一つの"
"規約に従います。"

#: deps/elixir/lib/elixir/pages/Naming Conventions.md:84
msgid "## is_ prefix (is_foo)"
msgstr "## is_ プレフィックス (is_foo)"

#: deps/elixir/lib/elixir/pages/Naming Conventions.md:86
msgid ""
"Type checks and other boolean checks that are allowed in guard clauses are "
"named with an `is_` prefix."
msgstr ""
"ガード節で使えるタイプチェックとその他の真偽チェックは、`is_`プレフィックスを"
"持つ名前にします。"

#: deps/elixir/lib/elixir/pages/Naming Conventions.md:88
msgid "Examples: `Integer.is_even/1`, `Kernel.is_list/1`"
msgstr "例: `Integer.is_even/1`, `Kernel.is_list/1`"

#: deps/elixir/lib/elixir/pages/Naming Conventions.md:90
msgid ""
"These functions and macros follow the Erlang convention of an `is_` prefix, "
"instead of a trailing question mark, precisely to indicate that they are "
"allowed in guard clauses."
msgstr ""
"これらの関数とマクロは、末尾疑問符ではなく、それらがガード節で使えることを明"
"確に示すために、Erlangの`is_`プレフィックス規約に従います。"

#: deps/elixir/lib/elixir/pages/Naming Conventions.md:92
msgid ""
"Note that type checks that are not valid in guard clauses do not follow this "
"convention. Examples: `Keyword.keyword?/1`, `Regex.regex?/1`"
msgstr ""
"ガード節で妥当でないタイプチェックはこの規約に従わないことに注意してくださ"
"い。 例: `Keyword.keyword?/1`, `Regex.regex?/1`"

#: deps/elixir/lib/elixir/pages/Naming Conventions.md:94
msgid "## Special names"
msgstr "## 特別な名前"

#: deps/elixir/lib/elixir/pages/Naming Conventions.md:96
msgid ""
"Some names have specific meaning in Elixir. We detail those cases below."
msgstr "Elixirにおいて特別な意味を持つ名前があります。以下に詳しく説明します。"

#: deps/elixir/lib/elixir/pages/Naming Conventions.md:98
msgid "### length and size"
msgstr "### lengthとsize"

#: deps/elixir/lib/elixir/pages/Naming Conventions.md:100
msgid ""
"When you see `size` in a function name, it means the operation runs in "
"constant time (also written as \"O(1) time\") because the size is stored "
"alongside the data structure."
msgstr ""
"関数名に`size`が含まれている場合は、操作が定数時間(\"O(1)時間”とも書かれる)で"
"行われることを意味します。sizeはデータ構造に格納されているからです。"

#: deps/elixir/lib/elixir/pages/Naming Conventions.md:102
msgid "Examples: `Kernel.map_size/1`, `Kernel.tuple_size/1`"
msgstr "例: `Kernel.map_size/1`, `Kernel.tuple_size/1`"

#: deps/elixir/lib/elixir/pages/Naming Conventions.md:104
msgid ""
"When you see `length`, the operation runs in linear time (\"O(n) time\") "
"because the entire data structure has to be traversed."
msgstr ""
"`length`がある場合は、操作は線形時間(\"O(n)時間\")で行われます。データ構造全"
"体を走査する必要があるからです。"

#: deps/elixir/lib/elixir/pages/Naming Conventions.md:106
msgid "Examples: `Kernel.length/1`, `String.length/1`"
msgstr "例: `Kernel.length/1`, `String.length/1`"

#: deps/elixir/lib/elixir/pages/Naming Conventions.md:108
msgid ""
"In other words, functions using the word \"size\" in its name will take the "
"same amount of time whether the data structure is tiny or huge. Conversely, "
"functions having \"length\" in its name will take more time as the data "
"structure grows in size.\n"
msgstr ""
"言い替えると、名前に単語`size`を使った関数はデータ構造が小くても巨大でも同じ"
"時間がかります。反対に、名前に`length`を持つ関数はデータ構造のサイズが大きく"
"なるにつれ、より多くの時間がかかります。\n"
