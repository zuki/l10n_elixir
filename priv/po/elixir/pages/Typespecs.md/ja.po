msgid ""
msgstr ""
"Project-Id-Version: l 10n_elixir\n"
"PO-Revision-Date: 2017-01-27 12:24+0900\n"
"Last-Translator: 小田 照敬 <EMAIL@ADDRESS>\n"
"Language-Team: Japanese\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"POT-Creation-Date: \n"
"X-Generator: Poedit 1.8.11\n"

#: deps/elixir/lib/elixir/pages/Typespecs.md:1
msgid "# Typespecs"
msgstr "# 型仕様"

#: deps/elixir/lib/elixir/pages/Typespecs.md:3
msgid ""
"Elixir comes with a notation for declaring types and specifications. Elixir "
"is a dynamically typed language, and as such, type specifications are never "
"used by the compiler to optimize or modify code. Still, using type "
"specifications is useful because"
msgstr ""
"Elixirには型と仕様を宣言するための記法があります。Elixirは動的に型付けされた"
"言語です。したがって、コンパイラが型仕様を使って最適化を行ったり、コードを変"
"更したりすることは決してありません。それでも、型仕様の仕様は次のような理由で"
"役に立ちます。"

#: deps/elixir/lib/elixir/pages/Typespecs.md:5
msgid ""
"  * they provide documentation (for example, tools such as [ExDoc](https://"
"github.com/elixir-lang/ex_doc) show type specifications in the "
"documentation)\n"
"  * they're used by tools such as [Dialyzer](http://www.erlang.org/doc/man/"
"dialyzer.html), that can analyze code with typespec to find type "
"inconsistencies and possible bugs"
msgstr ""
"  * ドキュメントを提供する（たとえば、[ExDoc](https://github.com/elixir-lang/"
"ex_doc) のようなツールはドキュメント中の型仕様を表示します）\n"
"  * 型仕様を使ってコードを分析し、型の不整合やバグを発見する[Dialyzer]"
"(http://www.erlang.org/doc/man/dialyzer.html)のようなツールに使用される"

#: deps/elixir/lib/elixir/pages/Typespecs.md:8
msgid ""
"Type specifications (sometimes referred to as *typespecs*) are defined in "
"different contexts using the following attributes:"
msgstr ""
"型仕様（時には*typespecs*と呼ばれます）は次の属性を使うことで異なるコンテキス"
"トで定義されます:"

#: deps/elixir/lib/elixir/pages/Typespecs.md:10
msgid ""
"  * `@type`\n"
"  * `@opaque`\n"
"  * `@typep`\n"
"  * `@spec`\n"
"  * `@callback`\n"
"  * `@macrocallback`"
msgstr ""
"  * `@type`\n"
"  * `@opaque`\n"
"  * `@typep`\n"
"  * `@spec`\n"
"  * `@callback`\n"
"  * `@macrocallback`"

#: deps/elixir/lib/elixir/pages/Typespecs.md:17
msgid ""
"See the \"Defining a type\" and \"Defining a specification\" sub-sections "
"below for more information on defining types and typespecs."
msgstr ""
"型と型仕様の定義に関する詳細は下の「型の定義」と「仕様の定義」を参照してくだ"
"さい。"

#: deps/elixir/lib/elixir/pages/Typespecs.md:19
msgid "## Types and their syntax"
msgstr "## 型とその構文"

#: deps/elixir/lib/elixir/pages/Typespecs.md:21
msgid ""
"The syntax Elixir provides for type specifications is similar to [the one in "
"Erlang](http://www.erlang.org/doc/reference_manual/typespec.html). Most of "
"the built-in types provided in Erlang (for example, `pid()`) are expressed "
"in the same way: `pid()` (or simply `pid`). Parametrized types (such as "
"`list(integer)`) are supported as well and so are remote types (such as "
"`Enum.t`). Integers and atom literals are allowed as types (e.g., `1`, `:"
"atom`, or `false`). All other types are built out of unions of predefined "
"types. Some shorthands are allowed, such as `[...]`, `<<>>`, and `{...}`."
msgstr ""
"Elixirが型指定のために提供する構文は [Erlangの構文](http://www.erlang.org/"
"doc/reference_manual/typespec.html)と似ています。Erlangで提供されている組み込"
"み型の大部分（たとえば、pid()）は、同じ方法で表現されます: `pid()`（または単"
"純に`pid`）。パラメタライズされた型（`list(integer)`など）やリモート型（Enum."
"tなど）もサポートされています。 整数とアトムリテラルは型として許されます（た"
"とえば、`1`, `:atom`, `false`）。 他のすべての型は、あらかじめ定義されている"
"型の和集合で構築されます。`[…]`, `<<>>`, `{…}`などの簡略表記も許されていま"
"す。"

#: deps/elixir/lib/elixir/pages/Typespecs.md:23
msgid "### Basic types"
msgstr "### 基本型"

#: deps/elixir/lib/elixir/pages/Typespecs.md:53
msgid "### Literals"
msgstr "### リテラル"

#: deps/elixir/lib/elixir/pages/Typespecs.md:55
msgid "The following literals are also supported in typespecs:"
msgstr "型仕様では以下のリテラルもサポートされます:"

#: deps/elixir/lib/elixir/pages/Typespecs.md:94
msgid "### Built-in types"
msgstr "### 組み込み型"

#: deps/elixir/lib/elixir/pages/Typespecs.md:96
msgid ""
"The following types are also provided by Elixir as shortcuts on top of the "
"basic and literal types described above."
msgstr ""
"上で述べた基本型とリテラル型に加えてショートカットとして次の方もElixirにより"
"提供されています。"

#: deps/elixir/lib/elixir/pages/Typespecs.md:98
msgid ""
"Built-in type           | Defined as\n"
":---------------------- | :---------\n"
"`term()`                | `any()`\n"
"`arity()`               | `0..255`\n"
"`as_boolean(t)`         | `t`\n"
"`binary()`              | `<<_::_*8>>`\n"
"`bitstring()`           | `<<_::_*1>>`\n"
"`boolean()`             | `false` \\| `true`\n"
"`byte()`                | `0..255`\n"
"`char()`                | `0..0x10FFFF`\n"
"`charlist()`            | `[char()]`\n"
"`fun()`                 | `(... -> any)`\n"
"`identifier()`          | `pid()` \\| `port()` \\| `reference()`\n"
"`iodata()`              | `iolist()` \\| `binary()`\n"
"`iolist()`              | `maybe_improper_list(byte() \\| binary() \\| "
"iolist(), binary() \\| [])`\n"
"`keyword()`             | `[{atom(), any()}]`\n"
"`keyword(t)`            | `[{atom(), t}]`\n"
"`list()`                | `[any()]`\n"
"`nonempty_list()`       | `nonempty_list(any())`\n"
"`maybe_improper_list()` | `maybe_improper_list(any(), any())`\n"
"`nonempty_maybe_improper_list()` | `nonempty_maybe_improper_list(any(), "
"any())`\n"
"`mfa()`                 | `{module(), atom(), arity()}`\n"
"`module()`              | `atom()`\n"
"`no_return()`           | `none()`\n"
"`node()`                | `atom()`\n"
"`number()`              | `integer()` \\| `float()`\n"
"`struct()`              | `%{:__struct__ => atom(), optional(atom()) => "
"any()}`\n"
"`timeout()`             | `:infinity` \\| `non_neg_integer()`"
msgstr ""
"埋込み型          | 定義\n"
":---------------------- | :---------\n"
"`term()`                | `any()`\n"
"`arity()`               | `0..255`\n"
"`as_boolean(t)`         | `t`\n"
"`binary()`              | `<<_::_*8>>`\n"
"`bitstring()`           | `<<_::_*1>>`\n"
"`boolean()`             | `false` \\| `true`\n"
"`byte()`                | `0..255`\n"
"`char()`                | `0..0x10FFFF`\n"
"`charlist()`            | `[char()]`\n"
"`fun()`                 | `(... -> any)`\n"
"`identifier()`          | `pid()` \\| `port()` \\| `reference()`\n"
"`iodata()`              | `iolist()` \\| `binary()`\n"
"`iolist()`              | `maybe_improper_list(byte() \\| binary() \\| "
"iolist(), binary() \\| [])`\n"
"`keyword()`             | `[{atom(), any()}]`\n"
"`keyword(t)`            | `[{atom(), t}]`\n"
"`list()`                | `[any()]`\n"
"`nonempty_list()`       | `nonempty_list(any())`\n"
"`maybe_improper_list()` | `maybe_improper_list(any(), any())`\n"
"`nonempty_maybe_improper_list()` | `nonempty_maybe_improper_list(any(), "
"any())`\n"
"`mfa()`                 | `{module(), atom(), arity()}`\n"
"`module()`              | `atom()`\n"
"`no_return()`           | `none()`\n"
"`node()`                | `atom()`\n"
"`number()`              | `integer()` \\| `float()`\n"
"`struct()`              | `%{:__struct__ => atom(), optional(atom()) => "
"any()}`\n"
"`timeout()`             | `:infinity` \\| `non_neg_integer()`"

#: deps/elixir/lib/elixir/pages/Typespecs.md:127
msgid "### Remote types"
msgstr "### リモート型"

#: deps/elixir/lib/elixir/pages/Typespecs.md:129
msgid ""
"Any module is also able to define its own types and the modules in Elixir "
"are no exception. For example, the `Range` module defines a `t/0` type that "
"represents a range: this type can be referred to as `t:Range.t/0`. In a "
"similar fashion, a string is `t:String.t/0`, any enumerable can be `t:Enum."
"t/0`, and so on."
msgstr ""
"すべてのモジュールは独自の型を定義することもでき、Elixirのモジュールも例外で"
"はありません。たとえば、`Range`モジュールは範囲を表す`t/0`型を定義していま"
"す。この型は`t:Range.t/0`で参照できます。同様に、文字列は`t:String.t/0`、すべ"
"てのenumerableは`t:Enum.t/0`などで参照できます。"

#: deps/elixir/lib/elixir/pages/Typespecs.md:131
msgid "### Maps"
msgstr "### マップ"

#: deps/elixir/lib/elixir/pages/Typespecs.md:133
msgid ""
"The key types in maps are allowed to overlap, and if they do, the leftmost "
"key takes precedence.\n"
"A map value does not belong to this type if it contains a key that is not in "
"the allowed map keys."
msgstr ""
"マップのキー型は重複が許されています。その場合、もっとも左のキーが優先されま"
"す。\n"
"マップの値は、マップがマップキーに許されていないキーを含んでいる場合はこの型"
"には属しません。"

#: deps/elixir/lib/elixir/pages/Typespecs.md:136
msgid ""
"If you want to denote that keys that were not previously defined in the map "
"are allowed,\n"
"it is common to end a map type with `optional(any) => any`."
msgstr ""
"以前にマップで定義されていなかったキーが許されていることを示したい場合は、"
"マップ型を`optional(any) => any`で終わらせることが一般的です。"

#: deps/elixir/lib/elixir/pages/Typespecs.md:139
msgid ""
"Notice that the syntactic representation of `map()` is `%{optional(any) => "
"any}`, not `%{}`. The notation `%{}` specifies the singleton type for the "
"empty map."
msgstr ""
"`map()`の構文表現は、`%{}`ではなく`%{optional(any) => any)`であることに注意し"
"てください。`%{}`表記は空のマップのための特異型を示すものです。"

#: deps/elixir/lib/elixir/pages/Typespecs.md:141
msgid "## Defining a type"
msgstr "## 型の定義"

#: deps/elixir/lib/elixir/pages/Typespecs.md:143
msgid ""
"The `@type`, `@typep`, and `@opaque` module attributes can be used to define "
"new types:"
msgstr ""
"新しい型の定義にはモジュール属性 `@type`, `@typep`,, `@opaque`を使用できます:"

#: deps/elixir/lib/elixir/pages/Typespecs.md:149
msgid ""
"A type defined with `@typep` is private. An opaque type, defined with "
"`@opaque` is a type where the internal structure of the type will not be "
"visible, but the type is still public."
msgstr ""
"`@typep`で定義された型はプライベートです。`@opaque`で定義されたopaque型は、型"
"の内部構造は不可視ですが、型は公開されます。"

#: deps/elixir/lib/elixir/pages/Typespecs.md:151
msgid ""
"Types can be parameterized by defining variables as parameters; these "
"variables can then be used to define the type."
msgstr ""
"型は変数をパラメタとして定義することによりパラメタライズすることができます。"
"これらの変数はその後、型の定義に使用できます。"

#: deps/elixir/lib/elixir/pages/Typespecs.md:155
msgid "## Defining a specification"
msgstr "## 仕様の定義"

#: deps/elixir/lib/elixir/pages/Typespecs.md:161
msgid ""
"Callbacks are used to define the callbacks functions of behaviours (see the "
"[\"Behaviours\"](behaviours.html) page in the documentation for more "
"information on behaviours)."
msgstr ""
"コールバックはビヘイビアのコールバック関数の定義に使用されます（ビヘイビアの"
"詳細についてはドキュメントの[“ビヘイビア”](behaviours.html) のページを参照し"
"てください）。"

#: deps/elixir/lib/elixir/pages/Typespecs.md:163
msgid ""
"Guards can be used to restrict type variables given as arguments to the "
"function."
msgstr "ガードは関数への引数として与えられる型変数の制限に使用できます。"

#: deps/elixir/lib/elixir/pages/Typespecs.md:167
msgid ""
"If you want to specify more than one variable, you separate them by a comma."
msgstr "2つ以上の変数を指定したい場合は、変数をカンマで分割します。"

#: deps/elixir/lib/elixir/pages/Typespecs.md:171
msgid "Type variables with no restriction can also be defined."
msgstr "制約なしの型変数も定義できます。"

#: deps/elixir/lib/elixir/pages/Typespecs.md:175
msgid ""
"You can also name your arguments in a typespec using `arg_name :: arg_type` "
"syntax. This is particularly useful in documentation as a way to "
"differentiate multiple arguments of the same type (or multiple elements of "
"the same type in a type definition):"
msgstr ""
"`arg_name :: arg_type`構文を使用して型仕様の引数に名前を付けることもできま"
"す。 これは、同じ型の複数の引数（または型定義内の同じ型の複数の要素）を区別す"
"る方法として、ドキュメントで特に役に立ちます。"

#: deps/elixir/lib/elixir/pages/Typespecs.md:180
msgid "Specifications can be overloaded just like ordinary functions."
msgstr "仕様は普通の関数のようにオーバーロードすることもできます。"

#: deps/elixir/lib/elixir/pages/Typespecs.md:185
msgid "## Notes"
msgstr "## 注記"

#: deps/elixir/lib/elixir/pages/Typespecs.md:187
msgid ""
"Elixir discourages the use of type `t:string/0` as it might be confused with "
"binaries which are referred to as \"strings\" in Elixir (as opposed to "
"character lists). In order to use the type that is called `t:string/0` in "
"Erlang, one has to use the `t:charlist/0` type which is a synonym for "
"`string`. If you use `string`, you'll get a warning from the compiler."
msgstr ""
"Elixirでは`t:string/0`の使用は推奨されません。Elixirでは（文字リストではな"
"く）「文字列」呼ばれるバイナリと混同される可能性があるからです。Erlangで`t:"
"string/0`と呼ばれる型を使用するには`string`の同義語である`t:charlist/0`型を使"
"用する必要があります。 `string`を使用すると、コンパイラから警告を受けます。"

#: deps/elixir/lib/elixir/pages/Typespecs.md:189
msgid ""
"If you want to refer to the \"string\" type (the one operated on by "
"functions in the `String` module), use `t:String.t/0` type instead.\n"
msgstr ""
"（`String`モジュールの関数で操作される）「文字列」型を参照したい場合は、`t:"
"String.t/0`型を使用します。\n"

#~ msgid ""
#~ "The attributes `@type`, `@opaque`, `@typep`, `@spec`, `@callback` and "
#~ "`@macrocallback` are the main mechanism for defining typespecs. See sub-"
#~ "sections \"Defining a type\" and \"Defining a specification\" below."
#~ msgstr ""
#~ "`@type`, `@opaque`, `@typep`, `@spec`, `@callback`と`@macrocallback` ア\n"
#~ "トリビュートがこのモジュールで定義されたマクロとしてモジュール内で評価\n"
#~ "されます。以下のサブセクション\"Defining a type\"と\"Defining a\n"
#~ "specification\"を参照してください。"

#~ msgid ""
#~ "The type syntax provided by Elixir is fairly similar to [the one in "
#~ "Erlang](http://www.erlang.org/doc/reference_manual/typespec.html)."
#~ msgstr ""
#~ "Elixirにより提供されるtypeシンタックスは[Erlangのも\n"
#~ "の](http://www.erlang.org/doc/reference_manual/typespec.html)によく似て\n"
#~ "います。"

#~ msgid ""
#~ "Most of the built-in types provided in Erlang (for example, `pid()`) are "
#~ "expressed the same way: `pid()` or simply `pid`. Parameterized types are "
#~ "also supported (`list(integer)`) and so are remote types (`Enum.t`)."
#~ msgstr ""
#~ "Erlangでのビルトインタイプの殆ど(例えば`pid()`)は同じ方法: `pid()`、あ\n"
#~ "るいはもっとシンプルに `pid`で表現されます。パラメタ化されたタイプ\n"
#~ "(`list(integer)`)や、リモートタイプ(`Enum.t`)もまたサポートされます。"

#~ msgid ""
#~ "Integers and atom literals are allowed as types (ex. `1`, `:atom` or "
#~ "`false`). All other types are built of unions of predefined types. "
#~ "Certain shorthands are allowed, such as `[...]`, `<<>>` and `{...}`."
#~ msgstr ""
#~ "整数とアトムリテラルはタイプとして許されます(例えば、`1`, `:atom`あるい"
#~ "は\n"
#~ "`false`)。他の全てのタイプは定義されたタイプの組み合わせにより作られま"
#~ "す。\n"
#~ "`[...]`、`<<>>`や`{...}`といった省略記法は許されます。"

#~ msgid ""
#~ "In map and struct type declarations such as `%{key: value}` or `"
#~ "%Struct{key: value}`, the key-value pair type information is not used by "
#~ "the current version of dialyzer.\n"
#~ msgstr ""
#~ "`%{key: value}`や`%Struct{key: value}`のようなマップと構造\n"
#~ "体の型の宣言で、key-valueペア型情報は現在のバージョンの\n"
#~ "dialyzerでは使用されません。\n"
