msgid ""
msgstr ""
"Project-Id-Version: l 10n_elixir\n"
"PO-Revision-Date: 2016-04-02 22:55+0900\n"
"Last-Translator: 小田 照敬 <EMAIL@ADDRESS>\n"
"Language-Team: Japanese\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: deps/elixir/lib/elixir/pages/Typespecs.md:1
msgid "# Typespecs"
msgstr "# Typespecs"

#: deps/elixir/lib/elixir/pages/Typespecs.md:3
#, fuzzy
msgid ""
"Elixir comes with a notation for declaring types and specifications. Elixir "
"is a dynamically typed language, and as such, type specifications are never "
"used by the compiler to optimize or modify code. Still, using type "
"specifications is useful because"
msgstr ""
"Elixirにはtypeとspecificationの宣言の為の記法があります。Elixirは動的に\n"
"型付けされ、だから、typespecはコンパイラによって最適化のためやコードの\n"
"変更のためには決して使われません。でも、typespecを使うことは文書化とバ\n"
"グを見付けるためにtypespecを使ってコードを解析する\n"
"[Dialyzer](http://www.erlang.org/doc/man/dialyzer.html) のようなツール\n"
"にとって役に立ちます。"

#: deps/elixir/lib/elixir/pages/Typespecs.md:5
msgid ""
"  * they provide documentation (for example, tools such as [ExDoc](https://"
"github.com/elixir-lang/ex_doc) show type specifications in the "
"documentation)\n"
"  * they're used by tools such as [Dialyzer](http://www.erlang.org/doc/man/"
"dialyzer.html), that can analyze code with typespec to find type "
"inconsistencies and possible bugs"
msgstr ""

#: deps/elixir/lib/elixir/pages/Typespecs.md:8
msgid ""
"Type specifications (sometimes referred to as *typespecs*) are defined in "
"different contexts using the following attributes:"
msgstr ""

#: deps/elixir/lib/elixir/pages/Typespecs.md:10
msgid ""
"  * `@type`\n"
"  * `@opaque`\n"
"  * `@typep`\n"
"  * `@spec`\n"
"  * `@callback`\n"
"  * `@macrocallback`"
msgstr ""

#: deps/elixir/lib/elixir/pages/Typespecs.md:17
msgid ""
"See the \"Defining a type\" and \"Defining a specification\" sub-sections "
"below for more information on defining types and typespecs."
msgstr ""

#: deps/elixir/lib/elixir/pages/Typespecs.md:19
msgid "## Types and their syntax"
msgstr "## Types and their syntax"

#: deps/elixir/lib/elixir/pages/Typespecs.md:21
msgid ""
"The syntax Elixir provides for type specifications is similar to [the one in "
"Erlang](http://www.erlang.org/doc/reference_manual/typespec.html). Most of "
"the built-in types provided in Erlang (for example, `pid()`) are expressed "
"in the same way: `pid()` (or simply `pid`). Parametrized types (such as "
"`list(integer)`) are supported as well and so are remote types (such as "
"`Enum.t`). Integers and atom literals are allowed as types (e.g., `1`, `:"
"atom`, or `false`). All other types are built out of unions of predefined "
"types. Some shorthands are allowed, such as `[...]`, `<<>>`, and `{...}`."
msgstr ""

#: deps/elixir/lib/elixir/pages/Typespecs.md:23
msgid "### Basic types"
msgstr "### Basic types"

#: deps/elixir/lib/elixir/pages/Typespecs.md:53
msgid "### Literals"
msgstr "### Literals"

#: deps/elixir/lib/elixir/pages/Typespecs.md:55
msgid "The following literals are also supported in typespecs:"
msgstr "typespecsでは以下のリテラルがサポートされます:"

#: deps/elixir/lib/elixir/pages/Typespecs.md:94
msgid "### Built-in types"
msgstr "### Built-in types"

#: deps/elixir/lib/elixir/pages/Typespecs.md:96
#, fuzzy
msgid ""
"The following types are also provided by Elixir as shortcuts on top of the "
"basic and literal types described above."
msgstr ""
"いくつかのタイプもまた、基本的かつリテラルのタイプの上にショートカット\n"
"としてElixirにより供給されます。"

#: deps/elixir/lib/elixir/pages/Typespecs.md:98
#, fuzzy
msgid ""
"Built-in type           | Defined as\n"
":---------------------- | :---------\n"
"`term()`                | `any()`\n"
"`arity()`               | `0..255`\n"
"`as_boolean(t)`         | `t`\n"
"`binary()`              | `<<_::_*8>>`\n"
"`bitstring()`           | `<<_::_*1>>`\n"
"`boolean()`             | `false` \\| `true`\n"
"`byte()`                | `0..255`\n"
"`char()`                | `0..0x10FFFF`\n"
"`charlist()`            | `[char()]`\n"
"`fun()`                 | `(... -> any)`\n"
"`identifier()`          | `pid()` \\| `port()` \\| `reference()`\n"
"`iodata()`              | `iolist()` \\| `binary()`\n"
"`iolist()`              | `maybe_improper_list(byte() \\| binary() \\| "
"iolist(), binary() \\| [])`\n"
"`keyword()`             | `[{atom(), any()}]`\n"
"`keyword(t)`            | `[{atom(), t}]`\n"
"`list()`                | `[any()]`\n"
"`nonempty_list()`       | `nonempty_list(any())`\n"
"`maybe_improper_list()` | `maybe_improper_list(any(), any())`\n"
"`nonempty_maybe_improper_list()` | `nonempty_maybe_improper_list(any(), "
"any())`\n"
"`mfa()`                 | `{module(), atom(), arity()}`\n"
"`module()`              | `atom()`\n"
"`no_return()`           | `none()`\n"
"`node()`                | `atom()`\n"
"`number()`              | `integer()` \\| `float()`\n"
"`struct()`              | `%{:__struct__ => atom(), optional(atom()) => "
"any()}`\n"
"`timeout()`             | `:infinity` \\| `non_neg_integer()`"
msgstr ""
"Built-in type           | Defined as\n"
":---------------------- | :---------\n"
"`term()`                | `any()`\n"
"`binary()`              | `<<_::_ * 8>>`\n"
"`bitstring()`           | `<<_::_ * 1>>`\n"
"`boolean()`             | `false` \\| `true`\n"
"`byte()`                | `0..255`\n"
"`char()`                | `0..0x10ffff`\n"
"`number()`              | `integer()` \\| `float()`\n"
"`char_list()`           | `[char()]`\n"
"`list()`                | `[any()]`\n"
"`maybe_improper_list()` | `maybe_improper_list(any(), any())`\n"
"`nonempty_list()`       | `nonempty_list(any())`\n"
"`iolist()`              | `maybe_improper_list(byte() \\| binary() \\| "
"iolist(), binary() \\| [])`\n"
"`iodata()`              | `iolist()` \\| `binary()`\n"
"`module()`              | `atom()` \\| `tuple()`\n"
"`arity()`               | `0..255`\n"
"`mfa()`                 | `{atom(), atom(), arity()}`\n"
"`identifier()`          | `pid()` \\| `port()` \\| `reference()`\n"
"`node()`                | `atom()`\n"
"`timeout()`             | `:infinity` \\| `non_neg_integer()`\n"
"`no_return()`           | `none()`\n"
"`fun()`                 | `(... -> any)`\n"
"`struct()`              | `%{__struct__: atom()}`\n"
"`as_boolean(t)`         | `t`\n"
"`keyword()`             | `[{atom(), any()}]`\n"
"`keyword(t)`            | `[{atom(), t}]`"

#: deps/elixir/lib/elixir/pages/Typespecs.md:127
msgid "### Remote types"
msgstr "### Remote types"

#: deps/elixir/lib/elixir/pages/Typespecs.md:129
#, fuzzy
msgid ""
"Any module is also able to define its own types and the modules in Elixir "
"are no exception. For example, the `Range` module defines a `t/0` type that "
"represents a range: this type can be referred to as `t:Range.t/0`. In a "
"similar fashion, a string is `t:String.t/0`, any enumerable can be `t:Enum."
"t/0`, and so on."
msgstr ""
"任意のモジュールもまたそれ自身のタイプの定義をすることが出来、\n"
"Elixirのモジュールも例外ではありません。例えば、文字列は`String.t`、\n"
"rangeは`Range.t`、任意のenumerableは`Enum.t`などとなります。"

#: deps/elixir/lib/elixir/pages/Typespecs.md:131
#, fuzzy
msgid "### Maps"
msgstr "### Basic types"

#: deps/elixir/lib/elixir/pages/Typespecs.md:133
msgid ""
"The key types in maps are allowed to overlap, and if they do, the leftmost "
"key takes precedence.\n"
"A map value does not belong to this type if it contains a key that is not in "
"the allowed map keys."
msgstr ""

#: deps/elixir/lib/elixir/pages/Typespecs.md:136
msgid ""
"If you want to denote that keys that were not previously defined in the map "
"are allowed,\n"
"it is common to end a map type with `optional(any) => any`."
msgstr ""

#: deps/elixir/lib/elixir/pages/Typespecs.md:139
msgid ""
"Notice that the syntactic representation of `map()` is `%{optional(any) => "
"any}`, not `%{}`. The notation `%{}` specifies the singleton type for the "
"empty map."
msgstr ""

#: deps/elixir/lib/elixir/pages/Typespecs.md:141
msgid "## Defining a type"
msgstr "## Defining a type"

#: deps/elixir/lib/elixir/pages/Typespecs.md:143
msgid ""
"The `@type`, `@typep`, and `@opaque` module attributes can be used to define "
"new types:"
msgstr ""

#: deps/elixir/lib/elixir/pages/Typespecs.md:149
msgid ""
"A type defined with `@typep` is private. An opaque type, defined with "
"`@opaque` is a type where the internal structure of the type will not be "
"visible, but the type is still public."
msgstr ""
"`@typep`で定義されたタイプはプライベートです。`@opaque`によって\n"
"定義されたopaqueタイプはタイプの内部構造が不可視となりますが、\n"
"タイプはパブリックのままです。"

#: deps/elixir/lib/elixir/pages/Typespecs.md:151
#, fuzzy
msgid ""
"Types can be parameterized by defining variables as parameters; these "
"variables can then be used to define the type."
msgstr ""
"変数はタイプを定義するために使うことができ、タイプは、変数を\n"
"使ってパラメタ化することもできます。"

#: deps/elixir/lib/elixir/pages/Typespecs.md:155
msgid "## Defining a specification"
msgstr "## Defining a specification"

#: deps/elixir/lib/elixir/pages/Typespecs.md:161
#, fuzzy
msgid ""
"Callbacks are used to define the callbacks functions of behaviours (see the "
"[\"Behaviours\"](behaviours.html) page in the documentation for more "
"information on behaviours)."
msgstr ""
"callbacksはビヘイビアのコールバック関数を定義するために使われます\n"
"(`Behaviour`を参照してください)。"

#: deps/elixir/lib/elixir/pages/Typespecs.md:163
msgid ""
"Guards can be used to restrict type variables given as arguments to the "
"function."
msgstr ""
"Guardsは関数の引数として与えられる変数の型を制限するために\n"
"使うことができます。"

#: deps/elixir/lib/elixir/pages/Typespecs.md:167
msgid ""
"If you want to specify more than one variable, you separate them by a comma."
msgstr ""

#: deps/elixir/lib/elixir/pages/Typespecs.md:171
msgid "Type variables with no restriction can also be defined."
msgstr "タイプ変数は制限なしで定義することもできます。"

#: deps/elixir/lib/elixir/pages/Typespecs.md:175
msgid ""
"You can also name your arguments in a typespec using `arg_name :: arg_type` "
"syntax. This is particularly useful in documentation as a way to "
"differentiate multiple arguments of the same type (or multiple elements of "
"the same type in a type definition):"
msgstr ""

#: deps/elixir/lib/elixir/pages/Typespecs.md:180
msgid "Specifications can be overloaded just like ordinary functions."
msgstr "specificationは普通の関数のようにオーバーロードすることが出来ます。"

#: deps/elixir/lib/elixir/pages/Typespecs.md:185
msgid "## Notes"
msgstr "## Notes"

#: deps/elixir/lib/elixir/pages/Typespecs.md:187
#, fuzzy
msgid ""
"Elixir discourages the use of type `t:string/0` as it might be confused with "
"binaries which are referred to as \"strings\" in Elixir (as opposed to "
"character lists). In order to use the type that is called `t:string/0` in "
"Erlang, one has to use the `t:charlist/0` type which is a synonym for "
"`string`. If you use `string`, you'll get a warning from the compiler."
msgstr ""
"Elixirは(文字のリストではなく)Elixirでの\"strings\"(文字列)として\n"
"参照されるバイナリと混同される可能性があるので、`string`タイプの\n"
"使用を推奨していません。Erlangで`string`と呼ばれているタイプを使\n"
"うためには、`string`のシノニムである`char_list`タイプを使う必要\n"
"があります。もし`string`を使用したらコンパイラから警告を受けるで\n"
"しょう。"

#: deps/elixir/lib/elixir/pages/Typespecs.md:189
#, fuzzy
msgid ""
"If you want to refer to the \"string\" type (the one operated on by "
"functions in the `String` module), use `t:String.t/0` type instead.\n"
msgstr ""
"もし(`String`モジュールの関数により操作される)\"string\"タイプを\n"
"好むなら、`String.t`タイプを代りに使ってください。"

#~ msgid ""
#~ "The attributes `@type`, `@opaque`, `@typep`, `@spec`, `@callback` and "
#~ "`@macrocallback` are the main mechanism for defining typespecs. See sub-"
#~ "sections \"Defining a type\" and \"Defining a specification\" below."
#~ msgstr ""
#~ "`@type`, `@opaque`, `@typep`, `@spec`, `@callback`と`@macrocallback` ア\n"
#~ "トリビュートがこのモジュールで定義されたマクロとしてモジュール内で評価\n"
#~ "されます。以下のサブセクション\"Defining a type\"と\"Defining a\n"
#~ "specification\"を参照してください。"

#~ msgid ""
#~ "The type syntax provided by Elixir is fairly similar to [the one in "
#~ "Erlang](http://www.erlang.org/doc/reference_manual/typespec.html)."
#~ msgstr ""
#~ "Elixirにより提供されるtypeシンタックスは[Erlangのも\n"
#~ "の](http://www.erlang.org/doc/reference_manual/typespec.html)によく似て\n"
#~ "います。"

#~ msgid ""
#~ "Most of the built-in types provided in Erlang (for example, `pid()`) are "
#~ "expressed the same way: `pid()` or simply `pid`. Parameterized types are "
#~ "also supported (`list(integer)`) and so are remote types (`Enum.t`)."
#~ msgstr ""
#~ "Erlangでのビルトインタイプの殆ど(例えば`pid()`)は同じ方法: `pid()`、あ\n"
#~ "るいはもっとシンプルに `pid`で表現されます。パラメタ化されたタイプ\n"
#~ "(`list(integer)`)や、リモートタイプ(`Enum.t`)もまたサポートされます。"

#~ msgid ""
#~ "Integers and atom literals are allowed as types (ex. `1`, `:atom` or "
#~ "`false`). All other types are built of unions of predefined types. "
#~ "Certain shorthands are allowed, such as `[...]`, `<<>>` and `{...}`."
#~ msgstr ""
#~ "整数とアトムリテラルはタイプとして許されます(例えば、`1`, `:atom`あるい"
#~ "は\n"
#~ "`false`)。他の全てのタイプは定義されたタイプの組み合わせにより作られま"
#~ "す。\n"
#~ "`[...]`、`<<>>`や`{...}`といった省略記法は許されます。"

#~ msgid ""
#~ "In map and struct type declarations such as `%{key: value}` or `"
#~ "%Struct{key: value}`, the key-value pair type information is not used by "
#~ "the current version of dialyzer.\n"
#~ msgstr ""
#~ "`%{key: value}`や`%Struct{key: value}`のようなマップと構造\n"
#~ "体の型の宣言で、key-valueペア型情報は現在のバージョンの\n"
#~ "dialyzerでは使用されません。\n"
