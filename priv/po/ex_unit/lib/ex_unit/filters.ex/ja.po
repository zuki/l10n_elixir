msgid ""
msgstr ""
"Project-Id-Version: l 10n_elixir\n"
"PO-Revision-Date: 2017-01-23 11:04+0900\n"
"Last-Translator: Keiji Suzuki <EMAIL@ADDRESS>\n"
"Language-Team: Japanese\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#. TRANSLATORS: def ExUnit.Filters.parse_path(file)
#: lib/ex_unit/filters.ex:8
msgid ""
"Parses filters out of a path.\n"
"\n"
"Determines whether a given file path (supplied to ExUnit/Mix as arguments\n"
"on the command line) includes a line number filter, and if so returns the\n"
"appropriate ExUnit configuration options.\n"
msgstr ""
"パスからフィルタをパースします。\n"
"\n"
"(コマンドライン引数としてExUnit/Mixに供給される)与えられた\n"
"ファイルパスが行番号フィルタを含んでいるか判定します。\n"
"含んでいる場合は、適切なExUnit構成オプションを返します。\n"

#. TRANSLATORS: def ExUnit.Filters.normalize(include, exclude)
#: lib/ex_unit/filters.ex:25
msgid ""
"Normalizes include and excludes to remove duplicates\n"
"and keep precedence.\n"
"\n"
"## Examples\n"
"\n"
"    iex> ExUnit.Filters.normalize(nil, nil)\n"
"    {[], []}\n"
"\n"
"    iex> ExUnit.Filters.normalize([:foo, :bar, :bar], [:foo, :baz])\n"
"    {[:foo, :bar], [:baz]}\n"
"\n"
msgstr ""
"重複を除去し優先度を保つためにincludeとexcludeを正規化します。\n"
"\n"
"## 例\n"
"\n"
"    iex> ExUnit.Filters.normalize(nil, nil)\n"
"    {[], []}\n"
"\n"
"    iex> ExUnit.Filters.normalize([:foo, :bar, :bar], [:foo, :baz])\n"
"    {[:foo, :bar], [:baz]}\n"
"\n"

#. TRANSLATORS: def ExUnit.Filters.parse(filters)
#: lib/ex_unit/filters.ex:45
msgid ""
"Parses the given filters, as one would receive from the command line.\n"
"\n"
"## Examples\n"
"\n"
"    iex> ExUnit.Filters.parse([\"foo:bar\", \"baz\", \"line:9\", \"bool:true"
"\"])\n"
"    [{:foo, \"bar\"}, :baz, {:line, \"9\"}, {:bool, \"true\"}]\n"
"\n"
msgstr ""
"コマンドラインから受け取ったものとして、指定のフィルタをパースします。\n"
"\n"
"## 例\n"
"\n"
"    iex> ExUnit.Filters.parse([\"foo:bar\", \"baz\", \"line:9\", \"bool:true"
"\"])\n"
"    [{:foo, \"bar\"}, :baz, {:line, \"9\"}, {:bool, \"true\"}]\n"
"\n"

#. TRANSLATORS: def ExUnit.Filters.eval(include, exclude, tags, collection)
#: lib/ex_unit/filters.ex:64
msgid ""
"Evaluates the `include` and `exclude` filters against the given `tags`.\n"
"\n"
"Some filters, like `:line`, may require the whole test collection to\n"
"find the closest line, that's why it must also be passed as argument.\n"
"\n"
"Filters can either be a regular expression or any data structure\n"
"that implements to `String.Chars`, which is invoked before comparing\n"
"the filter with the tag value.\n"
"\n"
"## Examples\n"
"\n"
"    iex> ExUnit.Filters.eval([foo: \"bar\"], [:foo], %{foo: \"bar\"}, [])\n"
"    :ok\n"
"\n"
"    iex> ExUnit.Filters.eval([foo: \"bar\"], [:foo], %{foo: \"baz\"}, [])\n"
"    {:error, \"due to foo filter\"}\n"
"\n"
msgstr ""
"指定された`tags`に対して`include`と`exclude`フィルタを評価します。\n"
"\n"
"`:line`など、最も近い行を見つけるためにテストコレクション全体を必要とするフィ"
"ルタも\n"
"あります。それが引数としてコレクションも渡されなければならない理由です。\n"
"\n"
"フィルタは正規表現、または、フィルタとタグ値が比較される前に\n"
"起動される`String.Chars`を実装している任意のデータ構造の\n"
"どちらかです。\n"
"\n"
"## 例\n"
"\n"
"    iex> ExUnit.Filters.eval([foo: \"bar\"], [:foo], %{foo: \"bar\"}, [])\n"
"    :ok\n"
"\n"
"    iex> ExUnit.Filters.eval([foo: \"bar\"], [:foo], %{foo: \"baz\"}, [])\n"
"    {:error, \"due to foo filter\"}\n"
"\n"

#. TRANSLATORS: Elixir.ExUnit.Filters Summary
#: lib/ex_unit/filters.ex:2
msgid "Conveniences for parsing and evaluating filters.\n"
msgstr "フィルタをパース・評価する便利ツールです。\n"
