#. TRANSLATORS: def ExUnit.Filters.normalize(include, exclude)
#: lib/ex_unit/filters.ex:25 
msgid ""
"Normalizes include and excludes to remove duplicates\n"
"and keep precedence.\n"
"\n"
"## Examples\n"
"\n"
"    iex> ExUnit.Filters.normalize(nil, nil)\n"
"    {[], []}\n"
"\n"
"    iex> ExUnit.Filters.normalize([:foo, :bar, :bar], [:foo, :baz])\n"
"    {[:foo, :bar], [:baz]}\n"
"\n"
msgstr ""
#. TRANSLATORS: def ExUnit.Filters.parse(filters)
#: lib/ex_unit/filters.ex:45 
msgid ""
"Parses the given filters, as one would receive from the command line.\n"
"\n"
"## Examples\n"
"\n"
"    iex> ExUnit.Filters.parse([\"foo:bar\", \"baz\", \"line:9\", \"bool:true\"])\n"
"    [{:foo, \"bar\"}, :baz, {:line, \"9\"}, {:bool, \"true\"}]\n"
"\n"
msgstr ""
#. TRANSLATORS: def ExUnit.Filters.eval(include, exclude, tags, collection)
#: lib/ex_unit/filters.ex:64 
msgid ""
"Evaluates the `include` and `exclude` filters against the given `tags`.\n"
"\n"
"Some filters, like `:line`, may require the whole test collection to\n"
"find the closest line, that's why it must also be passed as argument.\n"
"\n"
"Filters can either be a regular expression or any data structure\n"
"that implements to `String.Chars`, which is invoked before comparing\n"
"the filter with the tag value.\n"
"\n"
"## Examples\n"
"\n"
"    iex> ExUnit.Filters.eval([foo: \"bar\"], [:foo], %{foo: \"bar\"}, [])\n"
"    :ok\n"
"\n"
"    iex> ExUnit.Filters.eval([foo: \"bar\"], [:foo], %{foo: \"baz\"}, [])\n"
"    {:error, \"due to foo filter\"}\n"
"\n"
msgstr ""
#. TRANSLATORS: def ExUnit.Filters.parse_path(file)
#: lib/ex_unit/filters.ex:8 
msgid ""
"Parses filters out of a path.\n"
"\n"
"Determines whether a given file path (supplied to ExUnit/Mix as arguments\n"
"on the command line) includes a line number filter, and if so returns the\n"
"appropriate ExUnit configuration options.\n"
msgstr ""
#. TRANSLATORS: Elixir.ExUnit.Filters Summary
#: lib/ex_unit/filters.ex:2 
msgid ""
"Conveniences for parsing and evaluating filters.\n"
msgstr ""
