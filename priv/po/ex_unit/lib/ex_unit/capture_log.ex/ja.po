msgid ""
msgstr ""
"Project-Id-Version: l 10n_elixir\n"
"PO-Revision-Date: 2017-01-23 11:04+0900\n"
"Last-Translator: Keiji Suzuki <EMAIL@ADDRESS>\n"
"Language-Team: Japanese\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#. TRANSLATORS: def ExUnit.CaptureLog.capture_log(opts \\ [], fun)
#: lib/ex_unit/capture_log.ex:34
msgid ""
"Captures Logger messages generated when evaluating `fun`.\n"
"\n"
"Returns the binary which is the captured output.\n"
"\n"
"This function mutes the `:console` backend and captures any log\n"
"messages sent to Logger from the calling processes. It is possible\n"
"to ensure explicit log messages from other processes are captured\n"
"by waiting for their exit or monitor signal.\n"
"\n"
"However, `capture_log` does not guarantee to capture log messages\n"
"originated from processes spawned using a low level `Kernel` spawn\n"
"function (e.g. `Kernel.spawn/1`) and such processes exit with an\n"
"exception or a throw. Therefore, prefer using a `Task`, or other OTP\n"
"process, will send explicit logs before its exit or monitor signals\n"
"and will not cause VM generated log messages.\n"
"\n"
"Note that when the `async` is set to `true`, the messages from another\n"
"test might be captured. This is OK as long you consider such cases in\n"
"your assertions.\n"
"\n"
"It is possible to configure the level to capture with `:level`,\n"
"which will set the capturing level for the duration of the\n"
"capture, for instance, if the log level is set to :error\n"
"any message with the lower level will be ignored.\n"
"The default level is `nil`, which will capture all messages.\n"
"The behaviour is undetermined if async tests change Logger level.\n"
"\n"
"The format, metadata and colors can be configured with `:format`,\n"
"`:metadata` and `:colors` respectively. These three options\n"
"defaults to the `:console` backend configuration parameters.\n"
msgstr ""
"`fun`を評価した際に生成されたLoggerメッセージを捕捉します。\n"
"\n"
"捕捉された出力であるバイナリを返します。\n"
"\n"
"この関数は`:console`バックエンドを黙らせ、呼び出し元のプロセスから\n"
"Loggerに送られたすべてのログメッセージを補足します。他のプロセスからの\n"
"明示的なログメッセージをその終了やモニターシグナルを待つことにより補足\n"
"することを保証することが可能です。\n"
"\n"
"しかし、`capture_log`は（`Kernel.spawn/1`などの）低レベルな`Kernel`\n"
"spawn関数を使って生成されたプロセスに由来するログメッセージや例外による\n"
"終了または例外のスローの捕捉は保証しません。\n"
"\n"
"`async`が`true`にセットされている場合は、他のテストからのメッセージが\n"
"補足される場合があることに注意してください。これはアサーションの中で\n"
"そのようなケースを想定している限りは問題ありません。\n"
"\n"
"`:level`で捕捉するレベルを設定することができます。これは捕捉期間中の\n"
"捕捉レベルを設定します。たとえば、ログレベルを:errorに設定すると\n"
"それより低いレベルのメッセージは無視されます。デフォルトのレベルは\n"
"`nil`です。これはすべてのメッセージを捕捉します。非同期なテストが\n"
"Loggerレベルを変えると振る舞いは不定になります。\n"
"\n"
"フォーマット、メタデータ、カラーは各々、`:format`、`:metadata`、\n"
"`:colors`で設定できます。これら三つのオプションのデフォルトは\n"
"`:console`バックエンドの設定パラメタです。\n"

#. TRANSLATORS: Elixir.ExUnit.CaptureLog Summary
#: lib/ex_unit/capture_log.ex:2
msgid ""
"Functionality to capture logs for testing.\n"
"\n"
"## Examples\n"
"\n"
"    defmodule AssertionTest do\n"
"      use ExUnit.Case\n"
"\n"
"      import ExUnit.CaptureLog\n"
"\n"
"      test \"example\" do\n"
"        assert capture_log(fn ->\n"
"          Logger.error \"log msg\"\n"
"        end) =~ \"log msg\"\n"
"      end\n"
"\n"
"      test \"check multiple captures concurrently\" do\n"
"        fun = fn ->\n"
"          for msg <- [\"hello\", \"hi\"] do\n"
"            assert capture_log(fn -> Logger.error msg end) =~ msg\n"
"          end\n"
"          Logger.debug \"testing\"\n"
"        end\n"
"        assert capture_log(fun) =~ \"hello\"\n"
"        assert capture_log(fun) =~ \"testing\"\n"
"      end\n"
"    end\n"
"\n"
msgstr ""
"テスト用のlogを補足する機能です。\n"
"\n"
"## 例\n"
"\n"
"    defmodule AssertionTest do\n"
"      use ExUnit.Case\n"
"\n"
"      import ExUnit.CaptureLog\n"
"\n"
"      test \"example\" do\n"
"        assert capture_log(fn ->\n"
"          Logger.error \"log msg\"\n"
"        end) =~ \"log msg\"\n"
"      end\n"
"\n"
"      test \"check multiple captures concurrently\" do\n"
"        fun = fn ->\n"
"          for msg <- [\"hello\", \"hi\"] do\n"
"            assert capture_log(fn -> Logger.error msg end) =~ msg\n"
"          end\n"
"          Logger.debug \"testing\"\n"
"        end\n"
"        assert capture_log(fun) =~ \"hello\"\n"
"        assert capture_log(fun) =~ \"testing\"\n"
"      end\n"
"    end\n"
"\n"
