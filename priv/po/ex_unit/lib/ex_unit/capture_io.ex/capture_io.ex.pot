#. TRANSLATORS: Elixir.ExUnit.CaptureIO Summary
#: lib/ex_unit/capture_io.ex:2 
msgid ""
"Functionality to capture IO for testing.\n"
"\n"
"## Examples\n"
"\n"
"    defmodule AssertionTest do\n"
"      use ExUnit.Case\n"
"\n"
"      import ExUnit.CaptureIO\n"
"\n"
"      test \"example\" do\n"
"        assert capture_io(fn ->\n"
"          IO.puts \"a\"\n"
"        end) == \"a\\n\"\n"
"      end\n"
"\n"
"      test \"checking the return value and the IO output\" do\n"
"        fun = fn ->\n"
"          assert Enum.each([\"some\", \"example\"], &(IO.puts &1)) == :ok\n"
"        end\n"
"        assert capture_io(fun) == \"some\\nexample\\n\"\n"
"        # tip: or use only: \"capture_io(fun)\" to silence the IO output (so only assert the return value)\n"
"      end\n"
"    end\n"
"\n"
msgstr ""
#. TRANSLATORS: def ExUnit.CaptureIO.capture_io(fun)
#: lib/ex_unit/capture_io.ex:29 
msgid ""
"Captures IO generated when evaluating `fun`.\n"
"\n"
"Returns the binary which is the captured output.\n"
"\n"
"By default, `capture_io` replaces the `group_leader` (`:stdio`)\n"
"for the current process. However, the capturing of any other\n"
"named device, such as `:stderr`, is also possible globally by\n"
"giving the registered device name explicitly as an argument.\n"
"\n"
"Note that when capturing something other than `:stdio`,\n"
"the test should run with async false.\n"
"\n"
"When capturing `:stdio`, if the `:capture_prompt` option is `false`,\n"
"prompts (specified as arguments to `IO.get*` functions) are not\n"
"captured.\n"
"\n"
"A developer can set a string as an input. The default input is `:eof`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> capture_io(fn -> IO.write \"john\" end) == \"john\"\n"
"    true\n"
"\n"
"    iex> capture_io(:stderr, fn -> IO.write(:stderr, \"john\") end) == \"john\"\n"
"    true\n"
"\n"
"    iex> capture_io(\"this is input\", fn ->\n"
"    ...>   input = IO.gets \">\"\n"
"    ...>   IO.write input\n"
"    ...> end) == \">this is input\"\n"
"    true\n"
"\n"
"    iex> capture_io([input: \"this is input\", capture_prompt: false], fn ->\n"
"    ...>   input = IO.gets \">\"\n"
"    ...>   IO.write input\n"
"    ...> end) == \"this is input\"\n"
"    true\n"
"\n"
"## Returning values\n"
"\n"
"As seen in the examples above, `capture_io` returns the captured output.\n"
"If you want to also capture the result of the function executed inside\n"
"the `capture_io`, you can use `Kernel.send/2` to send yourself a message\n"
"and use `ExUnit.Assertions.assert_received/2` to match on the results:\n"
"\n"
"    capture_io([input: \"this is input\", capture_prompt: false], fn ->\n"
"      send self(), {:block_result, 42}\n"
"      # ...\n"
"    end)\n"
"\n"
"    assert_received {:block_result, 42}\n"
"\n"
msgstr ""
