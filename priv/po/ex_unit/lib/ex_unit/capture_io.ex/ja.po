msgid ""
msgstr ""
"Project-Id-Version: l 10n_elixir\n"
"PO-Revision-Date: 2017-01-23 11:04+0900\n"
"Last-Translator: Keiji Suzuki <EMAIL@ADDRESS>\n"
"Language-Team: Japanese\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#. TRANSLATORS: Elixir.ExUnit.CaptureIO Summary
#: lib/ex_unit/capture_io.ex:2
msgid ""
"Functionality to capture IO for testing.\n"
"\n"
"## Examples\n"
"\n"
"    defmodule AssertionTest do\n"
"      use ExUnit.Case\n"
"\n"
"      import ExUnit.CaptureIO\n"
"\n"
"      test \"example\" do\n"
"        assert capture_io(fn ->\n"
"          IO.puts \"a\"\n"
"        end) == \"a\\n\"\n"
"      end\n"
"\n"
"      test \"checking the return value and the IO output\" do\n"
"        fun = fn ->\n"
"          assert Enum.each([\"some\", \"example\"], &(IO.puts &1)) == :ok\n"
"        end\n"
"        assert capture_io(fun) == \"some\\nexample\\n\"\n"
"        # tip: or use only: \"capture_io(fun)\" to silence the IO output (so "
"only assert the return value)\n"
"      end\n"
"    end\n"
"\n"
msgstr ""
"テスト用のIOを捕捉する機能です。\n"
"\n"
"## 例\n"
"\n"
"    defmodule AssertionTest do\n"
"      use ExUnit.Case\n"
"\n"
"      import ExUnit.CaptureIO\n"
"\n"
"      test \"example\" do\n"
"        assert capture_io(fn ->\n"
"          IO.puts \"a\"\n"
"        end) == \"a\\n\"\n"
"      end\n"
"\n"
"      test \"checking the return value and the IO output\" do\n"
"        fun = fn ->\n"
"          assert Enum.each([\"some\", \"example\"], &(IO.puts &1)) == :ok\n"
"        end\n"
"        assert capture_io(fun) == \"some\\nexample\\n\"\n"
"        # tip: or use only: \"capture_io(fun)\" to silence the IO output (so "
"only assert the return value)\n"
"      end\n"
"    end\n"
"\n"

#. TRANSLATORS: def ExUnit.CaptureIO.capture_io(fun)
#: lib/ex_unit/capture_io.ex:29
msgid ""
"Captures IO generated when evaluating `fun`.\n"
"\n"
"Returns the binary which is the captured output.\n"
"\n"
"By default, `capture_io` replaces the `group_leader` (`:stdio`)\n"
"for the current process. However, the capturing of any other\n"
"named device, such as `:stderr`, is also possible globally by\n"
"giving the registered device name explicitly as an argument.\n"
"\n"
"Note that when capturing something other than `:stdio`,\n"
"the test should run with async false.\n"
"\n"
"When capturing `:stdio`, if the `:capture_prompt` option is `false`,\n"
"prompts (specified as arguments to `IO.get*` functions) are not\n"
"captured.\n"
"\n"
"A developer can set a string as an input. The default input is `:eof`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> capture_io(fn -> IO.write \"john\" end) == \"john\"\n"
"    true\n"
"\n"
"    iex> capture_io(:stderr, fn -> IO.write(:stderr, \"john\") end) == \"john"
"\"\n"
"    true\n"
"\n"
"    iex> capture_io(\"this is input\", fn ->\n"
"    ...>   input = IO.gets \">\"\n"
"    ...>   IO.write input\n"
"    ...> end) == \">this is input\"\n"
"    true\n"
"\n"
"    iex> capture_io([input: \"this is input\", capture_prompt: false], fn -"
">\n"
"    ...>   input = IO.gets \">\"\n"
"    ...>   IO.write input\n"
"    ...> end) == \"this is input\"\n"
"    true\n"
"\n"
"## Returning values\n"
"\n"
"As seen in the examples above, `capture_io` returns the captured output.\n"
"If you want to also capture the result of the function executed inside\n"
"the `capture_io`, you can use `Kernel.send/2` to send yourself a message\n"
"and use `ExUnit.Assertions.assert_received/2` to match on the results:\n"
"\n"
"    capture_io([input: \"this is input\", capture_prompt: false], fn ->\n"
"      send self(), {:block_result, 42}\n"
"      # ...\n"
"    end)\n"
"\n"
"    assert_received {:block_result, 42}\n"
"\n"
msgstr ""
"`fun`を評価中に生成されたIOを捕捉します。\n"
"\n"
"捕捉された出力であるバイナリを返します。\n"
"\n"
"`capture_io`は、デフォルトでカレントプロセスの\n"
"`group_leader`(`:stdio`)を置き換えます。しかし、引数として\n"
"登録済みのデバイス名を明に与えることにより`:stderr`などの\n"
"その他の任意の名前のデバイスをグローバルに補足することが可能です。\n"
"\n"
"`:stdio`以外の何か捕捉する際は、asyncをfalseにして走ら\n"
"テストを実行スべきであることに注意してください。\n"
"\n"
"`:stdio`を捕捉する際に、`:capture_prompt`オプションが`false`の場合は\n"
"(`IO.get*`関数への引数として指定された)プロンプトは捕捉されません。\n"
"\n"
"開発者は入力として文字列をセットできます。デフォルト入力は`:eof`です。\n"
"\n"
"## 例\n"
"\n"
"    iex> capture_io(fn -> IO.write \"john\" end) == \"john\"\n"
"    true\n"
"\n"
"    iex> capture_io(:stderr, fn -> IO.write(:stderr, \"john\") end) == \"john"
"\"\n"
"    true\n"
"\n"
"    iex> capture_io(\"this is input\", fn ->\n"
"    ...>   input = IO.gets \">\"\n"
"    ...>   IO.write input\n"
"    ...> end) == \">this is input\"\n"
"    true\n"
"\n"
"    iex> capture_io([input: \"this is input\", capture_prompt: false], fn -"
">\n"
"    ...>   input = IO.gets \">\"\n"
"    ...>   IO.write input\n"
"    ...> end) == \"this is input\"\n"
"    true\n"
"\n"
"## 値を返す\n"
"\n"
"上の例で見られるように、`capture_io`は捕捉された出力を返します。\n"
"`capture_io`の中で実行される関数の結果を捕捉したい場合は\n"
"`Kernel.send/2`を使って自分自身にメッセージを送信し、\n"
"`ExUnit.Assertions.assert_received/2`を使って結果にマッチさせることができま"
"す:\n"
"n\n"
"    capture_io([input: \"this is input\", capture_prompt: false], fn ->\n"
"      send self(), {:block_result, 42}\n"
"      # ...\n"
"    end)\n"
"\n"
"    assert_received {:block_result, 42}\n"
"\n"
