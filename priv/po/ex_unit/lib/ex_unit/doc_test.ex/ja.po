msgid ""
msgstr ""
"Project-Id-Version: l 10n_elixir\n"
"PO-Revision-Date: 2017-01-23 11:04+0900\n"
"Last-Translator: Keiji Suzuki <EMAIL@ADDRESS>\n"
"Language-Team: Japanese\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#. TRANSLATORS: defmacro ExUnit.DocTest.doctest(mod, opts \\ [])
#: lib/ex_unit/doc_test.ex:163
msgid ""
"This macro is used to generate ExUnit test cases for doctests.\n"
"\n"
"Calling `doctest(Module)` will generate tests for all doctests found\n"
"in the module `Module`\n"
"\n"
"Options can also be given:\n"
"\n"
"  * `:except` - generates tests for all functions except those listed\n"
"    (list of `{function, arity}` tuples, and/or `:moduledoc`).\n"
"\n"
"  * `:only` - generates tests only for functions listed\n"
"    (list of `{function, arity}` tuples, and/or `:moduledoc`).\n"
"\n"
"  * `:import` - when `true`, one can test a function defined in the module\n"
"    without referring to the module name. However, this is not feasible "
"when\n"
"    there is a clash with a module like Kernel. In these cases, `:import`\n"
"    should be set to `false` and a full `M.f` construct should be used.\n"
"\n"
"## Examples\n"
"\n"
"    doctest MyModule, except: [:moduledoc, trick_fun: 1]\n"
"\n"
"This macro is auto-imported with every `ExUnit.Case`.\n"
msgstr ""
"このマクロはdoctest用のExUnitテストケースの生成に\n"
"使用されます。\n"
"\n"
"`doctest(Module)`を呼び出すと、モジュール`Module`で見つけられた\n"
"すべてのdoctestのためのテストを生成します。\n"
"\n"
"以下のオプションも提供されています:\n"
"\n"
"  * `:except` - リスト (`{function, arity}`タプルまたは:moduledocのリスト)さ"
"れた\n"
"      関数を除外したすべての関数のテストを生成します\n"
"\n"
"  * `:only` - リスト (`{function, arity}`タプルまたは:moduledocのリスト)され"
"た\n"
"    関数のみのテストを生成します。\n"
"\n"
"  * `:import` - `true`の場合、モジュール名を参照することなく、\n"
"    モジュールで定義された関数をテストできます。しかしながら、\n"
"     Kernelのようなモジュールとの衝突がある場合はこれはできません。\n"
"     このような場合は`import`を`false`にセットし、完全な`M.f`文法を\n"
"     使わなければなりません。\n"
"\n"
"## 例\n"
"\n"
"    doctest MyModule, except: [:moduledoc, trick_fun: 1]\n"
"\n"
"このマクロは、`ExUnit.Case`ごとに自動的にインポートされます。\n"

#. TRANSLATORS: Elixir.ExUnit.DocTest Summary
#: lib/ex_unit/doc_test.ex:2
msgid ""
"ExUnit.DocTest implements functionality similar to [Python's\n"
"doctest](https://docs.python.org/2/library/doctest.html).\n"
"\n"
"It allows us to generate tests from the code\n"
"examples in a module/function/macro's documentation.\n"
"To do this, invoke the `doctest/1` macro from within\n"
"your test case and ensure your code examples are written\n"
"according to the syntax and guidelines below.\n"
"\n"
"## Syntax\n"
"\n"
"Every new test starts on a new line, with an `iex>` prefix.\n"
"Multiline expressions can be used by prefixing subsequent lines with either\n"
"`...>` (recommended) or `iex>`.\n"
"\n"
"The expected result should start at the next line after the `iex>`\n"
"or `...>` line(s) and is terminated either by a newline, new\n"
"`iex>` prefix or the end of the string literal.\n"
"\n"
"## Examples\n"
"\n"
"To run doctests include them in an ExUnit case with a `doctest` macro:\n"
"\n"
"    defmodule MyModule.Test do\n"
"      use ExUnit.Case, async: true\n"
"      doctest MyModule\n"
"    end\n"
"\n"
"The `doctest` macro loops through all functions and\n"
"macros defined in `MyModule`, parsing their documentation in\n"
"search of code examples.\n"
"\n"
"A very basic example is:\n"
"\n"
"    iex> 1+1\n"
"    2\n"
"\n"
"Expressions on multiple lines are also supported:\n"
"\n"
"    iex> Enum.map [1, 2, 3], fn(x) ->\n"
"    ...>   x * 2\n"
"    ...> end\n"
"    [2, 4, 6]\n"
"\n"
"Multiple results can be checked within the same test:\n"
"\n"
"    iex> a = 1\n"
"    1\n"
"    iex> a + 1\n"
"    2\n"
"\n"
"If you want to keep any two tests separate,\n"
"add an empty line between them:\n"
"\n"
"    iex> a = 1\n"
"    1\n"
"\n"
"    iex> a + 1  # will fail with a \"undefined function a/0\" error\n"
"    2\n"
"\n"
"If you don't want to assert for every result in a doctest, you can omit\n"
"the result:\n"
"\n"
"    iex> pid = spawn fn -> :ok end\n"
"    iex> is_pid(pid)\n"
"    true\n"
"\n"
"This is useful when the result is something variable (like a PID in the\n"
"example above) or when the result is a complicated data structure and you\n"
"don't want to show it all, but just parts of it or some of its properties.\n"
"\n"
"Similarly to IEx you can use numbers in your \"prompts\":\n"
"\n"
"    iex(1)> [1 + 2,\n"
"    ...(1)>  3]\n"
"    [3, 3]\n"
"\n"
"This is useful in two cases:\n"
"\n"
"  * being able to refer to specific numbered scenarios\n"
"  * copy-pasting examples from an actual IEx session\n"
"\n"
"You can also select or skip functions when calling\n"
"`doctest`. See the documentation on the `:except` and `:only` options below\n"
"for more info.\n"
"\n"
"## Opaque types\n"
"\n"
"Some types' internal structures are kept hidden and instead show a\n"
"user-friendly structure when inspected. The idiom in\n"
"Elixir is to print those data types in the format `#Name<...>`. Because "
"those\n"
"values are treated as comments in Elixir code due to the leading\n"
"`#` sign, they require special care when being used in doctests.\n"
"\n"
"Imagine you have a map that contains a MapSet and is printed as:\n"
"\n"
"    %{users: #MapSet<[:foo, :bar]>}\n"
"\n"
"If you try to match on such an expression, `doctest` will fail to compile.\n"
"There are two ways to resolve this.\n"
"\n"
"The first is to rely on the fact that doctest can compare internal\n"
"structures as long as they are at the root. So one could write:\n"
"\n"
"    iex> map = %{users: Enum.into([:foo, :bar], MapSet.new)}\n"
"    iex> map.users\n"
"    #MapSet<[:foo, :bar]>\n"
"\n"
"Whenever a doctest starts with \"#Name<\", `doctest` will perform a string\n"
"comparison. For example, the above test will perform the following match:\n"
"\n"
"    inspect(map.users) == \"#MapSet<[:foo, :bar]>\"\n"
"\n"
"Alternatively, since doctest results are actually evaluated, you can have\n"
"the MapSet building expression as the doctest result:\n"
"\n"
"    iex> %{users: Enum.into([:foo, :bar], MapSet.new)}\n"
"    %{users: Enum.into([:foo, :bar], MapSet.new)}\n"
"\n"
"The downside of this approach is that the doctest result is not really\n"
"what users would see in the terminal.\n"
"\n"
"## Exceptions\n"
"\n"
"You can also showcase expressions raising an exception, for example:\n"
"\n"
"    iex(1)> String.to_atom((fn() -> 1 end).())\n"
"    ** (ArgumentError) argument error\n"
"\n"
"What DocTest will be looking for is a line starting with `** (` and it\n"
"will parse it accordingly to extract the exception name and message.\n"
"At this moment, the exception parser would make the parser treat the next\n"
"line as a start of a completely new expression (if it is prefixed with "
"`iex>`)\n"
"or a no-op line with documentation. Thus, multiline messages are not\n"
"supported.\n"
"\n"
"## When not to use doctest\n"
"\n"
"In general, doctests are not recommended when your code examples contain\n"
"side effects. For example, if a doctest prints to standard output, doctest\n"
"will not try to capture the output.\n"
"\n"
"Similarly, doctests do not run in any kind of sandbox. So any module\n"
"defined in a code example is going to linger throughout the whole test\n"
"suite run.\n"
msgstr ""
"ExUnit.DocTestは、[Pythonのdoctest](http://docs.python.org/2/library/doctest."
"html)に\n"
"似た機能を実装しています。\n"
"\n"
"モジュール/関数/マクロのドキュメントに存在しているコード例から\n"
"テストを生成できます。これを行うには、テストケース内で\n"
"`doctest/1`マクロを起動します。また、コード例は以下に示す\n"
"構文とガイドラインにそって書く必要があります。\n"
"\n"
"## 構文\n"
"\n"
"すべての新規テストは、`iex>`を先頭に持つ新しい行から始めます。\n"
"複数行の式は後続行に`...>`（推奨）または`iex>`を前につけることにより\n"
"使用することができます。\n"
"\n"
"期待される結果は、`iex>`または`...>`行の次の行から開始し、改行または\n"
"新たな`iex`接頭辞、文字列リテラルの終了のいずれかで終わらなければ\n"
"なりません。\n"
"## 例\n"
"\n"
"ドックテストを実行するには、`doctest`マクロを持つExUnitケース内にそれを含めま"
"す:\n"
"\n"
"    defmodule MyModule.Test do\n"
"      use ExUnit.Case, async: true\n"
"      doctest MyModule\n"
"    end\n"
"\n"
"`doctest`マクロは`MyModule`で定義されたすべての\n"
"関数とマクロをループし、コード例を探してドキュメントを\n"
"パースします。\n"
"\n"
"非常に基本的な例は次の通りです:\n"
"\n"
"    iex> 1+1\n"
"    2\n"
"\n"
"複数行の式もサポートされています:\n"
"\n"
"    iex> Enum.map [1, 2, 3], fn(x) ->\n"
"    ...>   x * 2\n"
"    ...> end\n"
"    [2, 4, 6]\n"
"\n"
"同じテストの中で、複数の結果をチェックできます:\n"
"\n"
"    iex> a = 1\n"
"    1\n"
"    iex> a + 1\n"
"    2\n"
"\n"
"２つのテストを分離したい場合は、それらの間に\n"
"空行を追加してください:\n"
"\n"
"    iex> a = 1\n"
"    1\n"
"\n"
"    iex> a + 1  # will fail with a \"undefined function a/0\" error\n"
"    2\n"
"\n"
"doctestのすべての結果をassertしたくない場合は、結果を省略\n"
"できます:\n"
"\n"
"    iex> pid = spawn fn -> :ok end\n"
"    iex> is_pid(pid)\n"
"    true\n"
"\n"
"これは、結果が(上の例のpidのような)何らかの変数である場合や\n"
"結果が複雑なデータ構造ですべてを表示したくはないが、その一部や\n"
"いくつかのプロパティを表示したい場合に便利です。\n"
"\n"
"IExと同様に、\"プロンプト\"に番号を使うことができます:\n"
"\n"
"    iex(1)> [1 + 2,\n"
"    ...(1)>  3]\n"
"    [3, 3]\n"
"\n"
"これは２つのケースで役に立ちます:\n"
"\n"
"  * 特定の番号付けられたシナリオを参照することができること\n"
"  * 実際のIExセッションから例をコピーペーストができること\n"
"\n"
"さらに、`doctest`を呼ぶ際に関数を選択したりスキップしたり\n"
"することもできます。詳細は下記の`:except`や`:only`オプションの\n"
"ドキュメントを参照してください。\n"
"\n"
"## オパーク型\n"
"\n"
"型の中には内部構造を隠蔽し、インスペクト時にはユーザフレンドリな\n"
"構造を表示するものがあります。Elixirのイディオムではそのようなデータ型は\n"
"`#Name<...>`フォーマットで表示します。こららの値は`#`記号で\n"
"始まっているのでElixirのコードではコメントとして扱われますので、\n"
"doctestで使用される際には特別な注意が必要です。\n"
"\n"
"MapSetを含むマップがあり、次のように表示されるとします:\n"
"\n"
"    %{users: #MapSet<[:foo, :bar]>}\n"
"\n"
"このような式にマッチしようとした場合、`doctest`はコンパイルに\n"
"失敗します。これを解決するには２つの方法があります。\n"
"\n"
"１つは、それらがルートにある限り、doctestは内部構造を\n"
"比較できるという事実に頼ることです。それで次のように書けます:\n"
"\n"
"    iex> map = %{users: Enum.into([:foo, :bar], MapSet.new)}\n"
"    iex> map.users\n"
"    #MapSet<[:foo, :bar]>\n"
"\n"
"doctestが”#Name<\"で初まる場合は常に`doctest`は文字列比較を\n"
"行います。たとえば、上のテストは次のマッチを行います:\n"
"\n"
"    inspect(map.users) == \"#MapSet<[:foo, :bar]>\"\n"
"\n"
"もう１つの方法は、doctestの結果は実際に評価されるので、\n"
"doctestの結果として式を構築するMapSetを持つことができます:\n"
"\n"
"    iex> %{users: Enum.into([:foo, :bar], MapSet.new)}\n"
"    %{users: Enum.into([:foo, :bar], MapSet.new)}\n"
"\n"
"このアプローチの不利な面は、doctestの結果は\n"
"ユーザが実際に端末で見るものではないことです。\n"
"\n"
"## 例外\n"
"\n"
"例外を発生する式を示すこともできます。例えば:\n"
"\n"
"    iex(1)> String.to_atom((fn() -> 1 end).())\n"
"    ** (ArgumentError) argument error\n"
"\n"
"DocTestが探すものは`**(`で始まる行であり、それをパースし、\n"
"例外名とメッセージを抽出します。この段階では\n"
"例外パーサは、パーサが次の行を(それが`iex>`で始まっていれば)\n"
"完全に新しい式の開始か、ドキュメンのno-opの行として扱うように\n"
"します。したがって、複数行のメッセージはサポートされて\n"
"いません。\n"
"\n"
"## doctestを使わない場合\n"
"\n"
"一般に、コード例が副作用を含んでいる場合はdoctestは推奨されません。\n"
"たとえば、doctestが標準出力に出力する場合、doctestは出力を捕捉\n"
"しようとしません。\n"
"\n"
"同様に、doctestはいかなる種類のサンドボックスでも実行されません。\n"
"したがって、コード例の中で定義されたモジュールは、テストスイート\n"
"全体の実行中、居座ることになります。\n"
