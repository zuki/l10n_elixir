#. TRANSLATORS: Elixir.ExUnit.DocTest Summary
#: lib/ex_unit/doc_test.ex:2 
msgid ""
"ExUnit.DocTest implements functionality similar to [Python's\n"
"doctest](https://docs.python.org/2/library/doctest.html).\n"
"\n"
"It allows us to generate tests from the code\n"
"examples in a module/function/macro's documentation.\n"
"To do this, invoke the `doctest/1` macro from within\n"
"your test case and ensure your code examples are written\n"
"according to the syntax and guidelines below.\n"
"\n"
"## Syntax\n"
"\n"
"Every new test starts on a new line, with an `iex>` prefix.\n"
"Multiline expressions can be used by prefixing subsequent lines with either\n"
"`...>` (recommended) or `iex>`.\n"
"\n"
"The expected result should start at the next line after the `iex>`\n"
"or `...>` line(s) and is terminated either by a newline, new\n"
"`iex>` prefix or the end of the string literal.\n"
"\n"
"## Examples\n"
"\n"
"To run doctests include them in an ExUnit case with a `doctest` macro:\n"
"\n"
"    defmodule MyModule.Test do\n"
"      use ExUnit.Case, async: true\n"
"      doctest MyModule\n"
"    end\n"
"\n"
"The `doctest` macro loops through all functions and\n"
"macros defined in `MyModule`, parsing their documentation in\n"
"search of code examples.\n"
"\n"
"A very basic example is:\n"
"\n"
"    iex> 1+1\n"
"    2\n"
"\n"
"Expressions on multiple lines are also supported:\n"
"\n"
"    iex> Enum.map [1, 2, 3], fn(x) ->\n"
"    ...>   x * 2\n"
"    ...> end\n"
"    [2, 4, 6]\n"
"\n"
"Multiple results can be checked within the same test:\n"
"\n"
"    iex> a = 1\n"
"    1\n"
"    iex> a + 1\n"
"    2\n"
"\n"
"If you want to keep any two tests separate,\n"
"add an empty line between them:\n"
"\n"
"    iex> a = 1\n"
"    1\n"
"\n"
"    iex> a + 1  # will fail with a \"undefined function a/0\" error\n"
"    2\n"
"\n"
"If you don't want to assert for every result in a doctest, you can omit\n"
"the result:\n"
"\n"
"    iex> pid = spawn fn -> :ok end\n"
"    iex> is_pid(pid)\n"
"    true\n"
"\n"
"This is useful when the result is something variable (like a PID in the\n"
"example above) or when the result is a complicated data structure and you\n"
"don't want to show it all, but just parts of it or some of its properties.\n"
"\n"
"Similarly to IEx you can use numbers in your \"prompts\":\n"
"\n"
"    iex(1)> [1 + 2,\n"
"    ...(1)>  3]\n"
"    [3, 3]\n"
"\n"
"This is useful in two cases:\n"
"\n"
"  * being able to refer to specific numbered scenarios\n"
"  * copy-pasting examples from an actual IEx session\n"
"\n"
"You can also select or skip functions when calling\n"
"`doctest`. See the documentation on the `:except` and `:only` options below\n"
"for more info.\n"
"\n"
"## Opaque types\n"
"\n"
"Some types' internal structures are kept hidden and instead show a\n"
"user-friendly structure when inspected. The idiom in\n"
"Elixir is to print those data types in the format `#Name<...>`. Because those\n"
"values are treated as comments in Elixir code due to the leading\n"
"`#` sign, they require special care when being used in doctests.\n"
"\n"
"Imagine you have a map that contains a MapSet and is printed as:\n"
"\n"
"    %{users: #MapSet<[:foo, :bar]>}\n"
"\n"
"If you try to match on such an expression, `doctest` will fail to compile.\n"
"There are two ways to resolve this.\n"
"\n"
"The first is to rely on the fact that doctest can compare internal\n"
"structures as long as they are at the root. So one could write:\n"
"\n"
"    iex> map = %{users: Enum.into([:foo, :bar], MapSet.new)}\n"
"    iex> map.users\n"
"    #MapSet<[:foo, :bar]>\n"
"\n"
"Whenever a doctest starts with \"#Name<\", `doctest` will perform a string\n"
"comparison. For example, the above test will perform the following match:\n"
"\n"
"    inspect(map.users) == \"#MapSet<[:foo, :bar]>\"\n"
"\n"
"Alternatively, since doctest results are actually evaluated, you can have\n"
"the MapSet building expression as the doctest result:\n"
"\n"
"    iex> %{users: Enum.into([:foo, :bar], MapSet.new)}\n"
"    %{users: Enum.into([:foo, :bar], MapSet.new)}\n"
"\n"
"The downside of this approach is that the doctest result is not really\n"
"what users would see in the terminal.\n"
"\n"
"## Exceptions\n"
"\n"
"You can also showcase expressions raising an exception, for example:\n"
"\n"
"    iex(1)> String.to_atom((fn() -> 1 end).())\n"
"    ** (ArgumentError) argument error\n"
"\n"
"What DocTest will be looking for is a line starting with `** (` and it\n"
"will parse it accordingly to extract the exception name and message.\n"
"At this moment, the exception parser would make the parser treat the next\n"
"line as a start of a completely new expression (if it is prefixed with `iex>`)\n"
"or a no-op line with documentation. Thus, multiline messages are not\n"
"supported.\n"
"\n"
"## When not to use doctest\n"
"\n"
"In general, doctests are not recommended when your code examples contain\n"
"side effects. For example, if a doctest prints to standard output, doctest\n"
"will not try to capture the output.\n"
"\n"
"Similarly, doctests do not run in any kind of sandbox. So any module\n"
"defined in a code example is going to linger throughout the whole test\n"
"suite run.\n"
msgstr ""
#. TRANSLATORS: defmacro ExUnit.DocTest.doctest(mod, opts \\ [])
#: lib/ex_unit/doc_test.ex:163 
msgid ""
"This macro is used to generate ExUnit test cases for doctests.\n"
"\n"
"Calling `doctest(Module)` will generate tests for all doctests found\n"
"in the module `Module`\n"
"\n"
"Options can also be given:\n"
"\n"
"  * `:except` - generates tests for all functions except those listed\n"
"    (list of `{function, arity}` tuples, and/or `:moduledoc`).\n"
"\n"
"  * `:only` - generates tests only for functions listed\n"
"    (list of `{function, arity}` tuples, and/or `:moduledoc`).\n"
"\n"
"  * `:import` - when `true`, one can test a function defined in the module\n"
"    without referring to the module name. However, this is not feasible when\n"
"    there is a clash with a module like Kernel. In these cases, `:import`\n"
"    should be set to `false` and a full `M.f` construct should be used.\n"
"\n"
"## Examples\n"
"\n"
"    doctest MyModule, except: [:moduledoc, trick_fun: 1]\n"
"\n"
"This macro is auto-imported with every `ExUnit.Case`.\n"
msgstr ""
