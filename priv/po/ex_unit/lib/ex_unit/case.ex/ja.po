msgid ""
msgstr ""
"Project-Id-Version: l 10n_elixir\n"
"PO-Revision-Date: 2017-01-23 11:04+0900\n"
"Last-Translator: Keiji Suzuki <EMAIL@ADDRESS>\n"
"Language-Team: Japanese\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#. TRANSLATORS: defmacro ExUnit.Case.describe(message, list)
#: lib/ex_unit/case.ex:284
msgid ""
"Describes tests together.\n"
"\n"
"Every describe block receives a name which is used as prefix for\n"
"upcoming tests. Inside a block, `ExUnit.Callbacks.setup/1` may be\n"
"invoked and it will define a setup callback to run only for the\n"
"current block. The describe name is also added as a tag, allowing\n"
"developers to run tests for specific blocks.\n"
"\n"
"## Examples\n"
"\n"
"    defmodule StringTest do\n"
"      use ExUnit.Case, async: true\n"
"\n"
"      describe \"String.capitalize/1\" do\n"
"        test \"first grapheme is in uppercase\" do\n"
"          assert String.capitalize(\"hello\") == \"Hello\"\n"
"        end\n"
"\n"
"        test \"converts remaining graphemes to lowercase\" do\n"
"          assert String.capitalize(\"HELLO\") == \"Hello\"\n"
"        end\n"
"      end\n"
"    end\n"
"\n"
"When using Mix, you can run all tests in a describe block as:\n"
"\n"
"    mix test --only describe:\"String.capitalize/1\"\n"
"\n"
"Note describe blocks cannot be nested. Instead of relying on hierarchy\n"
"for composition, developers should build on top of named setups. For\n"
"example:\n"
"\n"
"    defmodule UserManagementTest do\n"
"      use ExUnit.Case, async: true\n"
"\n"
"      describe \"when user is logged in and is an admin\" do\n"
"        setup [:log_user_in, :set_type_to_admin]\n"
"\n"
"        test ...\n"
"      end\n"
"\n"
"      describe \"when user is logged in and is a manager\" do\n"
"        setup [:log_user_in, :set_type_to_manager]\n"
"\n"
"        test ...\n"
"      end\n"
"\n"
"      defp log_user_in(context) do\n"
"        # ...\n"
"      end\n"
"    end\n"
"\n"
"By forbidding hierarchies in favor of named setups, it is straight-forward\n"
"for the developer to glance at each describe block and know exactly the\n"
"setup steps involved.\n"
msgstr ""
"テストをまとめて記述します。\n"
"\n"
"すべての記述ブロックは続くテストの接頭辞として使用される名前を受取ります。\n"
"ブロック内では`ExUnit.Callbacks.setup/1` を起動することができます。\n"
"これはカレントブロックでのみ実行するsetupコールバックを定義します。\n"
"記述名はタグとしても追加されます。これにより開発者は特定のブロックのテスト"
"を\n"
"実行することができます。\n"
"\n"
"## 例\n"
"\n"
"    defmodule StringTest do\n"
"      use ExUnit.Case, async: true\n"
"\n"
"      describe \"String.capitalize/1\" do\n"
"        test \"first grapheme is in uppercase\" do\n"
"          assert String.capitalize(\"hello\") == \"Hello\"\n"
"        end\n"
"\n"
"        test \"converts remaining graphemes to lowercase\" do\n"
"          assert String.capitalize(\"HELLO\") == \"Hello\"\n"
"        end\n"
"      end\n"
"    end\n"
"\n"
"Mixを使う際に、次のようにして記述ブロック内のすべてのテストを実行できます。\n"
"\n"
"    mix test --only describe:\"String.capitalize/1\"\n"
"\n"
"記述ブロックはネストできないことに注意してください。開発者は階層構造に依存\n"
"するのではなく、名前付けセットアップで構築するべきです。\n"
"たとえば、\n"
"\n"
"    defmodule UserManagementTest do\n"
"      use ExUnit.Case, async: true\n"
"\n"
"      describe \"when user is logged in and is an admin\" do\n"
"        setup [:log_user_in, :set_type_to_admin]\n"
"\n"
"        test ...\n"
"      end\n"
"\n"
"      describe \"when user is logged in and is a manager\" do\n"
"        setup [:log_user_in, :set_type_to_manager]\n"
"\n"
"        test ...\n"
"      end\n"
"\n"
"      defp log_user_in(context) do\n"
"        # ...\n"
"      end\n"
"    end\n"
"\n"
"階層化を禁じ名前付けセットアップを選択することは、各記述ブロックを\n"
"一瞥しただけで含まれているセットアップステップを正確に理解できるので\n"
"開発者にとって分かりやすいものです。\n"

#. TRANSLATORS: def ExUnit.Case.register_attribute(env, name, opts \\ [])
#: lib/ex_unit/case.ex:435
msgid ""
"Registers a new attribute to be used during `ExUnit.Case` tests.\n"
"\n"
"The attribute values will be available as a key/value pair in\n"
"`context.registered`. The key/value pairs will be cleared\n"
"after each `ExUnit.Case.test/3` similar to `@tag`.\n"
"\n"
"`Module.register_attribute/3` is used to register the attribute,\n"
"this function takes the same options.\n"
"\n"
"## Examples\n"
"\n"
"    defmodule MyTest do\n"
"      use ExUnit.Case\n"
"      ExUnit.Case.register_attribute __ENV__, :foobar\n"
"\n"
"      @foobar hello: \"world\"\n"
"      test \"using custom test attribute\", context do\n"
"        assert context.registered.hello == \"world\"\n"
"      end\n"
"    end\n"
msgstr ""
"`ExUnit.Case`テスト内で使われる新しい属性を登録します。\n"
"\n"
"属性値は`context.registered`のkey/valueペアとして\n"
"利用可能になります。key/valueペアは`@tag`同様\n"
"各`ExUnit.Case.test`実行後にクリアされます。\n"
"\n"
"`Module.register_attribute/3`は属性の登録に使われますが、\n"
"この関数も同じオプションを取ります。\n"
"\n"
"## 例\n"
"\n"
"    defmodule MyTest do\n"
"      use ExUnit.Case\n"
"      ExUnit.Case.register_attribute __ENV__, :foobar\n"
"\n"
"      @foobar hello: \"world\"\n"
"      test \"using custom test attribute\", context do\n"
"        assert context.registered.hello == \"world\"\n"
"      end\n"
"    end\n"

#. TRANSLATORS: Elixir.ExUnit.Case Summary
#: lib/ex_unit/case.ex:6
msgid ""
"Sets up an ExUnit test case.\n"
"\n"
"This module must be used in other modules as a way to configure\n"
"and prepare them for testing.\n"
"\n"
"When used, it accepts the following options:\n"
"\n"
"  * `:async` - configure this specific test case to able to run in parallel\n"
"    with other test cases. May be used for performance when this test case\n"
"    does not change any global state. Defaults to `false`.\n"
"\n"
"This module automatically includes all callbacks defined in\n"
"`ExUnit.Callbacks`. See that module's documentation for more\n"
"information.\n"
"\n"
"## Examples\n"
"\n"
"     defmodule AssertionTest do\n"
"       # Use the module\n"
"       use ExUnit.Case, async: true\n"
"\n"
"       # The \"test\" macro is imported by ExUnit.Case\n"
"       test \"always pass\" do\n"
"         assert true\n"
"       end\n"
"     end\n"
"\n"
"## Context\n"
"\n"
"All tests receive a context as an argument. The context is particularly\n"
"useful for sharing information between callbacks and tests:\n"
"\n"
"    defmodule KVTest do\n"
"      use ExUnit.Case\n"
"\n"
"      setup do\n"
"        {:ok, pid} = KV.start_link\n"
"        {:ok, [pid: pid]}\n"
"      end\n"
"\n"
"      test \"stores key-value pairs\", context do\n"
"        assert KV.put(context[:pid], :hello, :world) == :ok\n"
"        assert KV.get(context[:pid], :hello) == :world\n"
"      end\n"
"    end\n"
"\n"
"As the context is a map, it can be pattern matched on to extract\n"
"information:\n"
"\n"
"    test \"stores key-value pairs\", %{pid: pid} do\n"
"      assert KV.put(pid, :hello, :world) == :ok\n"
"      assert KV.get(pid, :hello) == :world\n"
"    end\n"
"\n"
"## Tags\n"
"\n"
"The context is used to pass information from the callbacks to\n"
"the test. In order to pass information from the test to the\n"
"callback, ExUnit provides tags.\n"
"\n"
"By tagging a test, the tag value can be accessed in the context,\n"
"allowing the developer to customize the test. Let's see an\n"
"example:\n"
"\n"
"    defmodule FileTest do\n"
"      # Changing directory cannot be async\n"
"      use ExUnit.Case, async: false\n"
"\n"
"      setup context do\n"
"        # Read the :cd tag value\n"
"        if cd = context[:cd] do\n"
"          prev_cd = File.cwd!\n"
"          File.cd!(cd)\n"
"          on_exit fn -> File.cd!(prev_cd) end\n"
"        end\n"
"\n"
"        :ok\n"
"      end\n"
"\n"
"      @tag cd: \"fixtures\"\n"
"      test \"reads UTF-8 fixtures\" do\n"
"        File.read(\"hello\")\n"
"      end\n"
"    end\n"
"\n"
"In the example above, we have defined a tag called `:cd` that is\n"
"read in the setup callback to configure the working directory the\n"
"test is going to run on.\n"
"\n"
"Tags are also very effective when used with case templates\n"
"(`ExUnit.CaseTemplate`) allowing callbacks in the case template\n"
"to customize the test behaviour.\n"
"\n"
"Note a tag can be set in two different ways:\n"
"\n"
"    @tag key: value\n"
"    @tag :key       # equivalent to setting @tag key: true\n"
"\n"
"If a tag is given more than once, the last value wins.\n"
"\n"
"### Module tags\n"
"\n"
"A tag can be set for all tests in a module by setting `@moduletag`:\n"
"\n"
"    @moduletag :external\n"
"\n"
"If the same key is set via `@tag`, the `@tag` value has higher\n"
"precedence.\n"
"\n"
"### Known tags\n"
"\n"
"The following tags are set automatically by ExUnit and are\n"
"therefore reserved:\n"
"\n"
"  * `:case`       - the test case module\n"
"  * `:file`       - the file on which the test was defined\n"
"  * `:line`       - the line on which the test was defined\n"
"  * `:test`       - the test name\n"
"  * `:async`      - if the test case is in async mode\n"
"  * `:type`       - the type of the test (`:test`, `:property`, etc)\n"
"  * `:registered` - used for `ExUnit.Case.register_attribute/3` values\n"
"  * `:describe`   - the describe block the test belongs to\n"
"\n"
"The following tags customize how tests behaves:\n"
"\n"
"  * `:capture_log` - see the \"Log Capture\" section below\n"
"  * `:skip` - skips the test with the given reason\n"
"  * `:timeout` - customizes the test timeout in milliseconds (defaults to "
"60000)\n"
"  * `:report` - includes the given tags and context keys on error reports,\n"
"    see the \"Reporting tags\" section\n"
"\n"
"### Reporting tags\n"
"\n"
"ExUnit also allows tags or any other key in your context to be included\n"
"in error reports, making it easy for developers to see under which "
"circumstances\n"
"a test was evaluated. To do so, you use the `:report` tag:\n"
"\n"
"    @moduletag report: [:user_id]\n"
"\n"
"## Filters\n"
"\n"
"Tags can also be used to identify specific tests, which can then\n"
"be included or excluded using filters. The most common functionality\n"
"is to exclude some particular tests from running, which can be done\n"
"via `ExUnit.configure/1`:\n"
"\n"
"    # Exclude all external tests from running\n"
"    ExUnit.configure(exclude: [external: true])\n"
"\n"
"From now on, ExUnit will not run any test that has the `external` flag\n"
"set to `true`. This behaviour can be reversed with the `:include` option\n"
"which is usually passed through the command line:\n"
"\n"
"    mix test --include external:true\n"
"\n"
"Run `mix help test` for more information on how to run filters via Mix.\n"
"\n"
"Another use case for tags and filters is to exclude all tests that have\n"
"a particular tag by default, regardless of its value, and include only\n"
"a certain subset:\n"
"\n"
"    ExUnit.configure(exclude: :os, include: [os: :unix])\n"
"\n"
"Keep in mind that all tests are included by default, so unless they are\n"
"excluded first, the `include` option has no effect.\n"
"\n"
"## Log Capture\n"
"\n"
"ExUnit can optionally suppress printing of log messages that are generated "
"during a test. Log\n"
"messages generated while running a test are captured and only if the test "
"fails are they printed\n"
"to aid with debugging.\n"
"\n"
"You can opt into this behaviour for individual tests by tagging them with `:"
"capture_log` or enable\n"
"log capture for all tests in the ExUnit configuration:\n"
"\n"
"    ExUnit.start(capture_log: true)\n"
"\n"
"This default can be overridden by `@tag capture_log: false` or `@moduletag "
"capture_log: false`.\n"
"\n"
"Since `setup_all` blocks don't belong to a specific test, log messages "
"generated in them (or\n"
"between tests) are never captured. If you want to suppress these messages as "
"well, remove the\n"
"console backend globally:\n"
"\n"
"    config :logger, backends: []\n"
msgstr ""
"ExUnitテストケースをセットアップします。\n"
"\n"
"このモジュールは、テストの構成と準備する方法として\n"
"他のモジュール内で使用されなければなりません。\n"
"\n"
"使用される際、以下のオプションを受け付けます:\n"
"\n"
"  * :async - このテストケースを他のテストケースと並列に実行できるように\n"
"    構成します。このテストケースがグローバルな状態を変えない場合は\n"
"    パフォーマンスを上げるために使用できるでしょう。デフォルトは`false`で"
"す。\n"
"\n"
"このモジュールは`ExUnit.Callbacks`で定義されているすべてのコールバックを\n"
"自動的に含めます。詳細はそのモジュールドキュメントを参照して\n"
"ください。\n"
"\n"
"## 例\n"
"\n"
"     defmodule AssertionTest do\n"
"       # Use the module\n"
"       use ExUnit.Case, async: true\n"
"\n"
"       # The \"test\" macro is imported by ExUnit.Case\n"
"       test \"always pass\" do\n"
"         assert true\n"
"       end\n"
"     end\n"
"\n"
"## コンテキスト\n"
"\n"
"すべてのテストは引数としてコンテキストを受け取ります。コンテキストは\n"
"特にコールバックとテストの間で情報を共有するために役立ちます:\n"
"\n"
"    defmodule KVTest do\n"
"      use ExUnit.Case\n"
"\n"
"      setup do\n"
"        {:ok, pid} = KV.start_link\n"
"        {:ok, [pid: pid]}\n"
"      end\n"
"\n"
"      test \"stores key-value pairs\", context do\n"
"        assert KV.put(context[:pid], :hello, :world) == :ok\n"
"        assert KV.get(context[:pid], :hello) == :world\n"
"      end\n"
"    end\n"
"\n"
"コンテキストはマップなので、情報の抽出にパターンマッチングを\n"
"使うことができます:\n"
"\n"
"    test \"stores key-value pairs\", %{pid: pid} do\n"
"      assert KV.put(pid, :hello, :world) == :ok\n"
"      assert KV.get(pid, :hello) == :world\n"
"    end\n"
"\n"
"## タグ\n"
"\n"
"コンテキストはコールバックからテストへ情報を渡すために使わ\n"
"れます。テストからコールバックへ情報を渡すためにExUnitは\n"
"タグを提供します。\n"
"\n"
"テストにタグを付けることで、タグの値をコンテキストからアクセス\n"
"できるようになり、開発者にテストをカスタマイズすることができます。\n"
"例を見てみましょう:\n"
"\n"
"    defmodule FileTest do\n"
"      # Changing directory cannot be async\n"
"      use ExUnit.Case, async: false\n"
"\n"
"      setup context do\n"
"        # Read the :cd tag value\n"
"        if cd = context[:cd] do\n"
"          prev_cd = File.cwd!\n"
"          File.cd!(cd)\n"
"          on_exit fn -> File.cd!(prev_cd) end\n"
"        end\n"
"\n"
"        :ok\n"
"      end\n"
"\n"
"      @tag cd: \"fixtures\"\n"
"      test \"reads UTF-8 fixtures\" do\n"
"        File.read(\"hello\")\n"
"      end\n"
"    end\n"
"\n"
"この例では、`:cd`というタグを定義しました。セットアップ\n"
"コールバックはこれを読み、テストを実行する作業ディレクトリの\n"
"構成に使っています。\n"
"\n"
"タグはケーステンプレート(`ExUnit.CaseTemplates`)と一緒に\n"
"使用しても非常に効果的です。ケーステンプレート内のコールバックが\n"
"テストのぶるまいをカスタマイズできるようになるからです。\n"
"\n"
"タグは２つの異る方法で設定できることに注意してください:\n"
"\n"
"    @tag key: value\n"
"    @tag :key       # @tag key: true と同じです\n"
"\n"
"タグが2つ以上与えられた場合は、最後の値が優先されます。\n"
"\n"
"### モジュールタグ\n"
"\n"
"`@moduletag`を設定することによりモジュールのすべてのテストに\n"
"タグを設定することができます:\n"
"\n"
"    @moduletag :external\n"
"\n"
"同じキーが`@tag`でも設定された場合は、`@tag`の値が\n"
"優先されます。\n"
"\n"
"### 既知のタグ\n"
"\n"
"以下のタグはExUnitにより自動的にセットされ、\n"
"予約されています:\n"
"\n"
"  * `:case`       - テストケースモジュール\n"
"  * `:file`       - テストが定義されているファイル\n"
"  * `:line`       - テストが定義されている行\n"
"  * `:test`       - テスト名\n"
"  * `:async`      - テストケースがasyncモードかどうか\n"
"  * `:type`       - テストの型 (`:test`, `:property`, etc)\n"
"  * `:registered` -`ExUnit.Case.register_attribute/3` の値で使用される\n"
"  * `:describe`   - テストが属する記述ブロック\n"
"\n"
"以下のタグはテストのふるまいをカスタマイズします:\n"
"\n"
"  * `:capture_log` - 下記の”Log Capture”セクションを参照してください\n"
"  * `:skip` - 指定のreasonでテストをスキップします\n"
"  * `:timeout` - テストのタイムアウトをミリ秒でカスタマイズします (デフォルト"
"は60000)\n"
"  * `:report` - 指定のタグとコンテキストキーをエラーレポートに含めます。\n"
"    “タグの報告\"セクションを参照してください\n"
"\n"
"### タグの報告\n"
"\n"
"ExUnitは、テストが評価された状況を開発者が簡単にわかるように\n"
"タグやコンテキスト中の任意のキーをエラーレポートに含めることができます。\n"
"これを行うには`:report`タグを使います:\n"
"\n"
"    @moduletag report: [:user_id]\n"
"\n"
"## フィルター\n"
"\n"
"タグは特定のテストの識別にも使うことができます。これを使って\n"
"フィルタでテストを含めるか除外するかを指定できます。もっとも\n"
"一般的な機能は特定のテストの実行を除外することです。これは\n"
"`ExUnit.configure/1`でおこなうことができます:\n"
"\n"
"    # すべての外部テストを実行から除外する\n"
"    ExUnit.configure(exclude: [external: true])\n"
"\n"
"これを実行した後は、`true`にセットされた`external`フラグを持つすべての\n"
"テストをExUnitは実行しなくなります。このふるまいは、通常、コマンドラインで\n"
"渡される`:include`オプションで逆転することができます:\n"
"\n"
"    mix test --include external:true\n"
"\n"
"Mixを介したフィルタの実行方法の詳細な情報については`mix help test`を実行して"
"ください。\n"
"\n"
"タグとフィルタのもう一つのユースケースは、その値に関係なくデフォルトで特定の"
"タグをもつ\n"
"すべてのテストを除外し、その内のあるサブセットだけを含めることです:\n"
"\n"
"    ExUnit.configure(exclude: :os, include: [os: :unix])\n"
"\n"
"すべてのテストはデフォルトで含まれているので、それらが最初に除外されない限"
"り、\n"
"`include`オプションは効果がないことを心に留めておいてください。\n"
"\n"
"## ログの捕捉\n"
"\n"
"ExUnitはオプションでテスト中に生成されるログメッセージの表示を抑制する\n"
"ことができます。テストの実行中に生成されたログメッセージは捕捉され\n"
"テストが失敗した場合のみデバッグのために表示されます。\n"
"\n"
"このふるまいは、個々のテストに`:capture_log`タグを付けるか、ExUnitの\n"
"構成で次のようにすべてのテストでログ捕捉を有効にすることで選択できます:\n"
"\n"
"    config :ex_unit, capture_log: true\n"
"\n"
"このデフォルトは`@tag capture_log: false`または`@moduletag caputure_log: "
"false`で上書きできます。\n"
"\n"
"`setup_all`ブロックは特定のテストに属していないので、それら(またはテスト間)で"
"生成される\n"
"ログメッセージは決して捕捉されません。これらのメッセージも抑制したい場合"
"は、\n"
"コンソールバックエンドをグローバルに取り除いてください:\n"
"\n"
"    config :logger, backends: []\n"

#. TRANSLATORS: defmacro ExUnit.Case.test(message)
#: lib/ex_unit/case.ex:264
msgid ""
"Defines a not implemented test with a string.\n"
"\n"
"Provides a convenient macro that allows a test to be defined\n"
"with a string, but not yet implemented. The resulting test will\n"
"always fail and print \"Not implemented\" error message. The\n"
"resulting test case is also tagged with `:not_implemented`.\n"
"\n"
"## Examples\n"
"\n"
"    test \"this will be a test in future\"\n"
"\n"
msgstr ""
"文字列で実装していないテストを定義します。\n"
"\n"
"文字列で定義はされているが、まだ実装されないテストを\n"
"許す便利なマクロを提供します。テスト結果は常に失敗であり\n"
"\"Not implemented\"エラーメッセージが表示されます。\n"
"テストケースの結果には`:not_implemented`のタグも付けられます。\n"
"\n"
"## 例\n"
"\n"
"    test \"this will be a test in future\"\n"
"\n"

#. TRANSLATORS: defmacro ExUnit.Case.test(message, var \\ quote() do;  _;end, contents)
#: lib/ex_unit/case.ex:223
msgid ""
"Defines a test with a string.\n"
"\n"
"Provides a convenient macro that allows a test to be\n"
"defined with a string. This macro automatically inserts\n"
"the atom `:ok` as the last line of the test. That said,\n"
"a passing test always returns `:ok`, but, more importantly,\n"
"it forces Elixir to not tail call optimize the test and\n"
"therefore avoids hiding lines from the backtrace.\n"
"\n"
"## Examples\n"
"\n"
"    test \"true is equal to true\" do\n"
"      assert true == true\n"
"    end\n"
"\n"
msgstr ""
"文字列でテストを定義します。\n"
"\n"
"テストを文字列で定義できる便利なマクロを提供\n"
"します。このマクロはテストの最後の行として、\n"
"アトム`:ok`を自動的に挿入します。つまり、\n"
"テストは常に`:ok`を返すということですが、もっと重要な\n"
"ことは、Elixirに末尾再帰最適化をさせないように強制\n"
"するので、バックトレースから行を隱さないことです。\n"
"\n"
"## 例\n"
"\n"
"    test \"true is equal to true\" do\n"
"      assert true == true\n"
"    end\n"
"\n"

#. TRANSLATORS: def ExUnit.Case.register_test(map, type, name, tags)
#: lib/ex_unit/case.ex:381
msgid ""
"Registers a function to run as part of this case.\n"
"\n"
"This is used by 3rd party projects, like QuickCheck, to\n"
"implement macros like `property/3` that works like `test`\n"
"but instead defines a property. See `test/3` implementation\n"
"for an example of invoking this function.\n"
"\n"
"The test type will be converted to a string and pluralized for\n"
"display. You can use `ExUnit.plural_rule/2` to set a custom\n"
"pluralization.\n"
msgstr ""
"このテストケースの一部として実行する関数を登録します。\n"
"\n"
"これは、`test`のように作動するが代わりにプロパティを定義する\n"
"`property/3`のようなマクロを実装するためにQuickCheckのような\n"
"サードパーティプロジェクトで使用されます。この関数を起動している\n"
"例は`test/3`の実装を参照してください。\n"
"\n"
"テストタイプは文字列に変換され、表示用に複数形にされます。\n"
"`ExUnit.plural_rule/2`を使って、独自の複数形を設定する\n"
"ことができます。\n"
