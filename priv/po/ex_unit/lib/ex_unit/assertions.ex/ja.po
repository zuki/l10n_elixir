msgid ""
msgstr ""
"Project-Id-Version: l 10n_elixir\n"
"PO-Revision-Date: 2017-01-23 11:04+0900\n"
"Last-Translator: Keiji Suzuki <EMAIL@ADDRESS>\n"
"Language-Team: Japanese\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#. TRANSLATORS: def ExUnit.Assertions.flunk(message \\ "Flunked!")
#: lib/ex_unit/assertions.ex:760
msgid ""
"Fails with a message.\n"
"\n"
"## Examples\n"
"\n"
"    flunk \"This should raise an error\"\n"
"\n"
msgstr ""
"メッセージ付きで失敗します。\n"
"\n"
"## 例\n"
"\n"
"    flunk \"This should raise an error\"\n"
"\n"

#. TRANSLATORS: def ExUnit.Assertions.assert_raise(exception, message, function)
#: lib/ex_unit/assertions.ex:513
msgid ""
"Asserts the `exception` is raised during `function` execution with\n"
"the expected `message`, which can be a `Regex` or an exact `String`.\n"
"Returns the rescued exception, fails otherwise.\n"
"\n"
"## Examples\n"
"\n"
"    assert_raise ArithmeticError, \"bad argument in arithmetic expression\", "
"fn ->\n"
"      1 + \"test\"\n"
"    end\n"
"\n"
"    assert_raise RuntimeError, ~r/^today's lucky number is 0.+!$/, fn ->\n"
"      raise \"today's lucky number is 0.9391199065961959!\"\n"
"    end\n"
msgstr ""
"`function`実行中に予想さえる`message`を持つ`exception`が発生すると表明しま"
"す。\n"
"`message`は`Regex`あるいは、正確な`String`を使うことができます。レスキューさ"
"れた\n"
"例外を返し、さもなくば失敗します。\n"
"\n"
"## 例\n"
"\n"
"    assert_raise ArithmeticError, \"bad argument in arithmetic expression\", "
"fn ->\n"
"      1 + \"test\"\n"
"    end\n"
"\n"
"    assert_raise RuntimeError, ~r/^Today's lucky number is 0.+!$/, fn ->\n"
"      raise \"Today's lucky number is 0.4379087006197395!\"\n"
"    end\n"

#. TRANSLATORS: defmacro ExUnit.Assertions.assert_received(pattern, failure_message \\ nil)
#: lib/ex_unit/assertions.ex:351
msgid ""
"Asserts that a message matching `pattern` was received and is in the\n"
"current process' mailbox.\n"
"\n"
"The `pattern` argument must be a match pattern. Flunks with "
"`failure_message`\n"
"if a message matching `pattern` was not received.\n"
"\n"
"Timeout is set to 0, so there is no waiting time.\n"
"\n"
"## Examples\n"
"\n"
"    send self(), :hello\n"
"    assert_received :hello\n"
"\n"
"    send self(), :bye\n"
"    assert_received :hello, \"Oh No!\"\n"
"    ** (ExUnit.AssertionError) Oh No!\n"
"    Process mailbox:\n"
"      :bye\n"
"\n"
"You can also match against specific patterns:\n"
"\n"
"    send self(), {:hello, \"world\"}\n"
"    assert_received {:hello, _}\n"
"\n"
msgstr ""
"`pattern`にマッチするメッセージが受信され、カレントプロセスのmailboxに\n"
"あると表明します。\n"
"\n"
"`pattern`引数はマッチパターンでなければなりません。\n"
"`pattern`にマッチするメッセージを受信しないと、`failure_message`で失敗しま"
"す。\n"
"\n"
"タイムアウトは0にセットされますので、待ち時間はありません。\n"
"\n"
"## 例\n"
"\n"
"    send self, :hello\n"
"    assert_received :hello\n"
"\n"
"    send self, :bye\n"
"    assert_received :hello, \"Oh No!\"\n"
"    ** (ExUnit.AssertionError) Oh No!\n"
"    Process mailbox:\n"
"      :bye\n"
"\n"
"特定のパターンに対してマッチさせることもできます:\n"
"\n"
"    send self, {:hello, \"world\"}\n"
"    assert_received {:hello, _}\n"
"\n"

#. TRANSLATORS: def ExUnit.Assertions.assert(value, message)
#: lib/ex_unit/assertions.ex:302
msgid ""
"Asserts `value` is `true`, displaying the given `message` otherwise.\n"
"\n"
"## Examples\n"
"\n"
"    assert false, \"it will never be true\"\n"
"\n"
msgstr ""
"`value`が`true`と表明し、さもなければ与えられた`message`を表示します。\n"
"\n"
"## 例\n"
"\n"
"    assert false, \"it will never be true\"\n"
"\n"

#. TRANSLATORS: def ExUnit.Assertions.assert_raise(exception, function)
#: lib/ex_unit/assertions.ex:548
msgid ""
"Asserts the `exception` is raised during `function` execution.\n"
"Returns the rescued exception, fails otherwise.\n"
"\n"
"## Examples\n"
"\n"
"    assert_raise ArithmeticError, fn ->\n"
"      1 + \"test\"\n"
"    end\n"
"\n"
msgstr ""
"`function`を実行中に例外`exception`が発生と表明します。\n"
"レスキューされた例外を返し、さもなくば失敗します。\n"
"\n"
"## 例\n"
"\n"
"    assert_raise ArithmeticError, fn ->\n"
"      1 + \"test\"\n"
"    end\n"
"\n"

#. TRANSLATORS: def ExUnit.AssertionError.no_value()
#: lib/ex_unit/assertions.ex:13
msgid "Indicates no meaningful value for a field.\n"
msgstr "フィールドに意味のある値が無いことを示します。\n"

#. TRANSLATORS: defmacro ExUnit.Assertions.refute_received(pattern, failure_message \\ nil)
#: lib/ex_unit/assertions.ex:685
msgid ""
"Asserts a message matching `pattern` was not received (i.e. it is not in "
"the\n"
"current process' mailbox).\n"
"\n"
"The `pattern` argument must be a match pattern. Flunks with "
"`failure_message`\n"
"if a message matching `pattern` was received.\n"
"\n"
"Timeout is set to 0, so there is no waiting time.\n"
"\n"
"## Examples\n"
"\n"
"    send self(), :hello\n"
"    refute_received :bye\n"
"\n"
"    send self(), :hello\n"
"    refute_received :hello, \"Oh No!\"\n"
"    ** (ExUnit.AssertionError) Oh No!\n"
"    Process mailbox:\n"
"      :bye\n"
"\n"
msgstr ""
"`pattern`にマッチするメッセージが受信されていないと表明します(即ち、カレント"
"プロセスの\n"
"mailboxにはないといとことです)。\n"
"\n"
"`pattern`引数はマッチパターンでなければなりません。`pattern`にマッチするメッ"
"セージを受信すると、\n"
"`failure_message`で失敗します。\n"
"\n"
"タイムアウトは0にセットされていますので、待ち時間はありません。\n"
"\n"
"## 例\n"
"\n"
"     send self, :hello\n"
"    refute_received :bye\n"
"\n"
"    send self, :hello\n"
"    refute_received :hello, \"Oh No!\"\n"
"    ** (ExUnit.AssertionError) Oh No!\n"
"    Process mailbox:\n"
"      :bye\n"
"\n"

#. TRANSLATORS: def ExUnit.Assertions.assert_in_delta(value1, value2, delta, message \\ nil)
#: lib/ex_unit/assertions.ex:580
msgid ""
"Asserts that `value1` and `value2` differ by no more than `delta`.\n"
"\n"
"\n"
"## Examples\n"
"\n"
"    assert_in_delta 1.1, 1.5, 0.2\n"
"    assert_in_delta 10, 15, 4\n"
"\n"
msgstr ""
"`value1`と`value2`の差が`delta`より小さいと表明します。\n"
"\n"
"\n"
"## 例\n"
"\n"
"    assert_in_delta 1.1, 1.5, 0.2\n"
"    assert_in_delta 10, 15, 4\n"
"\n"

#. TRANSLATORS: defmacro ExUnit.Assertions.catch_error(expression)
#: lib/ex_unit/assertions.ex:624
msgid ""
"Asserts `expression` will cause an error.\n"
"Returns the error or fails otherwise.\n"
"\n"
"## Examples\n"
"\n"
"    assert catch_error(error 1) == 1\n"
"\n"
msgstr ""
"`expression`がerrorを引き起すという表明です。\n"
"errorを返します。さもなければ失敗します。\n"
"\n"
"## 例\n"
"\n"
"    assert catch_error(error 1) == 1\n"
"\n"

#. TRANSLATORS: defmacro ExUnit.Assertions.catch_throw(expression)
#: lib/ex_unit/assertions.ex:598
msgid ""
"Asserts `expression` will throw a value.\n"
"Returns the thrown value or fails otherwise.\n"
"\n"
"## Examples\n"
"\n"
"    assert catch_throw(throw 1) == 1\n"
"\n"
msgstr ""
"`expression`が値をthrowするという表明です。\n"
"throwされた値を返します。さもなければ失敗します。\n"
"\n"
"## 例\n"
"\n"
"    assert catch_throw(throw 1) == 1\n"
"\n"

#. TRANSLATORS: def ExUnit.Assertions.refute_in_delta(value1, value2, delta, message \\ nil)
#: lib/ex_unit/assertions.ex:736
msgid ""
"Asserts `value1` and `value2` are not within `delta`.\n"
"\n"
"If you supply `message`, information about the values will\n"
"automatically be appended to it.\n"
"\n"
"## Examples\n"
"\n"
"    refute_in_delta 1.1, 1.2, 0.2\n"
"    refute_in_delta 10, 11, 2\n"
"\n"
msgstr ""
"`value1`と`value2`が`delta`の間にないという表明です。\n"
"\n"
"もし`message`があれば、値についての情報が自動的に\n"
"追加されます。\n"
"\n"
"## 例\n"
"\n"
"    refute_in_delta 1.1, 1.2, 0.2\n"
"    refute_in_delta 10, 11, 2\n"
"\n"

#. TRANSLATORS: defmacro ExUnit.Assertions.refute_receive(pattern, timeout \\ Application.fetch_env!(:ex_unit, :refute_receive_timeout), failure_message \\ nil)
#: lib/ex_unit/assertions.ex:663
msgid ""
"Asserts that a message matching `pattern` was not received (and won't be "
"received)\n"
"within the `timeout` period, specified in milliseconds.\n"
"\n"
"The `pattern` argument must be a match pattern. Flunks with "
"`failure_message`\n"
"if a message matching `pattern` is received.\n"
"\n"
"## Examples\n"
"\n"
"    refute_receive :bye\n"
"\n"
"Refute received with an explicit timeout:\n"
"\n"
"    refute_receive :bye, 1000\n"
"\n"
msgstr ""
"`pattern`にマッチするメッセージが`timeout`時間内に受信されなかった(そして\n"
"受信されないだろう)という表明です。\n"
"\n"
"`pattern`引数はマッチパターンでなければなりません。`pattern`にマッチするメッ"
"セージを受信すると、\n"
"`failure_message`で失敗します。\n"
"\n"
"## 例\n"
"\n"
"     refute_receive :bye\n"
"\n"
"明示的なタイムアウトを指定して受信を否定します:\n"
"\n"
"    refute_receive :bye, 1000\n"
"\n"

#. TRANSLATORS: defmacro ExUnit.Assertions.catch_exit(expression)
#: lib/ex_unit/assertions.ex:611
msgid ""
"Asserts `expression` will exit.\n"
"Returns the exit status/message or fails otherwise.\n"
"\n"
"## Examples\n"
"\n"
"    assert catch_exit(exit 1) == 1\n"
"\n"
msgstr ""
"`expression`がexitするという表明です。\n"
"exit status/メッセージを返します。さもなければ失敗します。\n"
"\n"
"## 例\n"
"\n"
"    assert catch_exit(exit 1) == 1\n"
"\n"

#. TRANSLATORS: def ExUnit.Assertions.refute(value, message)
#: lib/ex_unit/assertions.ex:651
msgid ""
"Asserts `value` is `nil` or `false` (that is, `value` is not truthy).\n"
"\n"
"## Examples\n"
"\n"
"    refute true, \"This will obviously fail\"\n"
"\n"
msgstr ""
"`value`が`nil`か`false`である(つまり、`value`は真ではない)という表明です。\n"
"\n"
"## 例\n"
"\n"
"    refute true, \"This will obviously fail\"\n"
"\n"

#. TRANSLATORS: defmacro ExUnit.Assertions.refute(assertion)
#: lib/ex_unit/assertions.ex:180
msgid ""
"A negative assertion, expects the expression to be `false` or `nil`.\n"
"\n"
"Keep in mind that `refute` does not change the semantics of\n"
"the given expression. In other words, the following will fail:\n"
"\n"
"    refute {:ok, _} = some_function_that_returns_error_tuple()\n"
"\n"
"The code above will fail because the `=` operator always fails\n"
"when the sides do not match and `refute/2` does not change it.\n"
"\n"
"The correct way to write the refutation above is to use\n"
"`Kernel.match?/2`:\n"
"\n"
"    refute match? {:ok, _}, some_function_that_returns_error_tuple()\n"
"\n"
"## Examples\n"
"\n"
"    refute age < 0\n"
"\n"
msgstr ""
"否定的なアサーションで、パラメタが`false`か`nil`であることを期待します。\n"
"\n"
"`refute`は与えられた式のセマンティクスを変更しないことに\n"
"注意してください。言い替えると、以下は失敗します:\n"
"\n"
"    refute {:ok, _} = some_function_that_returns_error_tuple()\n"
"\n"
"このコードは失敗します。`=`オペレータは両辺がマッチしない場合は\n"
"常に失敗すし、`refute/2`はその振る舞いを変えないからです。\n"
"\n"
"上のrefutationを正しく書く方法は`Kernel.match?/2`を使う\n"
"ことです:\n"
"\n"
"    refute match? {:ok, _}, some_function_that_returns_error_tuple()\n"
"\n"
"## 例\n"
"\n"
"    refute age < 0\n"
"\n"

#. TRANSLATORS: Elixir.ExUnit.Assertions Summary
#: lib/ex_unit/assertions.ex:44
msgid ""
"This module contains a set of assertion functions that are\n"
"imported by default into your test cases.\n"
"\n"
"In general, a developer will want to use the general\n"
"`assert` macro in tests. This macro introspects your code\n"
"and provides good reporting whenever there is a failure.\n"
"For example, `assert some_fun() == 10` will fail (assuming\n"
"`some_fun()` returns `13`):\n"
"\n"
"    Comparison (using ==) failed in:\n"
"    code: some_fun() == 10\n"
"    lhs:  13\n"
"    rhs:  10\n"
"\n"
"This module also provides other convenience functions\n"
"like `assert_in_delta` and `assert_raise` to easily handle\n"
"other common cases such as checking a floating point number\n"
"or handling exceptions.\n"
msgstr ""
"このモジュールは、デフォルトでテストケースにインポートされる\n"
"一連のアサーションを含んでいます。\n"
"\n"
"一般に、開発者はテストにおいて、一般的な`assert`マクロを\n"
"使いたいと思います。このマクロはコードを調査して、\n"
"失敗があると常によいレポートを提供します。例えば、\n"
"`assert sum_fun() == 10`が失敗すると(`sum_fun()`は\n"
"13を返すとします):\n"
"\n"
"    Comparison (using ==) failed in:\n"
"    code: some_fun() == 10\n"
"    lhs:  13\n"
"    rhs:  10\n"
"\n"
"このモジュールは、浮動小数点数のチェックや例外の\n"
"ハンドリングといった他の共通のケースを簡単に扱う、\n"
"`assert_in_delta`や`assert_raise`のような、他の便利な\n"
"関数も提供します。\n"

#. TRANSLATORS: defmacro ExUnit.Assertions.assert_receive(pattern, timeout \\ Application.fetch_env!(:ex_unit, :assert_receive_timeout), failure_message \\ nil)
#: lib/ex_unit/assertions.ex:319
msgid ""
"Asserts that a message matching `pattern` was or is going to be received\n"
"within the `timeout` period, specified in milliseconds.\n"
"\n"
"Unlike `assert_received`, it has a default `timeout`\n"
"of 100 milliseconds.\n"
"\n"
"The `pattern` argument must be a match pattern. Flunks with "
"`failure_message`\n"
"if a message matching `pattern` is not received.\n"
"\n"
"## Examples\n"
"\n"
"    assert_receive :hello\n"
"\n"
"Asserts against a larger timeout:\n"
"\n"
"    assert_receive :hello, 20_000\n"
"\n"
"You can also match against specific patterns:\n"
"\n"
"    assert_receive {:hello, _}\n"
"\n"
"    x = 5\n"
"    assert_receive {:count, ^x}\n"
"\n"
msgstr ""
"`pattern`にマッチするメッセージが受信されたか、ミリ秒で指定された\n"
"`timeout`時間内に受信されるだろうと表明します。\n"
"\n"
"`assert_received`とは異なり、100ミリ秒のデフォルトタイムアウトを\n"
"持ちます。\n"
"\n"
"`pattern`引数はマッチパターンでなければなりません。`pattern`にマッチする\n"
"メッセージを受信しないと、`failure_message`で失敗します。\n"
"\n"
"## 例\n"
"\n"
"    assert_receive :hello\n"
"\n"
"大きなタイムアウトに対して表明します:\n"
"\n"
"    assert_receive :hello, 20_000\n"
"\n"
"特定のパターンに対してマッチさせることもできます:\n"
"\n"
"    assert_receive {:hello, _}\n"
"\n"
"    x = 5\n"
"    assert_receive {:count, ^x}\n"
"\n"

#. TRANSLATORS: defmacro ExUnit.Assertions.assert(assertion)
#: lib/ex_unit/assertions.ex:65
msgid ""
"Asserts its argument is a truthy value.\n"
"\n"
"`assert` introspects the underlying expression and provides\n"
"good reporting whenever there is a failure. For example,\n"
"if the expression uses the comparison operator, the message\n"
"will show the values of the two sides. The assertion\n"
"\n"
"    assert 1+2+3+4 > 15\n"
"\n"
" will fail with the message:\n"
"\n"
"    Assertion with > failed\n"
"    code: 1+2+3+4 > 15\n"
"    lhs:  10\n"
"    rhs:  15\n"
"\n"
"Similarly, if a match expression is given, it will report\n"
"any failure in terms of that match. Given\n"
"\n"
"    assert [one] = [two]\n"
"\n"
"you'll see:\n"
"\n"
"    match (=) failed\n"
"    code: [one] = [two]\n"
"    rhs:  [2]\n"
"\n"
"Keep in mind that `assert` does not change its semantics\n"
"based on the expression. In other words, the expression\n"
"is still required to return a truthy value. For example,\n"
"the following will fail:\n"
"\n"
"    assert nil = some_function_that_returns_nil()\n"
"\n"
"Even though the match works, `assert` still expects a truth\n"
"value. In such cases, simply use `Kernel.==/2` or\n"
"`Kernel.match?/2`.\n"
msgstr ""
"引数が真の値であると表明します。\n"
"\n"
"`asssert`は対象となる式を確認し、失敗がある場合はわかりやすい\n"
"レポートを提供します。たとえば、式が比較演算子を使っている場合\n"
"メッセージは両辺の値を表示します。\n"
"次のassertion\n"
"\n"
"    assert 1+2+3+4 > 15\n"
"\n"
"は、以下のメッセージで失敗します:\n"
"\n"
"    Assertion with > failed\n"
"    code: 1+2+3+4 > 15\n"
"    lhs:  10\n"
"    rhs:  15\n"
"\n"
"同様に、マッチ式が与えられると、そのマッチの項における\n"
"すべての失敗を報告します。以下の\n"
"\n"
"    assert [one] = [two]\n"
"\n"
"は、こうなります:\n"
"\n"
"    match (=) failed\n"
"    code: [one] = [two]\n"
"    rhs:  [2]\n"
"\n"
"`assert`は式に基いたセマンティクスは変えないことに\n"
"注意してください。言い替えると、式はあくまで真となる値を\n"
"返すことを要求しています。例えば、\n"
"以下は失敗します:\n"
"\n"
"    assert nil = some_function_that_returns_nil()\n"
"\n"
"例えマッチがきちんと動いていても、`assert`は真となる\n"
"値を期待しています。この場合、単に`Kernel.==/2`か\n"
"`Kernel.match?/2`を使ってください。\n"

#. TRANSLATORS: Elixir.ExUnit.MultiError Summary
#: lib/ex_unit/assertions.ex:29
msgid "Raised to signal multiple errors happened in a test case.\n"
msgstr "テストケースで複数のエラーが発生したことを知らせるために発生する\n"

#. TRANSLATORS: Elixir.ExUnit.AssertionError Summary
#: lib/ex_unit/assertions.ex:2
msgid "Raised to signal an assertion error.\n"
msgstr "アサーションエラーを知らせるために発生する\n"
