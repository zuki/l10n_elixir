#. TRANSLATORS: def ExUnit.Assertions.flunk(message \\ "Flunked!")
#: lib/ex_unit/assertions.ex:760 
msgid ""
"Fails with a message.\n"
"\n"
"## Examples\n"
"\n"
"    flunk \"This should raise an error\"\n"
"\n"
msgstr ""
#. TRANSLATORS: def ExUnit.Assertions.assert_raise(exception, message, function)
#: lib/ex_unit/assertions.ex:513 
msgid ""
"Asserts the `exception` is raised during `function` execution with\n"
"the expected `message`, which can be a `Regex` or an exact `String`.\n"
"Returns the rescued exception, fails otherwise.\n"
"\n"
"## Examples\n"
"\n"
"    assert_raise ArithmeticError, \"bad argument in arithmetic expression\", fn ->\n"
"      1 + \"test\"\n"
"    end\n"
"\n"
"    assert_raise RuntimeError, ~r/^today's lucky number is 0.+!$/, fn ->\n"
"      raise \"today's lucky number is 0.9391199065961959!\"\n"
"    end\n"
msgstr ""
#. TRANSLATORS: defmacro ExUnit.Assertions.assert_received(pattern, failure_message \\ nil)
#: lib/ex_unit/assertions.ex:351 
msgid ""
"Asserts that a message matching `pattern` was received and is in the\n"
"current process' mailbox.\n"
"\n"
"The `pattern` argument must be a match pattern. Flunks with `failure_message`\n"
"if a message matching `pattern` was not received.\n"
"\n"
"Timeout is set to 0, so there is no waiting time.\n"
"\n"
"## Examples\n"
"\n"
"    send self(), :hello\n"
"    assert_received :hello\n"
"\n"
"    send self(), :bye\n"
"    assert_received :hello, \"Oh No!\"\n"
"    ** (ExUnit.AssertionError) Oh No!\n"
"    Process mailbox:\n"
"      :bye\n"
"\n"
"You can also match against specific patterns:\n"
"\n"
"    send self(), {:hello, \"world\"}\n"
"    assert_received {:hello, _}\n"
"\n"
msgstr ""
#. TRANSLATORS: def ExUnit.Assertions.assert(value, message)
#: lib/ex_unit/assertions.ex:302 
msgid ""
"Asserts `value` is `true`, displaying the given `message` otherwise.\n"
"\n"
"## Examples\n"
"\n"
"    assert false, \"it will never be true\"\n"
"\n"
msgstr ""
#. TRANSLATORS: def ExUnit.Assertions.assert_raise(exception, function)
#: lib/ex_unit/assertions.ex:548 
msgid ""
"Asserts the `exception` is raised during `function` execution.\n"
"Returns the rescued exception, fails otherwise.\n"
"\n"
"## Examples\n"
"\n"
"    assert_raise ArithmeticError, fn ->\n"
"      1 + \"test\"\n"
"    end\n"
"\n"
msgstr ""
#. TRANSLATORS: def ExUnit.AssertionError.no_value()
#: lib/ex_unit/assertions.ex:13 
msgid ""
"Indicates no meaningful value for a field.\n"
msgstr ""
#. TRANSLATORS: defmacro ExUnit.Assertions.refute_received(pattern, failure_message \\ nil)
#: lib/ex_unit/assertions.ex:685 
msgid ""
"Asserts a message matching `pattern` was not received (i.e. it is not in the\n"
"current process' mailbox).\n"
"\n"
"The `pattern` argument must be a match pattern. Flunks with `failure_message`\n"
"if a message matching `pattern` was received.\n"
"\n"
"Timeout is set to 0, so there is no waiting time.\n"
"\n"
"## Examples\n"
"\n"
"    send self(), :hello\n"
"    refute_received :bye\n"
"\n"
"    send self(), :hello\n"
"    refute_received :hello, \"Oh No!\"\n"
"    ** (ExUnit.AssertionError) Oh No!\n"
"    Process mailbox:\n"
"      :bye\n"
"\n"
msgstr ""
#. TRANSLATORS: def ExUnit.Assertions.assert_in_delta(value1, value2, delta, message \\ nil)
#: lib/ex_unit/assertions.ex:580 
msgid ""
"Asserts that `value1` and `value2` differ by no more than `delta`.\n"
"\n"
"\n"
"## Examples\n"
"\n"
"    assert_in_delta 1.1, 1.5, 0.2\n"
"    assert_in_delta 10, 15, 4\n"
"\n"
msgstr ""
#. TRANSLATORS: defmacro ExUnit.Assertions.catch_error(expression)
#: lib/ex_unit/assertions.ex:624 
msgid ""
"Asserts `expression` will cause an error.\n"
"Returns the error or fails otherwise.\n"
"\n"
"## Examples\n"
"\n"
"    assert catch_error(error 1) == 1\n"
"\n"
msgstr ""
#. TRANSLATORS: defmacro ExUnit.Assertions.catch_throw(expression)
#: lib/ex_unit/assertions.ex:598 
msgid ""
"Asserts `expression` will throw a value.\n"
"Returns the thrown value or fails otherwise.\n"
"\n"
"## Examples\n"
"\n"
"    assert catch_throw(throw 1) == 1\n"
"\n"
msgstr ""
#. TRANSLATORS: def ExUnit.Assertions.refute_in_delta(value1, value2, delta, message \\ nil)
#: lib/ex_unit/assertions.ex:736 
msgid ""
"Asserts `value1` and `value2` are not within `delta`.\n"
"\n"
"If you supply `message`, information about the values will\n"
"automatically be appended to it.\n"
"\n"
"## Examples\n"
"\n"
"    refute_in_delta 1.1, 1.2, 0.2\n"
"    refute_in_delta 10, 11, 2\n"
"\n"
msgstr ""
#. TRANSLATORS: defmacro ExUnit.Assertions.refute_receive(pattern, timeout \\ Application.fetch_env!(:ex_unit, :refute_receive_timeout), failure_message \\ nil)
#: lib/ex_unit/assertions.ex:663 
msgid ""
"Asserts that a message matching `pattern` was not received (and won't be received)\n"
"within the `timeout` period, specified in milliseconds.\n"
"\n"
"The `pattern` argument must be a match pattern. Flunks with `failure_message`\n"
"if a message matching `pattern` is received.\n"
"\n"
"## Examples\n"
"\n"
"    refute_receive :bye\n"
"\n"
"Refute received with an explicit timeout:\n"
"\n"
"    refute_receive :bye, 1000\n"
"\n"
msgstr ""
#. TRANSLATORS: defmacro ExUnit.Assertions.catch_exit(expression)
#: lib/ex_unit/assertions.ex:611 
msgid ""
"Asserts `expression` will exit.\n"
"Returns the exit status/message or fails otherwise.\n"
"\n"
"## Examples\n"
"\n"
"    assert catch_exit(exit 1) == 1\n"
"\n"
msgstr ""
#. TRANSLATORS: def ExUnit.Assertions.refute(value, message)
#: lib/ex_unit/assertions.ex:651 
msgid ""
"Asserts `value` is `nil` or `false` (that is, `value` is not truthy).\n"
"\n"
"## Examples\n"
"\n"
"    refute true, \"This will obviously fail\"\n"
"\n"
msgstr ""
#. TRANSLATORS: defmacro ExUnit.Assertions.refute(assertion)
#: lib/ex_unit/assertions.ex:180 
msgid ""
"A negative assertion, expects the expression to be `false` or `nil`.\n"
"\n"
"Keep in mind that `refute` does not change the semantics of\n"
"the given expression. In other words, the following will fail:\n"
"\n"
"    refute {:ok, _} = some_function_that_returns_error_tuple()\n"
"\n"
"The code above will fail because the `=` operator always fails\n"
"when the sides do not match and `refute/2` does not change it.\n"
"\n"
"The correct way to write the refutation above is to use\n"
"`Kernel.match?/2`:\n"
"\n"
"    refute match? {:ok, _}, some_function_that_returns_error_tuple()\n"
"\n"
"## Examples\n"
"\n"
"    refute age < 0\n"
"\n"
msgstr ""
#. TRANSLATORS: Elixir.ExUnit.Assertions Summary
#: lib/ex_unit/assertions.ex:44 
msgid ""
"This module contains a set of assertion functions that are\n"
"imported by default into your test cases.\n"
"\n"
"In general, a developer will want to use the general\n"
"`assert` macro in tests. This macro introspects your code\n"
"and provides good reporting whenever there is a failure.\n"
"For example, `assert some_fun() == 10` will fail (assuming\n"
"`some_fun()` returns `13`):\n"
"\n"
"    Comparison (using ==) failed in:\n"
"    code: some_fun() == 10\n"
"    lhs:  13\n"
"    rhs:  10\n"
"\n"
"This module also provides other convenience functions\n"
"like `assert_in_delta` and `assert_raise` to easily handle\n"
"other common cases such as checking a floating point number\n"
"or handling exceptions.\n"
msgstr ""
#. TRANSLATORS: defmacro ExUnit.Assertions.assert_receive(pattern, timeout \\ Application.fetch_env!(:ex_unit, :assert_receive_timeout), failure_message \\ nil)
#: lib/ex_unit/assertions.ex:319 
msgid ""
"Asserts that a message matching `pattern` was or is going to be received\n"
"within the `timeout` period, specified in milliseconds.\n"
"\n"
"Unlike `assert_received`, it has a default `timeout`\n"
"of 100 milliseconds.\n"
"\n"
"The `pattern` argument must be a match pattern. Flunks with `failure_message`\n"
"if a message matching `pattern` is not received.\n"
"\n"
"## Examples\n"
"\n"
"    assert_receive :hello\n"
"\n"
"Asserts against a larger timeout:\n"
"\n"
"    assert_receive :hello, 20_000\n"
"\n"
"You can also match against specific patterns:\n"
"\n"
"    assert_receive {:hello, _}\n"
"\n"
"    x = 5\n"
"    assert_receive {:count, ^x}\n"
"\n"
msgstr ""
#. TRANSLATORS: defmacro ExUnit.Assertions.assert(assertion)
#: lib/ex_unit/assertions.ex:65 
msgid ""
"Asserts its argument is a truthy value.\n"
"\n"
"`assert` introspects the underlying expression and provides\n"
"good reporting whenever there is a failure. For example,\n"
"if the expression uses the comparison operator, the message\n"
"will show the values of the two sides. The assertion\n"
"\n"
"    assert 1+2+3+4 > 15\n"
"\n"
" will fail with the message:\n"
"\n"
"    Assertion with > failed\n"
"    code: 1+2+3+4 > 15\n"
"    lhs:  10\n"
"    rhs:  15\n"
"\n"
"Similarly, if a match expression is given, it will report\n"
"any failure in terms of that match. Given\n"
"\n"
"    assert [one] = [two]\n"
"\n"
"you'll see:\n"
"\n"
"    match (=) failed\n"
"    code: [one] = [two]\n"
"    rhs:  [2]\n"
"\n"
"Keep in mind that `assert` does not change its semantics\n"
"based on the expression. In other words, the expression\n"
"is still required to return a truthy value. For example,\n"
"the following will fail:\n"
"\n"
"    assert nil = some_function_that_returns_nil()\n"
"\n"
"Even though the match works, `assert` still expects a truth\n"
"value. In such cases, simply use `Kernel.==/2` or\n"
"`Kernel.match?/2`.\n"
msgstr ""
#. TRANSLATORS: Elixir.ExUnit.MultiError Summary
#: lib/ex_unit/assertions.ex:29 
msgid ""
"Raised to signal multiple errors happened in a test case.\n"
msgstr ""
#. TRANSLATORS: Elixir.ExUnit.AssertionError Summary
#: lib/ex_unit/assertions.ex:2 
msgid ""
"Raised to signal an assertion error.\n"
msgstr ""
