msgid ""
msgstr ""
"Project-Id-Version: elixir 1.4.0\n"
"PO-Revision-Date: 2017-01-23 11:04+0900\n"
"Last-Translator: Keiji Suzuki <EMAIL@ADDRESS>\n"
"Language-Team: Japanese\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#. TRANSLATORS: Elixir.Logger.Formatter Summary
#: lib/logger/formatter.ex:4
msgid ""
"Conveniences for formatting data for logs.\n"
"\n"
"This module allows developers to specify a string that\n"
"serves as template for log messages, for example:\n"
"\n"
"    $time $metadata[$level] $message\\n\n"
"\n"
"Will print error messages as:\n"
"\n"
"    18:43:12.439 user_id=13 [error] Hello\\n\n"
"\n"
"The valid parameters you can use are:\n"
"\n"
"  * `$time`     - time the log message was sent\n"
"  * `$date`     - date the log message was sent\n"
"  * `$message`  - the log message\n"
"  * `$level`    - the log level\n"
"  * `$node`     - the node that prints the message\n"
"  * `$metadata` - user controlled data presented in `\"key=val key2=val2\"` "
"format\n"
"  * `$levelpad` - sets to a single space if level is 4 characters long,\n"
"    otherwise set to the empty space. Used to align the message after "
"level.\n"
"\n"
"Backends typically allow developers to supply such control\n"
"strings via configuration files. This module provides `compile/1`,\n"
"which compiles the string into a format for fast operations at\n"
"runtime and `format/5` to format the compiled pattern into an\n"
"actual IO data.\n"
"\n"
"## Metadata\n"
"\n"
"Metadata to be sent to the Logger can be read and written with\n"
"the `Logger.metadata/0` and `Logger.metadata/1` functions. For example,\n"
"you can set `Logger.metadata([user_id: 13])` to add user_id metadata\n"
"to the current process. The user can configure the backend to chose\n"
"which metadata it wants to print and it will replace the `$metadata`\n"
"value.\n"
msgstr ""
"ログ用にデータをフォーマットする便利ツールです。\n"
"\n"
"このモジュールは、ログメッセージ用のテンプレートと\n"
"して使用される文字列を開発者が指定可能にします。たとえば、\n"
"\n"
"    $time $metadata[$level] $message\\n\n"
"\n"
"これでエラーメッセージは次のように出力されます:\n"
"\n"
"    18:43:12.439 user_id=13 [error] Hello\\n\n"
"\n"
"使用できる有効なパラメータは以下のとおりです:\n"
"\n"
"  * `$time`     - ログメッセージが送られた時刻\n"
"  * `$date`     - ログメッセージが送られた日付\n"
"  * `$message`  - ログメッセージ\n"
"  * `$level`    - ログレベル\n"
"  * `$node`     - メッセージを出力するノード\n"
"  * `$metadata` - `\"key=val key2=val2\"`形式で表現されたユーザ制御データ\n"
"  * `$levelpad` - レベルが4文字なら1つの空白にセットされ、\n"
"    それ以外は空の空白にセットされます。レベルの後のメッセージを揃えるために"
"使われます。\n"
"\n"
"通常、バックエンドはそのような制御文字列を設定ファイルを通じて\n"
"開発者が供給できるようにしています。このモジュールは、文字列を実行時に\n"
"高速な操作が行える形式にコンパイルする`compile/1`と、コンパイルされた\n"
"パターンを実際のIOデータにフォーマットする`format/5`を\n"
"提供しています。\n"
"\n"
"## メタデータ\n"
"\n"
"Loggerに送られるメタデータは`Logger.metadata/0`と\n"
"`Logger.metadata/1`で読み書きできます。たとえば、カレントプロセスに\n"
"user_idメタデータを追加するために、`Logger.metadata([user_id: 13])`と\n"
"設定することができます。ユーザは出力したいメタデータを選択して\n"
"`$metadata`の値を置換するかについてバックエンドを設定\n"
"できます。\n"

#. TRANSLATORS: def Logger.Formatter.prune(binary)
#: lib/logger/formatter.ex:49
msgid ""
"Prune non-valid UTF-8 codepoints.\n"
"\n"
"Typically called after formatting when the data cannot be printed.\n"
msgstr ""
"妥当でないUTF-8コードポイントを取り除きます。\n"
"\n"
"典型的には、データが表示できない時にフォーマット後に呼ばれます。\n"

#. TRANSLATORS: def Logger.Formatter.compile(str)
#: lib/logger/formatter.ex:68
msgid ""
"Compiles a format string into a data structure that the `format/5` can "
"handle.\n"
"\n"
"Check the module doc for documentation on the valid parameters. If you\n"
"pass `nil`, it defaults to: `$time $metadata [$level] $levelpad$message\\n`\n"
"\n"
"If you would like to make your own custom formatter simply pass\n"
"`{module, function}` to `compile/1` and the rest is handled.\n"
"\n"
"    iex> Logger.Formatter.compile(\"$time $metadata [$level] $message\\n\")\n"
"    [:time, \" \", :metadata, \" [\", :level, \"] \", :message, \"\\n\"]\n"
msgstr ""
"フォーマット文字列を`format/5`が取り扱えるデータ構造に\n"
"コンパイルします。\n"
"\n"
"有効なパラメータについてはモジュールドキュメントをチェックしてください。\n"
"`nil`を渡した場合は、次のデフォルトになります:\n"
"`$time $metadata [$level] $levelpad$message\\n`\n"
"\n"
"独自のカスタムフォーマッタを作りたい場合は、単に`compile/1`に\n"
"`{module, function}`を渡します。残りは処理されます。\n"
"\n"
"    iex> Logger.Formatter.compile(\"$time $metadata [$level] $message\\n\")\n"
"    [:time, \" \", :metadata, \" [\", :level, \"] \", :message, \"\\n\"]\n"

#. TRANSLATORS: def Logger.Formatter.format(config, level, msg, ts, md)
#: lib/logger/formatter.ex:100
msgid ""
"Takes a compiled format and injects the, level, timestamp, message and\n"
"metadata listdict and returns a properly formatted string.\n"
msgstr ""
"コンパイルされたフォーマットを取り出し、level, timestamp, messageとmetadata"
"を\n"
"注入して正しくフォーマットされた文字列を返します。\n"
