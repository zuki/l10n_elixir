#. TRANSLATORS: def Logger.compare_levels(level, level)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/logger/lib/logger.ex:380 
msgid ""
"Compares log levels.\n"
"\n"
"Receives two log levels and compares the `left`\n"
"against `right` and returns `:lt`, `:eq` or `:gt`.\n"
msgstr ""
#. TRANSLATORS: defmacro Logger.info(chardata_or_fun, metadata \\ [])
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/logger/lib/logger.ex:543 
msgid ""
"Logs some info.\n"
"\n"
"Returns the atom `:ok` or an `{:error, reason}` tuple.\n"
"\n"
"## Examples\n"
"\n"
"    Logger.info \"mission accomplished\"\n"
"    Logger.info fn -> \"expensive to calculate info\" end\n"
"    Logger.info fn -> {\"expensive to calculate info\", [additional: :metadata]} end\n"
"\n"
msgstr ""
#. TRANSLATORS: defmacro Logger.error(chardata_or_fun, metadata \\ [])
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/logger/lib/logger.ex:559 
msgid ""
"Logs an error.\n"
"\n"
"Returns the atom `:ok` or an `{:error, reason}` tuple.\n"
"\n"
"## Examples\n"
"\n"
"    Logger.error \"oops\"\n"
"    Logger.error fn -> \"expensive to calculate error\" end\n"
"    Logger.error fn -> {\"expensive to calculate error\", [additional: :metadata]} end\n"
"\n"
msgstr ""
#. TRANSLATORS: def Logger.remove_translator(translator)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/logger/lib/logger.ex:470 
msgid ""
"Removes a translator.\n"
msgstr ""
#. TRANSLATORS: def Logger.flush()
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/logger/lib/logger.ex:409 
msgid ""
"Flushes the Logger.\n"
"\n"
"This basically guarantees all messages sent to the\n"
"Logger prior to this call will be processed. This is useful\n"
"for testing and it should not be called in production code.\n"
msgstr ""
#. TRANSLATORS: def Logger.bare_log(level, chardata_or_fun, metadata \\ [])
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/logger/lib/logger.ex:489 
msgid ""
"Logs a message dynamically.\n"
"\n"
"Use this function only when there is a need to\n"
"explicitly avoid embedding metadata.\n"
msgstr ""
#. TRANSLATORS: defmacro Logger.debug(chardata_or_fun, metadata \\ [])
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/logger/lib/logger.ex:575 
msgid ""
"Logs a debug message.\n"
"\n"
"Returns the atom `:ok` or an `{:error, reason}` tuple.\n"
"\n"
"## Examples\n"
"\n"
"    Logger.debug \"hello?\"\n"
"    Logger.debug fn -> \"expensive to calculate debug\" end\n"
"    Logger.debug fn -> {\"expensive to calculate debug\", [additional: :metadata]} end\n"
"\n"
msgstr ""
#. TRANSLATORS: def Logger.enable(pid)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/logger/lib/logger.ex:347 
msgid ""
"Enables logging for the current process.\n"
"\n"
"Currently the only accepted process is self().\n"
msgstr ""
#. TRANSLATORS: def Logger.add_backend(backend, opts \\ [])
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/logger/lib/logger.ex:422 
msgid ""
"Adds a new backend.\n"
"\n"
"## Options\n"
"\n"
"  * `:flush` - when `true`, guarantees all messages currently sent\n"
"    to both Logger and Erlang's `error_logger` are processed before\n"
"    the backend is added\n"
"\n"
msgstr ""
#. TRANSLATORS: def Logger.add_translator(translator)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/logger/lib/logger.ex:462 
msgid ""
"Adds a new translator.\n"
msgstr ""
#. TRANSLATORS: def Logger.configure(options)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/logger/lib/logger.ex:397 
msgid ""
"Configures the logger.\n"
"\n"
"See the \"Runtime Configuration\" section in `Logger` module\n"
"documentation for the available options.\n"
msgstr ""
#. TRANSLATORS: def Logger.reset_metadata(keywords \\ [])
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/logger/lib/logger.ex:337 
msgid ""
"Resets the current process metadata to the given keyword list.\n"
msgstr ""
#. TRANSLATORS: defmacro Logger.log(level, chardata_or_fun, metadata \\ [])
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/logger/lib/logger.ex:591 
msgid ""
"Logs a message.\n"
"\n"
"Returns the atom `:ok` or an `{:error, reason}` tuple.\n"
"\n"
"Developers should use the macros `Logger.debug/2`,\n"
"`Logger.warn/2`, `Logger.info/2` or `Logger.error/2` instead\n"
"of this macro as they can automatically eliminate\n"
"the Logger call altogether at compile time if desired.\n"
msgstr ""
#. TRANSLATORS: def Logger.disable(pid)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/logger/lib/logger.ex:358 
msgid ""
"Disables logging for the current process.\n"
"\n"
"Currently the only accepted process is self().\n"
msgstr ""
#. TRANSLATORS: def Logger.configure_backend(backend, options)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/logger/lib/logger.ex:478 
msgid ""
"Configures the given backend.\n"
"\n"
"The backend needs to be started and running in order to\n"
"be configured at runtime.\n"
msgstr ""
#. TRANSLATORS: def Logger.metadata(keywords)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/logger/lib/logger.ex:311 
msgid ""
"Alters the current process metadata according the given keyword list.\n"
"\n"
"This will merge the given keyword list into the existing metadata. With\n"
"the exception of setting a key to nil will remove a key from the metadata.\n"
msgstr ""
#. TRANSLATORS: def Logger.remove_backend(backend, opts \\ [])
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/logger/lib/logger.ex:446 
msgid ""
"Removes a backend.\n"
"\n"
"## Options\n"
"\n"
"  * `:flush` - when `true`, guarantees all messages currently sent\n"
"    to both Logger and Erlang's `error_logger` are processed before\n"
"    the backend is removed\n"
msgstr ""
#. TRANSLATORS: defmacro Logger.warn(chardata_or_fun, metadata \\ [])
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/logger/lib/logger.ex:527 
msgid ""
"Logs a warning.\n"
"\n"
"Returns the atom `:ok` or an `{:error, reason}` tuple.\n"
"\n"
"## Examples\n"
"\n"
"    Logger.warn \"knob turned too far to the right\"\n"
"    Logger.warn fn -> \"expensive to calculate warning\" end\n"
"    Logger.warn fn -> {\"expensive to calculate warning\", [additional: :metadata]} end\n"
"\n"
msgstr ""
#. TRANSLATORS: def Logger.level()
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/logger/lib/logger.ex:369 
msgid ""
"Retrieves the Logger level.\n"
"\n"
"The Logger level can be changed via `configure/1`.\n"
msgstr ""
#. TRANSLATORS: Elixir.Logger Summary
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/logger/lib/logger.ex:2 
msgid ""
"A logger for Elixir applications.\n"
"\n"
"It includes many features:\n"
"\n"
"  * Provides debug, info, warn and error levels.\n"
"\n"
"  * Supports multiple backends which are automatically\n"
"    supervised when plugged into `Logger`.\n"
"\n"
"  * Formats and truncates messages on the client\n"
"    to avoid clogging `Logger` backends.\n"
"\n"
"  * Alternates between sync and async modes to remain\n"
"    performant when required but also apply backpressure\n"
"    when under stress.\n"
"\n"
"  * Wraps OTP's `error_logger` to prevent it from\n"
"    overflowing.\n"
"\n"
"## Levels\n"
"\n"
"The supported levels are:\n"
"\n"
"  * `:debug` - for debug-related messages\n"
"  * `:info` - for information of any kind\n"
"  * `:warn` - for warnings\n"
"  * `:error` - for errors\n"
"\n"
"## Configuration\n"
"\n"
"`Logger` supports a wide range of configurations.\n"
"\n"
"This configuration is split in three categories:\n"
"\n"
"  * Application configuration - must be set before the `:logger`\n"
"    application is started\n"
"\n"
"  * Runtime configuration - can be set before the `:logger`\n"
"    application is started, but may be changed during runtime\n"
"\n"
"  * Error logger configuration - configuration for the\n"
"    wrapper around OTP's `error_logger`\n"
"\n"
"### Application configuration\n"
"\n"
"The following configuration must be set via config files (e.g.,\n"
"`config/config.exs`) before the `:logger` application is started.\n"
"\n"
"  * `:backends` - the backends to be used. Defaults to `[:console]`.\n"
"    See the \"Backends\" section for more information.\n"
"\n"
"  * `:compile_time_purge_level` - purges *at compilation time* all calls that\n"
"    have log level lower than the value of this option. This means that\n"
"    `Logger` calls with level lower than this option will be completely\n"
"    removed at compile time, accruing no overhead at runtime. Defaults to\n"
"    `:debug` and only applies to the `Logger.debug/2`, `Logger.info/2`,\n"
"    `Logger.warn/2`, and `Logger.error/2` macros (e.g., it doesn't apply to\n"
"    `Logger.log/3`). Note that arguments passed to `Logger` calls that are\n"
"    removed from the AST at compilation time are never evaluated, thus any\n"
"    function call that occurs in these arguments is never executed. As a\n"
"    consequence, avoid code that looks like `Logger.debug(\"Cleanup:\n"
"    #{perform_cleanup()}\")` as in the example `perform_cleanup/0` won't be\n"
"    executed if the `:compile_time_purge_level` is `:info` or higher.\n"
"\n"
"  * `:compile_time_application` - sets the `:application` metadata value\n"
"    to the configured value at compilation time. This configuration is\n"
"    usually only useful for build tools to automatically add the\n"
"    application to the metadata for `Logger.debug/2`, `Logger.info/2`, etc.\n"
"    style of calls.\n"
"\n"
"For example, to configure the `:backends` and `compile_time_purge_level`\n"
"options in a `config/config.exs` file:\n"
"\n"
"    config :logger,\n"
"      backends: [:console],\n"
"      compile_time_purge_level: :info\n"
"\n"
"### Runtime Configuration\n"
"\n"
"All configuration below can be set via config files (e.g.,\n"
"`config/config.exs`) but also changed dynamically during runtime via\n"
"`Logger.configure/1`.\n"
"\n"
"  * `:level` - the logging level. Attempting to log any message\n"
"    with severity less than the configured level will simply\n"
"    cause the message to be ignored. Keep in mind that each backend\n"
"    may have its specific level, too. Note that, unlike what happens with the\n"
"    `:compile_time_purge_level` option, the argument passed to `Logger` calls\n"
"    is evaluated even if the level of the call is lower than `:level`.\n"
"\n"
"  * `:utc_log` - when `true`, uses UTC in logs. By default it uses\n"
"    local time (i.e., it defaults to `false`).\n"
"\n"
"  * `:truncate` - the maximum message size to be logged (in bytes). Defaults\n"
"    to 8192 bytes. Note this configuration is approximate. Truncated messages\n"
"    will have `\" (truncated)\"` at the end.  The atom `:infinity` can be passed\n"
"    to disable this behavior.\n"
"\n"
"  * `:sync_threshold` - if the `Logger` manager has more than\n"
"    `:sync_threshold` messages in its queue, `Logger` will change\n"
"    to *sync mode*, to apply backpressure to the clients.\n"
"    `Logger` will return to *async mode* once the number of messages\n"
"    in the queue is reduced to `sync_threshold * 0.75` messages.\n"
"    Defaults to 20 messages.\n"
"\n"
"  * `:translator_inspect_opts` - when translating OTP reports and\n"
"    errors, the last message and state must be inspected in the\n"
"    error reports. This configuration allow developers to change\n"
"    how much and how the data should be inspected.\n"
"\n"
"For example, to configure the `:level` and `:truncate` options in a\n"
"`config/config.exs` file:\n"
"\n"
"    config :logger,\n"
"      level: :warn,\n"
"      truncate: 4096\n"
"\n"
"### Error Logger configuration\n"
"\n"
"The following configuration applies to `Logger`'s wrapper around\n"
"Erlang's `error_logger`. All the configurations below must be set\n"
"before the `:logger` application starts.\n"
"\n"
"  * `:handle_otp_reports` - redirects OTP reports to `Logger` so\n"
"    they are formatted in Elixir terms. This uninstalls Erlang's\n"
"    logger that prints terms to terminal. Defaults to `true`.\n"
"\n"
"  * `:handle_sasl_reports` - redirects supervisor, crash and\n"
"    progress reports to `Logger` so they are formatted in Elixir\n"
"    terms. This uninstalls `sasl`'s logger that prints these\n"
"    reports to the terminal. Defaults to `false`.\n"
"\n"
"  * `:discard_threshold_for_error_logger` - a value that, when\n"
"    reached, triggers the error logger to discard messages. This\n"
"    value must be a positive number that represents the maximum\n"
"    number of messages accepted per second. Once above this\n"
"    threshold, the `error_logger` enters discard mode for the\n"
"    remainder of that second. Defaults to 500 messages.\n"
"\n"
"For example, to configure `Logger` to redirect all `error_logger` messages\n"
"using a `config/config.exs` file:\n"
"\n"
"    config :logger,\n"
"      handle_otp_reports: true,\n"
"      handle_sasl_reports: true\n"
"\n"
"Furthermore, `Logger` allows messages sent by Erlang's `error_logger`\n"
"to be translated into an Elixir format via translators. Translators\n"
"can be dynamically added at any time with the `add_translator/1`\n"
"and `remove_translator/1` APIs. Check `Logger.Translator` for more\n"
"information.\n"
"\n"
"## Backends\n"
"\n"
"`Logger` supports different backends where log messages are written to.\n"
"\n"
"The available backends by default are:\n"
"\n"
"  * `:console` - logs messages to the console (enabled by default)\n"
"\n"
"Developers may also implement their own backends, an option that\n"
"is explored in more detail below.\n"
"\n"
"The initial backends are loaded via the `:backends` configuration,\n"
"which must be set before the `:logger` application is started.\n"
"\n"
"### Console backend\n"
"\n"
"The console backend logs messages by printing them to the console. It supports\n"
"the following options:\n"
"\n"
"  * `:level` - the level to be logged by this backend.\n"
"    Note that messages are filtered by the general\n"
"    `:level` configuration for the `:logger` application first.\n"
"\n"
"  * `:format` - the format message used to print logs.\n"
"    Defaults to: `\"$time $metadata[$level] $levelpad$message\\n\"`.\n"
"\n"
"  * `:metadata` - the metadata to be printed by `$metadata`.\n"
"    Defaults to an empty list (no metadata).\n"
"\n"
"  * `:colors` - a keyword list of coloring options.\n"
"\n"
"  * `:device` - the device to log error messages to. Defaults to\n"
"    `:user` but can be changed to something else such as `:standard_error`.\n"
"\n"
"  * `:max_buffer` - maximum events to buffer while waiting\n"
"    for a confirmation from the IO device (default: 32).\n"
"    Once the buffer is full, the backend will block until\n"
"    a confirmation is received.\n"
"\n"
"In addition to the keys provided by the user via `Logger.metadata/1`,\n"
"the following extra keys are available to the `:metadata` list:\n"
"\n"
"  * `:application` - the current application\n"
"\n"
"  * `:module` - the current module\n"
"\n"
"  * `:function` - the current function\n"
"\n"
"  * `:file` - the current file\n"
"\n"
"  * `:line` - the current line\n"
"\n"
"The supported keys in the `:colors` keyword list are:\n"
"\n"
"  * `:enabled` - boolean value that allows for switching the\n"
"    coloring on and off. Defaults to: `IO.ANSI.enabled?`\n"
"\n"
"  * `:debug` - color for debug messages. Defaults to: `:cyan`\n"
"\n"
"  * `:info` - color for info messages. Defaults to: `:normal`\n"
"\n"
"  * `:warn` - color for warn messages. Defaults to: `:yellow`\n"
"\n"
"  * `:error` - color for error messages. Defaults to: `:red`\n"
"\n"
"See the `IO.ANSI` module for a list of colors and attributes.\n"
"\n"
"Here is an example of how to configure the `:console` backend in a\n"
"`config/config.exs` file:\n"
"\n"
"    config :logger, :console,\n"
"      format: \"\\n$time $metadata[$level] $levelpad$message\\n\"\n"
"      metadata: [:user_id]\n"
"\n"
"You can read more about formatting in `Logger.Formatter`.\n"
"\n"
"### Custom backends\n"
"\n"
"Any developer can create their own `Logger` backend.\n"
"Since `Logger` is an event manager powered by `:gen_event`,\n"
"writing a new backend is a matter of creating an event\n"
"handler, as described in the [`:gen_event`](http://erlang.org/doc/man/gen_event.html)\n"
"documentation.\n"
"\n"
"From now on, we will be using the term \"event handler\" to refer\n"
"to your custom backend, as we head into implementation details.\n"
"\n"
"Once the `:logger` application starts, it installs all event handlers listed under\n"
"the `:backends` configuration into the `Logger` event manager. The event\n"
"manager and all added event handlers are automatically supervised by `Logger`.\n"
"\n"
"Once initialized, the handler should be designed to handle events\n"
"in the following format:\n"
"\n"
"    {level, group_leader, {Logger, message, timestamp, metadata}} | :flush\n"
"\n"
"where:\n"
"\n"
"  * `level` is one of `:debug`, `:info`, `:warn`, or `:error`, as previously\n"
"    described\n"
"  * `group_leader` is the group leader of the process which logged the message\n"
"  * `{Logger, message, timestamp, metadata}` is a tuple containing information\n"
"    about the logged message:\n"
"    * the first element is always the atom `Logger`\n"
"    * `message` is the actual message (as chardata)\n"
"    * `timestamp` is the timestamp for when the message was logged, as a\n"
"      `{{year, month, day}, {hour, minute, second, millisecond}}` tuple\n"
"    * `metadata` is a keyword list of metadata used when logging the message\n"
"\n"
"It is recommended that handlers ignore messages where\n"
"the group leader is in a different node than the one where\n"
"the handler is installed. For example:\n"
"\n"
"    def handle_event({_level, gl, {Logger, _, _, _}}, state)\n"
"        when node(gl) != node() do\n"
"      {:ok, state}\n"
"    end\n"
"\n"
"In the case of the event `:flush` handlers should flush any pending data. This\n"
"event is triggered by `flush/0`.\n"
"\n"
"Furthermore, backends can be configured via the\n"
"`configure_backend/2` function which requires event handlers\n"
"to handle calls of the following format:\n"
"\n"
"    {:configure, options}\n"
"\n"
"where `options` is a keyword list. The result of the call is\n"
"the result returned by `configure_backend/2`. The recommended\n"
"return value for successful configuration is `:ok`.\n"
"\n"
"It is recommended that backends support at least the following\n"
"configuration options:\n"
"\n"
"  * `:level` - the logging level for that backend\n"
"  * `:format` - the logging format for that backend\n"
"  * `:metadata` - the metadata to include in that backend\n"
"\n"
"Check the implementation for `Logger.Backends.Console`, for\n"
"examples on how to handle the recommendations in this section\n"
"and how to process the existing options.\n"
msgstr ""
#. TRANSLATORS: def Logger.metadata()
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/logger/lib/logger.ex:329 
msgid ""
"Reads the current process metadata.\n"
msgstr ""
