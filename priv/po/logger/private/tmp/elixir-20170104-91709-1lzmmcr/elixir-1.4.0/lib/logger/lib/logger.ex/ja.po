msgid ""
msgstr ""
"Project-Id-Version: elixir 1.4.0\n"
"PO-Revision-Date: 2017-01-23 11:04+0900\n"
"Last-Translator: Keiji Suzuki <EMAIL@ADDRESS>\n"
"Language-Team: Japanese\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#. TRANSLATORS: def Logger.compare_levels(level, level)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/logger/lib/logger.ex:380
msgid ""
"Compares log levels.\n"
"\n"
"Receives two log levels and compares the `left`\n"
"against `right` and returns `:lt`, `:eq` or `:gt`.\n"
msgstr ""
"ログレベルを比較します。\n"
"\n"
"二つのログlevelを受取り、`right`に対して`left`を比較し、\n"
"`:lt`か`:eq`か`:gt`を返します。\n"

#. TRANSLATORS: defmacro Logger.info(chardata_or_fun, metadata \\ [])
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/logger/lib/logger.ex:543
msgid ""
"Logs some info.\n"
"\n"
"Returns the atom `:ok` or an `{:error, reason}` tuple.\n"
"\n"
"## Examples\n"
"\n"
"    Logger.info \"mission accomplished\"\n"
"    Logger.info fn -> \"expensive to calculate info\" end\n"
"    Logger.info fn -> {\"expensive to calculate info\", [additional: :"
"metadata]} end\n"
"\n"
msgstr ""
"何らかの情報をログします。\n"
"\n"
"アトム`:ok`か`{:error, reason}`タプルを返します。\n"
"\n"
"## 例\n"
"\n"
"    Logger.info \"mission accomplished\"\n"
"    Logger.info fn -> \"expensive to calculate info\" end\n"
"    Logger.info fn -> {\"expensive to calculate info\", [additional: :"
"metadata]} end\n"
"\n"

#. TRANSLATORS: defmacro Logger.error(chardata_or_fun, metadata \\ [])
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/logger/lib/logger.ex:559
msgid ""
"Logs an error.\n"
"\n"
"Returns the atom `:ok` or an `{:error, reason}` tuple.\n"
"\n"
"## Examples\n"
"\n"
"    Logger.error \"oops\"\n"
"    Logger.error fn -> \"expensive to calculate error\" end\n"
"    Logger.error fn -> {\"expensive to calculate error\", [additional: :"
"metadata]} end\n"
"\n"
msgstr ""
"エラーをログします。\n"
"\n"
"アトム`:ok`か、`{:error, reason}`タプルを返します。\n"
"\n"
"## 例\n"
"\n"
"    Logger.error \"oops\"\n"
"    Logger.error fn -> \"expensive to calculate error\" end\n"
"    Logger.error fn -> {\"expensive to calculate error\", [additional: :"
"metadata]} end\n"
"\n"

#. TRANSLATORS: def Logger.remove_translator(translator)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/logger/lib/logger.ex:470
msgid "Removes a translator.\n"
msgstr "translatorを取り除きます。\n"

#. TRANSLATORS: def Logger.flush()
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/logger/lib/logger.ex:409
msgid ""
"Flushes the Logger.\n"
"\n"
"This basically guarantees all messages sent to the\n"
"Logger prior to this call will be processed. This is useful\n"
"for testing and it should not be called in production code.\n"
msgstr ""
"Loggerをフラッシュします。\n"
"\n"
"基本的に、この呼出しの前にLoggerに送られた全てのメッセージが\n"
"処理されることを保証します。これはテストに便利ですが、\n"
"プロダクションコードでは呼ばれるべきではありません。\n"

#. TRANSLATORS: def Logger.bare_log(level, chardata_or_fun, metadata \\ [])
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/logger/lib/logger.ex:489
msgid ""
"Logs a message dynamically.\n"
"\n"
"Use this function only when there is a need to\n"
"explicitly avoid embedding metadata.\n"
msgstr ""
"動的にメッセージをログします。\n"
"\n"
"明確にメタデータを埋め込むことを避ける必要がある時にだけ、\n"
"この関数を使ってください。\n"

#. TRANSLATORS: defmacro Logger.debug(chardata_or_fun, metadata \\ [])
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/logger/lib/logger.ex:575
msgid ""
"Logs a debug message.\n"
"\n"
"Returns the atom `:ok` or an `{:error, reason}` tuple.\n"
"\n"
"## Examples\n"
"\n"
"    Logger.debug \"hello?\"\n"
"    Logger.debug fn -> \"expensive to calculate debug\" end\n"
"    Logger.debug fn -> {\"expensive to calculate debug\", [additional: :"
"metadata]} end\n"
"\n"
msgstr ""
"デバッグメッセージをログします。\n"
"\n"
"アトム`:ok`か`{:error, reason}`タプルを返します。\n"
"\n"
"## 例\n"
"\n"
"    Logger.debug \"hello?\"\n"
"    Logger.debug fn -> \"expensive to calculate debug\" end\n"
"    Logger.debug fn -> {\"expensive to calculate debug\", [additional: :"
"metadata]} end\n"
"\n"

#. TRANSLATORS: def Logger.enable(pid)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/logger/lib/logger.ex:347
msgid ""
"Enables logging for the current process.\n"
"\n"
"Currently the only accepted process is self().\n"
msgstr ""
"カレントプロセスでロギングを有効にします。\n"
"\n"
"現在のところ、受け付けるprocessはself()のみです。\n"

#. TRANSLATORS: def Logger.add_backend(backend, opts \\ [])
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/logger/lib/logger.ex:422
msgid ""
"Adds a new backend.\n"
"\n"
"## Options\n"
"\n"
"  * `:flush` - when `true`, guarantees all messages currently sent\n"
"    to both Logger and Erlang's `error_logger` are processed before\n"
"    the backend is added\n"
"\n"
msgstr ""
"新しいbackendを追加します。\n"
"\n"
"## オプション\n"
"\n"
"  * `:flush` - `true`の場合, 現在までにLoggerとErlangの\n"
"    `error_loggerに送らた全てのメッセージが、\n"
"    `backendが追加される前に処理されるることを保証します\n"
"\n"

#. TRANSLATORS: def Logger.add_translator(translator)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/logger/lib/logger.ex:462
msgid "Adds a new translator.\n"
msgstr "新しいtranslatorを追加します。\n"

#. TRANSLATORS: def Logger.configure(options)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/logger/lib/logger.ex:397
msgid ""
"Configures the logger.\n"
"\n"
"See the \"Runtime Configuration\" section in `Logger` module\n"
"documentation for the available options.\n"
msgstr ""
"loggerを構成します。\n"
"\n"
"利用可能なオプションについては、`Logger`モジュールドキュメントの\n"
"\"Runtime Configuration\"セクションを参照してください。\n"

#. TRANSLATORS: def Logger.reset_metadata(keywords \\ [])
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/logger/lib/logger.ex:337
msgid "Resets the current process metadata to the given keyword list.\n"
msgstr "カレントプロセスのメタデータを指定されたキーワードリストに再設定します。\n"

#. TRANSLATORS: defmacro Logger.log(level, chardata_or_fun, metadata \\ [])
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/logger/lib/logger.ex:591
msgid ""
"Logs a message.\n"
"\n"
"Returns the atom `:ok` or an `{:error, reason}` tuple.\n"
"\n"
"Developers should use the macros `Logger.debug/2`,\n"
"`Logger.warn/2`, `Logger.info/2` or `Logger.error/2` instead\n"
"of this macro as they can automatically eliminate\n"
"the Logger call altogether at compile time if desired.\n"
msgstr ""
"メッセージをログします。\n"
"\n"
"アトム`:ok`か`{:error, reason}`タプルを返します。\n"
"\n"
"必要に応じて開発者はこのマクロの代わりに、`Logger.debug/2`、\n"
"`Logger.warn/2`、`Logger.info/2`または`Logger.error/2`マクロを\n"
"使うべきです。コンパイル時に完全にLogger呼出しを自動的に取り除くことが\n"
"できるからです。\n"

#. TRANSLATORS: def Logger.disable(pid)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/logger/lib/logger.ex:358
msgid ""
"Disables logging for the current process.\n"
"\n"
"Currently the only accepted process is self().\n"
msgstr ""
"カレントプロセスのロギングを無効にします。\n"
"\n"
"現在のところ、受け付けるプロセスはself()のみです。\n"

#. TRANSLATORS: def Logger.configure_backend(backend, options)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/logger/lib/logger.ex:478
msgid ""
"Configures the given backend.\n"
"\n"
"The backend needs to be started and running in order to\n"
"be configured at runtime.\n"
msgstr ""
"与えられたbackendを構成します。\n"
"\n"
"実行時に構成するためにbackendがスタートし稼働している\n"
"必要があります。\n"

#. TRANSLATORS: def Logger.metadata(keywords)
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/logger/lib/logger.ex:311
msgid ""
"Alters the current process metadata according the given keyword list.\n"
"\n"
"This will merge the given keyword list into the existing metadata. With\n"
"the exception of setting a key to nil will remove a key from the metadata.\n"
msgstr ""
"指定されたキーワードリストにしたがってカレントプロセスのメタデータを変更します。\n"
"\n"
"これは指定されたキーワードリストを既存のメタデータにマージします。\n"
"例外として、キーにnilを設定するとメタデータからキーを取り除きます。\n"

#. TRANSLATORS: def Logger.remove_backend(backend, opts \\ [])
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/logger/lib/logger.ex:446
msgid ""
"Removes a backend.\n"
"\n"
"## Options\n"
"\n"
"  * `:flush` - when `true`, guarantees all messages currently sent\n"
"    to both Logger and Erlang's `error_logger` are processed before\n"
"    the backend is removed\n"
msgstr ""
"backendを取り除きます。\n"
"\n"
"## オプション\n"
"\n"
"  * `:flush` - `true`の場合, 現在までにLoggerとErlangの\n"
"    `error_loggerに送らた全てのメッセージが、\n"
"    `backendが取り除かれる前に処理されるることを保証します\n"

#. TRANSLATORS: defmacro Logger.warn(chardata_or_fun, metadata \\ [])
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/logger/lib/logger.ex:527
msgid ""
"Logs a warning.\n"
"\n"
"Returns the atom `:ok` or an `{:error, reason}` tuple.\n"
"\n"
"## Examples\n"
"\n"
"    Logger.warn \"knob turned too far to the right\"\n"
"    Logger.warn fn -> \"expensive to calculate warning\" end\n"
"    Logger.warn fn -> {\"expensive to calculate warning\", [additional: :"
"metadata]} end\n"
"\n"
msgstr ""
"警告をログします。\n"
"\n"
"アトム`:ok`か`{:error, reason}`タブルを返します。\n"
"\n"
"## 例\n"
"\n"
"    Logger.warn \"knob turned too far to the right\"\n"
"    Logger.warn fn -> \"expensive to calculate warning\" end\n"
"    Logger.warn fn -> {\"expensive to calculate warning\", [additional: :"
"metadata]} end\n"
"\n"

#. TRANSLATORS: def Logger.level()
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/logger/lib/logger.ex:369
msgid ""
"Retrieves the Logger level.\n"
"\n"
"The Logger level can be changed via `configure/1`.\n"
msgstr ""
"Loggerのレベルを取り出します。\n"
"\n"
"Loggerレベルは`configure/1`を通じて変更することができます。\n"

#. TRANSLATORS: Elixir.Logger Summary
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/logger/lib/logger.ex:2
msgid ""
"A logger for Elixir applications.\n"
"\n"
"It includes many features:\n"
"\n"
"  * Provides debug, info, warn and error levels.\n"
"\n"
"  * Supports multiple backends which are automatically\n"
"    supervised when plugged into `Logger`.\n"
"\n"
"  * Formats and truncates messages on the client\n"
"    to avoid clogging `Logger` backends.\n"
"\n"
"  * Alternates between sync and async modes to remain\n"
"    performant when required but also apply backpressure\n"
"    when under stress.\n"
"\n"
"  * Wraps OTP's `error_logger` to prevent it from\n"
"    overflowing.\n"
"\n"
"## Levels\n"
"\n"
"The supported levels are:\n"
"\n"
"  * `:debug` - for debug-related messages\n"
"  * `:info` - for information of any kind\n"
"  * `:warn` - for warnings\n"
"  * `:error` - for errors\n"
"\n"
"## Configuration\n"
"\n"
"`Logger` supports a wide range of configurations.\n"
"\n"
"This configuration is split in three categories:\n"
"\n"
"  * Application configuration - must be set before the `:logger`\n"
"    application is started\n"
"\n"
"  * Runtime configuration - can be set before the `:logger`\n"
"    application is started, but may be changed during runtime\n"
"\n"
"  * Error logger configuration - configuration for the\n"
"    wrapper around OTP's `error_logger`\n"
"\n"
"### Application configuration\n"
"\n"
"The following configuration must be set via config files (e.g.,\n"
"`config/config.exs`) before the `:logger` application is started.\n"
"\n"
"  * `:backends` - the backends to be used. Defaults to `[:console]`.\n"
"    See the \"Backends\" section for more information.\n"
"\n"
"  * `:compile_time_purge_level` - purges *at compilation time* all calls "
"that\n"
"    have log level lower than the value of this option. This means that\n"
"    `Logger` calls with level lower than this option will be completely\n"
"    removed at compile time, accruing no overhead at runtime. Defaults to\n"
"    `:debug` and only applies to the `Logger.debug/2`, `Logger.info/2`,\n"
"    `Logger.warn/2`, and `Logger.error/2` macros (e.g., it doesn't apply to\n"
"    `Logger.log/3`). Note that arguments passed to `Logger` calls that are\n"
"    removed from the AST at compilation time are never evaluated, thus any\n"
"    function call that occurs in these arguments is never executed. As a\n"
"    consequence, avoid code that looks like `Logger.debug(\"Cleanup:\n"
"    #{perform_cleanup()}\")` as in the example `perform_cleanup/0` won't be\n"
"    executed if the `:compile_time_purge_level` is `:info` or higher.\n"
"\n"
"  * `:compile_time_application` - sets the `:application` metadata value\n"
"    to the configured value at compilation time. This configuration is\n"
"    usually only useful for build tools to automatically add the\n"
"    application to the metadata for `Logger.debug/2`, `Logger.info/2`, etc.\n"
"    style of calls.\n"
"\n"
"For example, to configure the `:backends` and `compile_time_purge_level`\n"
"options in a `config/config.exs` file:\n"
"\n"
"    config :logger,\n"
"      backends: [:console],\n"
"      compile_time_purge_level: :info\n"
"\n"
"### Runtime Configuration\n"
"\n"
"All configuration below can be set via config files (e.g.,\n"
"`config/config.exs`) but also changed dynamically during runtime via\n"
"`Logger.configure/1`.\n"
"\n"
"  * `:level` - the logging level. Attempting to log any message\n"
"    with severity less than the configured level will simply\n"
"    cause the message to be ignored. Keep in mind that each backend\n"
"    may have its specific level, too. Note that, unlike what happens with "
"the\n"
"    `:compile_time_purge_level` option, the argument passed to `Logger` "
"calls\n"
"    is evaluated even if the level of the call is lower than `:level`.\n"
"\n"
"  * `:utc_log` - when `true`, uses UTC in logs. By default it uses\n"
"    local time (i.e., it defaults to `false`).\n"
"\n"
"  * `:truncate` - the maximum message size to be logged (in bytes). "
"Defaults\n"
"    to 8192 bytes. Note this configuration is approximate. Truncated "
"messages\n"
"    will have `\" (truncated)\"` at the end.  The atom `:infinity` can be "
"passed\n"
"    to disable this behavior.\n"
"\n"
"  * `:sync_threshold` - if the `Logger` manager has more than\n"
"    `:sync_threshold` messages in its queue, `Logger` will change\n"
"    to *sync mode*, to apply backpressure to the clients.\n"
"    `Logger` will return to *async mode* once the number of messages\n"
"    in the queue is reduced to `sync_threshold * 0.75` messages.\n"
"    Defaults to 20 messages.\n"
"\n"
"  * `:translator_inspect_opts` - when translating OTP reports and\n"
"    errors, the last message and state must be inspected in the\n"
"    error reports. This configuration allow developers to change\n"
"    how much and how the data should be inspected.\n"
"\n"
"For example, to configure the `:level` and `:truncate` options in a\n"
"`config/config.exs` file:\n"
"\n"
"    config :logger,\n"
"      level: :warn,\n"
"      truncate: 4096\n"
"\n"
"### Error Logger configuration\n"
"\n"
"The following configuration applies to `Logger`'s wrapper around\n"
"Erlang's `error_logger`. All the configurations below must be set\n"
"before the `:logger` application starts.\n"
"\n"
"  * `:handle_otp_reports` - redirects OTP reports to `Logger` so\n"
"    they are formatted in Elixir terms. This uninstalls Erlang's\n"
"    logger that prints terms to terminal. Defaults to `true`.\n"
"\n"
"  * `:handle_sasl_reports` - redirects supervisor, crash and\n"
"    progress reports to `Logger` so they are formatted in Elixir\n"
"    terms. This uninstalls `sasl`'s logger that prints these\n"
"    reports to the terminal. Defaults to `false`.\n"
"\n"
"  * `:discard_threshold_for_error_logger` - a value that, when\n"
"    reached, triggers the error logger to discard messages. This\n"
"    value must be a positive number that represents the maximum\n"
"    number of messages accepted per second. Once above this\n"
"    threshold, the `error_logger` enters discard mode for the\n"
"    remainder of that second. Defaults to 500 messages.\n"
"\n"
"For example, to configure `Logger` to redirect all `error_logger` messages\n"
"using a `config/config.exs` file:\n"
"\n"
"    config :logger,\n"
"      handle_otp_reports: true,\n"
"      handle_sasl_reports: true\n"
"\n"
"Furthermore, `Logger` allows messages sent by Erlang's `error_logger`\n"
"to be translated into an Elixir format via translators. Translators\n"
"can be dynamically added at any time with the `add_translator/1`\n"
"and `remove_translator/1` APIs. Check `Logger.Translator` for more\n"
"information.\n"
"\n"
"## Backends\n"
"\n"
"`Logger` supports different backends where log messages are written to.\n"
"\n"
"The available backends by default are:\n"
"\n"
"  * `:console` - logs messages to the console (enabled by default)\n"
"\n"
"Developers may also implement their own backends, an option that\n"
"is explored in more detail below.\n"
"\n"
"The initial backends are loaded via the `:backends` configuration,\n"
"which must be set before the `:logger` application is started.\n"
"\n"
"### Console backend\n"
"\n"
"The console backend logs messages by printing them to the console. It "
"supports\n"
"the following options:\n"
"\n"
"  * `:level` - the level to be logged by this backend.\n"
"    Note that messages are filtered by the general\n"
"    `:level` configuration for the `:logger` application first.\n"
"\n"
"  * `:format` - the format message used to print logs.\n"
"    Defaults to: `\"$time $metadata[$level] $levelpad$message\\n\"`.\n"
"\n"
"  * `:metadata` - the metadata to be printed by `$metadata`.\n"
"    Defaults to an empty list (no metadata).\n"
"\n"
"  * `:colors` - a keyword list of coloring options.\n"
"\n"
"  * `:device` - the device to log error messages to. Defaults to\n"
"    `:user` but can be changed to something else such as `:standard_error`.\n"
"\n"
"  * `:max_buffer` - maximum events to buffer while waiting\n"
"    for a confirmation from the IO device (default: 32).\n"
"    Once the buffer is full, the backend will block until\n"
"    a confirmation is received.\n"
"\n"
"In addition to the keys provided by the user via `Logger.metadata/1`,\n"
"the following extra keys are available to the `:metadata` list:\n"
"\n"
"  * `:application` - the current application\n"
"\n"
"  * `:module` - the current module\n"
"\n"
"  * `:function` - the current function\n"
"\n"
"  * `:file` - the current file\n"
"\n"
"  * `:line` - the current line\n"
"\n"
"The supported keys in the `:colors` keyword list are:\n"
"\n"
"  * `:enabled` - boolean value that allows for switching the\n"
"    coloring on and off. Defaults to: `IO.ANSI.enabled?`\n"
"\n"
"  * `:debug` - color for debug messages. Defaults to: `:cyan`\n"
"\n"
"  * `:info` - color for info messages. Defaults to: `:normal`\n"
"\n"
"  * `:warn` - color for warn messages. Defaults to: `:yellow`\n"
"\n"
"  * `:error` - color for error messages. Defaults to: `:red`\n"
"\n"
"See the `IO.ANSI` module for a list of colors and attributes.\n"
"\n"
"Here is an example of how to configure the `:console` backend in a\n"
"`config/config.exs` file:\n"
"\n"
"    config :logger, :console,\n"
"      format: \"\\n$time $metadata[$level] $levelpad$message\\n\"\n"
"      metadata: [:user_id]\n"
"\n"
"You can read more about formatting in `Logger.Formatter`.\n"
"\n"
"### Custom backends\n"
"\n"
"Any developer can create their own `Logger` backend.\n"
"Since `Logger` is an event manager powered by `:gen_event`,\n"
"writing a new backend is a matter of creating an event\n"
"handler, as described in the [`:gen_event`](http://erlang.org/doc/man/"
"gen_event.html)\n"
"documentation.\n"
"\n"
"From now on, we will be using the term \"event handler\" to refer\n"
"to your custom backend, as we head into implementation details.\n"
"\n"
"Once the `:logger` application starts, it installs all event handlers listed "
"under\n"
"the `:backends` configuration into the `Logger` event manager. The event\n"
"manager and all added event handlers are automatically supervised by "
"`Logger`.\n"
"\n"
"Once initialized, the handler should be designed to handle events\n"
"in the following format:\n"
"\n"
"    {level, group_leader, {Logger, message, timestamp, metadata}} | :flush\n"
"\n"
"where:\n"
"\n"
"  * `level` is one of `:debug`, `:info`, `:warn`, or `:error`, as "
"previously\n"
"    described\n"
"  * `group_leader` is the group leader of the process which logged the "
"message\n"
"  * `{Logger, message, timestamp, metadata}` is a tuple containing "
"information\n"
"    about the logged message:\n"
"    * the first element is always the atom `Logger`\n"
"    * `message` is the actual message (as chardata)\n"
"    * `timestamp` is the timestamp for when the message was logged, as a\n"
"      `{{year, month, day}, {hour, minute, second, millisecond}}` tuple\n"
"    * `metadata` is a keyword list of metadata used when logging the "
"message\n"
"\n"
"It is recommended that handlers ignore messages where\n"
"the group leader is in a different node than the one where\n"
"the handler is installed. For example:\n"
"\n"
"    def handle_event({_level, gl, {Logger, _, _, _}}, state)\n"
"        when node(gl) != node() do\n"
"      {:ok, state}\n"
"    end\n"
"\n"
"In the case of the event `:flush` handlers should flush any pending data. "
"This\n"
"event is triggered by `flush/0`.\n"
"\n"
"Furthermore, backends can be configured via the\n"
"`configure_backend/2` function which requires event handlers\n"
"to handle calls of the following format:\n"
"\n"
"    {:configure, options}\n"
"\n"
"where `options` is a keyword list. The result of the call is\n"
"the result returned by `configure_backend/2`. The recommended\n"
"return value for successful configuration is `:ok`.\n"
"\n"
"It is recommended that backends support at least the following\n"
"configuration options:\n"
"\n"
"  * `:level` - the logging level for that backend\n"
"  * `:format` - the logging format for that backend\n"
"  * `:metadata` - the metadata to include in that backend\n"
"\n"
"Check the implementation for `Logger.Backends.Console`, for\n"
"examples on how to handle the recommendations in this section\n"
"and how to process the existing options.\n"
msgstr ""
"Elixirアプリケーションのためのロガーです。\n"
"\n"
"多くの機能を含みます:\n"
"\n"
"  * debug, info, warn と error のレベルを提供します。\n"
"\n"
"  * Loggerにプラグインした時に自動的にスーパバイズされる、\n"
"    複数のバックエンドをサポートします。\n"
"\n"
"  * Loggerバックエンドを詰らせることを防ぐために、クライ\n"
"    アントでメッセージのフォーマットとトランケートをしま\n"
"    す。\n"
"\n"
"  * 負荷の下で、バックプレッシャーを処理しながら\n"
"    パフォーマンスを維持するために、同期と非同期モードを\n"
"    行き来します。\n"
"\n"
"  * オーバーフローから防ぐためにOTPの`error_logger`を\n"
"    ラップします。\n"
"\n"
"## Levels\n"
"\n"
"サポートされるレベルは:\n"
"\n"
"  * `:debug` - デバッグ関係のメッセージ\n"
"  * `:info` - 任意の種類のインフォメーション\n"
"  * `:warn` - 警告\n"
"  * `:error` - エラー\n"
"\n"
"## Configuration\n"
"\n"
"Loggerは広範囲のコンフィグレーションをサポートします。\n"
"\n"
"このコンフィグレーションは3つのカテゴリに分られます:\n"
"\n"
"  * Application configuration - Loggerアプリケーションが\n"
"    スタートする前にセットしなければなりません\n"
"\n"
"  * Runtime configuration - Loggerアプリケーションがスター\n"
"    トする前にセット出来ますが、実行中に変更もできます。\n"
"\n"
"  * Error logger configuration - OTPの`error_logger`のラッ\n"
"    パーのためのコンフィグレーション\n"
"\n"
"### Application configuration\n"
"\n"
"以下のコンフィグレーションはLoggerアプリケーションがスター\n"
"トする前にconfigファイルを通してセットされなければなりま\n"
"せん。\n"
"\n"
"  * `:backends` - 使用するバックエンドです。 デフォルトは\n"
"    `[:console]`です。詳細は\"Backends\"セクションを参照し\n"
"    てください。\n"
"\n"
"  * `:compile_time_purge_level` - 構成された値より低いlogレベルをコンパ\n"
"    イル時に全てパージします。これは、Logger呼出しをコンパイル時に完全\n"
"    に取り除き、実行時のオーバヘッドが無いことを意味します。デフォルト\n"
"    は`:debug`で`Logger.debug/2`、`Logger.info/2`などの呼出しスタイルだ\n"
"    けが適用されます。コンパイル時にASTからこれらの呼出しが削除されるの\n"
"    で、渡された引数は決して評価されません。したがって引数の中の任意の\n"
"    関数呼びだしも決して実行されません。結果として、\n"
"    `Logger.debug(\"Cleanup: #{perform_cleanup()}\")`のような例では、\n"
"    `:compile_time_purge_level`が、`:info`かより高いなら、\n"
"    `perform_cleanup/0`は実行されません。\n"
"\n"
"  * `:compile_time_application` - コンパイル時に構成され\n"
"    た値を`:application`メタデータにセットします。\n"
"    このコンフィグレーションは通常ビルドツールにより自動的\n"
"    アプリケーションにメタデータが追加するために、使われるだけです。\n"
"    `Logger.debug/2`, `Logger.info/2`などの呼出しスタイルだけが\n"
"    適用されます。\n"
"\n"
"例えば、`:backends`と`:compile_time_purge_level`を\n"
"`config/config.exs`ファイルに構成するために:\n"
"\n"
"    config :logger,\n"
"      backends: [:console],\n"
"      compile_time_purge_level: :info\n"
"\n"
"### Runtime Configuration\n"
"\n"
"以下の全てのコンフィグレーションはconfigファイルを通して\n"
"セットできますが、`Logger.configure/1`によっても実行時に動的に\n"
"変更することも出来ます。\n"
"\n"
"  * `:level` - ロギングレベルです。設定レベルより低い任意の\n"
"    レベルのメッセージはログしようとしても単に無視されます。\n"
"    それぞれのbackendもそれ自身の特定のレベルを持っているか\n"
"    もしれないことに注意してください。\n"
"    `:compile_time_purge_level`オプションと違って、\n"
"    `Logger`呼出しに渡された引数は呼出しのレベルが`:level`よ\n"
"    り低くても評価されます。\n"
"\n"
"  * `:utc_log` - `true`の時, UTCでログをとります。デフォルトでは\n"
"    ローカル時刻です(つまり、デフォルトは`false`です)。\n"
"\n"
"  * `:truncate` - 記録されるメッセージの最大長です。デフォル\n"
"    トは8192バイトです。この設定は概算ということに注意してく\n"
"    ださい。切り詰められたメッセージは末尾に`\"(truncated)\"`\n"
"    がつきます。\n"
"\n"
"  * `:sync_threshold` - Loggerマネージャがキューに\n"
"    `sync_threshold`個を超えるメッセージを持っていたら、バッ\n"
"    クプレッシャーをクライアントへ加えるために、Loggerは\n"
"    syncモードへ変更します。キューのメッセージが、\n"
"    `sync_threshold * 0.75`まで短くなったらLoggerはasyncモー\n"
"    ドへ戻ります。デフォルトは20メッセージです。\n"
"\n"
"  * `:translator_inspect_opts` - OTPのrepot, errorに変換する\n"
"    とき、最後のメッセージとステートはerror reportでインスペ\n"
"    クトされなければなりません。この設定はデベロッパに\n"
"    inspectされるべきデータの量と方法を変更することを許しま\n"
"    す。\n"
"\n"
"例えば、`:level`と`:truncate`を`config/config.exs`ファイルで\n"
"設定するには:\n"
"\n"
"    config :logger,\n"
"      level: :warn,\n"
"      truncate: 4096\n"
"\n"
"### Error Logger configuration\n"
"\n"
"以下のコンフィグレーションはErlangの`error_logger`をラッパー\n"
"するLoggerに適用されます。以下の全てのコンフィグレーションは、\n"
"Loggerアプリケーションが開始するまえにセットされなければなり\n"
"ません。\n"
"\n"
"  * `:handle_otp_reports` - OTP reportをElixirのタームにフォー\n"
"    マットしてLoggerへリダイレクトします。これは端末にターム\n"
"    をプリントするErlangのloggerをアンインストールしいます。\n"
"    デフォルトは`true`です。\n"
"\n"
"  * `:handle_sasl_reports` - supervisor、crashやprogressレポー\n"
"    トをElixirのタームへフォーマットしてLoggerへリダイレクト\n"
"    します。これは、それらのレポートを端末へプリントする\n"
"    `sasl`のloggerをアンインストールします。デフォルトは\n"
"    `false`です。\n"
"\n"
"  * `:discard_threshold_for_error_logger` - この値に到達する\n"
"    とerror loggerはメッセージを捨てはじめます。この値は正の\n"
"    数字でなくてはならず、秒間に受け付けるメッセージの最大値\n"
"    を表します。上の閾値に到達すると、`error_logger`はその瞬\n"
"    間にdiscardモードに入ります。デフォルトは500メッセージで\n"
"    す。\n"
"\n"
"例えば、全ての`error_logger`メッセージをLoggerにリダイレクトする\n"
"ように`config/config.exs`ファイルを使って設定すると:\n"
"\n"
"    config :logger,\n"
"      handle_otp_reports: true,\n"
"      handle_sasl_reports: true\n"
"\n"
"更にまた、LoggerはErlangの`error_logger`により送られたメッセー\n"
"ジをtranslatorを通じてElixirフォーマットに変換させることが出\n"
"来ます。translatorはいつでも動的に`add_translator/1`と\n"
"`remove_translator/1` APIで変更ができます。詳細は\n"
"`Logger.Translator`を参照してください。\n"
"\n"
"## Backends\n"
"\n"
"Loggerはログメッセージが書かれる異るbackendをサポートします。\n"
"\n"
"デフォルトで有効なbackendは:\n"
"\n"
"  * `:console` - コンソールへメッセージを記録します(デフォルトで有効)\n"
"\n"
"開発者は(下記で説明されるオプションで)自身のbackendを実装するかも\n"
"しれません。\n"
"\n"
"最初のbackendは、Loggerアプリケーションが開始されるまえにセッ\n"
"トされなければならない`:backends`コンフィグレーションにより\n"
"ロードされます。\n"
"\n"
"### Console backend\n"
"\n"
"console backendはコンソールへメッセージを記録します。以下の\n"
"オプションをサポートします:\n"
"\n"
"  * `:level` - このbackendで記録されるレベルです。メッセージ\n"
"    は、一般に`:logger`の`:level`コンフィグレーションで最初\n"
"    にフィルタされることに注意してください\n"
"\n"
"  * `:format` - ログをプリントするときに使うメッセージフォー\n"
"    マットです。デフォルトは:\n"
"    `\"$time $metadata[$level] $levelpad$message\\n\"`\n"
"\n"
"  * `:metadata` - `$metadata`によりでプリントされるメタデー\n"
"    タです。デフォルトは空のリストです(メタデータなし)\n"
"\n"
"  * `:colors` - カラーリングオプションのキーワードリストです。\n"
"\n"
"`Logger.metadata/1`を通じてユーザにより提供されるキーに加えて、\n"
"以下のデフォルトキーが`:metadata`リストで有効です:\n"
"\n"
"  * `:application` - 現在のアプリケーション\n"
"\n"
"  * `:module` - 現在のモジュール\n"
"\n"
"  * `:function` - 現在の関数\n"
"\n"
"  * `:file` - 現在のファイル\n"
"\n"
"  * `:line` - 現在の行\n"
"\n"
"`:colors`キーワードリストでサポートされるキーは以下のとおりです:\n"
"\n"
"  * `:enabled` - カラーのonとoffを切り換えるブーリアン値です。\n"
"    デフォルトは`IO.ANSI.enabled?`です\n"
"\n"
"  * `:debug` - debugメッセージのカラーです。デフォルトは:\n"
"    `:cyan`\n"
"\n"
"  * `:info` - infoメッセージのカラーです。デフォルトは:\n"
"     `:normal`\n"
"\n"
"  * `:warn` - warnメッセージのカラーです。デフォルトは:\n"
"     `:yellow`\n"
"\n"
"  * `:error` - errorメッセージのカラーです。デフォルトは:\n"
"     `:red`\n"
"\n"
"カラーのリストと属性については`IO.ANSI`モジュールを参照してください。\n"
"\n"
"これは`config/config.exs`ファイルで`:console` backendを\n"
"設定する方法の例です:\n"
"\n"
"    config :logger, :console,\n"
"      format: \"\\n$time $metadata[$level] $levelpad$message\\n\"\n"
"      metadata: [:user_id]\n"
"\n"
"フォーマットについての更なる情報は`Logger.Formatter`を読んでください。\n"
"\n"
"### Custom backends\n"
"\n"
"開発者は誰でも自身のLoggerのbackendを作ることが出来ます。\n"
"Loggerが`GenEvent`で動作するイベントマネージャなので、\n"
"新しいbackendを畫くことは、`GenEvent`モジュールとして\n"
"記述される、event handlerを作成する問題です。\n"
"\n"
"今後、実装の詳細に向って、カスタムbackendを参照する際に\n"
"\"event handler\"という用語を使います。\n"
"\n"
"Loggerが開始するとき、`:backend`コンフィグレーションの下の全\n"
"てのevent handlerをLoggerイベントマネージャにインストールし\n"
"ます。イベントマネージャと追加された全てのevent handlerは自\n"
"動的にLoggerによりsuperviseされます。\n"
"\n"
"初期化されると、ハンドラは下記のフォーマットのイベントを\n"
"ハンドルするように設計されるべきです:\n"
"\n"
"    {level, group_leader,\n"
"      {Logger, message, timestamp, metadata}}\n"
"\n"
"levelは前に説明した`:debug`、`:info`、`:warn`あるいは\n"
"`:error`のうちの何れかで、group_leaderはメッセージをログした\n"
"プロセスのグループリーダーで、アトム`Logger`で始まり\n"
"chardataとしてmessage、timestampとキーワードリストである\n"
"metadataからなるタプルが続きます。\n"
"\n"
"ハンドラがインストールされたところと異るノードのgroup\n"
"leaderのメッセージを無視することを推奨します。\n"
"\n"
"更にまた、backendはevent handlerが以下のフォーマット\n"
"のhandle callを要求する`configure_backend/2`関数を通じて、\n"
"設定されることが出来ます:\n"
"\n"
"    {:configure, options}\n"
"\n"
"`options`はキーワードリストです。その呼出しの結果は\n"
"`configure_backend/2`により返されます。コンフィグレーション\n"
"が成功したときに返す値の推奨は`:ok`です。\n"
"\n"
"backendは少なくとも以下のコンフィグレーション値をサポート\n"
"することが推奨されます:\n"
"\n"
"  * `level` - そのbackendでのログするレベルです\n"
"  * `format` - そのbackendでのログフォーマットです\n"
"  * `metadata` - そのbackendで含むメタデータです\n"
"\n"
"このセクションでの推奨をどのように取り扱うか、既存のオプショ\n"
"ンをどのように処理するかの例として、\n"
"`Logger.Backends.Console`の実装をチェックしてください。\n"

#. TRANSLATORS: def Logger.metadata()
#: /private/tmp/elixir-20170104-91709-1lzmmcr/elixir-1.4.0/lib/logger/lib/logger.ex:329
msgid "Reads the current process metadata.\n"
msgstr "カレントプロセスのメタデータを読み込みます。\n"
