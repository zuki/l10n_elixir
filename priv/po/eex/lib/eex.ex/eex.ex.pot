#. TRANSLATORS: def EEx.compile_string(source, options \\ [])
#: lib/eex.ex:165 
msgid ""
"Gets a string `source` and generate a quoted expression\n"
"that can be evaluated by Elixir or compiled to a function.\n"
msgstr ""
#. TRANSLATORS: def EEx.eval_string(source, bindings \\ [], options \\ [])
#: lib/eex.ex:184 
msgid ""
"Gets a string `source` and evaluate the values using the `bindings`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> EEx.eval_string \"foo <%= bar %>\", [bar: \"baz\"]\n"
"    \"foo baz\"\n"
"\n"
msgstr ""
#. TRANSLATORS: def EEx.compile_file(filename, options \\ [])
#: lib/eex.ex:174 
msgid ""
"Gets a `filename` and generate a quoted expression\n"
"that can be evaluated by Elixir or compiled to a function.\n"
msgstr ""
#. TRANSLATORS: def EEx.eval_file(filename, bindings \\ [], options \\ [])
#: lib/eex.ex:200 
msgid ""
"Gets a `filename` and evaluate the values using the `bindings`.\n"
"\n"
"## Examples\n"
"\n"
"    # sample.eex\n"
"    foo <%= bar %>\n"
"\n"
"    # iex\n"
"    EEx.eval_file \"sample.eex\", [bar: \"baz\"] #=> \"foo baz\"\n"
"\n"
msgstr ""
#. TRANSLATORS: defmacro EEx.function_from_string(kind, name, source, args \\ [], options \\ [])
#: lib/eex.ex:97 
msgid ""
"Generates a function definition from the string.\n"
"\n"
"The kind (`:def` or `:defp`) must be given, the\n"
"function name, its arguments and the compilation options.\n"
"\n"
"## Examples\n"
"\n"
"    iex> defmodule Sample do\n"
"    ...>   require EEx\n"
"    ...>   EEx.function_from_string :def, :sample, \"<%= a + b %>\", [:a, :b]\n"
"    ...> end\n"
"    iex> Sample.sample(1, 2)\n"
"    \"3\"\n"
"\n"
msgstr ""
#. TRANSLATORS: defmacro EEx.function_from_file(kind, name, file, args \\ [], options \\ [])
#: lib/eex.ex:126 
msgid ""
"Generates a function definition from the file contents.\n"
"\n"
"The kind (`:def` or `:defp`) must be given, the\n"
"function name, its arguments and the compilation options.\n"
"\n"
"This function is useful in case you have templates but\n"
"you want to precompile inside a module for speed.\n"
"\n"
"## Examples\n"
"\n"
"    # sample.eex\n"
"    <%= a + b %>\n"
"\n"
"    # sample.ex\n"
"    defmodule Sample do\n"
"      require EEx\n"
"      EEx.function_from_file :def, :sample, \"sample.eex\", [:a, :b]\n"
"    end\n"
"\n"
"    # iex\n"
"    Sample.sample(1, 2) #=> \"3\"\n"
"\n"
msgstr ""
#. TRANSLATORS: Elixir.EEx Summary
#: lib/eex.ex:10 
msgid ""
"EEx stands for Embedded Elixir. It allows you to embed\n"
"Elixir code inside a string in a robust way.\n"
"\n"
"    iex> EEx.eval_string \"foo <%= bar %>\", [bar: \"baz\"]\n"
"    \"foo baz\"\n"
"\n"
"## API\n"
"\n"
"This module provides 3 main APIs for you to use:\n"
"\n"
"  1. Evaluate a string (`eval_string`) or a file (`eval_file`)\n"
"     directly. This is the simplest API to use but also the\n"
"     slowest, since the code is evaluated and not compiled before.\n"
"\n"
"  2. Define a function from a string (`function_from_string`)\n"
"     or a file (`function_from_file`). This allows you to embed\n"
"     the template as a function inside a module which will then\n"
"     be compiled. This is the preferred API if you have access\n"
"     to the template at compilation time.\n"
"\n"
"  3. Compile a string (`compile_string`) or a file (`compile_file`)\n"
"     into Elixir syntax tree. This is the API used by both functions\n"
"     above and is available to you if you want to provide your own\n"
"     ways of handling the compiled template.\n"
"\n"
"## Options\n"
"\n"
"All functions in this module accept EEx-related options.\n"
"They are:\n"
"\n"
"  * `:line` - the line to be used as the template start. Defaults to 1.\n"
"  * `:file` - the file to be used in the template. Defaults to the given\n"
"    file the template is read from or to \"nofile\" when compiling from a string.\n"
"  * `:engine` - the EEx engine to be used for compilation.\n"
"  * `:trim` - trims whitespace left/right of quotation tags\n"
"\n"
"## Engine\n"
"\n"
"EEx has the concept of engines which allows you to modify or\n"
"transform the code extracted from the given string or file.\n"
"\n"
"By default, `EEx` uses the `EEx.SmartEngine` that provides some\n"
"conveniences on top of the simple `EEx.Engine`.\n"
"\n"
"### Tags\n"
"\n"
"`EEx.SmartEngine` supports the following tags:\n"
"\n"
"    <% Elixir expression - inline with output %>\n"
"    <%= Elixir expression - replace with result %>\n"
"    <%% EEx quotation - returns the contents inside %>\n"
"    <%# Comments - they are discarded from source %>\n"
"\n"
"All expressions that output something to the template\n"
"**must** use the equals sign (`=`). Since everything in\n"
"Elixir is an expression, there are no exceptions for this rule.\n"
"For example, while some template languages would special-case\n"
"`if/2` clauses, they are treated the same in EEx and\n"
"also require `=` in order to have their result printed:\n"
"\n"
"    <%= if true do %>\n"
"      It is obviously true\n"
"    <% else %>\n"
"      This will never appear\n"
"    <% end %>\n"
"\n"
"Notice that different engines may have different rules\n"
"for each tag. Other tags may be added in future versions.\n"
"\n"
"### Macros\n"
"\n"
"`EEx.SmartEngine` also adds some macros to your template.\n"
"An example is the `@` macro which allows easy data access\n"
"in a template:\n"
"\n"
"    iex> EEx.eval_string \"<%= @foo %>\", assigns: [foo: 1]\n"
"    \"1\"\n"
"\n"
"In other words, `<%= @foo %>` translates to:\n"
"\n"
"    <%= {:ok, v} = Access.fetch(assigns, :foo); v %>\n"
"\n"
"The `assigns` extension is useful when the number of variables\n"
"required by the template is not specified at compilation time.\n"
msgstr ""
