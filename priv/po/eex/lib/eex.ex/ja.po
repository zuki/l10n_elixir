msgid ""
msgstr ""
"Project-Id-Version: l 10n_elixir\n"
"PO-Revision-Date: 2017-01-23 11:03+0900\n"
"Last-Translator: Keiji Suzuki <EMAIL@ADDRESS>\n"
"Language-Team: Japanese\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#. TRANSLATORS: def EEx.compile_string(source, options \\ [])
#: lib/eex.ex:165
msgid ""
"Gets a string `source` and generate a quoted expression\n"
"that can be evaluated by Elixir or compiled to a function.\n"
msgstr ""
"`source`文字列を取得し、Elixirで評価可能あるいは、\n"
"関数にコンパイル可能なquoteされた式を生成します。\n"

#. TRANSLATORS: def EEx.eval_string(source, bindings \\ [], options \\ [])
#: lib/eex.ex:184
msgid ""
"Gets a string `source` and evaluate the values using the `bindings`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> EEx.eval_string \"foo <%= bar %>\", [bar: \"baz\"]\n"
"    \"foo baz\"\n"
"\n"
msgstr ""
"`source`文字列を取得し、`bindings`を使って値を評価します。\n"
"\n"
"## 例\n"
"\n"
"    iex> EEx.eval_string \"foo <%= bar %>\", [bar: \"baz\"]\n"
"    \"foo baz\"\n"
"\n"

#. TRANSLATORS: def EEx.compile_file(filename, options \\ [])
#: lib/eex.ex:174
msgid ""
"Gets a `filename` and generate a quoted expression\n"
"that can be evaluated by Elixir or compiled to a function.\n"
msgstr ""
"`filename`を取得し、Elixirで評価可能か、関数にコンパイル可能な\n"
"quoteされた式を生成します。\n"

#. TRANSLATORS: def EEx.eval_file(filename, bindings \\ [], options \\ [])
#: lib/eex.ex:200
msgid ""
"Gets a `filename` and evaluate the values using the `bindings`.\n"
"\n"
"## Examples\n"
"\n"
"    # sample.eex\n"
"    foo <%= bar %>\n"
"\n"
"    # iex\n"
"    EEx.eval_file \"sample.eex\", [bar: \"baz\"] #=> \"foo baz\"\n"
"\n"
msgstr ""
"`filename`を取得し、`bindings`を使って値を評価します。\n"
"\n"
"## Examples\n"
"\n"
"    # sample.eex\n"
"    foo <%= bar %>\n"
"\n"
"    # iex\n"
"    EEx.eval_file \"sample.eex\", [bar: \"baz\"] #=> \"foo baz\"\n"
"\n"

#. TRANSLATORS: defmacro EEx.function_from_string(kind, name, source, args \\ [], options \\ [])
#: lib/eex.ex:97
msgid ""
"Generates a function definition from the string.\n"
"\n"
"The kind (`:def` or `:defp`) must be given, the\n"
"function name, its arguments and the compilation options.\n"
"\n"
"## Examples\n"
"\n"
"    iex> defmodule Sample do\n"
"    ...>   require EEx\n"
"    ...>   EEx.function_from_string :def, :sample, \"<%= a + b %>\", [:a, :"
"b]\n"
"    ...> end\n"
"    iex> Sample.sample(1, 2)\n"
"    \"3\"\n"
"\n"
msgstr ""
"文字列から関数定義を生成します。\n"
"\n"
"kind(`:def`か`:defp`)、関数名、引数、コンパイルオプションは\n"
"必須です。\n"
"\n"
"## Examples\n"
"\n"
"    iex> defmodule Sample do\n"
"    ...>   require EEx\n"
"    ...>   EEx.function_from_string :def, :sample, \"<%= a + b %>\", [:a, :"
"b]\n"
"    ...> end\n"
"    iex> Sample.sample(1, 2)\n"
"    \"3\"\n"
"\n"

#. TRANSLATORS: defmacro EEx.function_from_file(kind, name, file, args \\ [], options \\ [])
#: lib/eex.ex:126
msgid ""
"Generates a function definition from the file contents.\n"
"\n"
"The kind (`:def` or `:defp`) must be given, the\n"
"function name, its arguments and the compilation options.\n"
"\n"
"This function is useful in case you have templates but\n"
"you want to precompile inside a module for speed.\n"
"\n"
"## Examples\n"
"\n"
"    # sample.eex\n"
"    <%= a + b %>\n"
"\n"
"    # sample.ex\n"
"    defmodule Sample do\n"
"      require EEx\n"
"      EEx.function_from_file :def, :sample, \"sample.eex\", [:a, :b]\n"
"    end\n"
"\n"
"    # iex\n"
"    Sample.sample(1, 2) #=> \"3\"\n"
"\n"
msgstr ""
"ファイルの内容から関数定義を生成します。\n"
"\n"
"kind(`:def`か`:defp`)、関数名、引数、コンパイルオプションは\n"
"必須です。\n"
"\n"
"この関数はテンプレートを持っているが、速度のために\n"
"モジュールの内側でプリコンパイルしたい場合に便利です。\n"
"\n"
"## Examples\n"
"\n"
"    # sample.eex\n"
"    <%= a + b %>\n"
"\n"
"    # sample.ex\n"
"    defmodule Sample do\n"
"      require EEx\n"
"      EEx.function_from_file :def, :sample, \"sample.eex\", [:a, :b]\n"
"    end\n"
"\n"
"    # iex\n"
"    Sample.sample(1, 2) #=> \"3\"\n"
"\n"

#. TRANSLATORS: Elixir.EEx Summary
#: lib/eex.ex:10
msgid ""
"EEx stands for Embedded Elixir. It allows you to embed\n"
"Elixir code inside a string in a robust way.\n"
"\n"
"    iex> EEx.eval_string \"foo <%= bar %>\", [bar: \"baz\"]\n"
"    \"foo baz\"\n"
"\n"
"## API\n"
"\n"
"This module provides 3 main APIs for you to use:\n"
"\n"
"  1. Evaluate a string (`eval_string`) or a file (`eval_file`)\n"
"     directly. This is the simplest API to use but also the\n"
"     slowest, since the code is evaluated and not compiled before.\n"
"\n"
"  2. Define a function from a string (`function_from_string`)\n"
"     or a file (`function_from_file`). This allows you to embed\n"
"     the template as a function inside a module which will then\n"
"     be compiled. This is the preferred API if you have access\n"
"     to the template at compilation time.\n"
"\n"
"  3. Compile a string (`compile_string`) or a file (`compile_file`)\n"
"     into Elixir syntax tree. This is the API used by both functions\n"
"     above and is available to you if you want to provide your own\n"
"     ways of handling the compiled template.\n"
"\n"
"## Options\n"
"\n"
"All functions in this module accept EEx-related options.\n"
"They are:\n"
"\n"
"  * `:line` - the line to be used as the template start. Defaults to 1.\n"
"  * `:file` - the file to be used in the template. Defaults to the given\n"
"    file the template is read from or to \"nofile\" when compiling from a "
"string.\n"
"  * `:engine` - the EEx engine to be used for compilation.\n"
"  * `:trim` - trims whitespace left/right of quotation tags\n"
"\n"
"## Engine\n"
"\n"
"EEx has the concept of engines which allows you to modify or\n"
"transform the code extracted from the given string or file.\n"
"\n"
"By default, `EEx` uses the `EEx.SmartEngine` that provides some\n"
"conveniences on top of the simple `EEx.Engine`.\n"
"\n"
"### Tags\n"
"\n"
"`EEx.SmartEngine` supports the following tags:\n"
"\n"
"    <% Elixir expression - inline with output %>\n"
"    <%= Elixir expression - replace with result %>\n"
"    <%% EEx quotation - returns the contents inside %>\n"
"    <%# Comments - they are discarded from source %>\n"
"\n"
"All expressions that output something to the template\n"
"**must** use the equals sign (`=`). Since everything in\n"
"Elixir is an expression, there are no exceptions for this rule.\n"
"For example, while some template languages would special-case\n"
"`if/2` clauses, they are treated the same in EEx and\n"
"also require `=` in order to have their result printed:\n"
"\n"
"    <%= if true do %>\n"
"      It is obviously true\n"
"    <% else %>\n"
"      This will never appear\n"
"    <% end %>\n"
"\n"
"Notice that different engines may have different rules\n"
"for each tag. Other tags may be added in future versions.\n"
"\n"
"### Macros\n"
"\n"
"`EEx.SmartEngine` also adds some macros to your template.\n"
"An example is the `@` macro which allows easy data access\n"
"in a template:\n"
"\n"
"    iex> EEx.eval_string \"<%= @foo %>\", assigns: [foo: 1]\n"
"    \"1\"\n"
"\n"
"In other words, `<%= @foo %>` translates to:\n"
"\n"
"    <%= {:ok, v} = Access.fetch(assigns, :foo); v %>\n"
"\n"
"The `assigns` extension is useful when the number of variables\n"
"required by the template is not specified at compilation time.\n"
msgstr ""
"EExはEmbedded Elixirを表します。それは、文字列中にElixirコード\n"
"を埋め込む強力な方法です。\n"
"\n"
"    iex> EEx.eval_string \"foo <%= bar %>\", [bar: \"baz\"]\n"
"    \"foo baz\"\n"
"\n"
"## API\n"
"\n"
"このモジュールは3つの主要なAPIを提供します:\n"
"\n"
"  1. 文字列(`eval_string`)あるいはファイル(`eval_file`)を直接\n"
"     評価します。これは利用が最も簡單なAPIですが、コードは\n"
"     評価されるまで事前にコンパイルされず、最も遲いです。\n"
"\n"
"  2. 文字列(`function_from_string`)あるいはファイル\n"
"     (`function_from_file`)から関数を定義します。これはコンパ\n"
"     イルされたときモジュール内の関数としてテンプレートに埋め\n"
"     込むことを可能にします。これはコンパイル時にテンプレート\n"
"     にアクセスするなら好ましいAPIです。\n"
"\n"
"  3. 文字列(`compile_string`)またはファイル(`compile_file`)を\n"
"     Elixir構文木にコンパイルします。これは上記の二つの関数に\n"
"     より使用されるAPIで、コンパイルされたテンプレートをハンド\n"
"     リングする方法を提供したいなら、それを可能にします。\n"
"\n"
"## オプション\n"
"\n"
"このモジュールの全ての関数はEEx関連のオプションを受け付けます。\n"
"それらは:\n"
"\n"
"  * `:line` - テンプレートの開始として使用される行。デフォルトは1。\n"
"  * `:file` - テンプレート内で使用されるファイル。デフォルトはテンプレート"
"の読み込みに指定された指定のファイル。\n"
"    または、文字列からコンパイルする場合は”nofile”.\n"
"  * `:engine` - コンパイルに使用するEExエンジン。\n"
"  * `:trim` - コーテーションタグの左右の空白を取る。\n"
"\n"
"## エンジン\n"
"\n"
"EExは与えられた文字列あるいはファイルから抽出されたコードを修\n"
"正あるいは変換することを許すengineというコンセプトを持っています。\n"
"\n"
"デフォルトで、`EEx`はシンプルな`EEx.Engine`の上に構築された幾\n"
"つかの便利機能を提供する`EEx.SmartEngine`を使います。\n"
"\n"
"### タグ\n"
"\n"
"`EEx.SmartEngine`は以下のタグをサポートします:\n"
"\n"
"    <% Elixir expression - inline with output %>\n"
"    <%= Elixir expression - replace with result %>\n"
"    <%% EEx quotation - コreturns the contents inside %>\n"
"    <%# Comments - they are discarded from source %>\n"
"\n"
"テンプレートに何かを出力する全ての式は等号(`=`)を使わなければ\n"
"**なりません**。Elixirは全てが式なので、このルールには例外はあ\n"
"りません。例えば、いくつかのテンプレート言語は`if/2`節を特例と\n"
"していますが、EExでは同じに扱われますので、その\n"
"結果をプリントするにはやはり`=`が必要です:\n"
"\n"
"    <%= if true do %>\n"
"      It is obviously true\n"
"    <% else %>\n"
"      This will never appear\n"
"    <% end %>\n"
"\n"
"タグについてはエンジンが異なるとルールが異なる場合があることに注意してくだ"
"さい。\n"
"また、将来のバージョンでは他にもタグが追加されるかもしれません。\n"
"\n"
"### マクロ\n"
"\n"
"`EEx.SmartEngine`はテンプレートにいくつかのマクロも\n"
"追加します。例えば、`@`マクロはテンプレート中で簡單に\n"
"データへアクセスすることが出来ます:\n"
"\n"
"    iex> EEx.eval_string \"<%= @foo %>\", assigns: [foo: 1]\n"
"    \"1\"\n"
"\n"
"言い替えると、 `<%= @foo %>` は以下に変換されます:\n"
"\n"
"    <%= {:ok, v} = Access.fetch(assigns, :foo); v %>\n"
"\n"
"テンプレートにより必要とされる変数の数がコンパイル時に\n"
"指定できないとき、`assings`拡張子が便利です。\n"
