#. TRANSLATORS: def IEx.Helpers.pwd()
#: lib/iex/helpers.ex:516 
msgid ""
"Prints the current working directory.\n"
msgstr ""
#. TRANSLATORS: def IEx.Helpers.ls(path \\ ".")
#: lib/iex/helpers.ex:536 
msgid ""
"Produces a simple list of a directory's contents.\n"
"\n"
"If `path` points to a file, prints its full path.\n"
msgstr ""
#. TRANSLATORS: def IEx.Helpers.r(module)
#: lib/iex/helpers.ex:386 
msgid ""
"Recompiles and reloads the given `module`.\n"
"\n"
"Please note that all the modules defined in the same\n"
"file as `module` are recompiled and reloaded.\n"
"\n"
"This function is meant to be used for development and\n"
"debugging purposes. Do not depend on it in production code.\n"
"\n"
"## In-memory reloading\n"
"\n"
"When we reload the module in IEx, we recompile the module source\n"
"code, updating its contents in memory. The original `.beam` file\n"
"in disk, probably the one where the first definition of the module\n"
"came from, does not change at all.\n"
"\n"
"Since typespecs and docs are loaded from the .beam file (they\n"
"are not loaded in memory with the module because there is no need\n"
"for them to be in memory), they are not reloaded when you reload\n"
"the module.\n"
msgstr ""
#. TRANSLATORS: def IEx.Helpers.c(files, path \\ :in_memory)
#: lib/iex/helpers.ex:126 
msgid ""
"Compiles the given files.\n"
"\n"
"It expects a list of files to compile and an optional path to write\n"
"the compiled code to (defaults to the current directory). When compiling\n"
"one file, there is no need to wrap it in a list.\n"
"\n"
"It returns the names of the compiled modules.\n"
"\n"
"If you want to recompile an existing module, check `r/1` instead.\n"
"\n"
"## Examples\n"
"\n"
"    iex> c [\"foo.ex\", \"bar.ex\"], \"ebin\"\n"
"    [Foo, Bar]\n"
"\n"
"    iex> c \"baz.ex\"\n"
"    [Baz]\n"
"\n"
msgstr ""
#. TRANSLATORS: defmacro IEx.Helpers.import_if_available(quoted_module, opts \\ [])
#: lib/iex/helpers.ex:682 
msgid ""
"Calls `import/2` with the given arguments, but only if the module is available.\n"
"\n"
"This lets you put imports in `.iex.exs` files (including `~/.iex.exs`) without\n"
"getting compile errors if you open a console where the module is not available.\n"
"\n"
"## Example\n"
"\n"
"    # In ~/.iex.exs\n"
"    import_if_available Ecto.Query\n"
"\n"
msgstr ""
#. TRANSLATORS: def IEx.Helpers.cd(directory)
#: lib/iex/helpers.ex:524 
msgid ""
"Changes the current working directory to the given path.\n"
msgstr ""
#. TRANSLATORS: defmacro IEx.Helpers.b(term)
#: lib/iex/helpers.ex:252 
msgid ""
"Prints the documentation for the given callback function.\n"
"\n"
"It also accepts single module argument to list\n"
"all available behaviour callbacks.\n"
"\n"
"## Examples\n"
"\n"
"    iex> b(Mix.Task.run/1)\n"
"    iex> b(Mix.Task.run)\n"
"    iex> b(GenServer)\n"
msgstr ""
#. TRANSLATORS: def IEx.Helpers.pid(string)
#: lib/iex/helpers.ex:722 
msgid ""
"Creates a PID from `string`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> pid(\"0.21.32\")\n"
"    #PID<0.21.32>\n"
"\n"
msgstr ""
#. TRANSLATORS: def IEx.Helpers.l(module)
#: lib/iex/helpers.ex:432 
msgid ""
"Loads the given module's BEAM code (and ensures any previous\n"
"old version was properly purged before).\n"
"\n"
"This function is useful when you know the bytecode for module\n"
"has been updated in the filesystem and you want to tell the VM\n"
"to load it.\n"
msgstr ""
#. TRANSLATORS: def IEx.Helpers.pid(x, y, z)
#: lib/iex/helpers.ex:735 
msgid ""
"Creates a PID with 3 non negative integers passed as arguments\n"
"to the function.\n"
"\n"
"## Examples\n"
"\n"
"    iex> pid(0, 21, 32)\n"
"    #PID<0.21.32>\n"
"    iex> pid(0, 64, 2048)\n"
"    #PID<0.64.2048>\n"
"\n"
msgstr ""
#. TRANSLATORS: defmacro IEx.Helpers.import_file(path)
#: lib/iex/helpers.ex:650 
msgid ""
"Evaluates the contents of the file at `path` as if it were directly typed into\n"
"the shell.\n"
"\n"
"`path` has to be a literal string. `path` is automatically expanded via\n"
"`Path.expand/1`.\n"
"\n"
"## Examples\n"
"\n"
"    # ~/file.exs\n"
"    value = 13\n"
"\n"
"    # in the shell\n"
"    iex(1)> import_file \"~/file.exs\"\n"
"    13\n"
"    iex(2)> value\n"
"    13\n"
"\n"
msgstr ""
#. TRANSLATORS: def IEx.Helpers.nl(nodes \\ Node.list(), module)
#: lib/iex/helpers.ex:757 
msgid ""
"Deploys a given module's BEAM code to a list of nodes.\n"
"\n"
"This function is useful for development and debugging when you have code that\n"
"has been compiled or updated locally that you want to run on other nodes.\n"
"\n"
"The node list defaults to a list of all connected nodes.\n"
"\n"
"Returns `{:error, :nofile}` if the object code (i.e. \".beam\" file) for the module\n"
"could not be found locally.\n"
"\n"
"## Examples\n"
"\n"
"    iex> nl(HelloWorld)\n"
"    {:ok, [{:node1@easthost, :loaded, HelloWorld},\n"
"           {:node1@westhost, :loaded, HelloWorld}]}\n"
"\n"
"    iex> nl(NoSuchModuleExists)\n"
"    {:error, :nofile}\n"
"\n"
msgstr ""
#. TRANSLATORS: defmacro IEx.Helpers.t(term)
#: lib/iex/helpers.ex:283 
msgid ""
"Prints the types for the given module or for the given function/arity pair.\n"
"\n"
"## Examples\n"
"\n"
"    iex> t(Enum)\n"
"    @type t() :: Enumerable.t()\n"
"    @type element() :: any()\n"
"    @type index() :: integer()\n"
"    @type default() :: any()\n"
"\n"
"    iex> t(Enum.t/0)\n"
"    @type t() :: Enumerable.t()\n"
"\n"
"    iex> t(Enum.t)\n"
"    @type t() :: Enumerable.t()\n"
"\n"
msgstr ""
#. TRANSLATORS: Elixir.IEx.Helpers Summary
#: lib/iex/helpers.ex:2 
msgid ""
"Welcome to Interactive Elixir. You are currently\n"
"seeing the documentation for the module `IEx.Helpers`\n"
"which provides many helpers to make Elixir's shell\n"
"more joyful to work with.\n"
"\n"
"This message was triggered by invoking the helper `h()`,\n"
"usually referred to as `h/0` (since it expects 0 arguments).\n"
"\n"
"You can use the `h/1` function to invoke the documentation\n"
"for any Elixir module or function:\n"
"\n"
"    iex> h Enum\n"
"    iex> h Enum.map\n"
"    iex> h Enum.reverse/1\n"
"\n"
"You can also use the `i/1` function to introspect any value\n"
"you have in the shell:\n"
"\n"
"    iex> i \"hello\"\n"
"\n"
"There are many other helpers available:\n"
"\n"
"  * `b/1`           - prints callbacks info and docs for a given module\n"
"  * `c/1`           - compiles a file into the current directory\n"
"  * `c/2`           - compiles a file to the given path\n"
"  * `cd/1`          - changes the current directory\n"
"  * `clear/0`       - clears the screen\n"
"  * `flush/0`       - flushes all messages sent to the shell\n"
"  * `h/0`           - prints this help message\n"
"  * `h/1`           - prints help for the given module, function or macro\n"
"  * `i/1`           - prints information about the data type of any given term\n"
"  * `import_file/1` - evaluates the given file in the shell's context\n"
"  * `l/1`           - loads the given module's BEAM code\n"
"  * `ls/0`          - lists the contents of the current directory\n"
"  * `ls/1`          - lists the contents of the specified directory\n"
"  * `nl/2`          - deploys local BEAM code to a list of nodes\n"
"  * `pid/1`         - creates a PID from a string\n"
"  * `pid/3`         - creates a PID with the 3 integer arguments passed\n"
"  * `pwd/0`         - prints the current working directory\n"
"  * `r/1`           - recompiles the given module's source file\n"
"  * `recompile/0`   - recompiles the current project\n"
"  * `respawn/0`     - respawns the current shell\n"
"  * `s/1`           - prints spec information\n"
"  * `t/1`           - prints type information\n"
"  * `v/0`           - retrieves the last value from the history\n"
"  * `v/1`           - retrieves the nth value from the history\n"
"\n"
"Help for all of those functions can be consulted directly from\n"
"the command line using the `h/1` helper itself. Try:\n"
"\n"
"    iex> h(v/0)\n"
"\n"
"To learn more about IEx as a whole, type `h(IEx)`.\n"
msgstr ""
#. TRANSLATORS: def IEx.Helpers.respawn()
#: lib/iex/helpers.ex:606 
msgid ""
"Respawns the current shell by starting a new shell process.\n"
"\n"
"Returns `true` if it worked.\n"
msgstr ""
#. TRANSLATORS: def IEx.Helpers.recompile()
#: lib/iex/helpers.ex:60 
msgid ""
"Recompiles the current Mix application.\n"
"\n"
"This helper only works when IEx is started with a Mix\n"
"project, for example, `iex -S mix`. The application is\n"
"not restarted after compilation, which means any long\n"
"running process may crash as the code is updated but the\n"
"state does not go through the proper code changes callback.\n"
"In any case, the supervision tree should notice the failure\n"
"and restart such servers.\n"
"\n"
"If you want to reload a single module, consider using\n"
"`r ModuleName` instead.\n"
"\n"
"This function is meant to be used for development and\n"
"debugging purposes. Do not depend on it in production code.\n"
msgstr ""
#. TRANSLATORS: def IEx.Helpers.v(n \\ -1)
#: lib/iex/helpers.ex:359 
msgid ""
"Returns the value of the `n`th expression in the history.\n"
"\n"
"`n` can be a negative value: if it is, the corresponding expression value\n"
"relative to the current one is returned. For example, `v(-2)` returns the\n"
"value of the expression evaluated before the last evaluated expression. In\n"
"particular, `v(-1)` returns the result of the last evaluated expression and\n"
"`v()` does the same.\n"
"\n"
"## Examples\n"
"\n"
"    iex(1)> \"hello\" <> \" world\"\n"
"    \"hello world\"\n"
"    iex(2)> 40 + 2\n"
"    42\n"
"    iex(3)> v(-2)\n"
"    \"hello world\"\n"
"    iex(4)> v(2)\n"
"    42\n"
"    iex(5)> v()\n"
"    42\n"
"\n"
msgstr ""
#. TRANSLATORS: defmacro IEx.Helpers.h(term)
#: lib/iex/helpers.ex:197 
msgid ""
"Prints the documentation for the given module\n"
"or for the given function/arity pair.\n"
"\n"
"## Examples\n"
"\n"
"    iex> h(Enum)\n"
"\n"
"It also accepts functions in the format `fun/arity`\n"
"and `module.fun/arity`, for example:\n"
"\n"
"    iex> h receive/1\n"
"    iex> h Enum.all?/2\n"
"    iex> h Enum.all?\n"
"\n"
msgstr ""
#. TRANSLATORS: def IEx.Helpers.clear()
#: lib/iex/helpers.ex:173 
msgid ""
"Clears the console screen.\n"
"\n"
"This function only works if ANSI escape codes are enabled\n"
"on the shell, which means this function is by default\n"
"unavailable on Windows machines.\n"
msgstr ""
#. TRANSLATORS: def IEx.Helpers.i(term)
#: lib/iex/helpers.ex:445 
msgid ""
"Prints information about the data type of any given term.\n"
"\n"
"## Examples\n"
"\n"
"    iex> i(1..5)\n"
"\n"
"Will print:\n"
"\n"
"    Term\n"
"      1..5\n"
"    Data type\n"
"      Range\n"
"    Description\n"
"      This is a struct. Structs are maps with a __struct__ key.\n"
"    Reference modules\n"
"      Range, Map\n"
"\n"
msgstr ""
#. TRANSLATORS: def IEx.Helpers.h()
#: lib/iex/helpers.ex:189 
msgid ""
"Prints the documentation for `IEx.Helpers`.\n"
msgstr ""
#. TRANSLATORS: defmacro IEx.Helpers.s(term)
#: lib/iex/helpers.ex:320 
msgid ""
"Prints the specs for the given module or for the given function/arity pair.\n"
"\n"
"## Examples\n"
"\n"
"    iex> s(Enum)\n"
"    iex> s(Enum.all?)\n"
"    iex> s(Enum.all?/2)\n"
"    iex> s(is_atom)\n"
"    iex> s(is_atom/1)\n"
"\n"
msgstr ""
#. TRANSLATORS: def IEx.Helpers.flush()
#: lib/iex/helpers.ex:490 
msgid ""
"Flushes all messages sent to the shell and prints them out.\n"
msgstr ""
#. TRANSLATORS: defmacro IEx.Helpers.import_file_if_available(path)
#: lib/iex/helpers.ex:618 
msgid ""
"Similar to `import_file` but only imports the file it if it is available.\n"
"\n"
"By default, `import_file/1` fails when the given file does not exist.\n"
"However, since `import_file/1` is expanded at compile-time, it's not\n"
"possible to conditionally import a file since the macro is always\n"
"expanded:\n"
"\n"
"    # This raises a File.Error if ~/.iex.exs doesn't exist.\n"
"    if (\"~/.iex.exs\" |> Path.expand |> File.exists?) do\n"
"      import_file \"~/.iex.exs\"\n"
"    end\n"
"\n"
"This macro addresses this issue by checking if the file exists or not\n"
"in behalf of the user.\n"
msgstr ""
