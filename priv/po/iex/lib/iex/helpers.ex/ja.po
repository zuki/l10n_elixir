msgid ""
msgstr ""
"Project-Id-Version: l 10n_elixir\n"
"POT-Creation-Date: \n"
"PO-Revision-Date: 2017-01-24 14:45+0900\n"
"Last-Translator: Keiji Suzuki <EMAIL@ADDRESS>\n"
"Language-Team: Japanese\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Poedit 1.8.11\n"

#. TRANSLATORS: def IEx.Helpers.pwd()
#: lib/iex/helpers.ex:516
msgid "Prints the current working directory.\n"
msgstr "現在の作業ディレクトリを表示します。\n"

#. TRANSLATORS: def IEx.Helpers.ls(path \\ ".")
#: lib/iex/helpers.ex:536
msgid ""
"Produces a simple list of a directory's contents.\n"
"\n"
"If `path` points to a file, prints its full path.\n"
msgstr ""
"ディレクトリ内容の簡単なリストを提供します。\n"
"\n"
"`path`がファイルを指している場合は、そのフルパスを表示します。\n"

#. TRANSLATORS: def IEx.Helpers.r(module)
#: lib/iex/helpers.ex:386
msgid ""
"Recompiles and reloads the given `module`.\n"
"\n"
"Please note that all the modules defined in the same\n"
"file as `module` are recompiled and reloaded.\n"
"\n"
"This function is meant to be used for development and\n"
"debugging purposes. Do not depend on it in production code.\n"
"\n"
"## In-memory reloading\n"
"\n"
"When we reload the module in IEx, we recompile the module source\n"
"code, updating its contents in memory. The original `.beam` file\n"
"in disk, probably the one where the first definition of the module\n"
"came from, does not change at all.\n"
"\n"
"Since typespecs and docs are loaded from the .beam file (they\n"
"are not loaded in memory with the module because there is no need\n"
"for them to be in memory), they are not reloaded when you reload\n"
"the module.\n"
msgstr ""
"`module`をリコンパイルしてリロードします。\n"
"\n"
"`module`と同じファイルに定義されている全てのモジュールも\n"
"リコンパイル、リロードされることに注意してください。\n"
"\n"
"この関数は開発とデバッグ目的で使用されることを意図してます。\n"
"製品コードではこの関数は使わないでください。\n"
"\n"
"## インメモリ・リローディング\n"
"\n"
"IExでモジュールをリロードする時、モジュールソースコードを\n"
"リコンパイルし、メモリの内容を更新します。\n"
"モジュールの最初の定義が書かれているディスク上のオリジナルの\n"
"`.beam`ファイルが変更されることはありません。\n"
"\n"
"typespecsとdocsは、.beamファイルからロードされるので\n"
"(これらは必要がないため、メモリにはロードされません)、\n"
"モジュールをリロードしても、これらはリロードされません。\n"

#. TRANSLATORS: def IEx.Helpers.c(files, path \\ :in_memory)
#: lib/iex/helpers.ex:126
msgid ""
"Compiles the given files.\n"
"\n"
"It expects a list of files to compile and an optional path to write\n"
"the compiled code to (defaults to the current directory). When compiling\n"
"one file, there is no need to wrap it in a list.\n"
"\n"
"It returns the names of the compiled modules.\n"
"\n"
"If you want to recompile an existing module, check `r/1` instead.\n"
"\n"
"## Examples\n"
"\n"
"    iex> c [\"foo.ex\", \"bar.ex\"], \"ebin\"\n"
"    [Foo, Bar]\n"
"\n"
"    iex> c \"baz.ex\"\n"
"    [Baz]\n"
"\n"
msgstr ""
"指定したファイルをコンパイルします。\n"
"\n"
"コンパイルするファイルのリストを指定します。\n"
"オプションでコンパイルされたコードを書き出すパスを指定します\n"
"(デフォルトはカレントディレクトリです)。\n"
"ファイルを１つだけコンパイルする場合は、リストにする必要はありません。\n"
"\n"
"コンパイルされたモジュールの名前を返します。\n"
"\n"
"既存のモジュールをリコンパイルしたい場合は、代わりに`r/1`を\n"
"チェックしてみてください。\n"
"\n"
"## 例\n"
"\n"
"    iex> c [\"foo.ex\", \"bar.ex\"], \"ebin\"\n"
"    [Foo, Bar]\n"
"\n"
"    iex> c \"baz.ex\"\n"
"    [Baz]\n"
"\n"

#. TRANSLATORS: defmacro IEx.Helpers.import_if_available(quoted_module, opts \\ [])
#: lib/iex/helpers.ex:682
msgid ""
"Calls `import/2` with the given arguments, but only if the module is "
"available.\n"
"\n"
"This lets you put imports in `.iex.exs` files (including `~/.iex.exs`) "
"without\n"
"getting compile errors if you open a console where the module is not "
"available.\n"
"\n"
"## Example\n"
"\n"
"    # In ~/.iex.exs\n"
"    import_if_available Ecto.Query\n"
"\n"
msgstr ""
"`quoted_module`が利用可能な場合に限り、`import/2`を指定した引数で呼び出しま"
"す。\n"
"\n"
"そのモジュールが利用できないコンソールを開いた場合もコンパイルエラーを出すこ"
"となく\n"
"`.iex.exs`ファイル（`~/.iex.exs`を含む）にインポートを置くことができます。\n"
"\n"
"## 例\n"
"\n"
"    # ~/.iex.exs において\n"
"    import_if_available Ecto.Query\n"
"\n"

#. TRANSLATORS: def IEx.Helpers.cd(directory)
#: lib/iex/helpers.ex:524
msgid "Changes the current working directory to the given path.\n"
msgstr "カレントワーキングディレクトリを指定のパスに変更します。\n"

#. TRANSLATORS: defmacro IEx.Helpers.b(term)
#: lib/iex/helpers.ex:252
msgid ""
"Prints the documentation for the given callback function.\n"
"\n"
"It also accepts single module argument to list\n"
"all available behaviour callbacks.\n"
"\n"
"## Examples\n"
"\n"
"    iex> b(Mix.Task.run/1)\n"
"    iex> b(Mix.Task.run)\n"
"    iex> b(GenServer)\n"
msgstr ""
"指定したコールバック関数のドキュメントを表示します。\n"
"\n"
"また、モジュールのみを引数にすることもでき、その場合、\n"
"利用可能なすべてのbehaviourコールバックを表示します。\n"
"\n"
"## 例\n"
"\n"
"    iex> b(Mix.Task.run/1)\n"
"    iex> b(Mix.Task.run)\n"
"    iex> b(GenServer)\n"

#. TRANSLATORS: def IEx.Helpers.pid(string)
#: lib/iex/helpers.ex:722
msgid ""
"Creates a PID from `string`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> pid(\"0.21.32\")\n"
"    #PID<0.21.32>\n"
"\n"
msgstr ""
"`string`からPIDを作成します。\n"
"\n"
"## 例\n"
"\n"
"    iex> pid(\"0.21.32\")\n"
"    #PID<0.21.32>\n"
"\n"

#. TRANSLATORS: def IEx.Helpers.l(module)
#: lib/iex/helpers.ex:432
msgid ""
"Loads the given module's BEAM code (and ensures any previous\n"
"old version was properly purged before).\n"
"\n"
"This function is useful when you know the bytecode for module\n"
"has been updated in the filesystem and you want to tell the VM\n"
"to load it.\n"
msgstr ""
"指定したモジュールのbeamコードをロードします。(また、ロード前には\n"
"以前の古いバージョンが正しくパージされることを保証します)。\n"
"\n"
"この関数は、ファイルシステムでモジュールのバイトコードが\n"
"更新されたことを知っていて、VMにロードするように教えたい\n"
"時に便利です。\n"

#. TRANSLATORS: def IEx.Helpers.pid(x, y, z)
#: lib/iex/helpers.ex:735
msgid ""
"Creates a PID with 3 non negative integers passed as arguments\n"
"to the function.\n"
"\n"
"## Examples\n"
"\n"
"    iex> pid(0, 21, 32)\n"
"    #PID<0.21.32>\n"
"    iex> pid(0, 64, 2048)\n"
"    #PID<0.64.2048>\n"
"\n"
msgstr ""
"この関数へ引数として渡された3つの非負整数からPIDを\n"
"作成します。\n"
"\n"
"## 例\n"
"\n"
"    iex> pid(0, 21, 32)\n"
"    #PID<0.21.32>\n"
"    iex> pid(0, 64, 2048)\n"
"    #PID<0.64.2048>\n"
"\n"

#. TRANSLATORS: defmacro IEx.Helpers.import_file(path)
#: lib/iex/helpers.ex:650
msgid ""
"Evaluates the contents of the file at `path` as if it were directly typed "
"into\n"
"the shell.\n"
"\n"
"`path` has to be a literal string. `path` is automatically expanded via\n"
"`Path.expand/1`.\n"
"\n"
"## Examples\n"
"\n"
"    # ~/file.exs\n"
"    value = 13\n"
"\n"
"    # in the shell\n"
"    iex(1)> import_file \"~/file.exs\"\n"
"    13\n"
"    iex(2)> value\n"
"    13\n"
"\n"
msgstr ""
"`path` ファイルの内容をシェルに直接入力したかのように\n"
"評価します。\n"
"\n"
"`path` はリテラル文字列でなければなりません。`path` は`Path.expand/1` を\n"
"使って自動的に展開されます。\n"
"\n"
"## 例\n"
"\n"
"    # ~/file.exs\n"
"    value = 13\n"
"\n"
"    # シェルにおいて\n"
"    iex(1)> import_file \"~/file.exs\"\n"
"    13\n"
"    iex(2)> value\n"
"    13\n"
"\n"

#. TRANSLATORS: def IEx.Helpers.nl(nodes \\ Node.list(), module)
#: lib/iex/helpers.ex:757
msgid ""
"Deploys a given module's BEAM code to a list of nodes.\n"
"\n"
"This function is useful for development and debugging when you have code "
"that\n"
"has been compiled or updated locally that you want to run on other nodes.\n"
"\n"
"The node list defaults to a list of all connected nodes.\n"
"\n"
"Returns `{:error, :nofile}` if the object code (i.e. \".beam\" file) for the "
"module\n"
"could not be found locally.\n"
"\n"
"## Examples\n"
"\n"
"    iex> nl(HelloWorld)\n"
"    {:ok, [{:node1@easthost, :loaded, HelloWorld},\n"
"           {:node1@westhost, :loaded, HelloWorld}]}\n"
"\n"
"    iex> nl(NoSuchModuleExists)\n"
"    {:error, :nofile}\n"
"\n"
msgstr ""
"指定したモジュールのbeamコードをノードリストへデプロイします。\n"
"\n"
"この関数は、ローカルに他のノードで走らせたい、コンパイルまたは\n"
"更新されたコードがある場合の開発とデバッグに便利です。\n"
"\n"
"ノードリストのデフォルトは全ての接続されたノードです。\n"
"\n"
"モジュールのオブジェクトコード（すなわち、”.beam”ファイル）がローカルにみつか"
"らない場合は\n"
"`{:error, :nofile}`を返します。\n"
"\n"
"## 例\n"
"\n"
"    iex> nl(HelloWorld)\n"
"    {:ok, [{:node1@easthost, :loaded, HelloWorld},\n"
"           {:node1@westhost, :loaded, HelloWorld}]}\n"
"\n"
"    iex> nl(NoSuchModuleExists)\n"
"    {:error, :nofile}\n"
"\n"

#. TRANSLATORS: defmacro IEx.Helpers.t(term)
#: lib/iex/helpers.ex:283
msgid ""
"Prints the types for the given module or for the given function/arity pair.\n"
"\n"
"## Examples\n"
"\n"
"    iex> t(Enum)\n"
"    @type t() :: Enumerable.t()\n"
"    @type element() :: any()\n"
"    @type index() :: integer()\n"
"    @type default() :: any()\n"
"\n"
"    iex> t(Enum.t/0)\n"
"    @type t() :: Enumerable.t()\n"
"\n"
"    iex> t(Enum.t)\n"
"    @type t() :: Enumerable.t()\n"
"\n"
msgstr ""
"指定のモジュールまたは関数/アリティ組の型を表示します。\n"
"\n"
"## 例\n"
"\n"
"    iex> t(Enum)\n"
"    @type t() :: Enumerable.t()\n"
"    @type element() :: any()\n"
"    @type index() :: integer()\n"
"    @type default() :: any()\n"
"\n"
"    iex> t(Enum.t/0)\n"
"    @type t() :: Enumerable.t()\n"
"\n"
"    iex> t(Enum.t)\n"
"    @type t() :: Enumerable.t()\n"
"\n"

#. TRANSLATORS: Elixir.IEx.Helpers Summary
#: lib/iex/helpers.ex:2
msgid ""
"Welcome to Interactive Elixir. You are currently\n"
"seeing the documentation for the module `IEx.Helpers`\n"
"which provides many helpers to make Elixir's shell\n"
"more joyful to work with.\n"
"\n"
"This message was triggered by invoking the helper `h()`,\n"
"usually referred to as `h/0` (since it expects 0 arguments).\n"
"\n"
"You can use the `h/1` function to invoke the documentation\n"
"for any Elixir module or function:\n"
"\n"
"    iex> h Enum\n"
"    iex> h Enum.map\n"
"    iex> h Enum.reverse/1\n"
"\n"
"You can also use the `i/1` function to introspect any value\n"
"you have in the shell:\n"
"\n"
"    iex> i \"hello\"\n"
"\n"
"There are many other helpers available:\n"
"\n"
"  * `b/1`           - prints callbacks info and docs for a given module\n"
"  * `c/1`           - compiles a file into the current directory\n"
"  * `c/2`           - compiles a file to the given path\n"
"  * `cd/1`          - changes the current directory\n"
"  * `clear/0`       - clears the screen\n"
"  * `flush/0`       - flushes all messages sent to the shell\n"
"  * `h/0`           - prints this help message\n"
"  * `h/1`           - prints help for the given module, function or macro\n"
"  * `i/1`           - prints information about the data type of any given "
"term\n"
"  * `import_file/1` - evaluates the given file in the shell's context\n"
"  * `l/1`           - loads the given module's BEAM code\n"
"  * `ls/0`          - lists the contents of the current directory\n"
"  * `ls/1`          - lists the contents of the specified directory\n"
"  * `nl/2`          - deploys local BEAM code to a list of nodes\n"
"  * `pid/1`         - creates a PID from a string\n"
"  * `pid/3`         - creates a PID with the 3 integer arguments passed\n"
"  * `pwd/0`         - prints the current working directory\n"
"  * `r/1`           - recompiles the given module's source file\n"
"  * `recompile/0`   - recompiles the current project\n"
"  * `respawn/0`     - respawns the current shell\n"
"  * `s/1`           - prints spec information\n"
"  * `t/1`           - prints type information\n"
"  * `v/0`           - retrieves the last value from the history\n"
"  * `v/1`           - retrieves the nth value from the history\n"
"\n"
"Help for all of those functions can be consulted directly from\n"
"the command line using the `h/1` helper itself. Try:\n"
"\n"
"    iex> h(v/0)\n"
"\n"
"To learn more about IEx as a whole, type `h(IEx)`.\n"
msgstr ""
"インタラクティブElixirへようこそ。これはElixirシェルをもっと楽し\n"
"くするために多くのヘルパーを提供している`IEx.Helpers`モジュールの\n"
"ドキュメントです。\n"
"\n"
"このメッセージは、通常 `h/0`(これは引数の数が0個ということを示しています)\n"
"で参照されるヘルパー`h()`を起動することにより表示されるものです。\n"
"\n"
"Elixirの任意のモジュールや関数のドキュメントを表示するには\n"
"`h/1`関数を使います:\n"
"\n"
"    iex> h Enum\n"
"    iex> h Enum.map\n"
"    iex> h Enum.reverse/1\n"
"\n"
"shellの中にいる場合は、任意の値の内部情報を見るために`i/1`関数を使うことも\n"
"できます:\n"
"\n"
"    iex> i \"hello\"\n"
"\n"
"他にも沢山のヘルパーが利用できます:\n"
"\n"
"  * `b/1`           - 与えられたモジュールのcallback info と docsを表示しま"
"す\n"
"  * `c/1`           - ファイルをコンパイルしてカレントディレクトリに置きま"
"す\n"
"  * `c/2`           - ファイルをコンパイルして指定のパスに置きます\n"
"  * `cd/1`          - カレントディレクトリを変更します\n"
"  * `clear/0`       - スクリーンをクリアします\n"
"  * `flush/0`       - シェルへ送信したすべてのメッセージをフラッシュします\n"
"  * `h/0`           - このヘルプメッセージを表示します\n"
"  * `h/1`           - 与えられたモジュール、関数、マクロのヘルプを表示しま"
"す\n"
"  * `i/1`           - 与えられた項のデータタイプに関する情報を表示します\n"
"  * `import_file/1` - 与えられたファイルをシェルのコンテキストで評価します\n"
"  * `l/1`           - 与えられたモジュールのbeamコードをロードします\n"
"  * `ls/0`          - カレントディレクトリの内容をリストします\n"
"  * `ls/1`          - 指定されたディレクトリの内容をリストします\n"
"  * `nl/2`          - 与えられたbeamコードをノードのリストへデプロイします\n"
"  * `pid/1`         - 文字列からPIDを作成します\n"
"  * `pid/3`         - 渡された3つの整数引数でPIDを作成します\n"
"  * `pwd/0`         - カレントワーキングディレクトリを表示します\n"
"  * `r/1`           - 与えられたモジュールのソースファイルを再コンパイルしま"
"す\n"
"  * `recompile/0`   - 現在のプロジェクトを再コンパイルします\n"
"  * `respawn/0`     - 現在のシェルを再生成します\n"
"  * `s/1`           - Spec情報を表示します\n"
"  * `t/1`           - 型情報を表示します\n"
"  * `v/0`           - 履歴の最新の値を取り出します\n"
"  * `v/1`           - 履歴のn番目の値を取り出します\n"
"\n"
"これらすべての関数のヘルプは`h/1`を使ってコマンドラインから\n"
"直接調べることができます。次のようにです:\n"
"\n"
"    iex> h(v/0)\n"
"\n"
"IEx全般についてもっと学ぶためには、`h(IEx)`とタイプしてください。\n"

#. TRANSLATORS: def IEx.Helpers.respawn()
#: lib/iex/helpers.ex:606
msgid ""
"Respawns the current shell by starting a new shell process.\n"
"\n"
"Returns `true` if it worked.\n"
msgstr ""
"新しいシェルプロセスを開始することで現在のシェルを再生成します。\n"
"\n"
"成功すると`true`を返します。\n"

#. TRANSLATORS: def IEx.Helpers.recompile()
#: lib/iex/helpers.ex:60
msgid ""
"Recompiles the current Mix application.\n"
"\n"
"This helper only works when IEx is started with a Mix\n"
"project, for example, `iex -S mix`. The application is\n"
"not restarted after compilation, which means any long\n"
"running process may crash as the code is updated but the\n"
"state does not go through the proper code changes callback.\n"
"In any case, the supervision tree should notice the failure\n"
"and restart such servers.\n"
"\n"
"If you want to reload a single module, consider using\n"
"`r ModuleName` instead.\n"
"\n"
"This function is meant to be used for development and\n"
"debugging purposes. Do not depend on it in production code.\n"
msgstr ""
"現在のMixアプリケーションを再コンパイルします。\n"
"\n"
"このヘルパはIExが、たとえば`iex -S mix`のように、\n"
"Mixプロジェクトを伴って開始された場合にのみ動作します。\n"
"コンパイル後にアプリケーションは再スタートしません。\n"
"これは、コードは更新されるが状態は適切なコード変更callbackを\n"
"経ないため、稼働中だったプロセスはクラッシュする可能性が\n"
"あることを意味します。いずれにしても、監視ツリーはその障害に\n"
"気づき、サーバをリスタートするはずです。\n"
"\n"
"一つのモジュールをリロードしたい場合は、代わりに\n"
"`r ModuleName`の使用を検討してください。\n"
"\n"
"この関数は開発またはデバッグ目的で使用されることを意図してます。\n"
"製品コードでは使用しないでください。\n"

#. TRANSLATORS: def IEx.Helpers.v(n \\ -1)
#: lib/iex/helpers.ex:359
msgid ""
"Returns the value of the `n`th expression in the history.\n"
"\n"
"`n` can be a negative value: if it is, the corresponding expression value\n"
"relative to the current one is returned. For example, `v(-2)` returns the\n"
"value of the expression evaluated before the last evaluated expression. In\n"
"particular, `v(-1)` returns the result of the last evaluated expression and\n"
"`v()` does the same.\n"
"\n"
"## Examples\n"
"\n"
"    iex(1)> \"hello\" <> \" world\"\n"
"    \"hello world\"\n"
"    iex(2)> 40 + 2\n"
"    42\n"
"    iex(3)> v(-2)\n"
"    \"hello world\"\n"
"    iex(4)> v(2)\n"
"    42\n"
"    iex(5)> v()\n"
"    42\n"
"\n"
msgstr ""
"履歴の`n`番目の式の値を返します。\n"
"\n"
"`n`には負値も指定できます。その場合、現在の式から相対した\n"
"該当の式の値が返ります。たとえば、`v(-2)`は、最後に評価された\n"
"式の前に評価された式の値が返ります。特に、`v(-1)`は最後に\n"
"評価した式の結果を返します。また、`v(0)`も同じです。\n"
"\n"
"## 例\n"
"\n"
"    iex(1)> \"hello\" <> \" world\"\n"
"    \"hello world\"\n"
"    iex(2)> 40 + 2\n"
"    42\n"
"    iex(3)> v(-2)\n"
"    \"hello world\"\n"
"    iex(4)> v(2)\n"
"    42\n"
"    iex(5)> v()\n"
"    42\n"
"\n"

#. TRANSLATORS: defmacro IEx.Helpers.h(term)
#: lib/iex/helpers.ex:197
msgid ""
"Prints the documentation for the given module\n"
"or for the given function/arity pair.\n"
"\n"
"## Examples\n"
"\n"
"    iex> h(Enum)\n"
"\n"
"It also accepts functions in the format `fun/arity`\n"
"and `module.fun/arity`, for example:\n"
"\n"
"    iex> h receive/1\n"
"    iex> h Enum.all?/2\n"
"    iex> h Enum.all?\n"
"\n"
msgstr ""
"指定したモジュールまたは関数/アリティ組のドキュメントを\n"
"表示します。\n"
"\n"
"## 例\n"
"\n"
"    iex> h(Enum)\n"
"\n"
"また、`fun/arity`または`module.fun/arity`の形式の関数も\n"
"受け付けます。例えば: \n"
"\n"
"    iex> h receive/1\n"
"    iex> h Enum.all?/2\n"
"    iex> h Enum.all?\n"
"\n"

#. TRANSLATORS: def IEx.Helpers.clear()
#: lib/iex/helpers.ex:173
msgid ""
"Clears the console screen.\n"
"\n"
"This function only works if ANSI escape codes are enabled\n"
"on the shell, which means this function is by default\n"
"unavailable on Windows machines.\n"
msgstr ""
"コンソールスクリーンをクリアします。\n"
"\n"
"この関数はANSIエスケープコードが有効なシェルでのみ動作します。\n"
"これはこの関数はデフォルトではWindowsで利用できないことを\n"
"意味します。\n"

#. TRANSLATORS: def IEx.Helpers.i(term)
#: lib/iex/helpers.ex:445
msgid ""
"Prints information about the data type of any given term.\n"
"\n"
"## Examples\n"
"\n"
"    iex> i(1..5)\n"
"\n"
"Will print:\n"
"\n"
"    Term\n"
"      1..5\n"
"    Data type\n"
"      Range\n"
"    Description\n"
"      This is a struct. Structs are maps with a __struct__ key.\n"
"    Reference modules\n"
"      Range, Map\n"
"\n"
msgstr ""
"指定した項のデータ型に関する情報を表示します。\n"
"\n"
"## 例\n"
"\n"
"    iex> i(1..5)\n"
"\n"
"次のように表示されます:\n"
"\n"
"    Term\n"
"      1..5\n"
"    Data type\n"
"      Range\n"
"    Description\n"
"      This is a struct. Structs are maps with a __struct__ key.\n"
"    Reference modules\n"
"      Range, Map\n"
"\n"

#. TRANSLATORS: def IEx.Helpers.h()
#: lib/iex/helpers.ex:189
msgid "Prints the documentation for `IEx.Helpers`.\n"
msgstr "`IEx.Helpers`のドキュメントを表示します。\n"

#. TRANSLATORS: defmacro IEx.Helpers.s(term)
#: lib/iex/helpers.ex:320
msgid ""
"Prints the specs for the given module or for the given function/arity pair.\n"
"\n"
"## Examples\n"
"\n"
"    iex> s(Enum)\n"
"    iex> s(Enum.all?)\n"
"    iex> s(Enum.all?/2)\n"
"    iex> s(is_atom)\n"
"    iex> s(is_atom/1)\n"
"\n"
msgstr ""
"指定したモジュールまたは関数/アリティ組のspecを表示します。\n"
"\n"
"## 例\n"
"\n"
"    iex> s(Enum)\n"
"    iex> s(Enum.all?)\n"
"    iex> s(Enum.all?/2)\n"
"    iex> s(is_atom)\n"
"    iex> s(is_atom/1)\n"
"\n"

#. TRANSLATORS: def IEx.Helpers.flush()
#: lib/iex/helpers.ex:490
msgid "Flushes all messages sent to the shell and prints them out.\n"
msgstr "シェルへ送られた全てのメッセージをフラッシュして表示します。\n"

#. TRANSLATORS: defmacro IEx.Helpers.import_file_if_available(path)
#: lib/iex/helpers.ex:618
msgid ""
"Similar to `import_file` but only imports the file it if it is available.\n"
"\n"
"By default, `import_file/1` fails when the given file does not exist.\n"
"However, since `import_file/1` is expanded at compile-time, it's not\n"
"possible to conditionally import a file since the macro is always\n"
"expanded:\n"
"\n"
"    # This raises a File.Error if ~/.iex.exs doesn't exist.\n"
"    if (\"~/.iex.exs\" |> Path.expand |> File.exists?) do\n"
"      import_file \"~/.iex.exs\"\n"
"    end\n"
"\n"
"This macro addresses this issue by checking if the file exists or not\n"
"in behalf of the user.\n"
msgstr ""
"`import_file`と同じですが、利用可能なファイルのみインポートします。\n"
"\n"
"デフォルトでは、`import_file/1` は指定したファイルが存在しない\n"
"場合失敗します。しかし、`import_file/1`はコンパイル時に展開される\n"
"ので、ファイルを条件付きでインポートすることはできません。マクロは\n"
"常に展開されるからです。\n"
"\n"
"    #  ~/.iex.exs が存在しないとこれは File.Error を発生します。\n"
"    if (\"~/.iex.exs\" |> Path.expand |> File.exists?) do\n"
"      import_file \"~/.iex.exs\"\n"
"    end\n"
"\n"
