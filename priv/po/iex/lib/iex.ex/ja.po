msgid ""
msgstr ""
"Project-Id-Version: l 10n_elixir\n"
"PO-Revision-Date: 2017-01-23 11:04+0900\n"
"Last-Translator: Keiji Suzuki <EMAIL@ADDRESS>\n"
"Language-Team: Japanese\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#. TRANSLATORS: defmacro IEx.pry(timeout \\ 5000)
#: lib/iex.ex:390
msgid ""
"Pries into the process environment.\n"
"\n"
"This is useful for debugging a particular chunk of code\n"
"and inspect the state of a particular process. The process\n"
"is temporarily changed to trap exits (i.e. the process flag\n"
"`:trap_exit` is set to `true`) and has the `group_leader` changed\n"
"to support ANSI escape codes. Those values are reverted by\n"
"calling `respawn`, which starts a new IEx shell, freeing up\n"
"the pried one.\n"
"\n"
"When a process is pried, all code runs inside IEx and, as\n"
"such, it is evaluated and cannot access private functions\n"
"of the module being pried. Module functions still need to be\n"
"accessed via `Mod.fun(args)`.\n"
"\n"
"## Examples\n"
"\n"
"Let's suppose you want to investigate what is happening\n"
"with some particular function. By invoking `IEx.pry/1` from\n"
"the function, IEx will allow you to access its binding\n"
"(variables), verify its lexical information and access\n"
"the process information. Let's see an example:\n"
"\n"
"    import Enum, only: [map: 2]\n"
"    require IEx\n"
"\n"
"    defmodule Adder do\n"
"      def add(a, b) do\n"
"        c = a + b\n"
"        IEx.pry\n"
"      end\n"
"    end\n"
"\n"
"When invoking `Adder.add(1, 2)`, you will receive a message in\n"
"your shell to pry the given environment. By allowing it,\n"
"the shell will be reset and you gain access to all variables\n"
"and the lexical scope from above:\n"
"\n"
"    pry(1)> map([a, b, c], &IO.inspect(&1))\n"
"    1\n"
"    2\n"
"    3\n"
"\n"
"Keep in mind that `IEx.pry/1` runs in the caller process,\n"
"blocking the caller during the evaluation cycle. The caller\n"
"process can be freed by calling `respawn`, which starts a\n"
"new IEx evaluation cycle, letting this one go:\n"
"\n"
"    pry(2)> respawn\n"
"    true\n"
"\n"
"    Interactive Elixir - press Ctrl+C to exit (type h() ENTER for help)\n"
"\n"
"Setting variables or importing modules in IEx does not\n"
"affect the caller the environment (hence it is called `pry`).\n"
msgstr ""
"プロセス環境を覗き見します。\n"
"\n"
"これは特定のコードの塊のデバッグと特定のプロセスの状態を\n"
"調べるのに役に立ちます。\n"
"\n"
"プロセスは一時的に`trap exits`に変更され(即ち、プロセスフラグ\n"
"`:trap_exit`が`true`にセットされます)、`group_leader`がANSIエスケープコー\n"
"ドをサポートするために変更されます。\n"
"これらの値は`respawn`を呼ぶことで戻され、新しいIExシェルを始め、\n"
"覗き見していたものを解放します。\n"
"\n"
"プロセスが覗き見されるとき、全てのコードはIExの中で動作します。そして覗\n"
"き見しているモジュールのプライベートな関数にアクセスしたり、評価したり\n"
"出来ません。モジュール関数は、まだ`Mod.fun(args)`でアクセスされる必要が\n"
"あります。\n"
"\n"
"## 例\n"
"\n"
"若干の特定の関数に何が起っているかを調査したいと仮定します。\n"
"IEx.pry/1を起動することにより、IExはあなたに変数のバインディングへの\n"
"アクセスやレキシカル情報の確認、プロセス情報へのアクセスを\n"
"許可するようになります。例を見てみましょう:\n"
"\n"
"    import Enum, only: [map: 2]\n"
"    require IEx\n"
"\n"
"    defmodule Adder do\n"
"      def add(a, b) do\n"
"        c = a + b\n"
"        IEx.pry\n"
"      end\n"
"    end\n"
"\n"
"`Adder.add(1, 2)`が起動されると、あなたのシェルに与えられた環境を覗くた\n"
"めのメッセージを受信します。これをあなたが許可することで、IEx.pryが呼び\n"
"出された時点でのレキシカルスコープと全ての変数へのアクセスが出来るよう\n"
"になります。\n"
"\n"
"    pry(1)> map([a, b, c], &IO.inspect(&1))\n"
"    1\n"
"    2\n"
"    3\n"
"\n"
"\n"
"評価サイクルの間ブロックされている呼び出し側プロセスの`IEx.pry/1`は動作中\n"
"であることに注意してください、呼び出し側プロセスは新しいIEx評価サイクル\n"
"を開始させる`respawn`の呼出により解放されます。これをやってみましょう:\n"
"\n"
"    pry(2)> respawn\n"
"    true\n"
"\n"
"    Interactive Elixir - press Ctrl+C to exit (type h() ENTER for help)\n"
"\n"
"IExでの変数の設定やモジュールのインポートは呼び出し側環境へ\n"
"影響を与えません(それ故、それは`pry`(「覗き見」)と呼ばれています)。\n"

#. TRANSLATORS: def IEx.inspect_opts()
#: lib/iex.ex:383
msgid "Gets the options used for inspecting.\n"
msgstr "インスペクトに使うオプションを取得します。\n"

#. TRANSLATORS: def IEx.pry(binding, env, timeout)
#: lib/iex.ex:453
msgid ""
"Callback for `IEx.pry/1`.\n"
"\n"
"You can invoke this function directly when you are not able to invoke\n"
"`IEx.pry/1` as a macro. This function expects the binding (from\n"
"`Kernel.binding/0`), the environment (from `__ENV__/0`) and the timeout\n"
"(a sensible default is 5000).\n"
msgstr ""
"`IEx.pry/1`のコールバックです。\n"
"\n"
"`IEx.pry/1`をマクロとして起動することが出来ない場合は、\n"
"この関数を直接起動することができます。この関数は引数に\n"
"binding(`Kernel.binding/0`)、environment(`__ENV__/0`)、\n"
"そしてtimeout(デフォルトは実用的な5000)を取ります。\n"

#. TRANSLATORS: def IEx.configure(options)
#: lib/iex.ex:227
msgid ""
"Configures IEx.\n"
"\n"
"The supported options are:\n"
"\n"
"  * `:colors`\n"
"  * `:inspect`\n"
"  * `:width`\n"
"  * `:history_size`\n"
"  * `:default_prompt`\n"
"  * `:alive_prompt`\n"
"\n"
"They are discussed individually in the sections below.\n"
"\n"
"## Colors\n"
"\n"
"A keyword list that encapsulates all color settings used by the\n"
"shell. See documentation for the `IO.ANSI` module for the list of\n"
"supported colors and attributes.\n"
"\n"
"List of supported keys in the keyword list:\n"
"\n"
"  * `:enabled`      - boolean value that allows for switching the coloring "
"on and off\n"
"  * `:eval_result`  - color for an expression's resulting value\n"
"  * `:eval_info`    - ... various informational messages\n"
"  * `:eval_error`   - ... error messages\n"
"  * `:stack_app`    - ... the app in stack traces\n"
"  * `:stack_info`   - ... the remaining info in stacktraces\n"
"  * `:ls_directory` - ... for directory entries (ls helper)\n"
"  * `:ls_device`    - ... device entries (ls helper)\n"
"\n"
"When printing documentation, IEx will convert the Markdown\n"
"documentation to ANSI as well. Colors for this can be configured\n"
"via:\n"
"\n"
"  * `:doc_code`        - the attributes for code blocks (cyan, bright)\n"
"  * `:doc_inline_code` - inline code (cyan)\n"
"  * `:doc_headings`    - h1 and h2 (yellow, bright)\n"
"  * `:doc_title`       - the overall heading for the output (reverse, "
"yellow, bright)\n"
"  * `:doc_bold`        - (bright)\n"
"  * `:doc_underline`   - (underline)\n"
"\n"
"IEx will also color inspected expressions using the `:syntax_colors`\n"
"option. Such can be disabled with:\n"
"\n"
"    IEx.configure [colors: [syntax_colors: false]]\n"
"\n"
"You can also configure the syntax colors, however, as desired:\n"
"\n"
"    IEx.configure [colors: [syntax_colors: [atom: :red]]]\n"
"\n"
"Configuration for most built-in data types are supported: `:atom`,\n"
"`:string`, `:binary`, `:list`, `:number`, `:boolean`, `:nil`, etc.\n"
"The default is:\n"
"\n"
"    [number: :magenta, atom: :cyan, string: :green,\n"
"     boolean: :magenta, nil: :magenta]\n"
"\n"
"## Inspect\n"
"\n"
"A keyword list containing inspect options used by the shell\n"
"when printing results of expression evaluation. Default to\n"
"pretty formatting with a limit of 50 entries.\n"
"\n"
"To show all entries, configure the limit to `:infinity`:\n"
"\n"
"    IEx.configure [inspect: [limit: :infinity]]\n"
"\n"
"See `Inspect.Opts` for the full list of options.\n"
"\n"
"## Width\n"
"\n"
"An integer indicating the number of columns to use in documentation\n"
"output. Default is 80 columns or result of `:io.columns`, whichever\n"
"is smaller. The configured value will be used unless it is too large,\n"
"which in that case `:io.columns` is used. This way you can configure\n"
"IEx to be your largest screen size and it should always take up the\n"
"full width of your terminal screen.\n"
"\n"
"## History size\n"
"\n"
"Number of expressions and their results to keep in the history.\n"
"The value is an integer. When it is negative, the history is unlimited.\n"
"\n"
"## Prompt\n"
"\n"
"This is an option determining the prompt displayed to the user\n"
"when awaiting input.\n"
"\n"
"The value is a keyword list with two possible keys representing prompt "
"types:\n"
"\n"
"  * `:default_prompt` - used when `Node.alive?/0` returns `false`\n"
"  * `:alive_prompt`   - used when `Node.alive?/0` returns `true`\n"
"\n"
"The following values in the prompt string will be replaced appropriately:\n"
"\n"
"  * `%counter` - the index of the history\n"
"  * `%prefix`  - a prefix given by `IEx.Server`\n"
"  * `%node`    - the name of the local node\n"
"\n"
msgstr ""
"IExの設定をします。\n"
"\n"
"サポートされるオプションは次の通り:\n"
"\n"
"  * `:colors`\n"
"  * `:inspect`\n"
"  * `:width`\n"
"  * `:history_size`\n"
"  * `:default_prompt`\n"
"  * `:alive_prompt`\n"
"\n"
"以下、個別に説明します。\n"
"\n"
"## Colors\n"
"\n"
"シェルで使われる全ての色設定をカプセル化したキーワードリストです。\n"
"サポートされている色と属性のリストについては`IO.ANSI`モジュールの\n"
"ドキュメントを参照してください。\n"
"\n"
"キーワドリストでサポートされているキーのリストは次の通り:\n"
"\n"
"  * `:enabled`      - カラーリングのオンとオフをスイッチするブール値\n"
"  * `:eval_result`  - 式の結果値のカラー\n"
"  * `:eval_info`    - ... いろいろな情報メッセージ\n"
"  * `:eval_error`   - ... エラーメッセージ\n"
"  * `:stack_app`    - ... スタックトレース中のapp\n"
"  * `:stack_info`   - ... スタックトレースの残りの情報\n"
"  * `:ls_directory` - ... ディレクトリエントリ (ls helper)\n"
"  * `:ls_device`    - ... デバイスエントリs (ls helper)\n"
"\n"
"ドキュメントを表示する際に、IExはMarkdownドキュメントをANSIに\n"
"コンバートします。以下でそれらの色を設定できます:\n"
"\n"
"  * `:doc_code`        - codeブロックの属性(cyan, bright)\n"
"  * `:doc_inline_code` - インラインコード (cyan)\n"
"  * `:doc_headings`    - h1 と h2 (yellow, bright)\n"
"  * `:doc_title`       - 出力の全体のヘディング (reverse,yellow,bright)\n"
"  * `:doc_bold`        - (bright)\n"
"  * `:doc_underline`   - (underline)\n"
"\n"
"IExは  `:syntax_colors`オプションを使うことで検査する式も\n"
"色付けます。これは次のようにして無効にすることができます:\n"
"\n"
"    IEx.configure [colors: [syntax_colors: false]]\n"
"\n"
"構文色は好きなように設定することもできます:\n"
"\n"
"    IEx.configure [colors: [syntax_colors: [atom: :red]]]\n"
"\n"
"`:atom`, `:string`, `:binary`, `:list`, `:number`, `:boolean`, `:nil`\n"
"など、ほとんどの組み込みデータ型の設定がサポートされています 。\n"
"デフォルトは次の通り:\n"
"\n"
"    [number: :magenta, atom: :cyan, string: :green,\n"
"     boolean: :magenta, nil: :magenta]\n"
"\n"
"## Inspect\n"
"\n"
"式を評価した結果を表示するときにシェルにより使用されるインスペクトオプ\n"
"ションを含んでいるキーワードリストです。プリティフォーマットのデフォル\n"
"トは50エントリに制限されています。\n"
"\n"
"すべてのエントリを表示するには、limitに`:infinity`を設定してください:\n"
"\n"
"    IEx.configure [inspect: [limit: :infinity]]\n"
"\n"
"オプションの完全なリストは`Inspect.Opts`を参照してください。\n"
"\n"
"## Width\n"
"\n"
"ドキュメントの出力時に使われるカラム数を示す整数です。\n"
"デフォルトは80カラムまたは`:io.columns`の結果のいずれか小さいほう\n"
"です。設定された値は大きすぎない限り使用されますが、大き過ぎると\n"
"`:io.columns`の値が使われます。これにより最大スクリーンサイズに\n"
"IExを設定でき、常にターミナルスクリーン一杯の幅で使えるようになる\n"
"はずです。\n"
"\n"
"## History size\n"
"\n"
"履歴に保持する式とその結果の数です。\n"
"その値は整数です。負数にすると履歴は無制限になります。\n"
"\n"
"## Prompt\n"
"\n"
"入力を待つときにユーザに表示するプロンプトを決定する\n"
"オプションです。\n"
"\n"
"値はキーワードリストです。プロンプトタイプを表す指定可能なキーが２つありま"
"す:\n"
"\n"
"  * `:default_prompt` - `Node.alive?` が `false` のとき使われます\n"
"  * `:alive_prompt`   - `Node.alive?` が `true` のとき使われます\n"
"\n"
"プロンプト文字列の中の以下の値は、適切に置換されます:\n"
"\n"
"  * `%counter` - 履歴のインデックス\n"
"  * `%prefix`  - `IEx.Server`により与えられたプレフィックス\n"
"  * `%node`    - ローカルノードの名前\n"
"\n"

#. TRANSLATORS: def IEx.started?()
#: lib/iex.ex:353
msgid "Returns `true` if IEx was started.\n"
msgstr "IExが開始されていた場合は`true`を返します。\n"

#. TRANSLATORS: Elixir.IEx Summary
#: lib/iex.ex:2
msgid ""
"Elixir's interactive shell.\n"
"\n"
"This module is the main entry point for Interactive Elixir and\n"
"in this documentation we will talk a bit about how IEx works.\n"
"\n"
"Notice that some of the functionalities described here will not be "
"available\n"
"depending on your terminal. In particular, if you get a message\n"
"saying that the smart terminal could not be run, some of the\n"
"features described here won't work.\n"
"\n"
"## Helpers\n"
"\n"
"IEx provides a bunch of helpers. They can be accessed by typing\n"
"`h()` into the shell or as a documentation for the `IEx.Helpers` module.\n"
"\n"
"## Autocomplete\n"
"\n"
"To discover all available functions for a module, type the module name\n"
"followed by a dot, then press tab to trigger autocomplete. For example:\n"
"\n"
"    Enum.\n"
"\n"
"Such function may not be available on some Windows shells. You may need\n"
"to pass the `--werl` flag when starting iex, as in `iex --werl` for it\n"
"to work. `--werl` may be permanently enabled by setting the `IEX_WITH_WERL`\n"
"environment variable.\n"
"\n"
"## The Break command\n"
"\n"
"Inside IEx, hitting `Ctrl+C` will open up the `BREAK` menu. In this\n"
"menu you can quit the shell, see process and ets tables information\n"
"and much more.\n"
"\n"
"## The User Switch command\n"
"\n"
"Besides the break command, one can type `Ctrl+G` to get to the\n"
"user switch command menu. When reached, you can type `h` to\n"
"get more information.\n"
"\n"
"In this menu, developers are able to start new shells and\n"
"alternate between them. Let's give it a try:\n"
"\n"
"    User switch command\n"
"     --> s 'Elixir.IEx'\n"
"     --> c\n"
"\n"
"The command above will start a new shell and connect to it.\n"
"Create a new variable called `hello` and assign some value to it:\n"
"\n"
"    hello = :world\n"
"\n"
"Now, let's roll back to the first shell:\n"
"\n"
"    User switch command\n"
"     --> c 1\n"
"\n"
"Now, try to access the `hello` variable again:\n"
"\n"
"    hello\n"
"    ** (UndefinedFunctionError) undefined function hello/0\n"
"\n"
"The command above fails because we have switched shells.\n"
"Since shells are isolated from each other, you can't access the\n"
"variables defined in one shell from the other one.\n"
"\n"
"The user switch command menu also allows developers to connect to remote\n"
"shells using the `r` command. A topic which we will discuss next.\n"
"\n"
"## Remote shells\n"
"\n"
"IEx allows you to connect to another node in two fashions.\n"
"First of all, we can only connect to a shell if we give names\n"
"both to the current shell and the shell we want to connect to.\n"
"\n"
"Let's give it a try. First start a new shell:\n"
"\n"
"    $ iex --sname foo\n"
"    iex(foo@HOST)1>\n"
"\n"
"The string between the parentheses in the prompt is the name\n"
"of your node. We can retrieve it by calling the `node/0`\n"
"function:\n"
"\n"
"    iex(foo@HOST)1> node()\n"
"    :\"foo@HOST\"\n"
"    iex(foo@HOST)2> Node.alive?()\n"
"    true\n"
"\n"
"For fun, let's define a simple module in this shell too:\n"
"\n"
"    iex(foo@HOST)3> defmodule Hello do\n"
"    ...(foo@HOST)3>   def world, do: \"it works!\"\n"
"    ...(foo@HOST)3> end\n"
"\n"
"Now, let's start another shell, giving it a name as well:\n"
"\n"
"    $ iex --sname bar\n"
"    iex(bar@HOST)1>\n"
"\n"
"If we try to dispatch to `Hello.world`, it won't be available\n"
"as it was defined only in the other shell:\n"
"\n"
"    iex(bar@HOST)1> Hello.world\n"
"    ** (UndefinedFunctionError) undefined function Hello.world/0\n"
"\n"
"However, we can connect to the other shell remotely. Open up\n"
"the User Switch prompt (Ctrl+G) and type:\n"
"\n"
"    User switch command\n"
"     --> r 'foo@HOST' 'Elixir.IEx'\n"
"     --> c\n"
"\n"
"Now we are connected into the remote node, as the prompt shows us,\n"
"and we can access the information and modules defined over there:\n"
"\n"
"    rem(foo@macbook)1> Hello.world\n"
"    \"it works\"\n"
"\n"
"In fact, connecting to remote shells is so common that we provide\n"
"a shortcut via the command line as well:\n"
"\n"
"    $ iex --sname baz --remsh foo@HOST\n"
"\n"
"Where \"remsh\" means \"remote shell\". In general, Elixir supports:\n"
"\n"
"  * remsh from an Elixir node to an Elixir node\n"
"  * remsh from a plain Erlang node to an Elixir node (through the ^G menu)\n"
"  * remsh from an Elixir node to a plain Erlang node (and get an `erl` shell "
"there)\n"
"\n"
"Connecting an Elixir shell to a remote node without Elixir is\n"
"**not** supported.\n"
"\n"
"## The .iex.exs file\n"
"\n"
"When starting, IEx looks for a local `.iex.exs` file (located in the "
"current\n"
"working directory), then a global one (located at `~/.iex.exs`) and loads "
"the\n"
"first one it finds (if any). The code in the loaded `.iex.exs` file is\n"
"evaluated in the shell's context. So, for instance, any modules that are\n"
"loaded or variables that are bound in the `.iex.exs` file will be available "
"in the\n"
"shell after it has booted.\n"
"\n"
"For example, take the following `.iex.exs` file:\n"
"\n"
"    # Load another \".iex.exs\" file\n"
"    import_file \"~/.iex.exs\"\n"
"\n"
"    # Import some module from lib that may not yet have been defined\n"
"    import_if_available MyApp.Mod\n"
"\n"
"    # Print something before the shell starts\n"
"    IO.puts \"hello world\"\n"
"\n"
"    # Bind a variable that'll be accessible in the shell\n"
"    value = 13\n"
"\n"
"Running IEx in the directory where the above `.iex.exs` file is located\n"
"results in:\n"
"\n"
"    $ iex\n"
"    Erlang 19 [...]\n"
"\n"
"    hello world\n"
"    Interactive Elixir - press Ctrl+C to exit (type h() ENTER for help)\n"
"    iex(1)> value\n"
"    13\n"
"\n"
"It is possible to load another file by supplying the `--dot-iex`\n"
"option to IEx. See `iex --help`.\n"
"\n"
"## Configuring the shell\n"
"\n"
"There are a number of customization options provided by IEx. Take a look\n"
"at the docs for the `IEx.configure/1` function by typing `h IEx."
"configure/1`.\n"
"\n"
"Those options can be configured in your project configuration file or "
"globally\n"
"by calling `IEx.configure/1` from your `~/.iex.exs` file. For example:\n"
"\n"
"    # .iex.exs\n"
"    IEx.configure(inspect: [limit: 3])\n"
"\n"
"Now run the shell:\n"
"\n"
"    $ iex\n"
"    Erlang 19 [...]\n"
"\n"
"    Interactive Elixir - press Ctrl+C to exit (type h() ENTER for help)\n"
"    iex(1)> [1, 2, 3, 4, 5]\n"
"    [1, 2, 3, ...]\n"
"\n"
"## Expressions in IEx\n"
"\n"
"As an interactive shell, IEx evaluates expressions. This has some\n"
"interesting consequences that are worth discussing.\n"
"\n"
"The first one is that the code is truly evaluated and not compiled.\n"
"This means that any benchmarking done in the shell is going to have\n"
"skewed results. So never run any profiling nor benchmarks in the shell.\n"
"\n"
"Second, IEx allows you to break an expression into many lines,\n"
"since this is common in Elixir. For example:\n"
"\n"
"    iex(1)> \"ab\n"
"    ...(1)> c\"\n"
"    \"ab\\nc\"\n"
"\n"
"In the example above, the shell will be expecting more input until it\n"
"finds the closing quote. Sometimes it is not obvious which character\n"
"the shell is expecting, and the user may find themselves trapped in\n"
"the state of incomplete expression with no ability to terminate it other\n"
"than by exiting the shell.\n"
"\n"
"For such cases, there is a special break-trigger (`#iex:break`) that when\n"
"encountered on a line by itself will force the shell to break out of any\n"
"pending expression and return to its normal state:\n"
"\n"
"    iex(1)> [\"ab\n"
"    ...(1)> c\"\n"
"    ...(1)> \"\n"
"    ...(1)> ]\n"
"    ...(1)> #iex:break\n"
"    ** (TokenMissingError) iex:1: incomplete expression\n"
"\n"
msgstr ""
"Elixirの対話シェルです。\n"
"\n"
"このモジュールは対話型Elixirのメインエントリポイントです。この\n"
"ドキュメントではIExがどのように働くかを少し説明します。\n"
"\n"
"ここで記述される機能の中には使用される端末により利用できない場合がある\n"
"ことに注意してください。特に、スマートターミナルは実行できない旨の\n"
"メッセージを目にした場合は、ここで記述される機能の一部は動かないでしょう。\n"
"\n"
"## ヘルパー\n"
"\n"
"IExはたくさんのヘルパーを提供しています。これらは、シェルで`h()`とタイプ\n"
"するか、`IEx.Helpers`モジュールのドキュメンテーションとしてアクセスすることが"
"できます。\n"
"\n"
"## オートコンプリート\n"
"\n"
"モジュールで利用可能なすべての関数を見付けには、モジュール名に続けてドット"
"を\n"
"タイプしたあと、タブを押すとオートコンプリートが起動されます。たとえば:\n"
"\n"
"    Enum.\n"
"\n"
"この機能は一部のWindowsシェルでは利用できないかもしれません。\n"
"動かすために、`iex --werl` のようにiexを開始する際に`--werl`\n"
"フラグを付ける必要があるかもしれません。`IEX_WITH_WERL`環境変数を\n"
"設定することにより`--werl`が常に有効になるでしょう。\n"
"\n"
"## ブレークコマンド\n"
"\n"
"IExの中で`Ctrl+C`を打つと、`BREAK`メニューが開かれます。このメニュー\n"
"では、シェルを終了したり、プロセスやetsテーブル情報を見たり、など\n"
"たくさんのことができます。\n"
"\n"
"## ユーザスイッチコマンド\n"
"\n"
"ブレークコマンドの他に、`Ctrl+G`をタイプするとユーザスイッチ\n"
"コマンドメニューを始めることができます。 そこで`h`をタイプすると\n"
"さらに詳細な情報を得ることができます。\n"
"\n"
"このメニューを使って、開発者は新しいシェルを開始して、新旧のシェルを\n"
"行き来することができます。やってみましょう:\n"
"\n"
"    User switch command\n"
"     --> s 'Elixir.IEx'\n"
"     --> c\n"
"\n"
"上のコマンドは新しいシェルを開始してそれに接続しています。\n"
"`hello`という新しい変数を作成して何か値を束縛します:\n"
"\n"
"    hello = :world\n"
"\n"
"そして、最初のシェルへロールバックしましょう:\n"
"\n"
"    User switch command\n"
"     --> c 1\n"
"\n"
"そして、再び`hello`変数へアクセスしてみます:\n"
"\n"
"    hello\n"
"    ** (UndefinedFunctionError) undefined function: hello/0\n"
"\n"
"上のコマンドはシェルを切り替えたため失敗します。\n"
"シェルは互いに隔離されているので、一方で定義された変数には\n"
"他方のシェルからはアクセスできません。\n"
"\n"
"ユーザスイッチコマンドメニューでも、開発者は`r`コマンドを使って\n"
"リモートシェルに接続できます。これは次に説明する話題です。\n"
"\n"
"## リモートシェル\n"
"\n"
"IExは二段階で他のノードに接続できます。\n"
"まず第一に、カレントシェルと接続したいシェルの双方に名前を付けても\n"
"一つのシェルにしか接続できません。\n"
"\n"
"やってみましょう。最初に新しいシェルを開始します:\n"
"\n"
"    $ iex --sname foo\n"
"    iex(foo@HOST)1>\n"
"\n"
"プロンプトの中にある括弧内の文字列はノード名です。\n"
"`node()`関数を呼ぶことで取得\n"
"できます:\n"
"\n"
"    iex(foo@HOST)1> node()\n"
"    :\"foo@HOST\"\n"
"    iex(foo@HOST)2> Node.alive?()\n"
"    true\n"
"\n"
"戯れに、このシェルでも簡単なモジュールを定義しましょう:\n"
"\n"
"    iex(foo@HOST)3> defmodule Hello do\n"
"    ...(foo@HOST)3>   def world, do: \"it works!\"\n"
"    ...(foo@HOST)3> end\n"
"\n"
"では、もう一つのシェルを同様に名前をつけて開始しましょう:\n"
"\n"
"    $ iex --sname bar\n"
"    iex(bar@HOST)1>\n"
"\n"
"`Hello.world`を発行しても利用できないでしょう。それは他のシェルで\n"
"しか定義されていないからです:\n"
"\n"
"    iex(bar@HOST)1> Hello.world\n"
"    ** (UndefinedFunctionError) undefined function: Hello.world/0\n"
"\n"
"しかし、そのシェルにはリモート接続することができます。ユーザスイッチプロン"
"プ\n"
"トを開いて(Ctrl+G)、以下をタイプします:\n"
"\n"
"    User switch command\n"
"     --> r 'foo@HOST' 'Elixir.IEx'\n"
"     --> c\n"
"\n"
"これでプロンプトが示すようにリモートノードに接続され、\n"
"そこで定義された情報やモジュールにアクセスすることができます:\n"
"\n"
"    rem(foo@macbook)1> Hello.world\n"
"    \"it works\"\n"
"\n"
"実際、以下のコマンドラインショートカットを提供しているように、リモート\n"
"シェルへの接続は一般的なことです:\n"
"\n"
"    $ iex --sname baz --remsh foo@HOST\n"
"\n"
"ここで”remsh\"は\"remote shell\"を意味します。一般に、Elixirは以下を\n"
"サポートします:\n"
"\n"
"  * ElixirノードからElixirノードへのremsh\n"
"  * プレーンerlangノードから(^Gメニューを介した)Elixirノードへのremsh\n"
"  * Elixirノードからプレーンerlangノードへのremsh(erl シェルが得られます)\n"
"\n"
"ElixirなしのElixirシェルのリモートノードへの接続はサポートされて \n"
"**いません** 。\n"
"\n"
"## .iex.exs ファイル\n"
"\n"
"IExは開始する際に(カレントディレクトリにある)ローカルな`.iex.exs`ファイ\n"
"ルを、次に(`~/.iex.exs`にある)グローバルなそれを探します。そして、（もし\n"
"あれば）最初に見付かったものをロードします。ロードされた`.iex.exs`ファイル"
"の\n"
"コードはシェルのコンテキストで評価されます。そして、たとえば、ロードされた\n"
"モジュールや`.iex.exs`ファイルの中で束縛されている変数は、ブート後のシェル"
"の\n"
"中で利用できます。\n"
"\n"
"たとえば、次の`.iex.exs`ファイルを考えます:\n"
"\n"
"    # 別の \".iex.exs” ファイルをロードする\n"
"    import_file \"~/.iex.exs\"\n"
"\n"
"    # シェルが開始する前に何かを表示する\n"
"    IO.puts \"hello world\"\n"
"\n"
"    # シェルから利用可能になる変数を束縛する。\n"
"    value = 13\n"
"\n"
"この`.iex.exs`ファイルがあるディレクトリでシェルを動かすと、以下の結果に\n"
"なります:\n"
"\n"
"    $ iex\n"
"    Erlang 19 [...]\n"
"\n"
"    hello world\n"
"    Interactive Elixir - press Ctrl+C to exit (type h() ENTER for help)\n"
"    iex(1)> value\n"
"    13\n"
"\n"
"IExに`--dot-iex`オプションを指定すると別のファイルのロードが可能になりま"
"す。\n"
"詳しくは`iex --help`を参照してください。\n"
"\n"
"## シェルの設定\n"
"\n"
"IExでは数多くのカスタマイズオプションが提供されています。`h IEx.configure/1` "
"と\n"
"タイプして`IEx.configure/1` 関数のドキュメントを見てください。\n"
"\n"
"これらのオプションはプロジェクト設定ファイルで、あるいは`~/.iex.exs`ファイル"
"から\n"
"`IEx.configure/1`をよぶことでグローバルに設定することができます。たとえば、\n"
"\n"
"    # .iex.exs\n"
"    IEx.configure(inspect: [limit: 3])\n"
"\n"
"シェルを起動します:\n"
"\n"
"    $ iex\n"
"    Erlang 19 [...]\n"
"\n"
"   Interactive Elixir - press Ctrl+C to exit (type h() ENTER for help)\n"
"    iex(1)> [1, 2, 3, 4, 5]\n"
"    [1, 2, 3, ...]\n"
"\n"
"## IExにおける式\n"
"\n"
"対話シェルとして、IExは式を評価します。これには議論する価値のある\n"
"面白い結果がいくつかあります。\n"
"\n"
"第一に、コードは正確に評価されるが、コンパイルはされないということです。\n"
"これはシェルで行われるどんなベンチマークも結果を歪めるだろうことを意味しま"
"す。\n"
"したがって、シェルのなかではどんなプロファイリングもベンチマークも動かしては"
"いけません。\n"
"\n"
"次に、IExは複数の行に式を分けることを許します。これはElixirで一般的な\n"
"ことだからです。たとえば:\n"
"\n"
"    iex(1)> \"ab\n"
"    ...(1)> c\"\n"
"    \"ab\\nc\"\n"
"\n"
"上の例では、引用符が閉じられるを見付けるまでシェルはさらなる\n"
"入力を予想しています。時々、シェルがどの文字を期待しているかが\n"
"明らかでなく、ユーザは不完全な式の状態でシェルを終了する以外に\n"
"方法がない窮地に陥るのに気が付くかも\n"
"しれません。\n"
"\n"
"そのような場合のために、特別なブレイクトリガ(`#iex:break`)が用意されていま"
"す。\n"
"これは、どのようなペンディング中の式からも抜け出して、正常状態に戻るようシェ"
"ルに\n"
"強制します:\n"
"\n"
"    iex(1)> [\"ab\n"
"    ...(1)> c\"\n"
"    ...(1)> \"\n"
"    ...(1)> ]\n"
"    ...(1)> #iex:break\n"
"    ** (TokenMissingError) iex:1: incomplete expression\n"
"\n"

#. TRANSLATORS: def IEx.configuration()
#: lib/iex.ex:332
msgid "Returns IEx configuration.\n"
msgstr "IEx設定を返します。\n"

#. TRANSLATORS: def IEx.color(color, string)
#: lib/iex.ex:360
msgid ""
"Returns `string` escaped using the specified `color`.\n"
"\n"
"ANSI escapes in `string` are not processed in any way.\n"
msgstr ""
"指定された`color`を使ってエスケープされた`string`を返します。\n"
"\n"
"`string`中のANSIエスケープはどのようにも処理されません。\n"

#. TRANSLATORS: def IEx.width()
#: lib/iex.ex:374
msgid ""
"Gets the IEx width for printing.\n"
"\n"
"Used by helpers and it has a maximum cap of 80 chars.\n"
msgstr ""
"IExの表示用の幅を取得します\n"
"\n"
"ヘルパーにより使用され、最大80文字となります。\n"

#. TRANSLATORS: def IEx.after_spawn(fun)
#: lib/iex.ex:339
msgid "Registers a function to be invoked after the IEx process is spawned.\n"
msgstr "IExプロセスが生成された後に起動される関数を登録します。\n"

#. TRANSLATORS: def IEx.after_spawn()
#: lib/iex.ex:346
msgid "Returns registered `after_spawn` callbacks.\n"
msgstr "登録された`after_spawn`コールバックを返します。\n"
